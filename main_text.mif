DEPTH = 16384;
WIDTH = 32;
ADDRESS_RADIX = HEX;
DATA_RADIX = HEX;
CONTENT
BEGIN
00000000 : 00004217;   % 224:  	la 	tp, ExceptionHandling	# carrega em tp o endere�o base das rotinas do sistema ECALL %
00000001 : 69820213;   % 224:  %
00000002 : 00521073;   % 225:  	csrw 	tp, utvec 		# seta utvec para o endere�o tp %
00000003 : 0000e073;   % 226:  	csrsi 	ustatus, 1 		# seta o bit de habilita��o de interrup��o em ustatus (reg 0)																																																				 %
00000004 : 00000413;   % 15: 	li s0, 0  # Initial frame %
00000005 : 00000493;   % 16: 	li s1, 0  # Reseting time %
00000006 : 00100913;   % 17: 	li s2, 1  # Game loop state  %
00000007 : 00000993;   % 18: 	li s3, 0  # Select state %
00000008 : 0fc12297;   % 20: 	la t0, GRAVITY_FACTOR %
00000009 : 11828293;   % 20:  %
0000000a : 0002a407;   % 21: 	flw fs0,0(t0) %
0000000b : 0fc12297;   % 22: 	la t0, JUMP_SPEED %
0000000c : 11028293;   % 22:  %
0000000d : 0002a487;   % 23: 	flw fs1,0(t0) %
0000000e : 0fc12297;   % 25: 	la t0, RIDLEY_JUMP_SPEED %
0000000f : 41c28293;   % 25:  %
00000010 : 0002a987;   % 26: 	flw fs3,0(t0) %
00000011 : 7ac0006f;   % 28: 	j SETUP %
00000012 : 00009317;   % 61: 	call PLAY_SOUND %
00000013 : 038300e7;   % 61:  %
00000014 : c0102573;   % 62:     csrr a0,3073 %
00000015 : 40950533;   % 63:     sub a0, a0, s1 #  # a0 = current time - last frame's time %
00000016 : 03200293;   % 64:     li t0, 50	# Loads frame rate (time (in ms) per frame) %
00000017 : fe5566e3;   % 65:     bltu a0,t0, GAME_LOOP  # While a0 < minimum time for a frame, keep looping  %
00000018 : 00144413;   % 68:     xori s0,s0,1		    # Switches frame value (register) %
00000019 : 00000317;   % 72: 	call INPUT_CHECK	    # Checks player's input %
0000001a : 260300e7;   % 72:  %
0000001b : 00001317;   % 74: 	call PHYSICS            # Physics operations %
0000001c : 298300e7;   % 74:  %
0000001d : 00001317;   % 76: 	call UPDATE_DOORS       # Updates doors %
0000001e : 130300e7;   % 76:  %
0000001f : 00006317;   % 77: 	call MAP_MOVE_RENDER    # Renders map when necessary %
00000020 : f90300e7;   % 77:  %
00000021 : 00003317;   % 79: 	call MARU_MARI_OPERATIONS %
00000022 : af8300e7;   % 79:  %
00000023 : 00003317;   % 81: 	call BOMB_POWER_OPERATIONS %
00000024 : bd4300e7;   % 81:  %
00000025 : 00003317;   % 83: 	call ITEM_CAPSULE_OPERATIONS %
00000026 : ca8300e7;   % 83:  %
00000027 : 00000513;   % 85: 	li a0,0 %
00000028 : 00003317;   % 86: 	call ENEMY_OPERATIONS %
00000029 : 1f8300e7;   % 86:  %
0000002a : 00002317;   % 88: 	call BEAMS_OPERATIONS %
0000002b : 768300e7;   % 88:  %
0000002c : 00007317;   % 90: 	call UPDATE_STATUS      # Updates player's sprite status %
0000002d : 8b4300e7;   % 90:  %
0000002e : 00000513;   % 92: 	li a0, 0     # Rendering player operation %
0000002f : 00000593;   % 93: 	li a1, 0     # Rendering full player %
00000030 : 00002317;   % 94: 	call RENDER_PLAYER	 %
00000031 : 998300e7;   % 94:  %
00000032 : 00003317;   % 96: 	call LOOT_OPERATIONS %
00000033 : df8300e7;   % 96:  %
00000034 : 00003317;   % 98: 	call BOMBS_OPERATIONS %
00000035 : 8b4300e7;   % 98:  %
00000036 : 00003317;   % 99: 	call EXPLOSIONS_OPERATIONS %
00000037 : f88300e7;   % 99:  %
00000038 : 00002317;   % 101: 	call RENDER_DOOR_FRAMES %
00000039 : 01c300e7;   % 101:  %
0000003a : 00007317;   % 103: 	call PLAYER_COLLISION  # Will see if player was hit by an enemy %
0000003b : 094300e7;   % 103:  %
0000003c : 00007317;   % 105: 	call BEAM_COLLISION  # Will see if beam hit an enemy %
0000003d : 734300e7;   % 105:  %
0000003e : 00000513;   % 107: 	li a0, 0     # Rendering UI operation %
0000003f : 00002317;   % 108: 	call RENDER_UI	 %
00000040 : cfc300e7;   % 108:  %
00000041 : ff2002b7;   % 111: 	li t0,0xFF200604	# Loads Bitmap Display address %
00000042 : 60428293;   % 111:  %
00000043 : 0082a023;   % 112: 	sw s0,0(t0)         # Stores new frame value (from s0) on Bitmap Display %
00000044 : c01024f3;   % 114: 	csrr s1,3073        # New time is stored in s1, in order to be compared later		 %
00000045 : f35ff06f;   % 116: 	j GAME_LOOP	        # Returns to loop's beginning %
00000046 : 00009317;   % 121: 	call RESET_MUSIC %
00000047 : f0c300e7;   % 121:  %
00000048 : c0102573;   % 123:     csrr a0,3073 %
00000049 : 40950533;   % 124:     sub a0, a0, s1 				# a0 = current time - last frame's time %
0000004a : 03200293;   % 125:     li t0, 50			# Loads frame rate (time (in ms) per frame) %
0000004b : fe5566e3;   % 126:     bltu a0,t0, MENU2_LOOP  # While a0 < minimum time for a frame, keep looping  %
0000004c : 00144413;   % 129:     xori s0,s0,1		    # Switches frame value (register) %
0000004d : 00000317;   % 131: 	call INPUT_CHECK	    # Checks player's input %
0000004e : 190300e7;   % 131:  %
0000004f : 00000513;   % 133: 	li a0,0               # Black %
00000050 : 00000593;   % 134: 	li a1,0               # Starting X (0) %
00000051 : 00000613;   % 135: 	li a2,0               # Starting Y (0) %
00000052 : 14000693;   % 136: 	li a3,320    # Gets width %
00000053 : 0f000713;   % 137: 	li a4,240   # Gets height %
00000054 : 008007b3;   % 138: 	mv a5,s0              # Gets frame %
00000055 : 00000813;   % 139: 	li a6,0               # Render per word %
00000056 : 00002317;   % 140: 	call RENDER_COLOR %
00000057 : 870300e7;   % 140:  %
00000058 : 0fc12517;   % 142: 	la a0,Select_UI %
00000059 : 47f50513;   % 142:  %
0000005a : 07000593;   % 143: 	li a1,112             # Starting X (0) %
0000005b : 06100613;   % 144: 	li a2,97              # Starting Y (0) %
0000005c : 00098463;   % 145: 	beqz s3,SKIP_SELECT_CONTINUE %
0000005d : 01860613;   % 146: 		addi a2,a2,24     # If selecting continue, render further down %
0000005e : 00800693;   % 148: 	li a3,8               # Gets width %
0000005f : 00800713;   % 149: 	li a4,8               # Gets height %
00000060 : 008007b3;   % 150: 	mv a5,s0              # Gets frame %
00000061 : 00000813;   % 151: 	li a6,0               # Only one sprite, so status is 0 %
00000062 : 00000893;   % 152: 	li a7,0               # Normal render %
00000063 : 00001317;   % 153: 	call RENDER_WORD %
00000064 : 7b0300e7;   % 153:  %
00000065 : 0fc12517;   % 155: 	la a0,START_TXT %
00000066 : f5050513;   % 155:  %
00000067 : 08000593;   % 156: 	li a1,128             # a1 = column %
00000068 : 06000613;   % 157: 	li a2,96              # a2 = row  %
00000069 : 0ea00693;   % 158: 	li a3,0x00EA          # a3 = colors  %
0000006a : 00800733;   % 159: 	mv a4,s0              # a4 = frame %
0000006b : 00100793;   % 160: 	li a5,1               # Font %
0000006c : 06800893;   % 161: 	li a7,104 # syscal for 'print integer' %
0000006d : 00000073;   % 162: 	ecall %
0000006e : 0fc12517;   % 164: 	la a0,CONTINUE_TXT %
0000006f : f3250513;   % 164:  %
00000070 : 08000593;   % 165: 	li a1,128             # a1 = column %
00000071 : 07800613;   % 166: 	li a2,120             # a2 = row  %
00000072 : 0ea00693;   % 167: 	li a3,0x00EA          # a3 = colors  %
00000073 : 00800733;   % 168: 	mv a4,s0              # a4 = frame %
00000074 : 00100793;   % 169: 	li a5,1               # Font %
00000075 : 06800893;   % 170: 	li a7,104 # syscal for 'print integer' %
00000076 : 00000073;   % 171: 	ecall %
00000077 : ff2002b7;   % 174: 	li t0,0xFF200604	# Loads Bitmap Display address %
00000078 : 60428293;   % 174:  %
00000079 : 0082a023;   % 175: 	sw s0,0(t0)         # Stores new frame value (from s0) on Bitmap Display %
0000007a : c01024f3;   % 177: 	csrr s1,3073        # New time is stored in s1, in order to be compared later		 %
0000007b : f2dff06f;   % 179: 	j MENU2_LOOP	# Returns to loop's beginning %
0000007c : 00000513;   % 184: 	li a0,0               # Black %
0000007d : 00000593;   % 185: 	li a1,0               # Starting X (0) %
0000007e : 00000613;   % 186: 	li a2,0               # Starting Y (0) %
0000007f : 14000693;   % 187: 	li a3,320    # Gets width %
00000080 : 0f000713;   % 188: 	li a4,240   # Gets height %
00000081 : 00000793;   % 189: 	li a5,0               # Gets frame %
00000082 : 00000813;   % 190: 	li a6,0               # Render per word %
00000083 : 00001317;   % 191: 	call RENDER_COLOR %
00000084 : 7bc300e7;   % 191:  %
00000085 : 0fc12517;   % 193: 	la a0,GAME_OVER_TXT %
00000086 : edf50513;   % 193:  %
00000087 : 07800593;   % 194: 	li a1,120             # a1 = column %
00000088 : 07400613;   % 195: 	li a2,116             # a2 = row  %
00000089 : 0ff00693;   % 196: 	li a3,0x00ff          # a3 = colors  %
0000008a : 00000713;   % 197: 	li a4,0               # a4 = frame %
0000008b : 00100793;   % 198: 	li a5,1               # Font %
0000008c : 06800893;   % 199: 	li a7,104 # syscal for 'print integer' %
0000008d : 00000073;   % 200: 	ecall %
0000008e : 00000513;   % 202: 	li a0,0               # Black %
0000008f : 00000593;   % 203: 	li a1,0               # Starting X (0) %
00000090 : 00000613;   % 204: 	li a2,0               # Starting Y (0) %
00000091 : 14000693;   % 205: 	li a3,320    # Gets width %
00000092 : 0f000713;   % 206: 	li a4,240   # Gets height %
00000093 : 00100793;   % 207: 	li a5,1               # Gets frame %
00000094 : 00000813;   % 208: 	li a6,0               # Render per word %
00000095 : 00001317;   % 209: 	call RENDER_COLOR %
00000096 : 774300e7;   % 209:  %
00000097 : 0fc12517;   % 211: 	la a0,GAME_OVER_TXT %
00000098 : e9750513;   % 211:  %
00000099 : 07800593;   % 212: 	li a1,120             # a1 = column %
0000009a : 07400613;   % 213: 	li a2,116             # a2 = row  %
0000009b : 0ff00693;   % 214: 	li a3,0x00ff          # a3 = colors  %
0000009c : 00100713;   % 215: 	li a4,1               # a4 = frame %
0000009d : 00100793;   % 216: 	li a5,1               # Font %
0000009e : 06800893;   % 217: 	li a7,104 # syscal for 'print integer' %
0000009f : 00000073;   % 218: 	ecall %
000000a0 : c01024f3;   % 220: 	csrr s1,3073        # New time is stored in s1, in order to be compared later %
000000a1 : c0102573;   % 224:     csrr a0,3073 %
000000a2 : 40950533;   % 225:     sub a0, a0, s1 				# a0 = current time - last frame's time %
000000a3 : 3e800293;   % 226:     li t0, 1000			# Loads frame rate (time (in ms) per frame) %
000000a4 : fe556ae3;   % 227:     bltu a0,t0, GAME_OVER_LOOP_PREP2  # While a0 < minimum time for a frame, keep looping  %
000000a5 : c0102573;   % 231:     csrr a0,3073 %
000000a6 : 40950533;   % 232:     sub a0, a0, s1 				# a0 = current time - last frame's time %
000000a7 : 03200293;   % 233:     li t0, 50			# Loads frame rate (time (in ms) per frame) %
000000a8 : fe556ae3;   % 234:     bltu a0,t0, GAME_OVER_LOOP  # While a0 < minimum time for a frame, keep looping  %
000000a9 : 00144413;   % 237:     xori s0,s0,1		    # Switches frame value (register) %
000000aa : 00000317;   % 239: 	call INPUT_CHECK	    # Checks player's input %
000000ab : 01c300e7;   % 239:  %
000000ac : ff2002b7;   % 242: 	li t0,0xFF200604	# Loads Bitmap Display address %
000000ad : 60428293;   % 242:  %
000000ae : 0082a023;   % 243: 	sw s0,0(t0)         # Stores new frame value (from s0) on Bitmap Display %
000000af : c01024f3;   % 245: 	csrr s1,3073        # New time is stored in s1, in order to be compared later		 %
000000b0 : fd5ff06f;   % 247: 	j GAME_OVER_LOOP	# Returns to loop's beginning %
000000b1 : 0fc12517;   % 17:     la a0, PLYR_STATUS   # Loads Player Status %
000000b2 : e6250513;   % 17:  %
000000b3 : 0fc12597;   % 18:     la a1, PLYR_POS      # Loads Player Pos %
000000b4 : e4e58593;   % 18:  %
000000b5 : ff200337;   % 21:     li t1,0xFF200000  	  # KDMMIO Address %
000000b6 : 00030313;   % 21:  %
000000b7 : 00032283;   % 22:     lw t0, 0(t1)	      # Reads the Keyboard Control bit %
000000b8 : 0012f293;   % 23:     andi t0, t0, 0x0001	  # Masks the least significant bit   %
000000b9 : 00100393;   % 27:     li t2,1                # Menu2 number %
000000ba : 03238863;   % 28:     beq t2,s2,MENU2_CHECK  # If on menu2 %
000000bb : 00200393;   % 30:     li t2,2                # Game scene number %
000000bc : 01238663;   % 31:     beq t2,s2,GAME_CHECK   # If on game %
000000bd : 00300393;   % 33:     li t2,3                     # Game over scene number %
000000be : 01238663;   % 34:     beq t2,s2,GAME_OVER_CHECK   # If on game over %
000000bf : 08029063;   % 37:         bnez t0, CONTINUE_GAME_CHECK    # If an input is detected, continue checking %
000000c0 : 2040006f;   % 38:         j NO_CHEAT_INPUT 		        # otherwise no input was detected, but check for other non-cheat inputs  %
000000c1 : 00029463;   % 41:         bnez t0, CONTINUE_GAME_OVER_CHECK   # If any input is detected, continue %
000000c2 : 4e40006f;   % 42:             j END_INPUT_CHECK               # end procedure %
000000c3 : 00000993;   % 46:             li s3,0 %
000000c4 : 00100913;   % 47:             li s2,1   %
000000c5 : 4dc0006f;   % 48:             j SETUP          # end procedure by going to setup %
000000c6 : 00029463;   % 51:         bnez t0, CONTINUE_MENU2_CHECK       # If any input is detected, continue %
000000c7 : 4d00006f;   % 53:             j END_INPUT_CHECK               # end procedure %
000000c8 : 00432283;   % 56:             lw t0, 4(t1)   # Reads key value %
000000c9 : 07700313;   % 58:             li t1, 'w'	   # Loads ascii value of 'w' key %
000000ca : 00629663;   % 59:             bne t0, t1, CHECK_INPUT.MENU2_S %
000000cb : 00000993;   % 60:                 li s3,0 %
000000cc : 4bc0006f;   % 61:                 j END_INPUT_CHECK               # end procedure %
000000cd : 07300313;   % 64:             li t1, 's'	# Loads ascii value of 's' key %
000000ce : 00629663;   % 65:             bne t0, t1, CHECK_INPUT.MENU2_ENTER %
000000cf : 00100993;   % 66:                 li s3,1 %
000000d0 : 4ac0006f;   % 67:                 j END_INPUT_CHECK               # end procedure %
000000d1 : 00a00313;   % 70:             li t1, '\n'	# Loads ascii value of ENTER key %
000000d2 : fc629ae3;   % 71:             bne t0, t1, MENU2_NO_INPUT %
000000d3 : 0fc12297;   % 72:                 la t0,PLYR_INFO %
000000d4 : dcc28293;   % 72:  %
000000d5 : 01e00313;   % 73:                 li t1, 30 %
000000d6 : 00628023;   % 74:                 sb t1,0(t0)     # Map 1 %
000000d7 : 0fc12297;   % 75:                 la t0, MAP_INFO # Loads Map Info address %
000000d8 : da828293;   % 75:  %
000000d9 : 00100313;   % 76:                 li t1,1         # Map 1 %
000000da : 00628023;   % 77:                 sb t1, 0(t0)    # Stores map 1 number %
000000db : 00400313;   % 78:                 li t1,4         # 4 - Force switch %
000000dc : 006280a3;   % 79:                 sb t1, 1(t0)    # Stores render byte %
000000dd : 00200913;   % 80:                 li s2,2   %
000000de : 4780006f;   % 81:                 j SETUP                         # end procedure by going to setup %
000000df : 00432283;   % 85:     lw t0, 4(t1)   # Reads key value %
000000e0 : 03100313;   % 88:     li t1, '1' %
000000e1 : 00629463;   % 89:     bne t0,t1, CHECK_INPUT.2 %
000000e2 : 0680006f;   % 90:     j INPUT.1 %
000000e3 : 03200313;   % 93:     li t1, '2' %
000000e4 : 00629463;   % 94:     bne t0,t1, CHECK_INPUT.3 %
000000e5 : 0800006f;   % 95:     j INPUT.2 %
000000e6 : 03300313;   % 98:     li t1, '3' %
000000e7 : 00629463;   % 99:     bne t0,t1, CHECK_INPUT.4 %
000000e8 : 0980006f;   % 100:     j INPUT.3 %
000000e9 : 03400313;   % 103:     li t1, '4' %
000000ea : 00629463;   % 104:     bne t0,t1, CHECK_INPUT.5 %
000000eb : 0b00006f;   % 105:     j INPUT.4 %
000000ec : 03500313;   % 108:     li t1, '5' %
000000ed : 00629463;   % 109:     bne t0,t1, CHECK_INPUT.6 %
000000ee : 0c80006f;   % 110:     j INPUT.5 %
000000ef : 03600313;   % 113:     li t1, '6' %
000000f0 : 00629463;   % 114:     bne t0,t1, CHECK_INPUT.7 %
000000f1 : 0e00006f;   % 115:     j INPUT.6 %
000000f2 : 03700313;   % 118:     li t1, '7' %
000000f3 : 00629463;   % 119:     bne t0,t1, CHECK_INPUT.O %
000000f4 : 0f80006f;   % 120:     j INPUT.7 %
000000f5 : 06f00313;   % 123:     li t1, 'o' %
000000f6 : 00629463;   % 124:     bne t0,t1, CHECK_INPUT.0 %
000000f7 : 1100006f;   % 125:     j INPUT.O %
000000f8 : 03000313;   % 128:     li t1, '0'	 %
000000f9 : 00629463;   % 129:     bne t0,t1, GOTO_NO_CHEAT_INPUT %
000000fa : 10c0006f;   % 130:     j INPUT.0 	 %
000000fb : 1180006f;   % 133:         j NO_CHEAT_INPUT %
000000fc : 0fc12297;   % 136:         la t0 MAP_INFO %
000000fd : d1428293;   % 136:  %
000000fe : 00100313;   % 137:         li t1, 1 %
000000ff : 00628023;   % 138:         sb t1, 0(t0) %
00000100 : 00400313;   % 139:         li t1, 4 %
00000101 : 006280a3;   % 140:         sb t1, 1(t0) %
00000102 : 00000313;   % 142:         li t1,0 %
00000103 : 006500a3;   % 143:         sb t1,1(a0) %
00000104 : 3e00006f;   % 145:         j SETUP %
00000105 : 0fc12297;   % 148:         la t0 MAP_INFO %
00000106 : cf028293;   % 148:  %
00000107 : 00200313;   % 149:         li t1, 2 %
00000108 : 00628023;   % 150:         sb t1, 0(t0) %
00000109 : 00400313;   % 151:         li t1, 4 %
0000010a : 006280a3;   % 152:         sb t1, 1(t0) %
0000010b : 00000313;   % 154:         li t1,0 %
0000010c : 006500a3;   % 155:         sb t1,1(a0) %
0000010d : 3bc0006f;   % 157:         j SETUP %
0000010e : 0fc12297;   % 160:         la t0 MAP_INFO %
0000010f : ccc28293;   % 160:  %
00000110 : 00300313;   % 161:         li t1, 3 %
00000111 : 00628023;   % 162:         sb t1, 0(t0) %
00000112 : 00400313;   % 163:         li t1, 4 %
00000113 : 006280a3;   % 164:         sb t1, 1(t0) %
00000114 : 00000313;   % 166:         li t1,0 %
00000115 : 006500a3;   % 167:         sb t1,1(a0) %
00000116 : 3980006f;   % 169:         j SETUP %
00000117 : 0fc12297;   % 172:         la t0 MAP_INFO %
00000118 : ca828293;   % 172:  %
00000119 : 00400313;   % 173:         li t1, 4 %
0000011a : 00628023;   % 174:         sb t1, 0(t0) %
0000011b : 00400313;   % 175:         li t1, 4 %
0000011c : 006280a3;   % 176:         sb t1, 1(t0) %
0000011d : 00000313;   % 178:         li t1,0 %
0000011e : 006500a3;   % 179:         sb t1,1(a0) %
0000011f : 3740006f;   % 181:         j SETUP %
00000120 : 0fc12297;   % 184:         la t0 MAP_INFO %
00000121 : c8428293;   % 184:  %
00000122 : 00500313;   % 185:         li t1, 5 %
00000123 : 00628023;   % 186:         sb t1, 0(t0) %
00000124 : 00400313;   % 187:         li t1, 4 %
00000125 : 006280a3;   % 188:         sb t1, 1(t0) %
00000126 : 00100313;   % 190:         li t1,1 %
00000127 : 006500a3;   % 191:         sb t1,1(a0) %
00000128 : 3500006f;   % 193:         j SETUP %
00000129 : 0fc12297;   % 196:         la t0 MAP_INFO %
0000012a : c6028293;   % 196:  %
0000012b : 00600313;   % 197:         li t1, 6 %
0000012c : 00628023;   % 198:         sb t1, 0(t0) %
0000012d : 00400313;   % 199:         li t1, 4 %
0000012e : 006280a3;   % 200:         sb t1, 1(t0) %
0000012f : 00100313;   % 202:         li t1,1 %
00000130 : 006500a3;   % 203:         sb t1,1(a0) %
00000131 : 32c0006f;   % 205:         j SETUP %
00000132 : 0fc12297;   % 208:         la t0 MAP_INFO %
00000133 : c3c28293;   % 208:  %
00000134 : 00700313;   % 209:         li t1, 7 %
00000135 : 00628023;   % 210:         sb t1, 0(t0) %
00000136 : 00400313;   % 211:         li t1, 4 %
00000137 : 006280a3;   % 212:         sb t1, 1(t0) %
00000138 : 00100313;   % 214:         li t1,1 %
00000139 : 006500a3;   % 215:         sb t1,1(a0) %
0000013a : 3080006f;   % 217:         j SETUP %
0000013b : 00000513;   % 220:         li a0, 0    # open doors %
0000013c : 5750006f;   % 222:         j CHANGE_DOORS_STATE %
0000013d : 00200513;   % 225:         li a0,2 %
0000013e : 00a00593;   % 226:         li a1,10 %
0000013f : 5f40606f;   % 227:         j DAMAGE_PLAYER %
00000140 : 2ec0006f;   % 228:         j END_INPUT_CHECK %
00000141 : ff200637;   % 233:     li a2,0xFF200520	# Loads KEY0 address   (1<<(code)) %
00000142 : 52060613;   % 233:  %
00000143 : 00062603;   % 234:     lw a2,0(a2)     # and loads its contents to a2 %
00000144 : ff2006b7;   % 236: 	li a3,0xFF200524	# Loads KEY1 address   (1<<(code - 32)) %
00000145 : 52468693;   % 236:  %
00000146 : 0006a683;   % 237:     lw a3,0(a3)     # and loads its contents to a3 %
00000147 : ff200737;   % 239: 	li a4,0xFF200528	# Loads KEY2 address   (1<<(code - 64)) %
00000148 : 52870713;   % 239:  %
00000149 : 00072703;   % 240:     lw a4,0(a4)     # and loads its contents to a4 %
0000014a : ff2007b7;   % 242: 	li a5,0xFF20052C	# Loads KEY3 address   (1<<(code - 96)) %
0000014b : 52c78793;   % 242:  %
0000014c : 0007a783;   % 243:     lw a5,0(a5)     # and loads its contents to a5 %
0000014d : 00d66eb3;   % 245:     or t4,a2,a3     # t4 == 0 only if there's no input in a2 and a3 %
0000014e : 00eeeeb3;   % 246:     or t4,t4,a4     # t4 == 0 only if there's no input in a2, a3 and a4 %
0000014f : 00feeeb3;   % 247:     or t4,t4,a5     # t4 == 0 only if there's no input in a2, a3, a4 and a5 %
00000150 : 00000813;   % 249:     li a6,0         # Sets a6 to 0 (no key was pressed) as a default %
00000151 : 040e9463;   % 250:     bnez t4,CONTINUE_NO_CHEAT_INPUT_CHECK  # If there's any input at all %
00000152 : 0fc12297;   % 253:         la t0, PLYR_INPUT # Loads PLYR_INPUT address %
00000153 : be728293;   % 253:  %
00000154 : 00080c63;   % 254:         beqz a6,CONTINUE_NO_INPUT   # If no key was pressed %
00000155 : 0002c383;   % 256:             lbu t2,0(t0)      # Loads PLYR_INPUT's value %
00000156 : 00039663;   % 257:             bnez t2, DONT_UPDATE_PLYR_INPUT  # If it isn't 0, don't update it %
00000157 : 00100393;   % 258:                 li t2, 1      # Otherwise, there's input %
00000158 : 00728023;   % 259:                 sb t2, 0(t0)  # store it %
00000159 : 2880006f;   % 261:                 j END_INPUT_CHECK   # End input check %
0000015a : 00000393;   % 264:         li t2, 0   # There isn't input %
0000015b : 00728023;   % 265:         sb t2, 0(t0)  %
0000015c : 0fc12517;   % 267:         la a0, PLYR_STATUS      # Loads Player Status %
0000015d : bb650513;   % 267:  %
0000015e : 00000313;   % 268:         li t1, 0        # Loads vertical direction (0 = normal) %
0000015f : 00650123;   % 269:         sb t1, 2(a0)    # Stores new direction on PLYR_STATUS %
00000160 : 006502a3;   % 271:         sb t1, 5(a0)                   %
00000161 : 00050323;   % 272: 	    sb zero, 6(a0)      # Stores new direction on MOVE_X %
00000162 : 2640006f;   % 273:         j END_INPUT_CHECK  %
00000163 : 00100213;   % 278:     li tp,1         # Number that will be shifted for comparisions %
00000164 : 01d00e93;   % 281:     li t4,0x1D      # W sanscode         %
00000165 : 01d21eb3;   % 282:     sll t4,tp,t4    # (1<<(29)) %
00000166 : 00cefeb3;   % 283:     and t4,t4,a2    # will be !=0 if W is being pressed %
00000167 : 000e9463;   % 284:     bnez t4,INPUT.W # if pressing W %
00000168 : 0340006f;   % 285:         j CHECK_INPUT.A # Otherwise, check if A was pressed %
00000169 : 00100813;   % 288:         li a6,1         # Sets a6 to 1 (a key was pressed) %
0000016a : 00454e83;   % 289:         lbu t4, 4(a0) # Loads player's abilities %
0000016b : 020e8063;   % 290:         beqz t4, W.NOT_MORPH_BALL # t4 != 0 ? BALL = OFF : BALL = ON (If on ball mode, deactivate it) %
0000016c : ffc10113;   % 292:             addi sp,sp,-4 %
0000016d : 00112023;   % 293:             sw ra,0(sp) %
0000016e : 00006317;   % 295:             call OUT_OF_MORPH_BALL      # Only changes temporary  %
0000016f : 4e4300e7;   % 295:  %
00000170 : 00012083;   % 297:             lw ra,0(sp) %
00000171 : 00410113;   % 298:             addi sp,sp,4 %
00000172 : 00c0006f;   % 300:             j CHECK_INPUT.A %
00000173 : 00100e93;   % 302:         li t4, 1      # Loads vertical direction (1 = up) %
00000174 : 01d50123;   % 303:         sb t4, 2(a0)  # Stores new direction on PLYR_STATUS %
00000175 : 01c00e93;   % 308:     li t4,0x1C      # A sanscode         %
00000176 : 01d21eb3;   % 309:     sll t4,tp,t4    # (1<<(28)) %
00000177 : 00cefeb3;   % 310:     and t4,t4,a2    # will be !=0 if A is being pressed %
00000178 : 000e9463;   % 311:     bnez t4,INPUT.A # if pressing A %
00000179 : 0140006f;   % 312:         j CHECK_INPUT.D # Otherwise, check if D was pressed %
0000017a : 00100813;   % 315:         li a6,1         # Sets a6 to 1 (a key was pressed) %
0000017b : fff00e93;   % 316:         li t4, -1     # Loads direction for MOVE_X (-1 = left) %
0000017c : 01d50323;   % 317:         sb t4, 6(a0)  # Stores new direction on MOVE_X %
0000017d : 0280006f;   % 318:         j CHECK_INPUT.S # If A was pressed, ignore D   (muahhahahahahah)    %
0000017e : 02300e93;   % 322:     li t4,0x23      # D sanscode   %
0000017f : fe0e8e93;   % 323:     addi t4,t4,-32  # adjusts it for comparision       %
00000180 : 01d21eb3;   % 324:     sll t4,tp,t4    # (1<<(0x23 - 32)) %
00000181 : 00defeb3;   % 325:     and t4,t4,a3    # will be !=0 if D is being pressed %
00000182 : 000e9463;   % 326:     bnez t4,INPUT.D # if pressing D %
00000183 : 0100006f;   % 327:         j CHECK_INPUT.S # Otherwise, check if S was pressed %
00000184 : 00100813;   % 330:         li a6,1         # Sets a6 to 1 (a key was pressed) %
00000185 : 00100e93;   % 331:         li t4, 1      # Loads direction for MOVE_X (1 = right) %
00000186 : 01d50323;   % 332:         sb t4, 6(a0)  # Stores new direction on MOVE_X %
00000187 : 01b00e93;   % 337:     li t4,0x1B      # S sanscode         %
00000188 : 01d21eb3;   % 338:     sll t4,tp,t4    # (1<<(27)) %
00000189 : 00cefeb3;   % 339:     and t4,t4,a2    # will be !=0 if S is being pressed %
0000018a : 000e9463;   % 340:     bnez t4,INPUT.S # if pressing S %
0000018b : 03c0006f;   % 341:         j CHECK_INPUT.SPACE # Otherwise, check if Space was pressed %
0000018c : 00100813;   % 344:         li a6,1         # Sets a6 to 1 (a key was pressed) %
0000018d : fff5ce83;   % 345:         lbu t4, -1(a1) # Loads player's abilities %
0000018e : 00750f03;   % 346:         lb t5, 7(a0)  # Loads direction on MOVE_Y %
0000018f : 01d02eb3;   % 347:         slt t4, zero, t4 # t4 > 0 ? t4=1 : t4=0 --> if t4 = 1 or 2 (morph ball ability aquired) then go into morph ball %
00000190 : 020f1463;   % 349:         bnez t5, SkipMorphBallTransformation %
00000191 : 020e8263;   % 350:         beqz t4, SkipMorphBallTransformation  %
00000192 : 00450e83;   % 351:         lb t4, 4(a0) # loads ball mode  %
00000193 : 000e9e63;   % 352:         bnez t4, SkipMorphBallTransformation %
00000194 : ffc10113;   % 354:             addi sp,sp,-4 %
00000195 : 00112023;   % 355:             sw ra,0(sp) %
00000196 : 00006317;   % 357:             call INTO_MORPH_BALL      # Only changes temporary  %
00000197 : 438300e7;   % 357:  %
00000198 : 00012083;   % 359:             lw ra,0(sp) %
00000199 : 00410113;   % 360:             addi sp,sp,4 %
0000019a : 02900e93;   % 367:     li t4,0x29      # SPACE sanscode   %
0000019b : fe0e8e93;   % 368:     addi t4,t4,-32  # adjusts it for comparision       %
0000019c : 01d21eb3;   % 369:     sll t4,tp,t4    # (1<<(0x23 - 32)) %
0000019d : 00defeb3;   % 370:     and t4,t4,a3    # will be !=0 if SPACE is being pressed %
0000019e : 000e9463;   % 371:     bnez t4,INPUT.SPACE # if pressing SPACE %
0000019f : 04c0006f;   % 372:         j CHECK_INPUT.K # Otherwise, check if K was pressed %
000001a0 : 00100813;   % 375:         li a6,1         # Sets a6 to 1 (a key was pressed) %
000001a1 : 00450e83;   % 376:         lb t4, 4(a0) # loads ball mode  %
000001a2 : 020e8063;   % 377:         beqz t4, SPACE.NOT_MORPH_BALL %
000001a3 : ffc10113;   % 379:             addi sp,sp,-4 %
000001a4 : 00112023;   % 380:             sw ra,0(sp) %
000001a5 : 00006317;   % 382:             call OUT_OF_MORPH_BALL      # Only changes temporary  %
000001a6 : 408300e7;   % 382:  %
000001a7 : 00012083;   % 384:             lw ra,0(sp) %
000001a8 : 00410113;   % 385:             addi sp,sp,4 %
000001a9 : 0240006f;   % 387:             j CHECK_INPUT.K %
000001aa : 00750303;   % 389:             lb t1, 7(a0)  # Loads current direction on MOVE_Y %
000001ab : 00030463;   % 390:             beqz t1, CAN_JUMP %
000001ac : 0180006f;   % 391:             j CHECK_INPUT.K %
000001ad : 00100313;   % 393:                 li t1, 1     # Loads ground position (1 = freefall) %
000001ae : 006501a3;   % 394:                 sb t1, 3(a0) # Stores new direction on PLYR_STATUS %
000001af : fff00313;   % 396:                 li t1, -1      # Loads direction for MOVE_Y (-1 = up) %
000001b0 : 006503a3;   % 397:                 sb t1, 7(a0)   # Stores new direction on MOVE_Y %
000001b1 : 20948953;   % 400:                 fmv.s fs2,fs1  # Sets fs2 (player's Y speed) to -9  %
000001b2 : 04200e93;   % 405:     li t4,0x42      # K sanscode   %
000001b3 : fc0e8e93;   % 406:     addi t4,t4,-64  # adjusts it for comparision       %
000001b4 : 01d21eb3;   % 407:     sll t4,tp,t4    # (1<<(0x23 - 64)) %
000001b5 : 00eefeb3;   % 408:     and t4,t4,a4    # will be !=0 if K is being pressed %
000001b6 : 000e9463;   % 409:     bnez t4,INPUT.K # if pressing K %
000001b7 : 0cc0006f;   % 410:         j CHECK_INPUT.J # Otherwise, check if J was pressed %
000001b8 : 00100813;   % 413:         li a6,1            # Sets a6 to 1 (a key was pressed) %
000001b9 : 00450e83;   % 414:         lb t4, 4(a0)       # loads ball mode  %
000001ba : 060e8463;   % 415:         beqz t4, K.SHOOT   # If standing %
000001bb : fff5ce03;   % 416:             lbu t3,-1(a1)  # Loads number of abilities %
000001bc : 00300313;   % 417:             li t1,3        # Number where bomb ability is aquired %
000001bd : 006e5463;   % 418:             bge t3,t1,K.PLACE_BOMB   # If player can place bombs %
000001be : 0b00006f;   % 419:                 j CHECK_INPUT.J      # otherwise, skip it %
000001bf : fe010113;   % 423:                 addi sp,sp,-32 %
000001c0 : 01012e23;   % 424:                 sw a6,28(sp) %
000001c1 : 00f12c23;   % 425:                 sw a5,24(sp) %
000001c2 : 00e12a23;   % 426:                 sw a4,20(sp) %
000001c3 : 00d12823;   % 427:                 sw a3,16(sp) %
000001c4 : 00c12623;   % 428:                 sw a2,12(sp) %
000001c5 : 00b12423;   % 429:                 sw a1,8(sp) %
000001c6 : 00a12223;   % 430:                 sw a0,4(sp) %
000001c7 : 00112023;   % 431:                 sw ra,0(sp) %
000001c8 : 00002317;   % 433:                 call BOMB_SPAWN %
000001c9 : 044300e7;   % 433:  %
000001ca : 01c12803;   % 435:                 lw a6,28(sp) %
000001cb : 01812783;   % 436:                 lw a5,24(sp) %
000001cc : 01412703;   % 437:                 lw a4,20(sp) %
000001cd : 01012683;   % 438:                 lw a3,16(sp) %
000001ce : 00c12603;   % 439:                 lw a2,12(sp) %
000001cf : 00812583;   % 440:                 lw a1,8(sp) %
000001d0 : 00412503;   % 441:                 lw a0,4(sp) %
000001d1 : 00012083;   % 442:                 lw ra,0(sp) %
000001d2 : 02010113;   % 443:                 addi sp,sp,32 %
000001d3 : 05c0006f;   % 445:                 j CHECK_INPUT.J     %
000001d4 : 00100e93;   % 448:             li t4, 1     # Loads attacking status (1 = attacking) %
000001d5 : 01d502a3;   % 449:             sb t4, 5(a0) # Stores new attack status on PLYR_STATUS %
000001d6 : fe010113;   % 451:                 addi sp,sp,-32 %
000001d7 : 01012e23;   % 452:                 sw a6,28(sp) %
000001d8 : 00f12c23;   % 453:                 sw a5,24(sp) %
000001d9 : 00e12a23;   % 454:                 sw a4,20(sp) %
000001da : 00d12823;   % 455:                 sw a3,16(sp) %
000001db : 00c12623;   % 456:                 sw a2,12(sp) %
000001dc : 00b12423;   % 457:                 sw a1,8(sp) %
000001dd : 00a12223;   % 458:                 sw a0,4(sp) %
000001de : 00112023;   % 459:                 sw ra,0(sp) %
000001df : 00002317;   % 461:                 call BEAM_SPAWN %
000001e0 : ef0300e7;   % 461:  %
000001e1 : 01c12803;   % 463:                 lw a6,28(sp) %
000001e2 : 01812783;   % 464:                 lw a5,24(sp) %
000001e3 : 01412703;   % 465:                 lw a4,20(sp) %
000001e4 : 01012683;   % 466:                 lw a3,16(sp) %
000001e5 : 00c12603;   % 467:                 lw a2,12(sp) %
000001e6 : 00812583;   % 468:                 lw a1,8(sp) %
000001e7 : 00412503;   % 469:                 lw a0,4(sp) %
000001e8 : 00012083;   % 470:                 lw ra,0(sp) %
000001e9 : 02010113;   % 471:                 addi sp,sp,32 %
000001ea : 03b00e93;   % 477:     li t4,0x3B      # J sanscode   %
000001eb : fe0e8e93;   % 478:     addi t4,t4,-32  # adjusts it for comparision       %
000001ec : 01d21eb3;   % 479:     sll t4,tp,t4    # (1<<(0x23 - 64)) %
000001ed : 00defeb3;   % 480:     and t4,t4,a3    # will be !=0 if J is being pressed %
000001ee : 000e9463;   % 481:     bnez t4,INPUT.J # if pressing J %
000001ef : d8dff06f;   % 482:         j NO_INPUT  # There's no input %
000001f0 : 00100813;   % 486:         li a6,1         # Sets a6 to 1 (a key was pressed) %
000001f1 : 0fc12f17;   % 487:         la t5, PLYR_INFO_2    # Loads address to PLYR_INFO_2 %
000001f2 : 96cf0f13;   % 487:  %
000001f3 : 001f4e83;   % 488:         lbu t4,1(t5)          # Loads missile cooldown %
000001f4 : 000e9863;   % 489:         bnez t4,SKIP_ENABLE_MISSILE  # If cooldown != 0, don't enable byte %
000001f5 : 000f4f83;   % 490:             lbu t6,0(t5)          # Loads missile enable byte %
000001f6 : 001fcf93;   % 491:             xori t6,t6,1          # Switches its value %
000001f7 : 01ff0023;   % 492:             sb t6,0(t5)           # and stores it back %
000001f8 : 001ece93;   % 494:             xori t4,t4,1      # Switches cooldown value %
000001f9 : 01df00a3;   % 495:             sb t4,1(t5)       # and stores it back %
000001fa : d61ff06f;   % 496:         j NO_INPUT   # needs to go there for last check :/ %
000001fb : 00008067;   % 500: 		ret	 %
000001fc : 00100313;   % 18: 	li t1,1	 %
000001fd : 0fc11297;   % 19: 	la t0,Brinstar %
000001fe : 90428293;   % 19:  %
000001ff : 00628023;   % 20: 	sb t1,0(t0)	 %
00000200 : 00100313;   % 25:     li t1,1                # Menu 2 scene number %
00000201 : 01230a63;   % 26:     beq t1,s2,SETUP_MENU2  # If on game menu 2 %
00000202 : 00200313;   % 28:     li t1,2                # Game scene number %
00000203 : 01230a63;   % 29:     beq t1,s2,SETUP_GAME   # If on game %
00000204 : 00300313;   % 31:     li t1,3                     # Game over scene number %
00000205 : 01230463;   % 32:     beq t1,s2,SETUP_GAME_OVER   # If on game over %
00000206 : 901ff06f;   % 35:         j MENU2_LOOP %
00000207 : 9d5ff06f;   % 39:         j GAME_OVER_LOOP_PREP %
00000208 : 0fc12297;   % 44:     la t0, NEXT_MAP   # Loads NEXT_MAP address %
00000209 : 8ec28293;   % 44:  %
0000020a : 00028523;   % 45:     sb zero,10(t0)    # Stores 0 on Render Next Map Door (in order to render current map's doors properly) %
0000020b : 0fc12297;   % 48:     la t0, MAP_INFO # Loads Map Info address %
0000020c : 8d828293;   % 48:  %
0000020d : 0002c303;   % 49:     lbu t1, 0 (t0)  # Loads byte related to map number %
0000020e : 0012c383;   % 50:     lbu t2, 1 (t0)  # Loads rendering byte (0 - don't render, 1 - render once, 2 - render twice,  %
0000020f : 0fc12e97;   % 53:     la t4, Doors    # Doors info address %
00000210 : c50e8e93;   % 53:  %
00000211 : 0fc12f17;   % 54:     la t5, Frames   # Frames info address %
00000212 : c88f0f13;   % 54:  %
00000213 : 00100293;   % 56:     li t0, 1  %
00000214 : 00629463;   % 57:     bne t0, t1, SKIP_MAP1_SETUP  %
00000215 : 0ac0006f;   % 58:     j MAP1_SETUP %
00000216 : 00200293;   % 61:         li t0, 2  %
00000217 : 00629463;   % 62:         bne t0, t1, SKIP_MAP2_SETUP  %
00000218 : 1cc0006f;   % 63:         j MAP2_SETUP %
00000219 : 00300293;   % 66:         li t0, 3  %
0000021a : 00629463;   % 67:         bne t0, t1, SKIP_MAP3_SETUP  %
0000021b : 2fc0006f;   % 68:         j MAP3_SETUP %
0000021c : 00400293;   % 71:         li t0, 4 %
0000021d : 00629463;   % 72:         bne t0, t1, SKIP_MAP4_SETUP  %
0000021e : 41c0006f;   % 73:         j MAP4_SETUP %
0000021f : 00500293;   % 76:         li t0, 5  %
00000220 : 00629463;   % 77:         bne t0, t1, SKIP_MAP5_SETUP  %
00000221 : 5440006f;   % 78:         j MAP5_SETUP %
00000222 : 00600293;   % 81:         li t0, 6 %
00000223 : 00629463;   % 82:         bne t0, t1, SKIP_MAP6_SETUP  %
00000224 : 6640006f;   % 83:         j MAP6_SETUP %
00000225 : 00700293;   % 86:             li t0, 7  %
00000226 : 00629463;   % 87:             bne t0, t1, SKIP_MAP7_SETUP  %
00000227 : 77c0006f;   % 88:             j MAP7_SETUP %
00000228 : 00700513;   % 91:         li a0, 7 %
00000229 : 00000593;   % 92:         li a1, 0 %
0000022a : 00000613;   % 93:         li a2, 0 %
0000022b : 14000693;   % 94:         li a3, 320 %
0000022c : 0f000713;   % 95:         li a4, 240 %
0000022d : 00000793;   % 96:         li a5, 0 %
0000022e : 00000813;   % 97:         li a6, 0	 %
0000022f : 00001317;   % 99:         call RENDER_COLOR %
00000230 : 10c300e7;   % 99:  %
00000231 : 00700513;   % 101:         li a0, 7 %
00000232 : 00000593;   % 102:         li a1, 0 %
00000233 : 00000613;   % 103:         li a2, 0 %
00000234 : 14000693;   % 104:         li a3, 320 %
00000235 : 0f000713;   % 105:         li a4, 240 %
00000236 : 00100793;   % 106:         li a5, 1 %
00000237 : 00000813;   % 107:         li a6, 0 %
00000238 : 00001317;   % 108:         call RENDER_COLOR %
00000239 : 0e8300e7;   % 108:  %
0000023a : 00001537;   % 110: 	    li a0, 3000 %
0000023b : bb850513;   % 110:  %
0000023c : 02000893;   % 111: 	    li a7,32 %
0000023d : 00000073;   % 112: 	    ecall %
0000023e : 00a00893;   % 113: 	    li a7, 10 %
0000023f : 00000073;   % 114:         ecall	    					 %
00000240 : 0fc12297;   % 117:         la t0, Doors1   # Doors address %
00000241 : b9428293;   % 117:  %
00000242 : 005ea023;   % 118:         sw t0,0(t4)     # Stores Doors1 address on Doors address %
00000243 : 0fc12297;   % 120:         la t0, Frames1  # Frames address %
00000244 : bc428293;   % 120:  %
00000245 : 005f2023;   % 121:         sw t0,0(t5)     # Stores Frames1 address on Doors address %
00000246 : 0fc12297;   % 123:         la t0,Zoomers   # Zoomers address %
00000247 : 92028293;   % 123:  %
00000248 : 0fc12317;   % 124:         la t1,Zoomers1  # Loads Zoomers1 address for Map 1 %
00000249 : 92030313;   % 124:  %
0000024a : 0062a023;   % 125:         sw t1,0(t0)     # and stores it %
0000024b : 0fc12297;   % 127:         la t0,Rippers   # Rippers address %
0000024c : acc28293;   % 127:  %
0000024d : 0002a023;   % 128:         sw zero,0(t0)   # Stores 0 to it (no rippers) %
0000024e : 0fc12297;   % 130:         la t0,Blocks    # Blocks address %
0000024f : 8d028293;   % 130:  %
00000250 : 0002a023;   % 131:         sw zero,0(t0)   # Stores 0 to it (no breakable blocks) %
00000251 : 0fc15517;   % 133:         la a0, Map1 	# Map Address      %
00000252 : 1e050513;   % 133:  %
00000253 : 0fc11297;   % 134:         la t0, CURRENT_MAP # Loads CURRENT_MAP address %
00000254 : 7b428293;   % 134:  %
00000255 : 00a2a023;   % 135:         sw a0, 0(t0)    # Stores Map1 address on CURRENT_MAP %
00000256 : 0062c583;   % 137:         lbu a1, 6(t0)   # Loads current X on Map (starting X on Matrix (top left)) %
00000257 : 0072c603;   % 138:         lbu a2, 7(t0)   # Loads current Y on Map (starting Y on Matrix (top left))	 %
00000258 : 0082c683;   % 139:         lbu a3, 8(t0)   # Loads current X offset on Map %
00000259 : 0092c703;   % 140:         lbu a4, 9(t0)   # Loads current Y offset on Map	 %
0000025a : 00400313;   % 142:         li t1, 4 %
0000025b : 06639263;   % 143:         bne t2, t1 CONTINUE_MAP1_SETUP %
0000025c : 00200393;   % 145:             li t2, 2 %
0000025d : 007282a3;   % 146:             sb t2, 5 (t0)  # Stores new rendering byte (2 - render twice)  %
0000025e : 01700593;   % 149:             li a1, 23 %
0000025f : 00b28323;   % 150:             sb a1, 6(t0)   # Stores new X on Map (starting X on Matrix (top left)) %
00000260 : 00000613;   % 151:             li a2, 0 %
00000261 : 00c283a3;   % 152:             sb a2, 7(t0)   # Stores new Y on Map (starting Y on Matrix (top left))	 %
00000262 : 00800693;   % 153:             li a3, 8 %
00000263 : 00d28423;   % 154:             sb a3, 8(t0)   # Stores new X offset on Map %
00000264 : 00000713;   % 155:             li a4, 0 %
00000265 : 00e284a3;   % 156:             sb a4, 9(t0)   # Stores new Y offset on Map	 %
00000266 : 0fc11297;   % 159:             la t0, PLYR_POS %
00000267 : 78228293;   % 159:  %
00000268 : 09800313;   % 160:             li t1, 152 %
00000269 : 00629023;   % 161:             sh t1, 0(t0)   # Stores new player's X related to the screen %
0000026a : 0a000313;   % 162:             li t1, 160 %
0000026b : 00628223;   % 163:             sb t1, 4(t0)   # Stores new player's Y related to the screen %
0000026c : 00000313;   % 165:             li t1, 0     %
0000026d : 00628323;   % 166:             sb t1, 6(t0)   # Stores new player's X offset %
0000026e : 00000313;   % 167:             li t1, 0 %
0000026f : 006283a3;   % 168:             sb t1, 7(t0)   # Stores new player's Y offset %
00000270 : 02100313;   % 170:             li t1, 33 %
00000271 : 00628423;   % 171:             sb t1, 8(t0)   # Stores new player's X related to the matrix %
00000272 : 00a00313;   % 172:             li t1, 10 %
00000273 : 00628523;   % 173:             sb t1, 10(t0)  # Stores new player's Y related to the matrix %
00000274 : 00000793;   % 176:         li a5, 0		# Frame = 0 %
00000275 : 01400813;   % 177:         li a6, 20	# Screen Width = 20 %
00000276 : 00f00893;   % 178:         li a7, 15	# Screen Height = 15 %
00000277 : 00000e13;   % 179:         li t3, 0		# Starting X for rendering (top left, related to Matrix) %
00000278 : 00000393;   % 180:         li t2, 0		# Starting Y for rendering (top left, related to Matrix) %
00000279 : 00000213;   % 181:         li tp, 0        # Map won't be dislocated %
0000027a : 00002317;   % 183:         call RENDER_MAP %
0000027b : 828300e7;   % 183:  %
0000027c : 0fc11297;   % 185:         la t0, CURRENT_MAP # Loads CURRENT_MAP address %
0000027d : 71028293;   % 185:  %
0000027e : 0062c583;   % 186:         lbu a1, 6(t0)   # Loads current X on Map (starting X on Matrix (top left)) %
0000027f : 0072c603;   % 187:         lbu a2, 7(t0)   # Loads current Y on Map (starting Y on Matrix (top left))	 %
00000280 : 0082c683;   % 188:         lbu a3, 8(t0)   # Loads current X offset on Map %
00000281 : 0092c703;   % 189:         lbu a4, 9(t0)   # Loads current Y offset on Map %
00000282 : 00100793;   % 190:         li a5, 1		# Frame = 0 %
00000283 : 01400813;   % 191:         li a6, 20	# Screen Width = 20 %
00000284 : 00f00893;   % 192:         li a7, 15	# Screen Height = 15 %
00000285 : 00000e13;   % 193:         li t3, 0		# Starting X for rendering (top left, related to Matrix) %
00000286 : 00000393;   % 194:         li t2, 0		# Starting Y for rendering (top left, related to Matrix) %
00000287 : 00000213;   % 195:         li tp, 0        # Map won't be dislocated %
00000288 : 00001317;   % 197:         call RENDER_MAP %
00000289 : 7f0300e7;   % 197:  %
0000028a : 7140006f;   % 199:         j END_SETUP %
0000028b : 0fc12297;   % 202:         la t0, Doors2   # Doors address %
0000028c : a6d28293;   % 202:  %
0000028d : 005ea023;   % 203:         sw t0,0(t4)     # Stores Doors2 address on Doors address %
0000028e : 0fc12297;   % 205:         la t0, Frames2  # Frames address %
0000028f : a9f28293;   % 205:  %
00000290 : 005f2023;   % 206:         sw t0,0(t5)     # Stores Frames2 address on Doors address %
00000291 : 0fc11297;   % 208:         la t0,Zoomers   # Zoomers address %
00000292 : 7f428293;   % 208:  %
00000293 : 0fc12317;   % 209:         la t1,Zoomers2  # Loads Zoomers2 address for Map 2 %
00000294 : 83d30313;   % 209:  %
00000295 : 0062a023;   % 210:         sw t1,0(t0)     # and stores it %
00000296 : 0fc12297;   % 212:         la t0,Rippers   # Rippers address %
00000297 : 9a028293;   % 212:  %
00000298 : 0fc12317;   % 213:         la t1,Rippers2  # Loads Rippers2 address for Map 2 %
00000299 : 9a030313;   % 213:  %
0000029a : 0062a023;   % 214:         sw t1,0(t0)     # and stores it %
0000029b : 0fc11297;   % 216:         la t0,Blocks    # Blocks address %
0000029c : 79c28293;   % 216:  %
0000029d : 0fc11317;   % 217:         la t1,Blocks2   # Loads Blocks2 address for Map 2 %
0000029e : 79c30313;   % 217:  %
0000029f : 0062a023;   % 218:         sw t1,0(t0)     # and stores it %
000002a0 : 0fc15517;   % 220:         la a0, Map2 	# Map Address      %
000002a1 : 42b50513;   % 220:  %
000002a2 : 0fc11297;   % 221:         la t0, CURRENT_MAP # Loads CURRENT_MAP address %
000002a3 : 67828293;   % 221:  %
000002a4 : 00a2a023;   % 222:         sw a0, 0(t0)    # Stores Map2 address on CURRENT_MAP %
000002a5 : 0062c583;   % 224:         lbu a1, 6(t0)   # Loads current X on Map (starting X on Matrix (top left)) %
000002a6 : 0072c603;   % 225:         lbu a2, 7(t0)   # Loads current Y on Map (starting Y on Matrix (top left))	 %
000002a7 : 0082c683;   % 226:         lbu a3, 8(t0)   # Loads current X offset on Map %
000002a8 : 0092c703;   % 227:         lbu a4, 9(t0)   # Loads current Y offset on Map		 %
000002a9 : 00400313;   % 229:         li t1, 4 %
000002aa : 06639263;   % 230:         bne t2, t1 CONTINUE_MAP2_SETUP %
000002ab : 00200393;   % 232:             li t2, 2 %
000002ac : 007282a3;   % 233:             sb t2, 5 (t0)  # Stores new rendering byte (2 - render twice)  %
000002ad : 00000593;   % 236:             li a1, 0 %
000002ae : 00b28323;   % 237:             sb a1, 6(t0)   # Stores new X on Map (starting X on Matrix (top left)) %
000002af : 00000613;   % 238:             li a2, 0 %
000002b0 : 00c283a3;   % 239:             sb a2, 7(t0)   # Stores new Y on Map (starting Y on Matrix (top left))	 %
000002b1 : 00000693;   % 240:             li a3, 0 %
000002b2 : 00d28423;   % 241:             sb a3, 8(t0)   # Stores new X offset on Map %
000002b3 : 00000713;   % 242:             li a4, 0 %
000002b4 : 00e284a3;   % 243:             sb a4, 9(t0)   # Stores new Y offset on Map	 %
000002b5 : 0fc11297;   % 246:             la t0, PLYR_POS %
000002b6 : 64628293;   % 246:  %
000002b7 : 02000313;   % 247:             li t1, 32 %
000002b8 : 00629023;   % 248:             sh t1, 0(t0)   # Stores new player's X related to the screen %
000002b9 : 06000313;   % 249:             li t1, 96 %
000002ba : 00628223;   % 250:             sb t1, 4(t0)   # Stores new player's Y related to the screen %
000002bb : 00000313;   % 252:             li t1, 0     %
000002bc : 00628323;   % 253:             sb t1, 6(t0)   # Stores new player's X offset %
000002bd : 00000313;   % 254:             li t1, 0 %
000002be : 006283a3;   % 255:             sb t1, 7(t0)   # Stores new player's Y offset %
000002bf : 00200313;   % 257:             li t1, 2 %
000002c0 : 00628423;   % 258:             sb t1, 8(t0)   # Stores new player's X related to the matrix %
000002c1 : 00600313;   % 259:             li t1, 6 %
000002c2 : 00628523;   % 260:             sb t1, 10(t0)  # Stores new player's Y related to the matrix %
000002c3 : 00000793;   % 263:         li a5, 0		# Frame = 0 %
000002c4 : 01400813;   % 264:         li a6, 20	# Screen Width = 20 %
000002c5 : 00f00893;   % 265:         li a7, 15	# Screen Height = 15 %
000002c6 : 00000e13;   % 266:         li t3, 0		# Starting X for rendering (top left, related to Matrix) %
000002c7 : 00000393;   % 267:         li t2, 0		# Starting Y for rendering (top left, related to Matrix) %
000002c8 : 00000213;   % 268:         li tp, 0        # Map won't be dislocated %
000002c9 : 00001317;   % 270:         call RENDER_MAP %
000002ca : 6ec300e7;   % 270:  %
000002cb : 0fc11297;   % 272:         la t0, CURRENT_MAP # Loads CURRENT_MAP address %
000002cc : 5d428293;   % 272:  %
000002cd : 0062c583;   % 273:         lbu a1, 6(t0)   # Loads current X on Map (starting X on Matrix (top left)) %
000002ce : 0072c603;   % 274:         lbu a2, 7(t0)   # Loads current Y on Map (starting Y on Matrix (top left))	 %
000002cf : 0082c683;   % 275:         lbu a3, 8(t0)   # Loads current X offset on Map %
000002d0 : 0092c703;   % 276:         lbu a4, 9(t0)   # Loads current Y offset on Map	 %
000002d1 : 00100793;   % 277:         li a5, 1		# Frame = 1 %
000002d2 : 01400813;   % 278:         li a6, 20	# Screen Width = 20 %
000002d3 : 00f00893;   % 279:         li a7, 15	# Screen Height = 15 %
000002d4 : 00000e13;   % 280:         li t3, 0		# Starting X for rendering (top left, related to Matrix) %
000002d5 : 00000393;   % 281:         li t2, 0		# Starting Y for rendering (top left, related to Matrix) %
000002d6 : 00000213;   % 282:         li tp, 0        # Map won't be dislocated %
000002d7 : 00001317;   % 283:         call RENDER_MAP %
000002d8 : 6b4300e7;   % 283:  %
000002d9 : 5d80006f;   % 285:         j END_SETUP %
000002da : 0fc12297;   % 288:         la t0, Doors3   # Doors address %
000002db : 93e28293;   % 288:  %
000002dc : 005ea023;   % 289:         sw t0,0(t4)     # Stores Doors3 address on Doors address %
000002dd : 0fc12297;   % 291:         la t0, Frames3  # Frames address %
000002de : 97628293;   % 291:  %
000002df : 005f2023;   % 292:         sw t0,0(t5)     # Stores Frames3 address on Doors address %
000002e0 : 0fc11297;   % 294:         la t0,Zoomers   # Zoomers address %
000002e1 : 6b828293;   % 294:  %
000002e2 : 0fc11317;   % 295:         la t1,Zoomers3  # Loads Zoomers3 address for Map 3 %
000002e3 : 76e30313;   % 295:  %
000002e4 : 0062a023;   % 296:         sw t1,0(t0)     # and stores it %
000002e5 : 0fc12297;   % 298:         la t0,Rippers   # Rippers address %
000002e6 : 86428293;   % 298:  %
000002e7 : 0002a023;   % 299:         sw zero,0(t0)   # Stores 0 to it (no rippers) %
000002e8 : 0fc11297;   % 301:         la t0,Blocks    # Blocks address %
000002e9 : 66828293;   % 301:  %
000002ea : 0002a023;   % 302:         sw zero,0(t0)   # Stores 0 to it (no breakable blocks) %
000002eb : 0fc15517;   % 304:         la a0, Map3 	# Map Address      %
000002ec : 68650513;   % 304:  %
000002ed : 0fc11297;   % 305:         la t0, CURRENT_MAP # Loads CURRENT_MAP address %
000002ee : 54c28293;   % 305:  %
000002ef : 00a2a023;   % 306:         sw a0, 0(t0)    # Stores Map3 address on CURRENT_MAP %
000002f0 : 0062c583;   % 308:         lbu a1, 6(t0)   # Loads current X on Map (starting X on Matrix (top left)) %
000002f1 : 0072c603;   % 309:         lbu a2, 7(t0)   # Loads current Y on Map (starting Y on Matrix (top left))	 %
000002f2 : 0082c683;   % 310:         lbu a3, 8(t0)   # Loads current X offset on Map %
000002f3 : 0092c703;   % 311:         lbu a4, 9(t0)   # Loads current Y offset on Map		 %
000002f4 : 00400313;   % 313:         li t1, 4 %
000002f5 : 06639263;   % 314:         bne t2, t1 CONTINUE_MAP3_SETUP %
000002f6 : 00200393;   % 316:             li t2, 2 %
000002f7 : 007282a3;   % 317:             sb t2, 5 (t0)  # Stores new rendering byte (2 - render twice)  %
000002f8 : 00000593;   % 320:             li a1, 0 %
000002f9 : 00b28323;   % 321:             sb a1, 6(t0)   # Stores new X on Map (starting X on Matrix (top left)) %
000002fa : 00000613;   % 322:             li a2, 0 %
000002fb : 00c283a3;   % 323:             sb a2, 7(t0)   # Stores new Y on Map (starting Y on Matrix (top left))	 %
000002fc : 00000693;   % 324:             li a3, 0 %
000002fd : 00d28423;   % 325:             sb a3, 8(t0)   # Stores new X offset on Map %
000002fe : 00000713;   % 326:             li a4, 0 %
000002ff : 00e284a3;   % 327:             sb a4, 9(t0)   # Stores new Y offset on Map	 %
00000300 : 0fc11297;   % 330:             la t0, PLYR_POS %
00000301 : 51a28293;   % 330:  %
00000302 : 02000313;   % 331:             li t1, 32 %
00000303 : 00629023;   % 332:             sh t1, 0(t0)   # Stores new player's X related to the screen %
00000304 : 06000313;   % 333:             li t1, 96 %
00000305 : 00628223;   % 334:             sb t1, 4(t0)   # Stores new player's Y related to the screen %
00000306 : 00000313;   % 336:             li t1, 0     %
00000307 : 00628323;   % 337:             sb t1, 6(t0)   # Stores new player's X offset %
00000308 : 00000313;   % 338:             li t1, 0 %
00000309 : 006283a3;   % 339:             sb t1, 7(t0)   # Stores new player's Y offset %
0000030a : 00200313;   % 341:             li t1, 2 %
0000030b : 00628423;   % 342:             sb t1, 8(t0)   # Stores new player's X related to the matrix %
0000030c : 00600313;   % 343:             li t1, 6 %
0000030d : 00628523;   % 344:             sb t1, 10(t0)  # Stores new player's Y related to the matrix %
0000030e : 00000793;   % 347:         li a5, 0		# Frame = 0 %
0000030f : 01400813;   % 348:         li a6, 20	# Screen Width = 20 %
00000310 : 00f00893;   % 349:         li a7, 15	# Screen Height = 15 %
00000311 : 00000e13;   % 350:         li t3, 0		# Starting X for rendering (top left, related to Matrix) %
00000312 : 00000393;   % 351:         li t2, 0		# Starting Y for rendering (top left, related to Matrix) %
00000313 : 00000213;   % 352:         li tp, 0        # Map won't be dislocated %
00000314 : 00001317;   % 354:         call RENDER_MAP %
00000315 : 5c0300e7;   % 354:  %
00000316 : 0fc11297;   % 356:         la t0, CURRENT_MAP # Loads CURRENT_MAP address %
00000317 : 4a828293;   % 356:  %
00000318 : 0062c583;   % 357:         lbu a1, 6(t0)   # Loads current X on Map (starting X on Matrix (top left)) %
00000319 : 0072c603;   % 358:         lbu a2, 7(t0)   # Loads current Y on Map (starting Y on Matrix (top left))	 %
0000031a : 0082c683;   % 359:         lbu a3, 8(t0)   # Loads current X offset on Map %
0000031b : 0092c703;   % 360:         lbu a4, 9(t0)   # Loads current Y offset on Map	 %
0000031c : 00100793;   % 361:         li a5, 1		# Frame = 1 %
0000031d : 01400813;   % 362:         li a6, 20	# Screen Width = 20 %
0000031e : 00f00893;   % 363:         li a7, 15	# Screen Height = 15 %
0000031f : 00000e13;   % 364:         li t3, 0		# Starting X for rendering (top left, related to Matrix) %
00000320 : 00000393;   % 365:         li t2, 0		# Starting Y for rendering (top left, related to Matrix) %
00000321 : 00000213;   % 366:         li tp, 0        # Map won't be dislocated %
00000322 : 00001317;   % 367:         call RENDER_MAP %
00000323 : 588300e7;   % 367:  %
00000324 : 4ac0006f;   % 369:         j END_SETUP %
00000325 : 0fc12297;   % 373:         la t0, Doors4   # Doors address %
00000326 : 81b28293;   % 373:  %
00000327 : 005ea023;   % 374:         sw t0,0(t4)     # Stores Doors4 address on Doors address %
00000328 : 0fc12297;   % 376:         la t0, Frames4  # Frames address %
00000329 : 85728293;   % 376:  %
0000032a : 005f2023;   % 377:         sw t0,0(t5)     # Stores Frames4 address on Doors address %
0000032b : 0fc11297;   % 379:         la t0,Zoomers   # Zoomers address %
0000032c : 58c28293;   % 379:  %
0000032d : 0fc11317;   % 380:         la t1,Zoomers4  # Loads Zoomers4 address for Map 4 %
0000032e : 68b30313;   % 380:  %
0000032f : 0062a023;   % 381:         sw t1,0(t0)     # and stores it %
00000330 : 0fc11297;   % 383:         la t0,Rippers   # Rippers address %
00000331 : 73828293;   % 383:  %
00000332 : 0fc11317;   % 384:         la t1,Rippers4  # Loads Rippers4 address for Map 4 %
00000333 : 75c30313;   % 384:  %
00000334 : 0062a023;   % 385:         sw t1,0(t0)     # and stores it %
00000335 : 0fc11297;   % 387:         la t0,Blocks    # Blocks address %
00000336 : 53428293;   % 387:  %
00000337 : 0002a023;   % 388:         sw zero,0(t0)   # Stores 0 to it (no breakable blocks) %
00000338 : 0fc16517;   % 390:         la a0, Map4 	# Map Address      %
00000339 : 8d950513;   % 390:  %
0000033a : 0fc11297;   % 391:         la t0, CURRENT_MAP # Loads CURRENT_MAP address %
0000033b : 41828293;   % 391:  %
0000033c : 00a2a023;   % 392:         sw a0, 0(t0)    # Stores Map4 address on CURRENT_MAP %
0000033d : 0062c583;   % 394:         lbu a1, 6(t0)   # Loads current X on Map (starting X on Matrix (top left)) %
0000033e : 0072c603;   % 395:         lbu a2, 7(t0)   # Loads current Y on Map (starting Y on Matrix (top left))	 %
0000033f : 0082c683;   % 396:         lbu a3, 8(t0)   # Loads current X offset on Map %
00000340 : 0092c703;   % 397:         lbu a4, 9(t0)   # Loads current Y offset on Map		 %
00000341 : 00400313;   % 399:         li t1, 4 %
00000342 : 06639263;   % 400:         bne t2, t1 CONTINUE_MAP4_SETUP %
00000343 : 00200393;   % 402:             li t2, 2 %
00000344 : 007282a3;   % 403:             sb t2, 5 (t0)  # Stores new rendering byte (2 - render twice)  %
00000345 : 00000593;   % 406:             li a1, 0 %
00000346 : 00b28323;   % 407:             sb a1, 6(t0)   # Stores new X on Map (starting X on Matrix (top left)) %
00000347 : 01e00613;   % 408:             li a2, 30 %
00000348 : 00c283a3;   % 409:             sb a2, 7(t0)   # Stores new Y on Map (starting Y on Matrix (top left))	 %
00000349 : 00000693;   % 410:             li a3, 0 %
0000034a : 00d28423;   % 411:             sb a3, 8(t0)   # Stores new X offset on Map %
0000034b : 00000713;   % 412:             li a4, 0 %
0000034c : 00e284a3;   % 413:             sb a4, 9(t0)   # Stores new Y offset on Map	 %
0000034d : 0fc11297;   % 416:             la t0, PLYR_POS %
0000034e : 3e628293;   % 416:  %
0000034f : 02000313;   % 417:             li t1, 32 %
00000350 : 00629023;   % 418:             sh t1, 0(t0)   # Stores new player's X related to the screen %
00000351 : 06000313;   % 419:             li t1, 96 %
00000352 : 00628223;   % 420:             sb t1, 4(t0)   # Stores new player's Y related to the screen %
00000353 : 00000313;   % 422:             li t1, 0     %
00000354 : 00628323;   % 423:             sb t1, 6(t0)   # Stores new player's X offset %
00000355 : 00000313;   % 424:             li t1, 0 %
00000356 : 006283a3;   % 425:             sb t1, 7(t0)   # Stores new player's Y offset %
00000357 : 00200313;   % 427:             li t1, 2 %
00000358 : 00628423;   % 428:             sb t1, 8(t0)   # Stores new player's X related to the matrix %
00000359 : 02400313;   % 429:             li t1, 36 %
0000035a : 00628523;   % 430:             sb t1, 10(t0)  # Stores new player's Y related to the matrix %
0000035b : 00000793;   % 433:         li a5, 0		# Frame = 0 %
0000035c : 01400813;   % 434:         li a6, 20	# Screen Width = 20 %
0000035d : 00f00893;   % 435:         li a7, 15	# Screen Height = 15 %
0000035e : 00000e13;   % 436:         li t3, 0		# Starting X for rendering (top left, related to Matrix) %
0000035f : 00000393;   % 437:         li t2, 0		# Starting Y for rendering (top left, related to Matrix) %
00000360 : 00000213;   % 438:         li tp, 0        # Map won't be dislocated %
00000361 : 00001317;   % 440:         call RENDER_MAP %
00000362 : 48c300e7;   % 440:  %
00000363 : 0fc11297;   % 442:         la t0, CURRENT_MAP # Loads CURRENT_MAP address %
00000364 : 37428293;   % 442:  %
00000365 : 0062c583;   % 443:         lbu a1, 6(t0)   # Loads current X on Map (starting X on Matrix (top left)) %
00000366 : 0072c603;   % 444:         lbu a2, 7(t0)   # Loads current Y on Map (starting Y on Matrix (top left))	 %
00000367 : 0082c683;   % 445:         lbu a3, 8(t0)   # Loads current X offset on Map %
00000368 : 0092c703;   % 446:         lbu a4, 9(t0)   # Loads current Y offset on Map	 %
00000369 : 00100793;   % 447:         li a5, 1		# Frame = 1 %
0000036a : 01400813;   % 448:         li a6, 20	# Screen Width = 20 %
0000036b : 00f00893;   % 449:         li a7, 15	# Screen Height = 15 %
0000036c : 00000e13;   % 450:         li t3, 0		# Starting X for rendering (top left, related to Matrix) %
0000036d : 00000393;   % 451:         li t2, 0		# Starting Y for rendering (top left, related to Matrix) %
0000036e : 00000213;   % 452:         li tp, 0        # Map won't be dislocated %
0000036f : 00001317;   % 453:         call RENDER_MAP %
00000370 : 454300e7;   % 453:  %
00000371 : 3780006f;   % 455:         j END_SETUP %
00000372 : 0fc11297;   % 458:         la t0, Doors5   # Doors address %
00000373 : 6f028293;   % 458:  %
00000374 : 005ea023;   % 459:         sw t0,0(t4)     # Stores Doors5 address on Doors address %
00000375 : 0fc11297;   % 461:         la t0, Frames5  # Frames address %
00000376 : 73028293;   % 461:  %
00000377 : 005f2023;   % 462:         sw t0,0(t5)     # Stores Frames5 address on Doors address %
00000378 : 0fc11297;   % 464:         la t0,Zoomers   # Zoomers address %
00000379 : 45828293;   % 464:  %
0000037a : 0fc11317;   % 465:         la t1,Zoomers5  # Loads Zoomers5 address for Map 5 %
0000037b : 5dc30313;   % 465:  %
0000037c : 0062a023;   % 466:         sw t1,0(t0)     # and stores it %
0000037d : 0fc11297;   % 468:         la t0,Rippers   # Rippers address %
0000037e : 60428293;   % 468:  %
0000037f : 0002a023;   % 469:         sw zero,0(t0)   # Stores 0 to it (no rippers) %
00000380 : 0fc11297;   % 471:         la t0,Blocks    # Blocks address %
00000381 : 40828293;   % 471:  %
00000382 : 0002a023;   % 472:         sw zero,0(t0)   # Stores 0 to it (no breakable blocks) %
00000383 : 0fc16517;   % 474:         la a0, Map5 	# Map Address      %
00000384 : b3450513;   % 474:  %
00000385 : 0fc11297;   % 475:         la t0, CURRENT_MAP # Loads CURRENT_MAP address %
00000386 : 2ec28293;   % 475:  %
00000387 : 00a2a023;   % 476:         sw a0, 0(t0)    # Stores Map5 address on CURRENT_MAP %
00000388 : 0062c583;   % 478:         lbu a1, 6(t0)   # Loads current X on Map (starting X on Matrix (top left)) %
00000389 : 0072c603;   % 479:         lbu a2, 7(t0)   # Loads current Y on Map (starting Y on Matrix (top left))	 %
0000038a : 0082c683;   % 480:         lbu a3, 8(t0)   # Loads current X offset on Map %
0000038b : 0092c703;   % 481:         lbu a4, 9(t0)   # Loads current Y offset on Map		 %
0000038c : 00400313;   % 483:         li t1, 4 %
0000038d : 06639263;   % 484:         bne t2, t1 CONTINUE_MAP5_SETUP %
0000038e : 00200393;   % 486:             li t2, 2 %
0000038f : 007282a3;   % 487:             sb t2, 5 (t0)  # Stores new rendering byte (2 - render twice)  %
00000390 : 01400593;   % 490:             li a1, 20 %
00000391 : 00b28323;   % 491:             sb a1, 6(t0)   # Stores new X on Map (starting X on Matrix (top left)) %
00000392 : 00000613;   % 492:             li a2, 0 %
00000393 : 00c283a3;   % 493:             sb a2, 7(t0)   # Stores new Y on Map (starting Y on Matrix (top left))	 %
00000394 : 00000693;   % 494:             li a3, 0 %
00000395 : 00d28423;   % 495:             sb a3, 8(t0)   # Stores new X offset on Map %
00000396 : 00000713;   % 496:             li a4, 0 %
00000397 : 00e284a3;   % 497:             sb a4, 9(t0)   # Stores new Y offset on Map	 %
00000398 : 0fc11297;   % 500:             la t0, PLYR_POS %
00000399 : 2ba28293;   % 500:  %
0000039a : 11000313;   % 501:             li t1, 272 %
0000039b : 00629023;   % 502:             sh t1, 0(t0)   # Stores new player's X related to the screen %
0000039c : 06000313;   % 503:             li t1, 96 %
0000039d : 00628223;   % 504:             sb t1, 4(t0)   # Stores new player's Y related to the screen %
0000039e : 00000313;   % 506:             li t1, 0     %
0000039f : 00628323;   % 507:             sb t1, 6(t0)   # Stores new player's X offset %
000003a0 : 00000313;   % 508:             li t1, 0 %
000003a1 : 006283a3;   % 509:             sb t1, 7(t0)   # Stores new player's Y offset %
000003a2 : 02500313;   % 511:             li t1, 37 %
000003a3 : 00628423;   % 512:             sb t1, 8(t0)   # Stores new player's X related to the matrix %
000003a4 : 00600313;   % 513:             li t1, 6 %
000003a5 : 00628523;   % 514:             sb t1, 10(t0)  # Stores new player's Y related to the matrix %
000003a6 : 00000793;   % 517:         li a5, 0		# Frame = 0 %
000003a7 : 01400813;   % 518:         li a6, 20	# Screen Width = 20 %
000003a8 : 00f00893;   % 519:         li a7, 15	# Screen Height = 15 %
000003a9 : 00000e13;   % 520:         li t3, 0		# Starting X for rendering (top left, related to Matrix) %
000003aa : 00000393;   % 521:         li t2, 0		# Starting Y for rendering (top left, related to Matrix) %
000003ab : 00000213;   % 522:         li tp, 0        # Map won't be dislocated %
000003ac : 00001317;   % 524:         call RENDER_MAP %
000003ad : 360300e7;   % 524:  %
000003ae : 0fc11297;   % 526:         la t0, CURRENT_MAP # Loads CURRENT_MAP address %
000003af : 24828293;   % 526:  %
000003b0 : 0062c583;   % 527:         lbu a1, 6(t0)   # Loads current X on Map (starting X on Matrix (top left)) %
000003b1 : 0072c603;   % 528:         lbu a2, 7(t0)   # Loads current Y on Map (starting Y on Matrix (top left))	 %
000003b2 : 0082c683;   % 529:         lbu a3, 8(t0)   # Loads current X offset on Map %
000003b3 : 0092c703;   % 530:         lbu a4, 9(t0)   # Loads current Y offset on Map	 %
000003b4 : 00100793;   % 531:         li a5, 1		# Frame = 1 %
000003b5 : 01400813;   % 532:         li a6, 20	# Screen Width = 20 %
000003b6 : 00f00893;   % 533:         li a7, 15	# Screen Height = 15 %
000003b7 : 00000e13;   % 534:         li t3, 0		# Starting X for rendering (top left, related to Matrix) %
000003b8 : 00000393;   % 535:         li t2, 0		# Starting Y for rendering (top left, related to Matrix) %
000003b9 : 00000213;   % 536:         li tp, 0        # Map won't be dislocated %
000003ba : 00001317;   % 537:         call RENDER_MAP %
000003bb : 328300e7;   % 537:  %
000003bc : 24c0006f;   % 539:         j END_SETUP %
000003bd : 0fc11297;   % 542:         la t0, Doors6   # Doors address %
000003be : 5cd28293;   % 542:  %
000003bf : 005ea023;   % 543:         sw t0,0(t4)     # Stores Doors6 address on Doors address %
000003c0 : 0fc11297;   % 545:         la t0, Frames6  # Frames address %
000003c1 : 61128293;   % 545:  %
000003c2 : 005f2023;   % 546:         sw t0,0(t5)     # Stores Frames6 address on Doors address %
000003c3 : 0fc11297;   % 548:         la t0,Zoomers   # Zoomers address %
000003c4 : 32c28293;   % 548:  %
000003c5 : 0002a023;   % 549:         sw zero,0(t0)   # Stores 0 to it (no zoomers) %
000003c6 : 0fc11297;   % 551:         la t0,Rippers   # Rippers address %
000003c7 : 4e028293;   % 551:  %
000003c8 : 0002a023;   % 552:         sw zero,0(t0)   # Stores 0 to it (no rippers) %
000003c9 : 0fc11297;   % 554:         la t0,Blocks    # Blocks address %
000003ca : 2e428293;   % 554:  %
000003cb : 0002a023;   % 555:         sw zero,0(t0)   # Stores 0 to it (no breakable blocks) %
000003cc : 0fc16517;   % 557:         la a0, Map6 	# Map Address      %
000003cd : c6b50513;   % 557:  %
000003ce : 0fc11297;   % 558:         la t0, CURRENT_MAP # Loads CURRENT_MAP address %
000003cf : 1c828293;   % 558:  %
000003d0 : 00a2a023;   % 559:         sw a0, 0(t0)    # Stores Map6 address on CURRENT_MAP %
000003d1 : 0062c583;   % 561:         lbu a1, 6(t0)   # Loads current X on Map (starting X on Matrix (top left)) %
000003d2 : 0072c603;   % 562:         lbu a2, 7(t0)   # Loads current Y on Map (starting Y on Matrix (top left))	 %
000003d3 : 0082c683;   % 563:         lbu a3, 8(t0)   # Loads current X offset on Map %
000003d4 : 0092c703;   % 564:         lbu a4, 9(t0)   # Loads current Y offset on Map		 %
000003d5 : 00400313;   % 566:         li t1, 4 %
000003d6 : 06639263;   % 567:         bne t2, t1 CONTINUE_MAP6_SETUP %
000003d7 : 00200393;   % 569:             li t2, 2 %
000003d8 : 007282a3;   % 570:             sb t2, 5 (t0)  # Stores new rendering byte (2 - render twice)  %
000003d9 : 00000593;   % 573:             li a1, 0 %
000003da : 00b28323;   % 574:             sb a1, 6(t0)   # Stores new X on Map (starting X on Matrix (top left)) %
000003db : 00000613;   % 575:             li a2, 0 %
000003dc : 00c283a3;   % 576:             sb a2, 7(t0)   # Stores new Y on Map (starting Y on Matrix (top left))	 %
000003dd : 00000693;   % 577:             li a3, 0 %
000003de : 00d28423;   % 578:             sb a3, 8(t0)   # Stores new X offset on Map %
000003df : 00000713;   % 579:             li a4, 0 %
000003e0 : 00e284a3;   % 580:             sb a4, 9(t0)   # Stores new Y offset on Map	 %
000003e1 : 0fc11297;   % 583:             la t0, PLYR_POS %
000003e2 : 19628293;   % 583:  %
000003e3 : 11000313;   % 584:             li t1, 272 %
000003e4 : 00629023;   % 585:             sh t1, 0(t0)   # Stores new player's X related to the screen %
000003e5 : 06000313;   % 586:             li t1, 96 %
000003e6 : 00628223;   % 587:             sb t1, 4(t0)   # Stores new player's Y related to the screen %
000003e7 : 00000313;   % 589:             li t1, 0     %
000003e8 : 00628323;   % 590:             sb t1, 6(t0)   # Stores new player's X offset %
000003e9 : 00000313;   % 591:             li t1, 0 %
000003ea : 006283a3;   % 592:             sb t1, 7(t0)   # Stores new player's Y offset %
000003eb : 01100313;   % 594:             li t1, 17 %
000003ec : 00628423;   % 595:             sb t1, 8(t0)   # Stores new player's X related to the matrix %
000003ed : 00600313;   % 596:             li t1, 6 %
000003ee : 00628523;   % 597:             sb t1, 10(t0)  # Stores new player's Y related to the matrix %
000003ef : 00000793;   % 600:         li a5, 0		# Frame = 0 %
000003f0 : 01400813;   % 601:         li a6, 20	# Screen Width = 20 %
000003f1 : 00f00893;   % 602:         li a7, 15	# Screen Height = 15 %
000003f2 : 00000e13;   % 603:         li t3, 0		# Starting X for rendering (top left, related to Matrix) %
000003f3 : 00000393;   % 604:         li t2, 0		# Starting Y for rendering (top left, related to Matrix) %
000003f4 : 00000213;   % 605:         li tp, 0        # Map won't be dislocated %
000003f5 : 00001317;   % 606:         call RENDER_MAP %
000003f6 : 23c300e7;   % 606:  %
000003f7 : 0fc11297;   % 608:         la t0, CURRENT_MAP # Loads CURRENT_MAP address %
000003f8 : 12428293;   % 608:  %
000003f9 : 0062c583;   % 609:         lbu a1, 6(t0)   # Loads current X on Map (starting X on Matrix (top left)) %
000003fa : 0072c603;   % 610:         lbu a2, 7(t0)   # Loads current Y on Map (starting Y on Matrix (top left))	 %
000003fb : 0082c683;   % 611:         lbu a3, 8(t0)   # Loads current X offset on Map %
000003fc : 0092c703;   % 612:         lbu a4, 9(t0)   # Loads current Y offset on Map	 %
000003fd : 00100793;   % 613:         li a5, 1		# Frame = 1 %
000003fe : 01400813;   % 614:         li a6, 20	# Screen Width = 20 %
000003ff : 00f00893;   % 615:         li a7, 15	# Screen Height = 15 %
00000400 : 00000e13;   % 616:         li t3, 0		# Starting X for rendering (top left, related to Matrix) %
00000401 : 00000393;   % 617:         li t2, 0		# Starting Y for rendering (top left, related to Matrix) %
00000402 : 00000213;   % 618:         li tp, 0        # Map won't be dislocated  %
00000403 : 00001317;   % 619:         call RENDER_MAP %
00000404 : 204300e7;   % 619:  %
00000405 : 1280006f;   % 621:         j END_SETUP %
00000406 : 0fc11297;   % 624:         la t0, Doors7   # Doors address %
00000407 : 4ae28293;   % 624:  %
00000408 : 005ea023;   % 625:         sw t0,0(t4)     # Stores Doors1 address on Doors address %
00000409 : 0fc11297;   % 627:         la t0, Frames7  # Frames address %
0000040a : 4f428293;   % 627:  %
0000040b : 005f2023;   % 628:         sw t0,0(t5)     # Stores Frames7 address on Doors address %
0000040c : 0fc11297;   % 630:         la t0,Zoomers   # Zoomers address %
0000040d : 20828293;   % 630:  %
0000040e : 0002a023;   % 631:         sw zero,0(t0)   # Stores 0 to it (no zoomers) %
0000040f : 0fc11297;   % 633:         la t0,Rippers   # Rippers address %
00000410 : 3bc28293;   % 633:  %
00000411 : 0002a023;   % 634:         sw zero,0(t0)   # Stores 0 to it (no rippers) %
00000412 : 0fc11297;   % 636:         la t0,Blocks    # Blocks address %
00000413 : 1c028293;   % 636:  %
00000414 : 0002a023;   % 637:         sw zero,0(t0)   # Stores 0 to it (no breakable blocks) %
00000415 : 0fc16517;   % 639:         la a0, Map7 	# Map Address      %
00000416 : c7650513;   % 639:  %
00000417 : 0fc11297;   % 640:         la t0, CURRENT_MAP # Loads CURRENT_MAP address %
00000418 : 0a428293;   % 640:  %
00000419 : 00a2a023;   % 641:         sw a0, 0(t0)    # Stores Map7 address on CURRENT_MAP %
0000041a : 0062c583;   % 643:         lbu a1, 6(t0)   # Loads current X on Map (starting X on Matrix (top left)) %
0000041b : 0072c603;   % 644:         lbu a2, 7(t0)   # Loads current Y on Map (starting Y on Matrix (top left))	 %
0000041c : 0082c683;   % 645:         lbu a3, 8(t0)   # Loads current X offset on Map %
0000041d : 0092c703;   % 646:         lbu a4, 9(t0)   # Loads current Y offset on Map		 %
0000041e : 00400313;   % 648:         li t1, 4 %
0000041f : 06639263;   % 649:         bne t2, t1 CONTINUE_MAP7_SETUP %
00000420 : 00200393;   % 651:             li t2, 2 %
00000421 : 007282a3;   % 652:             sb t2, 5 (t0)  # Stores new rendering byte (2 - render twice)  %
00000422 : 00000593;   % 655:             li a1, 0 %
00000423 : 00b28323;   % 656:             sb a1, 6(t0)   # Stores new X on Map (starting X on Matrix (top left)) %
00000424 : 00000613;   % 657:             li a2, 0 %
00000425 : 00c283a3;   % 658:             sb a2, 7(t0)   # Stores new Y on Map (starting Y on Matrix (top left))	 %
00000426 : 00000693;   % 659:             li a3, 0 %
00000427 : 00d28423;   % 660:             sb a3, 8(t0)   # Stores new X offset on Map %
00000428 : 00000713;   % 661:             li a4, 0 %
00000429 : 00e284a3;   % 662:             sb a4, 9(t0)   # Stores new Y offset on Map	 %
0000042a : 0fc11297;   % 665:             la t0, PLYR_POS %
0000042b : 07228293;   % 665:  %
0000042c : 11000313;   % 666:             li t1, 272 %
0000042d : 00629023;   % 667:             sh t1, 0(t0)   # Stores new player's X related to the screen %
0000042e : 06000313;   % 668:             li t1, 96 %
0000042f : 00628223;   % 669:             sb t1, 4(t0)   # Stores new player's Y related to the screen %
00000430 : 00000313;   % 671:             li t1, 0     %
00000431 : 00628323;   % 672:             sb t1, 6(t0)   # Stores new player's X offset %
00000432 : 00000313;   % 673:             li t1, 0 %
00000433 : 006283a3;   % 674:             sb t1, 7(t0)   # Stores new player's Y offset %
00000434 : 01100313;   % 676:             li t1, 17 %
00000435 : 00628423;   % 677:             sb t1, 8(t0)   # Stores new player's X related to the matrix %
00000436 : 00600313;   % 678:             li t1, 6 %
00000437 : 00628523;   % 679:             sb t1, 10(t0)  # Stores new player's Y related to the matrix %
00000438 : 00000793;   % 682:         li a5, 0		# Frame = 0 %
00000439 : 01400813;   % 683:         li a6, 20	# Screen Width = 20 %
0000043a : 00f00893;   % 684:         li a7, 15	# Screen Height = 15 %
0000043b : 00000e13;   % 685:         li t3, 0		# Starting X for rendering (top left, related to Matrix) %
0000043c : 00000393;   % 686:         li t2, 0		# Starting Y for rendering (top left, related to Matrix) %
0000043d : 00000213;   % 687:         li tp, 0        # Map won't be dislocated %
0000043e : 00001317;   % 688:         call RENDER_MAP %
0000043f : 118300e7;   % 688:  %
00000440 : 0fc11297;   % 690:         la t0, CURRENT_MAP # Loads CURRENT_MAP address %
00000441 : 00028293;   % 690:  %
00000442 : 0062c583;   % 691:         lbu a1, 6(t0)   # Loads current X on Map (starting X on Matrix (top left)) %
00000443 : 0072c603;   % 692:         lbu a2, 7(t0)   # Loads current Y on Map (starting Y on Matrix (top left))	 %
00000444 : 0082c683;   % 693:         lbu a3, 8(t0)   # Loads current X offset on Map %
00000445 : 0092c703;   % 694:         lbu a4, 9(t0)   # Loads current Y offset on Map	 %
00000446 : 00100793;   % 695:         li a5, 1		# Frame = 1 %
00000447 : 01400813;   % 696:         li a6, 20	# Screen Width = 20 %
00000448 : 00f00893;   % 697:         li a7, 15	# Screen Height = 15 %
00000449 : 00000e13;   % 698:         li t3, 0		# Starting X for rendering (top left, related to Matrix) %
0000044a : 00000393;   % 699:         li t2, 0		# Starting Y for rendering (top left, related to Matrix) %
0000044b : 00000213;   % 700:         li tp, 0        # Map won't be dislocated %
0000044c : 00001317;   % 701:         call RENDER_MAP %
0000044d : 0e0300e7;   % 701:  %
0000044e : 0040006f;   % 703:         j END_SETUP %
0000044f : 0fc11297;   % 706:     la t0, CURRENT_MAP   # Loads CURRENT_MAP address %
00000450 : fc428293;   % 706:  %
00000451 : 0052c303;   % 707:     lbu t1,5(t0)         # Loads rendering byte      %
00000452 : 00300393;   % 708:     li t2, 3             # Loads 3 (switch map through door) to be compared with %
00000453 : 00731463;   % 709:     bne t1,t2, END_SETUP_NORMAL # If rendering byte != 3, return to game loop %
00000454 : 5c80506f;   % 710:         j LEAVE_DOOR_ANIMATION_PREP # Otherwise, finish map switch %
00000455 : 00099e63;   % 714:         bnez s3,SKIP_ABILITY_RESET   # If clicking on continue, habilities will be kept %
00000456 : 0fc11297;   % 715:             la t0,PLYR_INFO %
00000457 : fc028293;   % 715:  %
00000458 : 000280a3;   % 716:             sb zero,1(t0)     # Resets ability information %
00000459 : 0fc11297;   % 718:             la t0, ITEM_CAPSULE_INFO %
0000045a : ff828293;   % 718:  %
0000045b : 00028023;   % 719:             sb zero,0(t0)              # Restores capsule %
0000045c : 00100993;   % 721:             li s3, 1       # If player's info was already reset %
0000045d : 0fc11297;   % 722:             la t0,MOVE_X %
0000045e : fb828293;   % 722:  %
0000045f : 0002a023;   % 723:             sw zero,0(t0)  # Resets MOVE_X, MOVE_Y,JUMP byte and Player input byte %
00000460 : 0fc11297;   % 725:             la t0,PLYR_INFO_2 %
00000461 : fb028293;   % 725:  %
00000462 : 0002a023;   % 726:             sw zero,0(t0) %
00000463 : 0002a223;   % 727:             sw zero,4(t0) %
00000464 : 00003317;   % 729:             call RESET_ENEMIES %
00000465 : 914300e7;   % 729:  %
00000466 : 00000317;   % 731:             call RESET_BLOCKS %
00000467 : 130300e7;   % 731:  %
00000468 : ea9fe06f;   % 733:     j GAME_LOOP %
00000469 : 0fc11297;   % 752:     la t0, Doors # Loads Doors address %
0000046a : 2e828293;   % 752:  %
0000046b : 0fc11217;   % 753: 	la tp, CURRENT_MAP # Loads CURRENT_MAP address %
0000046c : f5420213;   % 753:  %
0000046d : 0002a503;   % 754: 	lw a0,0(t0)   # Gets current map's doors address %
0000046e : 00054283;   % 755: 	lbu t0,0(a0)  # Loads number of doors in this map %
0000046f : 00150513;   % 756: 	addi a0,a0,1  # Goes to next byte (where doors from current map start) %
00000470 : 00000313;   % 757: 	li t1,0       # Counter for doors %
00000471 : 00000593;   % 758:     li a1,0       # Default: won't render doors unless there's a change of state %
00000472 : 00350383;   % 761:         lb t2,3(a0)  # Loads C (counter) parameter %
00000473 : 0003c663;   % 762:         blt t2,zero,UPDATE_DOORS_LOOP_COUNT_UP    # If counter is negative, iterate up %
00000474 : 02704663;   % 763:         bgt t2,zero,UPDATE_DOORS_LOOP_COUNT_DOWN  # If counter is positive, iterate down %
00000475 : 0640006f;   % 764:             j NEXT_IN_UPDATE_DOORS_LOOP # Otherwise, counter is 0 and should stay this way %
00000476 : 00138393;   % 767:             addi t2,t2,1  # C++ %
00000477 : 007501a3;   % 768:             sb t2,3(a0)   # and stores updated C on door's counter byte %
00000478 : 04039c63;   % 769:             bnez t2,NEXT_IN_UPDATE_DOORS_LOOP # If C != 0, go update next door %
00000479 : 00200393;   % 771:                 li t2,2         # Loads 2 (open) %
0000047a : 00750123;   % 772:                 sb t2,2(a0)     # and stores it on door's state byte %
0000047b : 03c00393;   % 773:                 li t2,60 # Gets new counter (related to open door) %
0000047c : 007501a3;   % 774:                 sb t2,3(a0)     # and stores it on door's counter byte %
0000047d : 00100593;   % 775:                 li a1,1         # Since status was updated, should render doors   %
0000047e : 0400006f;   % 776:                 j NEXT_IN_UPDATE_DOORS_LOOP   %
0000047f : fff38393;   % 780:             addi t2,t2,-1  # C-- %
00000480 : 007501a3;   % 781:             sb t2,3(a0)    # and stores updated C on door's counter byte %
00000481 : 02039a63;   % 782:             bnez t2,NEXT_IN_UPDATE_DOORS_LOOP # If C != 0, go update next door %
00000482 : 00254383;   % 784:                 lbu t2,2(a0)  # Loads door's state byte %
00000483 : fff38393;   % 785:                 addi t2,t2,-1 # If state is 2 -> 1; if state is 1 -> 0 %
00000484 : 00038e63;   % 786:                 beqz t2, UPDATE_DOORS_LOOP_CHANGE_OPENING  # If t2 = 0, state was 1 (opening) %
00000485 : 00100393;   % 789:                     li t2,1             # Loads 1 (opening) %
00000486 : 00750123;   % 790:                     sb t2,2(a0)         # and stores it on door's state byte %
00000487 : 00400393;   % 791:                     li t2,4  # Gets new counter (related to opening door -- positive, in order to close) %
00000488 : 007501a3;   % 792:                     sb t2,3(a0)         # and stores it on door's counter byte %
00000489 : 00100593;   % 793:                     li a1,1             # Since status was updated, should render doors   %
0000048a : 0100006f;   % 794:                     j NEXT_IN_UPDATE_DOORS_LOOP  %
0000048b : 00000393;   % 797:                     li t2,0         # Loads 0 (closed) %
0000048c : 00750123;   % 798:                     sb t2,2(a0)     # and stores it on door's state byte %
0000048d : 00100593;   % 800:                     li a1,1         # Since status was updated, should render doors   %
0000048e : 00450513;   % 804:             addi a0,a0,4 # Going to the next door's address                                   %
0000048f : 00130313;   % 805:             addi t1,t1,1 # Iterating counter by 1                                    %
00000490 : 00535463;   % 806:             bge t1,t0, END_UPDATE_DOORS_LOOP # If all of the map's doors were checked, end loop                                   %
00000491 : f85ff06f;   % 807:             j UPDATE_DOORS_LOOP # otherwise, go back to the loop's beginning                      %
00000492 : 00058c63;   % 811:         beqz a1,END_UPDATE_DOORS # If a1 is 0, doors shouldn't be rendered again %
00000493 : 00300293;   % 812:         li t0, 3        # To be compared with rendering byte (3 - switch map through doors) %
00000494 : 00524303;   % 813:         lbu t1, 5(tp)   # Loads CURRENT_MAP's rendering byte on t1 %
00000495 : 00628663;   % 814:         beq t0,t1,END_UPDATE_DOORS # If rendering byte is 3, don't change it %
00000496 : 00200393;   % 816:         li t2, 2       # t2 = 2 (map will be rendered again) %
00000497 : 007202a3;   % 817:         sb t2, 5(tp)   # Stores t3 on CURRENT_MAP's rendering byte %
00000498 : 00008067;   % 821:         ret  %
00000499 : 0fc11297;   % 844:     la t0, Doors # Loads Doors address %
0000049a : 22828293;   % 844:  %
0000049b : 0fc11217;   % 845: 	la tp, CURRENT_MAP # Loads CURRENT_MAP address %
0000049c : e9420213;   % 845:  %
0000049d : 0002a603;   % 846: 	lw a2,0(t0)   # Gets current map's doors address %
0000049e : 00064283;   % 847: 	lbu t0,0(a2)  # Loads number of doors in this map %
0000049f : 00160613;   % 848: 	addi a2,a2,1  # Goes to next byte (where doors from current map start) %
000004a0 : 00159593;   % 849:     slli a1,a1,1  # Multiplies a1 by 2  %
000004a1 : 00000313;   % 851:     li t1,0       # Counter for doors      %
000004a2 : 00100393;   % 854:         li t2,1       # Loads 1 (opening/closing) %
000004a3 : 00760123;   % 855:         sb t2,2(a2)   # and stores it on door's state byte     %
000004a4 : 00050a63;   % 856:         beqz a0, CHANGE_DOORS_STATE_LOOP_OPEN_DOORS # If a0 = 0, open doors %
000004a5 : 00400393;   % 858:             li t2,4  # Gets new counter (related to closing door -- positive, in order to close) %
000004a6 : 40b383b3;   % 859:             sub t2,t2,a1        # t2 = 4 if a1 is 0, otherwise, t2 = 2 %
000004a7 : 007601a3;   % 860:             sb t2,3(a2)         # Stores C on door's counter byte %
000004a8 : 00c0006f;   % 861:             j NEXT_IN_CHANGE_DOORS_STATE_LOOP  %
000004a9 : ffe00393;   % 864:             li t2,-2  # Gets new counter (related to opening door -- negative, in order to open) %
000004aa : 007601a3;   % 865:             sb t2,3(a2)         # and stores it on door's counter byte %
000004ab : 00460613;   % 868:         addi a2,a2,4 # Going to the next door's address                                   %
000004ac : 00130313;   % 869:         addi t1,t1,1 # Iterating counter by 1                                    %
000004ad : 00535463;   % 870:         bge t1,t0, END_CHANGE_DOORS_STATE_LOOP # If all of the map's doors were checked, end loop                                   %
000004ae : fd1ff06f;   % 871:         j CHANGE_DOORS_STATE_LOOP # otherwise, go back to the loop's beginning                      %
000004af : 00200393;   % 874:         li t2, 2       # t2 = 2 (map will be rendered again) %
000004b0 : 007202a3;   % 875:         sb t2, 5(tp)   # Stores t3 on CURRENT_MAP's rendering byte %
000004b1 : 00008067;   % 876:         ret  # End of procedure, return     %
000004b2 : 0fc11517;   % 880:     la a0, Blocks2 %
000004b3 : f4850513;   % 880:  %
000004b4 : 00254283;   % 881:     lbu t0,2(a0) %
000004b5 : 00354303;   % 882:     lbu t1,3(a0) %
000004b6 : 00450513;   % 883:     addi a0,a0,4 %
000004b7 : 026285b3;   % 884:     mul a1,t0,t1   # Total number of iterations %
000004b8 : 00000293;   % 885:     li t0,0 %
000004b9 : 00050303;   % 887:         lb t1,0(a0) %
000004ba : fff00393;   % 888:         li t2,-1 %
000004bb : 00730463;   % 889:         beq t1,t2,NEXT_IN_RESET_BLOCKS_LOOP %
000004bc : 00050023;   % 890:             sb zero,0(a0) %
000004bd : 00150513;   % 892:             addi a0,a0,1 %
000004be : 00128293;   % 893:             addi t0,t0,1 %
000004bf : feb2c4e3;   % 894:             blt t0,a1,RESET_BLOCKS_LOOP %
000004c0 : 00008067;   % 895:                 ret         %
000004c1 : 0fc11517;   % 22:     la a0, MOVE_X	       # Loads address of MOVE_X %
000004c2 : e2850513;   % 22:  %
000004c3 : 00050283;   % 23:     lb t0, 0(a0)	       # Loads information from MOVE_X %
000004c4 : 0fc11597;   % 24:     la a1, CURRENT_MAP     # Loads CURRENT_MAP's address %
000004c5 : df058593;   % 24:  %
000004c6 : 0005a603;   % 25:     lw a2, 0(a1) 	       # a2 has the current map's address  %
000004c7 : 0fc11697;   % 26:     la a3, PLYR_POS        # Loads Player Position %
000004c8 : dfe68693;   % 26:  %
000004c9 : 0fc11317;   % 28:     la t1, PLYR_INFO_2	   # Loads address of the second part of PLYR_INFO %
000004ca : e0c30313;   % 28:  %
000004cb : 00430303;   % 29:     lb t1,4(t1)            # Gets the DAMAGE_MOVE_X value %
000004cc : 00029e63;   % 31:     bnez t0, MOVE_PLAYER_X # If there's X movement, go to MOVE_PLAYER_X %
000004cd : 00031c63;   % 32:     bnez t1, MOVE_PLAYER_X # Otherwise, if there's damaging X movement, go to MOVE_PLAYER_X %
000004ce : 00069303;   % 35:     lh t1, 0(a3)  # Loads Player's X related to screen %
000004cf : 00669123;   % 36:     sh t1, 2(a3)  # Stores Player's X related to screen on old X %
000004d0 : 0086c303;   % 37:     lbu t1, 8(a3) # Loads Player's X related to screen %
000004d1 : 006684a3;   % 38:     sb t1, 9(a3)  # Stores Player's X related to screen on old X %
000004d2 : 19c0006f;   % 39:     j CHECK_MOVE_Y         # Otherwise, go check Y movement %
000004d3 : 00229713;   % 42:         slli a4, t0, 2  # Multiplies the value stored on MOVE_X by 4. a4 will store the movement of the player (+/- 4 pixels) %
000004d4 : 00030463;   % 44:         beqz t1,CONTINUE_MOVE_PLAYER_X  # If there's no damage knockback %
000004d5 : 00600733;   % 46:             mv a4,t1    # Adds value from DAMAGE_MOVE_X (if any) %
000004d6 : 00d6c303;   % 49:         lbu t1, 13(a3)  # Loads Player's Facing direction (0 = Right, 1 = Left) %
000004d7 : 006282b3;   % 50:         add t0,t0,t1    # Adds Facing direction with MOVE_X (if the result t0 = -1 or 2, the direction has changed) %
000004d8 : 00200393;   % 51:         li t2,2         # t1 = 2 %
000004d9 : 0072f463;   % 52:         bgeu t0,t2,CHANGE_X_DIRECTION # If t0 = -1 or 2, the direction chas changed %
000004da : 0100006f;   % 53:             j KEEP_X_DIRECTION  %
000004db : 00134313;   % 57:             xori t1,t1,1   # Inverts direction (0 -> 1; 1 -> 0) %
000004dc : 006686a3;   % 58:             sb t1, 13(a3)  # Loads Player's Facing direction (0 = Right, 1 = Left) %
000004dd : 1700006f;   % 59:             j CHECK_MOVE_Y %
000004de : 00668803;   % 61:             lb a6, 6(a3)	# Loads Player's X offset %
000004df : 00e80833;   % 62:             add a6,a6,a4	# Adds the X Movement to the Player's Offset %
000004e0 : 0086c883;   % 64:             lbu a7, 8(a3)	# Loads Player's X on Matrix %
000004e1 : 011684a3;   % 65:             sb a7, 9(a3)	# Stores Player's X on Matrix on the Old X %
000004e2 : 00085663;   % 67:             bge a6,zero,SKIP_LEFT_X %
000004e3 : fff88893;   % 70:             addi a7, a7, -1		  # Player's X on matrix -= 1 (goes to the left) %
000004e4 : 01080813;   % 71:             addi a6,a6,16  # Offset gets corrected (relative to new X on matrix coordinate) %
000004e5 : 01000e13;   % 74:             li t3, 16 %
000004e6 : 01c84663;   % 75:             blt a6,t3, SKIP_RIGHT_X %
000004e7 : 00188893;   % 77:             addi a7,a7, 1	 # Player's X on matrix += 1 (goes to the right) %
000004e8 : 41c80833;   % 78:             sub a6,a6,t3	 # Offset gets corrected (relative to new X on matrix coordinate) %
000004e9 : fe010113;   % 82:             addi sp,sp,-32 %
000004ea : 01112e23;   % 83:             sw a7,28(sp) %
000004eb : 01012c23;   % 84:             sw a6,24(sp) %
000004ec : 00e12a23;   % 85:             sw a4,20(sp) %
000004ed : 00d12823;   % 86:             sw a3,16(sp) %
000004ee : 00c12623;   % 87:             sw a2,12(sp) %
000004ef : 00b12423;   % 88:             sw a1,8(sp) %
000004f0 : 00a12223;   % 89:             sw a0,4(sp) %
000004f1 : 00112023;   % 90:             sw ra,0(sp) %
000004f2 : 00c005b3;   % 92:             mv a1,a2 # Moves current map's address to a1  %
000004f3 : 00d00633;   % 93:             mv a2,a3 # Moves PLYR_POS to a2 %
000004f4 : 00006317;   % 94:             call CHECK_HORIZONTAL_COLLISION # Checking collision %
000004f5 : b64300e7;   % 94:  %
000004f6 : 00a002b3;   % 96:             mv t0,a0     # Moves result of collision check to t0  %
000004f7 : 01c12883;   % 99:             lw a7,28(sp) %
000004f8 : 01812803;   % 100:             lw a6,24(sp) %
000004f9 : 01412703;   % 101:             lw a4,20(sp) %
000004fa : 01012683;   % 102:             lw a3,16(sp) %
000004fb : 00c12603;   % 103:             lw a2,12(sp) %
000004fc : 00812583;   % 104:             lw a1,8(sp) %
000004fd : 00412503;   % 105:             lw a0,4(sp) %
000004fe : 00012083;   % 106:             lw ra,0(sp) %
000004ff : 02010113;   % 107:             addi sp,sp,32 %
00000500 : 00069383;   % 110:             lh t2, 0(a3)          # Loads Player's Current X %
00000501 : 00029e63;   % 111:             bnez t0, CAN_MOVE_X   # If a0 != 0, player can move (go to CAN_MOVE_X) %
00000502 : 00700f33;   % 113:                 mv t5,t2              # store player's current X (t2) in t5 %
00000503 : 0fc11297;   % 114:                 la t0,PLYR_INPUT      # Loads PLYR_INPUT on t0 %
00000504 : d2328293;   % 114:  %
00000505 : 00200313;   % 115:                 li t1, 2              # Sets t1 to 2 (there's player input, but can't move) %
00000506 : 00628023;   % 116:                 sb t1, 0(t0)          # and stores it in PLYR_INPUT %
00000507 : 0300006f;   % 117:                 j Fixed_X_Map %
00000508 : 0fc11297;   % 120:         la t0,PLYR_INPUT      # Loads PLYR_INPUT on t0 %
00000509 : d0f28293;   % 120:  %
0000050a : 00100313;   % 121:         li t1, 1              # Sets t1 to 1 (there's player input, and can move) %
0000050b : 00628023;   % 122:         sb t1, 0(t0)          # and stores it in PLYR_INPUT %
0000050c : 01068323;   % 124:         sb a6, 6(a3)    # Stores new X offset %
0000050d : 01168423;   % 125:         sb a7, 8(a3)    # Stores new X coordinate on matrix %
0000050e : 00770f33;   % 127:         add t5, a4, t2  # t5 = Player's current X + Movement of Player on X axis %
0000050f : 00064283;   % 129:         lbu t0, 0(a2)   # loads first byte to check what type of map it is (0 - Fixed, 1 - Horizontal, 2 - Vertical) %
00000510 : 00100e13;   % 130:         li t3, 1        # Loads 1 and  %
00000511 : 005e1463;   % 131:         bne t3, t0, Fixed_X_Map # compares with the result %
00000512 : 0100006f;   % 132:         j Horizontal_Map %
00000513 : 00769123;   % 136:           sh t2,2(a3) # Stores original X on old X related to screen %
00000514 : 01e69023;   % 137:           sh t5,0(a3) # Stores new X on current X related to screen %
00000515 : 0900006f;   % 138:           j CHECK_MOVE_Y %
00000516 : 0065c283;   % 141:             lbu t0, 6(a1)    # Loads Map's X postition on Matrix %
00000517 : 0085c303;   % 142:             lbu t1, 8(a1)    # Loads Map's X offset %
00000518 : 07700e13;   % 144:             li t3, 119      # loads left_border = 120  %
00000519 : 01ee4863;   % 145:             blt t3, t5, NOT_LEFT_BORDER_PASS  # if new player position on screen doesn't pass the left border, go to NOT_LEFT_BORDER_PASS %
0000051a : 00628eb3;   % 148:             add t4,t0,t1     # Will be 0 if Map's X offset and X position are 0 %
0000051b : fe0e80e3;   % 149:           	beqz t4, Fixed_X_Map  # If on leftmost part of the map, map won't move %
0000051c : 01c0006f;   % 150:             j MOVE_SCREEN_X     # otherwise, move the map left %
0000051d : 0b800e13;   % 153:             li t3, 184 #loads right_border = 180  %
0000051e : fdee5ae3;   % 154:             bge t3,t5,Fixed_X_Map   # if new player position on screen doesn't pass the right border, go to Fixed_X_Map %
0000051f : 00164303;   % 155:             lbu t1, 1(a2)    # Loads Map matrix width %
00000520 : 01400e13;   % 156:             li t3, 20 # Loads Map screen width related to matrix %
00000521 : 41c30333;   % 157:             sub t1,t1,t3    # t1 = Map Matrix Width - Screen Matrix Width (t1 = Map's X when it's on rightmost part of the map) %
00000522 : fc6282e3;   % 158:             beq t0,t1, Fixed_X_Map  # If on rightmost part of the map, map won't move %
00000523 : 00200e13;   % 162:             li t3, 2       # t3 = 2 (map will be rendered again) %
00000524 : 01c582a3;   % 163:             sb t3, 5(a1)   # Stores t3 on CURRENT_MAP's rendering byte %
00000525 : 00769123;   % 164:             sh t2,2(a3)    # Stores player's original X on old X related to screen %
00000526 : 0065c383;   % 167:             lbu t2, 6(a1)  # Loads Map X postition on Matrix %
00000527 : 0085c803;   % 168:             lbu a6, 8(a1)  # Loads map's X offset %
00000528 : 00e80833;   % 170:             add a6,a6,a4  # Adds the X Movement to the map's Offset %
00000529 : 00000313;   % 172:             li t1,0  # Right now, the map's X won't be updated  %
0000052a : 00085e63;   % 173:             bge a6, zero, NO_X_OFFSET_NEGATIVE_CORRECTION  %
0000052b : 00038863;   % 175:                 beqz t2 LEFTMOST_PART_OF_MAP_RESET %
0000052c : fff00313;   % 177:                     li t1, -1 %
0000052d : 01080813;   % 178:                     addi a6,a6,16 # Corrects negative offset by adding 16 %
0000052e : 01c0006f;   % 179:                     j NO_X_OFFSET_CORRECTION %
0000052f : 00000813;   % 182:                     li a6,0 %
00000530 : 0140006f;   % 183:                     j NO_X_OFFSET_CORRECTION %
00000531 : 01000293;   % 187:                 li t0, 16 %
00000532 : 00584663;   % 188:                 blt a6,t0, NO_X_OFFSET_CORRECTION %
00000533 : 00100313;   % 189:                 li t1,1 %
00000534 : 40580833;   % 190:                 sub a6,a6,t0 # Corrects values that surpass 16 by subtracting 16 from them %
00000535 : 01058423;   % 193:                 sb a6, 8(a1)   # Stores Map new X offset that is equal to player's X offset %
00000536 : 006383b3;   % 194:                 add t2,t2,t1  # adds to the X -1, 0 or 1 (moves map horizontally) %
00000537 : 00758323;   % 195:                 sb t2, 6(a1)   # Stores Map X postition on Matrix %
00000538 : 0040006f;   % 196:                 j CHECK_MOVE_Y %
00000539 : 0fc11517;   % 200:     la a0, MOVE_Y	       # Loads address of MOVE_Y %
0000053a : c4950513;   % 200:  %
0000053b : 00050283;   % 201:     lb t0, 0(a0)	       # Loads information from MOVE_Y %
0000053c : 0fc11597;   % 202:     la a1, CURRENT_MAP     # Loads CURRENT_MAP's address %
0000053d : c1058593;   % 202:  %
0000053e : 0005a603;   % 203:     lw a2, 0(a1) 	       # a2 has the current map's address  %
0000053f : 0fc11697;   % 204:     la a3, PLYR_POS        # Loads Player Position address %
00000540 : c1e68693;   % 204:  %
00000541 : 06029a63;   % 206:     bnez t0, MOVE_PLAYER_Y # If there's Y movement, go to MOVE_PLAYER_Y %
00000542 : 0046c303;   % 207:         lbu t1, 4(a3)  # Loads Player's Y related to screen %
00000543 : 006682a3;   % 208:         sb t1, 5(a3)  # Stores Player's Y related to screen on old Y %
00000544 : 00a6c303;   % 209:         lbu t1, 10(a3)  # Loads Player's Y related to screen %
00000545 : 006685a3;   % 210:         sb t1, 11(a3)  # Stores Player's Y related to screen on old Y %
00000546 : fec10113;   % 212:         addi sp,sp,-20 %
00000547 : 00d12823;   % 213:         sw a3,16(sp) %
00000548 : 00c12623;   % 214:         sw a2,12(sp) %
00000549 : 00b12423;   % 215:         sw a1,8(sp) %
0000054a : 00a12223;   % 216:         sw a0,4(sp) %
0000054b : 00112023;   % 217:         sw ra,0(sp) %
0000054c : 00c005b3;   % 219:         mv a1,a2 # Moves current map's address to a1  %
0000054d : 00d00633;   % 220:         mv a2,a3 # Moves PLYR_POS to a2 %
0000054e : 00006317;   % 221:         call CHECK_VERTICAL_COLLISION # Checking collision %
0000054f : b24300e7;   % 221:  %
00000550 : 00a002b3;   % 222:         mv t0,a0     # Moves result of collision check to t0  %
00000551 : 01012683;   % 225:         lw a3,16(sp) %
00000552 : 00c12603;   % 226:         lw a2,12(sp) %
00000553 : 00812583;   % 227:         lw a1,8(sp) %
00000554 : 00412503;   % 228:         lw a0,4(sp) %
00000555 : 00012083;   % 229:         lw ra,0(sp) %
00000556 : 01410113;   % 230:         addi sp,sp,20 %
00000557 : 00028c63;   % 232:         beqz t0, HAS_GROUND    # If t0 (holds result of collision check) != 0 go to HAS_GROUND %
00000558 : 0fc11517;   % 234:         la a0, MOVE_Y	   # Loads address of MOVE_Y %
00000559 : bcd50513;   % 234:  %
0000055a : 00100293;   % 235:         li t0, 1           # Gets number correspondent to DOWN (1) %
0000055b : 00550023;   % 236:         sb t0, 0(a0)	   # and stores it %
0000055c : 0080006f;   % 239:         j MOVE_PLAYER_Y %
0000055d : 31c0006f;   % 242:       j END_PHYSICS %
0000055e : 00150383;   % 245:         lb t2, 1(a0)   # Loads JUMP information %
0000055f : 0002c463;   % 246:         blt t0,zero, MOVE_PLAYER_UP %
00000560 : 05c0006f;   % 247:         j ITERATE_JUMP %
00000561 : 0fc11317;   % 250:             la t1, PLYR_INFO_2	       # Loads address of the second part of PLYR_INFO %
00000562 : bac30313;   % 250:  %
00000563 : 00330303;   % 251:             lb t1,3(t1)                # Gets the taking damage byte %
00000564 : 00031c63;   % 252:             bnez t1,SKIP_INPUT_CHECK   # If taking damage, only do a small hop %
00000565 : 02000313;   % 253:             li t1, 32 # minimum height of jump required for the movement  %
00000566 : 0063c863;   % 254:             blt t2, t1, SKIP_INPUT_CHECK %
00000567 : 00254303;   % 255:             lbu t1, 2(a0)   # Loads PLYR_INPUT %
00000568 : 00031463;   % 256:             bnez t1, SKIP_INPUT_CHECK # t1 != 0 ? SKIP_INPUT_CHECK : SWITCH_DOWN %
00000569 : 0140006f;   % 257:             j SWITCH_DOWN %
0000056a : c0097353;   % 260:                 fcvt.w.s t1,fs2  %
0000056b : 00035663;   % 261:                 bge t1,zero, SWITCH_DOWN %
0000056c : 05000313;   % 262:                 li t1, 80 # maximum height of jump required for the movement  %
0000056d : 0263c463;   % 263:                 blt t2, t1, ITERATE_JUMP   #  %
0000056e : 0fc11297;   % 266:                 la t0,PLYR_INPUT      # Loads PLYR_INPUT on t0 %
0000056f : b7728293;   % 266:  %
00000570 : 00100313;   % 267:                 li t1, 1              # Sets t1 to 1 (there's player input, and can move) %
00000571 : 00628023;   % 268:                 sb t1, 0(t0)          # and stores it in PLYR_INPUT  %
00000572 : 006500a3;   % 270:                 sb t1, 1(a0)          # reset jump information %
00000573 : 00650023;   % 271:                 sb t1,0(a0)           # Switches MOVE_Y to 1 (Down)     %
00000574 : 00200313;   % 273:                 li t1, 2 %
00000575 : d0037953;   % 274:                 fcvt.s.w fs2,t1     # Sets speed to zero        %
00000576 : 2b80006f;   % 275:                 j END_PHYSICS %
00000577 : 00897953;   % 278:             fadd.s fs2,fs2,fs0    # fs2 = Player's current Y speed + gravity factor        %
00000578 : c0097753;   % 279:             fcvt.w.s a4,fs2       # Sets a4 = floor(fs2) %
00000579 : 00800293;   % 281:             li t0,8             # Loads max speed (8, when falling) %
0000057a : 00574463;   % 282:             blt a4,t0, SKIP_MAX_SPEED   # If a4 < 8, skip this part %
0000057b : 00800713;   % 284:                 li a4,8 %
0000057c : 00e002b3;   % 288:                 mv t0,a4                # moves a4 to t0 %
0000057d : 0002d463;   % 289:                 bge t0,zero, SKIP_ABS   # if t0 >= 0, skip this %
0000057e : 405002b3;   % 290:                     sub t0,zero,t0      # otherwise, t0 will be its opposite  %
0000057f : 005383b3;   % 292:                     add t2,t2,t0        # t0 to t2 (JUMP factor) %
00000580 : 007500a3;   % 293:                     sb t2, 1(a0)        # and stores it %
00000581 : 0076c803;   % 295:         lbu a6, 7(a3)	# Loads Player's Y offset %
00000582 : 00e80833;   % 296:         add a6,a6,a4	# Adds the X Movement to the Player's Offset %
00000583 : 00a6c883;   % 298:         lbu a7, 10(a3)	# Loads Player's Y on Matrix %
00000584 : 011685a3;   % 299:         sb a7, 11(a3)	# Stores Plater's Y on Matrix on the Old Y %
00000585 : 00085663;   % 301:         bge a6,zero,SKIP_UP_Y %
00000586 : fff88893;   % 303:         addi a7, a7, -1		  # Player's Y on matrix -= 1 (goes to the left) %
00000587 : 01080813;   % 304:         addi a6,a6,16  # Offset gets corrected (relative to new X on matrix coordinate) %
00000588 : 01000e13;   % 307:             li t3, 16 %
00000589 : 01c84663;   % 308:             blt a6,t3, SKIP_DOWN_Y %
0000058a : 00188893;   % 310:             addi a7,a7, 1	 # Player's Y on matrix += 1 (goes to the right) %
0000058b : 41c80833;   % 311:             sub a6,a6,t3	 # Offset gets corrected (relative to new Y on matrix coordinate) %
0000058c : fe010113;   % 315:             addi sp,sp,-32 %
0000058d : 01112e23;   % 316:             sw a7,28(sp) %
0000058e : 01012c23;   % 317:             sw a6,24(sp) %
0000058f : 00e12a23;   % 318:             sw a4,20(sp) %
00000590 : 00d12823;   % 319:             sw a3,16(sp) %
00000591 : 00c12623;   % 320:             sw a2,12(sp) %
00000592 : 00b12423;   % 321:             sw a1,8(sp) %
00000593 : 00a12223;   % 322:             sw a0,4(sp) %
00000594 : 00112023;   % 323:             sw ra,0(sp) %
00000595 : 00c005b3;   % 325:             mv a1,a2 # Moves current map's address to a1  %
00000596 : 00d00633;   % 326:             mv a2,a3 # Moves PLYR_POS to a2 %
00000597 : 00e006b3;   % 327:             mv a3,a4 # Moves offset modifier to a3 %
00000598 : 00006317;   % 328:             call CHECK_VERTICAL_COLLISION # Checking collision %
00000599 : 9fc300e7;   % 328:  %
0000059a : 00a002b3;   % 329:             mv t0,a0     # Moves result of collision check to t0  %
0000059b : 01c12883;   % 332:             lw a7,28(sp) %
0000059c : 01812803;   % 333:             lw a6,24(sp) %
0000059d : 01412703;   % 334:             lw a4,20(sp) %
0000059e : 01012683;   % 335:             lw a3,16(sp) %
0000059f : 00c12603;   % 336:             lw a2,12(sp) %
000005a0 : 00812583;   % 337:             lw a1,8(sp) %
000005a1 : 00412503;   % 338:             lw a0,4(sp) %
000005a2 : 00012083;   % 339:             lw ra,0(sp) %
000005a3 : 02010113;   % 340:             addi sp,sp,32 %
000005a4 : 0046c383;   % 343:             lbu t2, 4(a3)    # Loads Player's Current Y %
000005a5 : 0e029663;   % 344:             bnez t0, CAN_MOVE_Y # t0 != 0 ? CAN_MOVE_Y : Fixed_Y_Map %
000005a6 : 00700f33;   % 345:                 mv t5,t2 # storing PLYRS_current Y in t5 %
000005a7 : d0007953;   % 346:                 fcvt.s.w fs2,zero # Resets player's jump speed %
000005a8 : 00050283;   % 348:                 lb t0, 0(a0) # Gets MOVE_Y info %
000005a9 : 0602c863;   % 349:                 blt t0,zero, STOP_JUMP # If t0 <= -1 (aka, player would start jumping), reset %
000005aa : 0fc11317;   % 351:                     la t1, PLYR_INFO_2	   # Loads address of the second part of PLYR_INFO %
000005ab : a8830313;   % 351:  %
000005ac : 00030223;   % 352:                     sb zero,4(t1)          # If player hit the ground, stop damage knockback %
000005ad : 0076c283;   % 354:                     lbu t0, 7(a3)  # Loads player's Y offset %
000005ae : 04028463;   % 355:                     beqz t0,SKIP_ADJUST_Y_DOWN # If player is on ground and Y offset = 0, don't reajust position %
000005af : 01168523;   % 356:                         sb a7, 10(a3)   # Stores new Y coordinate on matrix %
000005b0 : 00064283;   % 357:                         lbu t0, 0(a2)   # Loads first byte to check what type of map it is (0 - Fixed, 1 - Horizontal, 2 - Vertical) %
000005b1 : 00200e13;   % 358:                         li t3, 2        # Loads 2 and  %
000005b2 : 025e1c63;   % 359:                         bne t3, t0, SKIP_ADJUST_Y_DOWN # compares with the result %
000005b3 : 0095c283;   % 361:                             lbu t0, 9(a1)    # Loads map's Y offset %
000005b4 : 000584a3;   % 362:                             sb zero, 9(a1)   # Sets map's Y offset to 0 %
000005b5 : 00264e83;   % 363:                             lbu t4, 2(a2)    # Loads Map matrix height %
000005b6 : 00f00e13;   % 364:                             li t3, 15 # Loads Map screen height related to matrix %
000005b7 : 41ce8e33;   % 365:                             sub t3,t4,t3     # t4 = Map Matrix Height - Screen Matrix Height (t4 = Map's Y when it's on lowermost part of the map) %
000005b8 : 0075ce83;   % 366:                             lbu t4, 7(a1)    # Loads Map Y postition on Matrix %
000005b9 : 01cede63;   % 367:                             bge t4,t3,SKIP_ADJUST_Y_DOWN  # If on lowermost Y, don't update map's Y it %
000005ba : 005e82b3;   % 368:                             add t0,t4,t0   # t4 will only be 4 if offset was 0 and Y is zero %
000005bb : 00028a63;   % 369:                             beqz t0,SKIP_ADJUST_Y_DOWN    # If on topmost Y, don't update map's Y it %
000005bc : 001e8e93;   % 370:                             addi t4,t4,1     # adds 1 to it %
000005bd : 01d583a3;   % 371:                             sb t4, 7(a1)     # and stores it %
000005be : 00200e13;   % 372:                             li t3, 2         # t3 = 2 (map will be rendered again) %
000005bf : 01c582a3;   % 373:                             sb t3, 5(a1)     # Stores t3 on CURRENT_MAP's rendering byte %
000005c0 : 000683a3;   % 375:                     sb zero, 7(a3) # Sets player's Y offset to 0 %
000005c1 : 00050023;   % 376:                     sb zero, 0(a0) # MOVE_Y = 0 %
000005c2 : fff00313;   % 377:                     li t1,-1 %
000005c3 : 006500a3;   % 378:                     sb t1, 1(a0) # JUMP = 0 %
000005c4 : 09c0006f;   % 379:                     j Fixed_Y_Map %
000005c5 : 0fc11317;   % 383:                     la t1, PLYR_INFO_2	   # Loads address of the second part of PLYR_INFO %
000005c6 : a1c30313;   % 383:  %
000005c7 : 00634283;   % 384:                     lbu t0,6(t1)          # If player hit the ground, there's no damage knockback anymore %
000005c8 : ff628293;   % 385:                     addi t0,t0,-10 %
000005c9 : 00530323;   % 386:                     sb t0,6(t1)          # If player hit the ground, there's no damage knockback anymore %
000005ca : 00800293;   % 389:                     li t0,8 %
000005cb : 00154303;   % 390:                     lbu t1,1(a0) # Gets JUMP info %
000005cc : 0062a2b3;   % 391:                     slt t0,t0,t1 # t1 > 8 ? t0 = 1 : t0 = 0 %
000005cd : 00550023;   % 392:                     sb t0, 0(a0) # MOVE_Y = t0  %
000005ce : 000500a3;   % 393:                     sb zero,1(a0) # reseting jump byte %
000005cf : 0076c283;   % 395:                     lbu t0, 7(a3)  # Loads player's Y offset %
000005d0 : 02028e63;   % 396:                     beqz t0,SKIP_ADJUST_Y_UP # If player has Y offset = 0, don't reajust position %
000005d1 : 000683a3;   % 398:                         sb zero, 7(a3) # Sets player's Y offset to 0 %
000005d2 : 00064283;   % 399:                         lbu t0, 0(a2)   # Loads first byte to check what type of map it is (0 - Fixed, 1 - Horizontal, 2 - Vertical) %
000005d3 : 00200e13;   % 400:                         li t3, 2        # Loads 2 and  %
000005d4 : 025e1663;   % 401:                         bne t3, t0, SKIP_ADJUST_Y_UP # compares with the result %
000005d5 : 000584a3;   % 403:                             sb zero, 9(a1)   # Sets map's Y offset to 0 %
000005d6 : 00264e83;   % 404:                             lbu t4, 2(a2)    # Loads Map matrix height %
000005d7 : 00f00e13;   % 405:                             li t3, 15 # Loads Map screen height related to matrix %
000005d8 : 41ce8e33;   % 406:                             sub t3,t4,t3     # t4 = Map Matrix Height - Screen Matrix Height (t4 = Map's Y when it's on lowermost part of the map) %
000005d9 : 0075ce83;   % 407:                             lbu t4, 7(a1)    # Loads Map Y postition on Matrix %
000005da : 01ceda63;   % 408:                             bge t4,t3,SKIP_ADJUST_Y_UP  # If on lowermost Y, don't update map's Y it %
000005db : 000e8863;   % 409:                             beqz t4,SKIP_ADJUST_Y_UP    # If on topmost Y, don't update map's Y it %
000005dc : 01d583a3;   % 410:                             sb t4, 7(a1)     # and stores it %
000005dd : 00200e13;   % 411:                             li t3, 2         # t3 = 2 (map will be rendered again) %
000005de : 01c582a3;   % 412:                             sb t3, 5(a1)     # Stores t3 on CURRENT_MAP's rendering byte %
000005df : 0300006f;   % 414:                         j Fixed_Y_Map %
000005e0 : 0fc11297;   % 417:             la t0,PLYR_INPUT      # Loads PLYR_INPUT on t0 %
000005e1 : 9af28293;   % 417:  %
000005e2 : 00100313;   % 418:             li t1, 1              # Sets t1 to 1 (there's player input, and can move) %
000005e3 : 00628023;   % 419:             sb t1, 0(t0)          # and stores it in PLYR_INPUT  %
000005e4 : 010683a3;   % 421:             sb a6, 7(a3)    # Stores new Y offset %
000005e5 : 01168523;   % 422:             sb a7, 10(a3)   # Stores new Y coordinate on matrix %
000005e6 : 00770f33;   % 424:             add t5, a4, t2  # t5 = Player's current X + Movement of Player on X axis %
000005e7 : 00064283;   % 426:             lbu t0, 0(a2)   # loads first byte to check what type of map it is (0 - Fixed, 1 - Horizontal, 2 - Vertical) %
000005e8 : 00200e13;   % 427:             li t3, 2        # Loads 2 and  %
000005e9 : 005e1463;   % 428:             bne t3, t0, Fixed_Y_Map # compares with the result %
000005ea : 0300006f;   % 429:             j Vertical_Map %
000005eb : 0075c383;   % 433:             lbu t2 7(a1)    # Gets map's Y related to matrix %
000005ec : 00a6cf03;   % 434:             lbu t5, 10(a3)	# Loads Player's Y related to matrix %
000005ed : 407f0f33;   % 435:             sub t5,t5,t2    # Gets the Y matrix related to the map's Y %
000005ee : 004f1f13;   % 436:             slli t5,t5,4 # Multiplies t5 by 16 in order to get Y related to screen %
000005ef : 0076c383;   % 437:             lbu t2, 7(a3)	# Loads Player's Y offset %
000005f0 : 007f0f33;   % 438:             add t5,t5,t2    # Adds offset to position %
000005f1 : 0095c383;   % 439:             lbu t2 9(a1)    # Gets map's offset %
000005f2 : 407f0f33;   % 440:             sub t5,t5,t2    # and takes it from player's position %
000005f3 : 01e682a3;   % 442:             sb t5,5(a3) # Stores original Y on old Y  related to screen %
000005f4 : 01e68223;   % 443:             sb t5,4(a3) # Stores new Y on current Y related to screen %
000005f5 : 0bc0006f;   % 444:             j END_PHYSICS %
000005f6 : 0075c283;   % 447:             lbu t0, 7(a1)    # Loads Map's Y postition on Matrix %
000005f7 : 0095c303;   % 448:             lbu t1, 9(a1)    # Loads Map's Y offset %
000005f8 : 05e00e13;   % 450:             li t3, 94      # loads top vertical border = 94  %
000005f9 : 01ee4863;   % 451:             blt t3, t5, NOT_TOP_BORDER_PASS  # if new player position on screen doesn't pass the upper border, go to NOT_LEFT_BORDER_PASS %
000005fa : 00628eb3;   % 453:             add t4,t0,t1     # Will be 0 if Map's X offset and X position are 0 %
000005fb : fc0e80e3;   % 454:             beqz t4, Fixed_Y_Map  # If on uppermost part of the map, map won't move %
000005fc : 01c0006f;   % 455:             j MOVE_SCREEN_Y     # otherwise, move the map left %
000005fd : 06000e13;   % 458:             li t3, 96 #loads bottom vertical border = 96  %
000005fe : fbee5ae3;   % 459:             bge t3,t5,Fixed_Y_Map   # if new player position on screen doesn't pass the lower border, go to Fixed_X_Map %
000005ff : 00264303;   % 460:             lbu t1, 2(a2)    # Loads Map matrix height %
00000600 : 00f00e13;   % 461:             li t3, 15 # Loads Map screen height related to matrix %
00000601 : 41c30333;   % 462:             sub t1,t1,t3    # t1 = Map Matrix Height - Screen Matrix Height (t1 = Map's Y when it's on lowermost part of the map) %
00000602 : fa6282e3;   % 463:             beq t0,t1, Fixed_Y_Map  # If on lowermost part of the map, map won't move %
00000603 : 00200e13;   % 466:             li t3, 2       # t3 = 2 (map will be rendered again) %
00000604 : 01c582a3;   % 467:             sb t3, 5(a1)   # Stores t3 on CURRENT_MAP's rendering byte %
00000605 : 007682a3;   % 469:             sb t2,5(a3)    # Stores player's original Y on old Y related to screen %
00000606 : 0075c383;   % 472:             lbu t2, 7(a1)  # Loads Map Y postition on Matrix %
00000607 : 0095c803;   % 473:             lbu a6, 9(a1)  # Loads map's Y offset %
00000608 : 00e80833;   % 474:             add a6,a6,a4  # Adds the Y Movement to the map's Offset %
00000609 : 00000313;   % 475:             li t1,0  # Right now, the map's Y won't be updated  %
0000060a : 00085e63;   % 476:             bge a6, zero, NO_Y_OFFSET_NEGATIVE_CORRECTION  %
0000060b : 00038863;   % 478:                 beqz t2 TOP_OF_MAP_RESET %
0000060c : fff00313;   % 480:                     li t1, -1 %
0000060d : 01080813;   % 481:                     addi a6,a6,16 # Corrects negative offset by adding 16 %
0000060e : 0340006f;   % 482:                     j NO_Y_OFFSET_CORRECTION %
0000060f : 00000813;   % 485:                     li a6,0 %
00000610 : 02c0006f;   % 486:                     j NO_Y_OFFSET_CORRECTION %
00000611 : 01000293;   % 490:                 li t0, 16 %
00000612 : 02584263;   % 491:                 blt a6,t0, NO_Y_OFFSET_CORRECTION %
00000613 : 00100313;   % 492:                 li t1,1 %
00000614 : 40580833;   % 493:                 sub a6,a6,t0 # Corrects values that surpass 16 by subtracting 16 from them %
00000615 : 00264e83;   % 495:                 lbu t4, 2(a2)    # Loads Map matrix height %
00000616 : 00f00e13;   % 496:                 li t3, 15 # Loads Map screen height related to matrix %
00000617 : 41ce8eb3;   % 497:                 sub t4,t4,t3     # t4 = Map Matrix Height - Screen Matrix Height (t1 = Map's Y when it's on lowermost part of the map) %
00000618 : 00138f13;   % 498:                 addi t5,t2,1     # Maximum Y on map %
00000619 : 01df4463;   % 500:                 blt t5,t4,NO_Y_OFFSET_CORRECTION    # If t5 != maximum Y on map, skip this next correction %
0000061a : 00000813;   % 502:                 li a6,0    # set offset to 0                %
0000061b : 010584a3;   % 505:                 sb a6, 9(a1)   # Stores Map new Y offset that is equal to player's Y offset %
0000061c : 006383b3;   % 506:                 add t2,t2,t1  # adds to the Y -1, 0 or 1 (moves map horizontally) %
0000061d : 007583a3;   % 507:                 sb t2, 7(a1)   # Stores Map Y postition on Matrix %
0000061e : 00264283;   % 509:                 lbu t0,2(a2)  # Loads map's height %
0000061f : 00f00313;   % 510:                 li t1,15 # and the screen's height %
00000620 : 406282b3;   % 511:                 sub t0,t0,t1  # Subtracts from map's height the screen height %
00000621 : 0053c663;   % 512:                 blt t2,t0,END_PHYSICS # If the new Y passes the limit of map %
00000622 : 000584a3;   % 513:                     sb zero, 9(a1) %
00000623 : 005583a3;   % 514:                     sb t0, 7(a1)   # Stores Map Y postition on Matrix %
00000624 : 00008067;   % 518:       ret %
00000625 : 00088e63;   % 38: beqz a7,NORMAL %
00000626 : 00950533;   % 40: 		add a0,a0,s1	# Image address + X on sprite  %
00000627 : 03298e33;   % 41: 		mul t3,s3,s2	# t3 = sprite width * Y on sprite %
00000628 : 01c50533;   % 42: 		add a0,a0,t3	# a0 = Image address + X on sprite + sprite widht * Y on sprite %
00000629 : 03480eb3;   % 43: 		mul t4,a6,s4	# t4 = sprite status x height of rendering area (for files that have more than one sprite) %
0000062a : 033e8eb3;   % 44: 		mul t4,t4,s3	# t4 = sprite status x height of rendering area x sprite's width %
0000062b : 00c0006f;   % 45: 		j START_RENDER %
0000062c : 02e80eb3;   % 47: 		mul t4,a6,a4	# t4 = sprite status x height of rendering area (for files that have more than one sprite) %
0000062d : 02de8eb3;   % 48: 		mul t4,t4,a3	# t4 = sprite status x height of rendering area x width of rendering area (on NORMAL_RENDER: a3 = sprite's width) %
0000062e : 01d50533;   % 51: 		add a0,a0,t4	# Adds the dislocation calculated on t4 to the sprite's address %
0000062f : 000012b7;   % 53: 	li t0,0x0FF0	#t0 = 0x0FF0 %
00000630 : ff028293;   % 53:  %
00000631 : 00f282b3;   % 54: 	add t0,t0,a5	# Rendering Address corresponds to 0x0FF0 + frame %
00000632 : 01429293;   % 55: 	slli t0,t0,20	# Shifts 20 bits, making printing adress correct (0xFF00 0000 or 0xFF10 0000) %
00000633 : 00b282b3;   % 56: 	add t0,t0,a1	# t0 = 0xFF00 0000 + X or 0xFF10 0000 + X %
00000634 : 14000313;   % 57: 	li t1,320	# t1 = 320 %
00000635 : 02c30333;   % 58: 	mul t1,t1,a2	# t1 = 320 * Y  %
00000636 : 006282b3;   % 59: 	add t0,t0,t1	# t0 = 0xFF00 0000 + X + (Y * 320) or 0xFF10 0000 + X + (Y * 320) %
00000637 : 000003b3;   % 61: 	mv t2,zero	# t2 = 0 (Resets line counter) %
00000638 : 00000e33;   % 62: 	mv t3,zero	# t3 = 0 (Resets column counter) %
00000639 : 00050e83;   % 65: 		lb t4,0(a0)	# loads byte(1 pixel) on t4 %
0000063a : 02000f13;   % 68: 		li t5,32 # Loads 32 (value of green pixel in samus) %
0000063b : 01df1c63;   % 69: 		bne t5,t4,SKIP_SWITCH %
0000063c : 0fc11f17;   % 70: 			la t5, PLYR_INFO_2    # Loads address to PLYR_INFO_2 %
0000063d : 840f0f13;   % 70:  %
0000063e : 000f4f03;   % 71: 			lbu t5,0(t5)          # Loads missile enable byte %
0000063f : 000f0463;   % 72: 			beqz t5,SKIP_SWITCH   # If player isn't in missile mode %
00000640 : 0f000e93;   % 73: 				li t4 240        # Otherwise render cyan instead of green %
00000641 : 01d28023;   % 76: 		sb t4,0(t0)	# prints 1 pixel from t4 %
00000642 : 00128293;   % 78: 		addi t0,t0,1	# increments bitmap address %
00000643 : 00150513;   % 79: 		addi a0,a0,1	# increments image address %
00000644 : 001e0e13;   % 81: 		addi t3,t3,1		# increments column counter %
00000645 : fcde48e3;   % 82: 		blt t3,a3,PRINT_LINE	# if column counter < width, repeat %
00000646 : 14028293;   % 84: 		addi t0,t0,320	# goes to next line on bitmap display %
00000647 : 40d282b3;   % 85: 		sub t0,t0,a3	# goes to right X on bitmap display (current address - width) %
00000648 : 00088663;   % 87: 		beqz a7, NORMAL_RENDER	# If not on crop mode %
00000649 : 01350533;   % 89: 			add a0,a0,s3	# a0 += sprite width	 %
0000064a : 40d50533;   % 90: 			sub a0,a0,a3	# a0 -= rendering width %
0000064b : 00000e33;   % 93: 			mv t3,zero		# t3 = 0 (Resets column counter) %
0000064c : 00138393;   % 94: 			addi t2,t2,1		# increments line counter %
0000064d : fae3c8e3;   % 95: 			bgt a4,t2,PRINT_LINE	# if height > line counter, repeat %
0000064e : 00008067;   % 96: 			ret %
0000064f : 00088e63;   % 122: beqz a7,NORMAL_WORD %
00000650 : 00950533;   % 124: 		add a0,a0,s1	# Image address + X on sprite  %
00000651 : 03298e33;   % 125: 		mul t3,s3,s2	# t3 = sprite width * Y on sprite %
00000652 : 01c50533;   % 126: 		add a0,a0,t3	# a0 = Image address + X on sprite + sprite widht * Y on sprite %
00000653 : 03480eb3;   % 127: 		mul t4,a6,s4	# t4 = sprite status x height of rendering area (for files that have more than one sprite) %
00000654 : 033e8eb3;   % 128: 		mul t4,t4,s3	# t4 = sprite status x height of rendering area x sprite's width %
00000655 : 00c0006f;   % 129: 		j START_RENDER_WORD %
00000656 : 02e80eb3;   % 131: 		mul t4,a6,a4	# t4 = sprite status x height of rendering area (for files that have more than one sprite) %
00000657 : 02de8eb3;   % 132: 		mul t4,t4,a3	# t4 = sprite status x height of rendering area x width of rendering area (on NORMAL_RENDER: a3 = sprite's width) %
00000658 : 01d50533;   % 135: 		add a0,a0,t4	# Adds the dislocation calculated on t4 to the sprite's address %
00000659 : 000012b7;   % 137: 	li t0,0x0FF0	#t0 = 0x0FF0 %
0000065a : ff028293;   % 137:  %
0000065b : 00f282b3;   % 138: 	add t0,t0,a5	# Rendering Address corresponds to 0x0FF0 + frame %
0000065c : 01429293;   % 139: 	slli t0,t0,20	# Shifts 20 bits, making printing adress correct (0xFF00 0000 or 0xFF10 0000) %
0000065d : 00b282b3;   % 140: 	add t0,t0,a1	# t0 = 0xFF00 0000 + X or 0xFF10 0000 + X %
0000065e : 14000313;   % 141: 	li t1,320	# t1 = 320 %
0000065f : 02c30333;   % 142: 	mul t1,t1,a2	# t1 = 320 * Y  %
00000660 : 006282b3;   % 143: 	add t0,t0,t1	# t0 = 0xFF00 0000 + X + (Y * 320) or 0xFF10 0000 + X + (Y * 320) %
00000661 : 000003b3;   % 145: 	mv t2,zero	# t2 = 0 (Resets line counter) %
00000662 : 00000e33;   % 146: 	mv t3,zero	# t3 = 0 (Resets column counter) %
00000663 : 00050e83;   % 150: 		lb t4,0(a0)	# loads word(4 pixels) on t4 %
00000664 : 01d28023;   % 151: 		sb t4,0(t0)	# prints 4 pixels from t4 %
00000665 : 00128293;   % 153: 		addi t0,t0,1	# increments bitmap address %
00000666 : 00150513;   % 154: 		addi a0,a0,1	# increments image address %
00000667 : 001e0e13;   % 156: 		addi t3,t3,1		# increments column counter %
00000668 : fede46e3;   % 157: 		blt t3,a3,PRINT_LINE_WORD	# if column counter < width, repeat %
00000669 : 14028293;   % 159: 		addi t0,t0,320	# goes to next line on bitmap display %
0000066a : 40d282b3;   % 160: 		sub t0,t0,a3	# goes to right X on bitmap display (current address - width) %
0000066b : 00088663;   % 162: 		beqz a7, NORMAL_RENDER_WORD	# If not on crop mode %
0000066c : 01350533;   % 164: 			add a0,a0,s3	# a0 += sprite width	 %
0000066d : 40d50533;   % 165: 			sub a0,a0,a3	# a0 -= rendering width %
0000066e : 00000e33;   % 168: 			mv t3,zero		# t3 = 0 (Resets column counter) %
0000066f : 00138393;   % 169: 			addi t2,t2,1		# increments line counter %
00000670 : fce3c6e3;   % 170: 			bgt a4,t2,PRINT_LINE_WORD	# if height > line counter, repeat %
00000671 : 00008067;   % 171: 			ret %
00000672 : 000012b7;   % 194: 	li t0,0xFF0	# t0 = 0xFF0 %
00000673 : ff028293;   % 194:  %
00000674 : 00f282b3;   % 195: 	add t0,t0,a5	# Rendering Address corresponds to 0x0FF0 + frame %
00000675 : 01429293;   % 196: 	slli t0,t0,20	# Shifts 20 bits, making printing adress correct (0xFF00 0000 or 0xFF10 0000) %
00000676 : 00b282b3;   % 198: 	add t0,t0,a1	# t0 = 0xFF00 0000 + X or 0xFF10 0000 + X %
00000677 : 14000313;   % 200: 	li t1,320	# t1 = 320 %
00000678 : 02c30333;   % 201: 	mul t1,t1,a2	# t1 = 320 * Y  %
00000679 : 006282b3;   % 202: 	add t0,t0,t1	# t0 = 0xFF00 0000 + X + (Y * 320) or 0xFF10 0000 + X + (Y * 320) %
0000067a : 000003b3;   % 204: 	mv t2,zero	# t2 = 0 (Resets line counter) %
0000067b : 00000e33;   % 205: 	mv t3,zero	# t3 = 0 (Resets column counter) %
0000067c : 00851313;   % 207: 	slli t1,a0,8	# Shifts 8 bits on a0 %
0000067d : 00650533;   % 208: 	add a0,a0,t1	# a0 now stores two bytes of the same color (e.g.: 0x000000FF -> 0x0000FFFF) %
0000067e : 00081863;   % 210: 	bnez a6, PRINT_LINE_COLOR_HALF # If not printing 4 pixels at once %
0000067f : 01051313;   % 211: 		slli t1,a0,16	       # Shifts 16 bits on a0 %
00000680 : 00650533;   % 212: 		add a0,a0,t1	       # a0 now stores four bytes of the same color (e.g.: 0x0000FFFF -> 0xFFFFFFFF) %
00000681 : 02c0006f;   % 213: 		j PRINT_LINE_COLOR_WORD %
00000682 : 00a29023;   % 216: 		sh a0,0(t0)	# Renders two color pixels at once %
00000683 : 00228293;   % 217: 		addi t0,t0,2	# increments bitmap address by 2 bytes %
00000684 : 002e0e13;   % 219: 		addi t3,t3,2			# increments column counter %
00000685 : fede4ae3;   % 220: 		blt t3,a3,PRINT_LINE_COLOR_HALF	# if column counter < width, repeat %
00000686 : 14028293;   % 222: 		addi t0,t0,320	# goes to next line on bitmap display %
00000687 : 40d282b3;   % 223: 		sub t0,t0,a3	# goes to right X on bitmap display (current address - width) %
00000688 : 00000e33;   % 225: 		mv t3,zero			# t3 = 0 (resets column counter) %
00000689 : 00138393;   % 226: 		addi t2,t2,1			# increments line counter %
0000068a : fee3c0e3;   % 227: 		bgt a4,t2,PRINT_LINE_COLOR_HALF	# if height > line counter, repeat %
0000068b : 00008067;   % 228: 		ret			 %
0000068c : 00a2a023;   % 231: 		sw a0,0(t0)	# Renders four color pixels at once %
0000068d : 00428293;   % 232: 		addi t0,t0,4	# increments bitmap address by 4 bytes %
0000068e : 004e0e13;   % 234: 		addi t3,t3,4			# increments column counter %
0000068f : fede4ae3;   % 235: 		blt t3,a3,PRINT_LINE_COLOR_WORD	# if column counter < width, repeat %
00000690 : 14028293;   % 236: 		addi t0,t0,320	# goes to next line on bitmap display %
00000691 : 40d282b3;   % 237: 		sub t0,t0,a3	# goes to right X on bitmap display (current address - width) %
00000692 : 00000e33;   % 239: 		mv t3,zero			# t3 = 0 (resets column counter) %
00000693 : 00138393;   % 240: 		addi t2,t2,1			# increments line counter %
00000694 : fee3c0e3;   % 241: 		bgt a4,t2,PRINT_LINE_COLOR_WORD	# if height > line counter, repeat %
00000695 : 00008067;   % 242: 		ret %
00000696 : 00b00233;   % 263: 	mv tp,a1  # tp gets value from a1 %
00000697 : 0fc10317;   % 265: 	la t1, PLYR_INFO_2	 # Loads address of the second part of PLYR_INFO %
00000698 : 6d430313;   % 265:  %
00000699 : 00334283;   % 266:     lbu t0,3(t1)         # and damage cooldown %
0000069a : 00028c63;   % 267: 	beqz t0,RENDER_PLAYER_SKIP_DAMAGE %
0000069b : 00734283;   % 268: 		lbu t0,7(t1)     # Loads render byte %
0000069c : 0012c393;   % 269: 		xori t2,t0,1     # inverts it %
0000069d : 007303a3;   % 270: 		sb t2,7(t1)      # and stores it %
0000069e : 00029463;   % 271: 		bnez t0,RENDER_PLAYER_SKIP_DAMAGE # If it wasn't 0, render %
0000069f : 00008067;   % 272: 		ret	# Otherwise, finish procedure %
000006a0 : 0fc10297;   % 274: 	la t0, PLYR_STATUS # Loads PLAYER_STATUS address %
000006a1 : 6a628293;   % 274:  %
000006a2 : 0fc10397;   % 275: 	la t2,PLYR_POS	# Loads PLYR_POS address %
000006a3 : 69238393;   % 275:  %
000006a4 : 00039583;   % 277: 	lh a1, 0(t2)	# Loads top left X coordinate related to sprite %
000006a5 : 0043c603;   % 278: 	lbu a2, 4(t2)	# Loads top left Y coordinate related to sprite	 %
000006a6 : 008007b3;   % 280: 	mv a5, s0		# Gets frame  %
000006a7 : 0002c803;   % 281: 	lbu a6, 0(t0)   # Loads Player's sprite status %
000006a8 : 000008b3;   % 282: 	mv a7,zero 		# Operation (0 - normal operation) %
000006a9 : 00050463;   % 284: 	beqz a0, RENDER_PLAYER_NORMAL # If a0 = 0,  then player will be rendered normally %
000006aa : 2b80006f;   % 285: 	j RENDER_PLAYER_TRAIL         # Otherwise (a0 = 1) render player's trail %
000006ab : fec10113;   % 288: 		addi sp,sp,-20 %
000006ac : 00912023;   % 289: 		sw s1,0(sp) %
000006ad : 01212223;   % 290: 		sw s2,4(sp) %
000006ae : 01312423;   % 291: 		sw s3,8(sp) %
000006af : 01412623;   % 292: 		sw s4,12(sp) %
000006b0 : 00112823;   % 293: 		sw ra,16(sp) %
000006b1 : 0012c303;   % 297: 		lbu t1, 1(t0)	# Loads Player's horizontal direction (0 = Right, 1 = Left) %
000006b2 : 0042c383;   % 298: 		lbu t2, 4(t0)   # Loads Player's morph ball status %
000006b3 : 00038463;   % 300: 		beqz t2, RENDER_PLAYER_STAND # If player isn't on morph ball, go to RENDER_PLAYER_STAND %
000006b4 : 1f80006f;   % 301: 		j RENDER_PLAYER_BALL         # Otherwise, go to RENDER_PLAYER_BALL %
000006b5 : 0062c383;   % 304: 		lbu t2, 6(t0)   # Loads Player's MOVE_X value (-1 left, 1 right, 0 not moving on X axis) %
000006b6 : 0072ce03;   % 305: 		lbu t3, 7(t0)   # Loads Player's MOVE_Y value (-1 up, 1 right, 0 not moving on Y axis) %
000006b7 : 0022ce83;   % 306: 		lbu t4, 2(t0)	# Loads Player's vertical direction (0 = Normal, 1 = Up) %
000006b8 : 0052cf03;   % 307: 		lbu t5, 5(t0)	# Loads Player's attacking status (0 - no, 1 - yes) %
000006b9 : 00030463;   % 309: 		beqz t1, RENDER_PLYR_RIGHT # Checks if player is looking right %
000006ba : 0f00006f;   % 310: 		j RENDER_PLYR_LEFT	   # If player is looking left %
000006bb : 01c38333;   % 313: 			add t1, t2, t3  # t1 will be 0 if t2 (MOVE_X) = 0 and t3 (MOVE_Y) = 0 %
000006bc : 00030e63;   % 314: 			beqz t1,RENDER_IDLE_RIGHT # If t1 = 0, player isn't moving (go to RENDER_IDLE_RIGHT) %
000006bd : 0fc10317;   % 315: 				la t1,PLYR_INPUT # Otherwise, load PLYR_INPUT address %
000006be : 63b30313;   % 315:  %
000006bf : 00034303;   % 316: 				lbu t1,0(t1)     # and get its value %
000006c0 : ffe30313;   % 317: 				addi t1,t1,-2    # subtracts 2 from it %
000006c1 : 00030463;   % 318: 				beqz t1, RENDER_IDLE_RIGHT # if the result is 0 (t1 would've been 2, so player couldn't move) go to idle %
000006c2 : 0340006f;   % 319: 					j NOT_IDLE_RIGHT	   # Otherwise, go to NOT_IDLE_RIGHT %
000006c3 : 01400693;   % 322: 				li a3, 20   # Sprite's Widht %
000006c4 : 01e00833;   % 323: 				mv a6, t5	# Idle sprites have their status set to 1 if player is attacking %
000006c5 : 000e9a63;   % 324: 				bnez t4, RENDER_IDLE_RIGHT_UP # If player is looking up %
000006c6 : 0fc15517;   % 327: 				la a0, Samus_Right_Idle # Loads Player's Image Address  %
000006c7 : 2e450513;   % 327:  %
000006c8 : 02000713;   % 328: 				li a4, 32  # Sprite's Height %
000006c9 : 1b80006f;   % 329: 				j START_RENDER_PLAYER # Start rendering player %
000006ca : ffa60613;   % 332: 				addi a2,a2, -6 # Offseting sprite's Y so that it renders in propper place %
000006cb : 0fc15517;   % 333: 				la a0, Samus_Right_Idle_Up # Loads Player's Image Address  %
000006cc : 7d050513;   % 333:  %
000006cd : 02600713;   % 334: 				li a4, 38  # Sprite's Height %
000006ce : 1a40006f;   % 335: 				j START_RENDER_PLAYER # Start rendering player %
000006cf : 000e1463;   % 338: 				bnez t3, RENDER_JUMP_RIGHT %
000006d0 : 0380006f;   % 339: 				j NOT_JUMP_RIGHT %
000006d1 : ffc58593;   % 348: 					addi a1,a1, -4 # Offseting sprite's X so that it renders in propper place %
000006d2 : ffa60613;   % 349: 					addi a2,a2, -6 # Offseting sprite's Y so that it renders in propper place %
000006d3 : 02000713;   % 350: 					li a4, 32  # Sprite's Height %
000006d4 : 01e00833;   % 351: 					mv a6, t5	# Jump sprites have their status set to 1 if player is attacking %
000006d5 : 000e9a63;   % 352: 					bnez t4, RENDER_JUMP_RIGHT_UP	# If player is looking up %
000006d6 : 01800693;   % 354: 						li a3, 24  # Sprite's Widht %
000006d7 : 0fc18517;   % 355: 						la a0, Samus_Right_Jump # Loads Player's Image Address  %
000006d8 : 16050513;   % 355:  %
000006d9 : 1780006f;   % 356: 						j START_RENDER_PLAYER   # Start rendering player %
000006da : 01400693;   % 359: 						li a3, 20  # Sprite's Widht %
000006db : 0fc18517;   % 360: 						la a0, Samus_Right_Jump_Up # Loads Player's Image Address  %
000006dc : 75050513;   % 360:  %
000006dd : 1680006f;   % 361: 						j START_RENDER_PLAYER      # Start rendering player %
000006de : 000e8463;   % 364: 					beqz t4, RENDER_MOVEMENT_RIGHT %
000006df : 0300006f;   % 365: 					j RENDER_MOVEMENT_RIGHT_UP %
000006e0 : 02000713;   % 368: 						li a4, 32  # Sprite's Height %
000006e1 : 000f0463;   % 369: 						beqz t5, RENDER_MOVEMENT_RIGHT_NORMAL %
000006e2 : 0140006f;   % 370: 						j RENDER_MOVEMENT_RIGHT_ATTACK %
000006e3 : 0fc16517;   % 373: 							la a0, Samus_Right	   # Loads Player's Image Address  %
000006e4 : d6050513;   % 373:  %
000006e5 : 01400693;   % 374: 							li a3, 20              # Sprite's Widht %
000006e6 : 1440006f;   % 375: 							j START_RENDER_PLAYER  # Start rendering player %
000006e7 : 0fc16517;   % 378: 							la a0, Samus_Right_Attack  # Loads Player's Image Address  %
000006e8 : 4d050513;   % 378:  %
000006e9 : 01c00693;   % 379: 							li a3, 28                  # Sprite's Widht %
000006ea : 1340006f;   % 380: 							j START_RENDER_PLAYER      # Start rendering player %
000006eb : ffa60613;   % 383: 						addi a2,a2, -6 # Offseting sprite's X so that it renders in propper place %
000006ec : 01400693;   % 384: 						li a3, 20      # Sprite's Widht %
000006ed : 02600713;   % 385: 						li a4, 38      # Sprite's Height %
000006ee : 000f0463;   % 386: 						beqz t5, RENDER_MOVEMENT_RIGHT_UP_NORMAL %
000006ef : 0100006f;   % 387: 						j RENDER_MOVEMENT_RIGHT_UP_ATTACK %
000006f0 : 0fc17517;   % 390: 							la a0, Samus_Right_Up  # Loads Player's Image Address %
000006f1 : f2c50513;   % 390:  %
000006f2 : 1140006f;   % 391: 							j START_RENDER_PLAYER  # Start rendering player %
000006f3 : 0fc18517;   % 394: 							la a0, Samus_Right_Up_Attack  # Loads Player's Image Address %
000006f4 : 80850513;   % 394:  %
000006f5 : 1080006f;   % 395: 							j START_RENDER_PLAYER         # Start rendering player %
000006f6 : ffc58593;   % 398: 			addi a1,a1, -4 # Offseting sprite's X so that it renders in propper place %
000006f7 : 01c38333;   % 399: 			add t1, t2, t3  # t1 will only be 0 if player isn't moving  %
000006f8 : 00030e63;   % 400: 			beqz t1,RENDER_IDLE_LEFT # Checks if player is mooving or not %
000006f9 : 0fc10317;   % 401: 				la t1,PLYR_INPUT # Otherwise, load PLYR_INPUT address %
000006fa : 54b30313;   % 401:  %
000006fb : 00034303;   % 402: 				lbu t1,0(t1)     # and get its value %
000006fc : ffe30313;   % 403: 				addi t1,t1,-2    # subtracts 2 from it %
000006fd : 00030463;   % 404: 				beqz t1, RENDER_IDLE_LEFT # if the result is 0 (t1 would've been 2, so player couldn't move) go to idle %
000006fe : 0340006f;   % 405: 			j NOT_IDLE_LEFT	  # If player is moving or not %
000006ff : 01400693;   % 408: 				li a3, 20  # Sprite's Widht %
00000700 : 01e00833;   % 409: 				mv a6, t5	# Idle sprites have their status set to 1 if player is attacking %
00000701 : 000e9a63;   % 410: 				bnez t4, RENDER_IDLE_LEFT_UP	# If player is looking up %
00000702 : 0fc19517;   % 413: 					la a0, Samus_Left_Idle # Loads Player's Image Address  %
00000703 : 4b450513;   % 413:  %
00000704 : 02000713;   % 414: 					li a4, 32  # Sprite's Height %
00000705 : 0c80006f;   % 415: 					j START_RENDER_PLAYER # Start rendering player %
00000706 : ffa60613;   % 418: 					addi a2,a2, -6 # Offseting sprite's Y so that it renders in propper place %
00000707 : 0fc1a517;   % 419: 					la a0, Samus_Left_Idle_Up # Loads Player's Image Address  %
00000708 : 9a050513;   % 419:  %
00000709 : 02600713;   % 420: 					li a4, 38  # Sprite's Height %
0000070a : 0b40006f;   % 421: 					j START_RENDER_PLAYER # Start rendering player %
0000070b : 000e1463;   % 424: 				bnez t3, RENDER_JUMP_LEFT %
0000070c : 0340006f;   % 425: 				j NOT_JUMP_LEFT %
0000070d : ffc58593;   % 434: 					addi a1,a1, -4 # Offseting sprite's X so that it renders in propper place %
0000070e : ffa60613;   % 435: 					addi a2,a2, -6 # Offseting sprite's Y so that it renders in propper place %
0000070f : 01800693;   % 436: 					li a3, 24  # Sprite's Widht %
00000710 : 02000713;   % 437: 					li a4, 32  # Sprite's Height %
00000711 : 01e00833;   % 438: 					mv a6, t5	# Jump sprites have their status set to 1 if player is attacking %
00000712 : 000e9863;   % 439: 					bnez t4, RENDER_JUMP_LEFT_UP	# If player is looking up %
00000713 : 0fc1c517;   % 444: 					la a0, Samus_Left_Jump # Loads Player's Image Address  %
00000714 : 63050513;   % 444:  %
00000715 : 0880006f;   % 445: 					j START_RENDER_PLAYER   # Start rendering player %
00000716 : 0fc1d517;   % 448: 						la a0, Samus_Left_Jump_Up # Loads Player's Image Address  %
00000717 : c2450513;   % 448:  %
00000718 : 07c0006f;   % 449: 						j START_RENDER_PLAYER      # Start rendering player %
00000719 : 000e8463;   % 452: 					beqz t4, RENDER_MOVEMENT_LEFT %
0000071a : 0340006f;   % 453: 					j RENDER_MOVEMENT_LEFT_UP %
0000071b : ff858593;   % 456: 						addi a1,a1, -8 # Offseting sprite's X so that it renders in propper place %
0000071c : 02000713;   % 457: 						li a4, 32      # Sprite's Height %
0000071d : 000f0463;   % 458: 						beqz t5, RENDER_MOVEMENT_LEFT_NORMAL %
0000071e : 0140006f;   % 459: 						j RENDER_MOVEMENT_LEFT_ATTACK %
0000071f : 0fc1a517;   % 462: 							la a0, Samus_Left	   # Loads Player's Image Address  %
00000720 : f3050513;   % 462:  %
00000721 : 01c00693;   % 463: 							li a3, 28              # Sprite's Widht %
00000722 : 0540006f;   % 464: 							j START_RENDER_PLAYER  # Start rendering player %
00000723 : 0fc1b517;   % 467: 							la a0, Samus_Left_Attack  # Loads Player's Image Address  %
00000724 : 9a050513;   % 467:  %
00000725 : 01c00693;   % 468: 							li a3, 28                  # Sprite's Widht %
00000726 : 0440006f;   % 469: 							j START_RENDER_PLAYER      # Start rendering player %
00000727 : ffa60613;   % 472: 						addi a2,a2, -6 # Offseting sprite's X so that it renders in propper place %
00000728 : 01400693;   % 473: 						li a3, 20      # Sprite's Widht %
00000729 : 02600713;   % 474: 						li a4, 38      # Sprite's Height %
0000072a : 000f0463;   % 475: 						beqz t5, RENDER_MOVEMENT_LEFT_UP_NORMAL %
0000072b : 0100006f;   % 476: 						j RENDER_MOVEMENT_LEFT_UP_ATTACK %
0000072c : 0fc1b517;   % 479: 							la a0, Samus_Left_Up  # Loads Player's Image Address %
0000072d : 3fc50513;   % 479:  %
0000072e : 0240006f;   % 480: 							j START_RENDER_PLAYER  # Start rendering player %
0000072f : 0fc1c517;   % 483: 							la a0, Samus_Left_Up_Attack  # Loads Player's Image Address %
00000730 : cd850513;   % 483:  %
00000731 : 0180006f;   % 484: 							j START_RENDER_PLAYER         # Start rendering player %
00000732 : 0fc1e517;   % 487: 			la a0, Morph_Ball # Loads morph ball image address %
00000733 : ab450513;   % 487:  %
00000734 : 01060613;   % 488: 			addi a2, a2, 16 # Adds 16 to Player's Y %
00000735 : 01000693;   % 489: 			li a3, 16 # Loads 16 to width of rendering area %
00000736 : 01000713;   % 490: 			li a4, 16 # Loads 16 to height of rendering area	 %
00000737 : 04020263;   % 494: 			beqz tp, RENDER_PLAYER_SKIP_CROP # If tp is 0, don't crop image %
00000738 : 00100293;   % 495: 				li t0,1    # To compare with tp (16 pixels to the left) %
00000739 : 02428263;   % 496: 				beq t0,tp, RENDER_PLAYER_CROP_LEFT %
0000073a : 00d009b3;   % 499: 					mv s3,a3         # Moves sprite's width to s3 %
0000073b : 00e00a33;   % 500: 					mv s4,a4         # Moves sprite's height to s4 %
0000073c : 01000693;   % 501: 					li a3,16  # New width of rendering area %
0000073d : 00100893;   % 502: 					li a7,1          # Sets to crop mode %
0000073e : 40d984b3;   % 503: 					sub s1,s3,a3     # Sets starting X to be 16 pixels before width of sprite's width %
0000073f : 00000913;   % 504: 					li s2,0          # Sets starting Y on sprite to 0 %
00000740 : 009585b3;   % 505: 					add a1,a1,s1     # Corrects player's starting X to be dislocated to the cropped X %
00000741 : 01c0006f;   % 506: 					j RENDER_PLAYER_SKIP_CROP %
00000742 : 00d009b3;   % 509: 					mv s3,a3         # Moves sprite's width to s3 %
00000743 : 00e00a33;   % 510: 					mv s4,a4         # Moves sprite's height to s4 %
00000744 : 01000693;   % 511: 					li a3,16  # New width of rendering area %
00000745 : 00100893;   % 512: 					li a7,1          # Sets to crop mode %
00000746 : 00000493;   % 513: 					li s1,0          # Sets starting X on sprite to 0  %
00000747 : 00000913;   % 514: 					li s2,0          # Sets starting Y on sprite to 0	 %
00000748 : 0fc10f17;   % 518: 				la t5, PLYR_INFO_2    # Loads address to PLYR_INFO_2 %
00000749 : 410f0f13;   % 518:  %
0000074a : 000f4f03;   % 519: 				lbu t5,0(t5)          # Loads missile enable byte %
0000074b : 000f0863;   % 520: 				beqz t5,RENDER_PLAYER_SKIP_MISSILE   # If player isn't in missile mode %
0000074c : 00000317;   % 521: 					call RENDER    # Otherwise, render sprite byte by byte (to change color) %
0000074d : b64300e7;   % 521:  %
0000074e : 00c0006f;   % 522: 					j END_RENDER_PLAYER %
0000074f : 00000317;   % 524: 					call RENDER_WORD	# Calls RENDER_WORD procedure %
00000750 : c00300e7;   % 524:  %
00000751 : 00012483;   % 527: 					lw s1,0(sp) %
00000752 : 00412903;   % 528: 					lw s2,4(sp) %
00000753 : 00812983;   % 529: 					lw s3,8(sp) %
00000754 : 00c12a03;   % 530: 					lw s4,12(sp) %
00000755 : 01012083;   % 531: 					lw ra,16(sp) %
00000756 : 01410113;   % 532: 					addi sp,sp,20 %
00000757 : 00008067;   % 534: 					ret	   # End of procedure %
00000758 : 00144793;   % 537: 		xori a5,s0,1	# Gets oposite frame %
00000759 : 0fc10297;   % 539: 		la t0, PLYR_MATRIX  # Loads PLYR_MATRIX address %
0000075a : 3be28293;   % 539:  %
0000075b : 0012ce03;   % 540: 		lbu t3, 1(t0) # Loads Player's old X related to matrix (Starting X for rendering (top left, related to Matrix)) %
0000075c : 0032c383;   % 541: 		lbu t2, 3(t0) # Loads Player's old Y related to matrix (Starting Y for rendering (top left, related to Matrix)) %
0000075d : 00200813;   % 543: 		li a6, 2	    # Width (Number of Tiles) = 2 %
0000075e : 00200893;   % 544: 		li a7, 2	    # Height (Number of Tiles) = 2 %
0000075f : 00b2c303;   % 546: 		lbu t1,11(t0)    # Loads player's MOVE_Y %
00000760 : 00603333;   % 547: 		sltu t1,zero,t1  # t1 != 0 ? t1 = 1 : t1 = 0 %
00000761 : 00c28e83;   % 548: 		lb t4,12(t0)     # Loads player's JUMP %
00000762 : 000ed663;   % 549: 		bge t4,zero,SKIP_JUMP_CORRECTION      # t4 < 0 ? t4 = 1 : t4 = 0 %
00000763 : 00100313;   % 550: 			li t1,1        # Will add 1 to the height %
00000764 : 00028623;   % 551: 			sb zero,12(t0) # Sets JUMP to 0 %
00000765 : 006888b3;   % 553: 		add a7,a7,t1     # If player is moving vertically (t0 != 0), the height will increase by 1  %
00000766 : 0082c283;   % 555: 		lbu t0, 8(t0)   # Loads Player's morph ball status %
00000767 : 020e0a63;   % 556: 		beqz t3,SKIP_MOVE_Y_RENDER_PLAYER_TRAIL   # If player is on leftmost side, don't increase the width %
00000768 : fffe0e13;   % 559: 			addi t3,t3,-1     # Moves X left by 1 tile %
00000769 : 0fc10317;   % 560: 			la t1 CURRENT_MAP # Loads CURRENT_MAP address %
0000076a : 35c30313;   % 560:  %
0000076b : 00032303;   % 561: 			lw t1,0(t1)       # Gets current map's address %
0000076c : 00134303;   % 562: 			lbu t1,1(t1)      # Gets current map's width %
0000076d : 41c30333;   % 563: 			sub t1,t1,t3      # t1 = Map's width - Player's old X related to matrix %
0000076e : 00400e93;   % 564: 			li t4,4           # t2 is used for comparing %
0000076f : 01d34863;   % 565: 			blt t1,t4,SET_NEW_WIDTH_RENDER_PLAYER_TRAIL # If t1 < 4, set the width to t1 %
00000770 : 0012c313;   % 567: 			xori t1,t0,1	# If player is on morph ball (t0 = 1), t1 = 0 and vice versa %
00000771 : 00330813;   % 568: 			addi a6,t1,3    # Width (Number of Tiles) = 3 (on morph ball) or 4 (not on morph ball) %
00000772 : 0080006f;   % 569: 			j SKIP_MOVE_Y_RENDER_PLAYER_TRAIL %
00000773 : 00600833;   % 571: 				mv a6,t1    # Width (Number of Tiles) = t1 (t1 < 4) %
00000774 : 00028463;   % 573: 		beqz t0, RENDER_PLAYER_TRAIL_STAND  # If player isn't on morph ball, go to RENDER_PLAYER_TRAIL_STAND %
00000775 : 0100006f;   % 574: 		j START_RENDER_PLAYER_TRAIL         # otherwise, player is on morph ball and go to START_RENDER_PLAYER_TRAIL %
00000776 : fff38393;   % 577: 			addi t2,t2,-1   # Moves Y up by 1 tile %
00000777 : 00188893;   % 578: 			addi a7,a7,1    # Height (Number of Tiles) = 3 (if not jumping) or 4 (if jumping) %
00000778 : 0040006f;   % 579: 			j START_RENDER_PLAYER_TRAIL %
00000779 : 00100db3;   % 582: 			mv s11, ra	# Moves ra to s11 -- so that we don't need to use the stack %
0000077a : 00004317;   % 583: 			call SCENE_RENDER	# Calls SCENE_RENDER procedure %
0000077b : 258300e7;   % 583:  %
0000077c : 01b000b3;   % 584: 			mv ra, s11  # Returns s11 to ra -- so that we don't need to use the stack %
0000077d : 00008067;   % 585: 			ret			# End of procedure %
0000077e : ffc10113;   % 605:     addi sp,sp,-4 %
0000077f : 00112023;   % 606:     sw ra,0(sp) %
00000780 : 0fc10517;   % 609: 	la a0, Energy_UI    # Image address %
00000781 : 71f50513;   % 609:  %
00000782 : 01800593;   % 610: 	li a1,24            # Starting X (24) %
00000783 : 02000613;   % 611: 	li a2,32            # Starting Y (32) %
00000784 : 01800693;   % 612: 	li a3,24            # Gets width %
00000785 : 00800713;   % 613: 	li a4,8             # Gets height %
00000786 : 008007b3;   % 614: 	mv a5,s0            # Gets frame %
00000787 : 00000813;   % 615: 	li a6,0             # Only one sprite, so there's no status %
00000788 : 00000893;   % 616: 	li a7,0             # Normal render %
00000789 : 00000317;   % 617: 	call RENDER_WORD %
0000078a : b18300e7;   % 617:  %
0000078b : 0fc10297;   % 619: 	la t0, PLYR_INFO %
0000078c : 2ec28293;   % 619:  %
0000078d : 00028503;   % 620: 	lb a0, 0(t0)          # Loads player's health %
0000078e : 00055463;   % 621: 	bge a0,zero,SKIP_LIFE_CORRECTION %
0000078f : 00000513;   % 622: 		li a0,0 %
00000790 : 03000593;   % 624: 	li a1,48              # a1 = column %
00000791 : 02000613;   % 625: 	li a2,32              # a2 = row  %
00000792 : 0000c6b7;   % 626: 	li a3,0xc7ff          # a3 = colors  %
00000793 : 7ff68693;   % 626:  %
00000794 : 00800733;   % 627: 	mv a4,s0              # a4 = frame %
00000795 : 00100793;   % 628: 	li a5,1               # Font %
00000796 : 06500893;   % 629: 	li a7,101 # syscal for 'print integer' %
00000797 : 00000073;   % 630: 	ecall %
00000798 : 00012083;   % 633: 	lw ra,0(sp) %
00000799 : 00410113;   % 634: 	addi sp,sp,4 %
0000079a : 00008067;   % 636: 	ret %
0000079b : 0a089863;   % 670: bnez a7,RENDER_ENTITY_TRAIL # If a0 != 0, render trail %
0000079c : 00000893;   % 671: 	li a7,0     # at the beginning, sprite doesn't need to be cropped %
0000079d : 00000493;   % 672: 	li s1,0     # Setting s1 to 0, in case needs to crop but skips horizontal crop %
0000079e : 00000913;   % 673: 	li s2,0     # Setting s2 to 0, in case needs to crop but skips vertical crop %
0000079f : 00d009b3;   % 674: 	mv s3,a3    # Storing sprite's width in (in case needs to crop but skips horizontal crop) %
000007a0 : 00e00a33;   % 675: 	mv s4,a4    # Storing sprite's width in (in case needs to crop but skips horizontal crop) %
000007a1 : 00d582b3;   % 678: 	add t0,a1,a3   # t0 (rightmost X + 1) = top left X related to screen + rendering area width  %
000007a2 : 14505e63;   % 679: 	bge zero,t0, END_RENDER_ENTITY # If t0 <= 0, sprite's outside of screen (don't try to render >:[ ) %
000007a3 : 14000313;   % 680: 	li t1,320 # t1 = 320 %
000007a4 : 1465da63;   % 681: 	bge a1,t1, END_RENDER_ENTITY # If a1 >= 320, sprite's outside of screen (don't try to render >:[ ) %
000007a5 : 0005c663;   % 684: 		blt a1,zero,CORRECT_X_LEFT # If so, crop the image %
000007a6 : 00534e63;   % 686: 		blt t1,t0,CORRECT_X_RIGHT # If so, crop the image %
000007a7 : 0240006f;   % 687: 		j RENDER_ENTITY_CHECK_VERTICAL# Otherwise, the a1 and a3 arguments are already defined correctly, go check vertical		 %
000007a8 : 00100893;   % 690: 			li a7,1         # Sprite will need to be cropped %
000007a9 : 40b004b3;   % 691: 			sub s1,zero,a1  # s1 (X in sprite where rendering starts) will be the absolute value of a1 %
000007aa : 00b686b3;   % 693: 			add a3,a3,a1    # Since a1 will be negative, a3 will be reduced to a smaller width %
000007ab : 00000593;   % 694: 			li a1,0         # and a1 will be set to 0 (leftmost X)   %
000007ac : 0100006f;   % 695: 			j RENDER_ENTITY_CHECK_VERTICAL # Go check vertical arguments		 %
000007ad : 00100893;   % 698: 			li a7,1         # Sprite will need to be cropped %
000007ae : 406282b3;   % 701: 			sub t0,t0,t1  # t0 will hold the excess width (what passes through the right border) %
000007af : 405686b3;   % 702: 			sub a3,a3,t0  # take away from width (a3) the excess %
000007b0 : 00e602b3;   % 707: 		add t0,a2,a4   # t0 (lowermost Y + 1) = top left Y related to screen + rendering area height  %
000007b1 : 12505063;   % 708: 		bge zero,t0, END_RENDER_ENTITY # If t0 <= 0, sprite's outside of screen (don't try to render >:[ ) %
000007b2 : 0f000313;   % 709: 		li t1,240 # t1 = 240 %
000007b3 : 01030313;   % 710: 		addi t1,t1,16 %
000007b4 : 10665a63;   % 711: 		bge a2,t1, END_RENDER_ENTITY # If a2 >= 240, sprite's outside of screen (don't try to render >:[ ) %
000007b5 : 00064663;   % 714: 			blt a2,zero,CORRECT_Y_TOP # If so, crop the image %
000007b6 : 00534e63;   % 716: 			blt t1,t0,CORRECT_Y_BOTTOM # If so, crop the image %
000007b7 : 0240006f;   % 717: 			j RENDER_ENTITY_START # Otherwise, the a2 and a4 arguments are already defined correctly, render	 %
000007b8 : 00100893;   % 720: 				li a7,1         # Sprite will need to be cropped %
000007b9 : 40c00933;   % 721: 				sub s2,zero,a2  # s2 (Y in sprite where rendering starts) will be the absolute value of a2 %
000007ba : 00c70733;   % 723: 				add a4,a4,a2    # Since a2 will be negative, a4 will be reduced to a smaller height %
000007bb : 00000613;   % 724: 				li a2,0         # and a1 will be set to 0 (topmost Y)   %
000007bc : 0100006f;   % 725: 				j RENDER_ENTITY_START # render	 %
000007bd : 00100893;   % 728: 				li a7,1         # Sprite will need to be cropped %
000007be : 406282b3;   % 731: 				sub t0,t0,t1  # t0 will hold the excess height (what passes through the bottom border) %
000007bf : 40570733;   % 732: 				sub a4,a4,t0  # take away from height (a4) the excess %
000007c0 : ffc10113;   % 738: 			addi sp,sp,-4 %
000007c1 : 00112023;   % 739: 			sw ra,0(sp) %
000007c2 : 00000317;   % 741: 			call RENDER  %
000007c3 : 98c300e7;   % 741:  %
000007c4 : 00012083;   % 743: 			lw ra,0(sp) %
000007c5 : 00410113;   % 744: 			addi sp,sp,4 %
000007c6 : 0cc0006f;   % 746: 			j END_RENDER_ENTITY %
000007c7 : 00000513;   % 749: 	li a0,0         # So that it renders map's trail %
000007c8 : 00144793;   % 750: 	xori a5,s0,1	# Gets oposite frame %
000007c9 : 00b00e33;   % 753: 	mv t3,a1   # column where rendering will begin (X related to Matrix) %
000007ca : 00c003b3;   % 754: 	mv t2,a2   # line where rendering will begin (Y related to Matrix) %
000007cb : 00d00833;   % 755: 	mv a6,a3   # width (Related to Matrix) of rendering area %
000007cc : 00e008b3;   % 756: 	mv a7,a4   # height (Related to Matrix) of rendering area %
000007cd : 0fc10217;   % 758: 	la tp,CURRENT_MAP # Loads CURRENT_MAP's address %
000007ce : 1cc20213;   % 758:  %
000007cf : 00624283;   % 760: 	lbu t0,6(tp)   # loads map's current X   %
000007d0 : 00d58333;   % 761: 	add t1,a1,a3   # t1 (rightmost X + 1) = top left X related to matrix + rendering area width  %
000007d1 : 0a62d063;   % 762: 	bge t0,t1, END_RENDER_ENTITY # If t1 <= map's current X, area is outside of screen (don't try to render >:[ ) %
000007d2 : 01428e93;   % 763: 	addi t4,t0,20    # t1 = map's current X + 20 %
000007d3 : 09d5cc63;   % 764: 	blt a1,t4, END_RENDER_ENTITY # If a1 > map's current X + 20, area is outside of screen (don't try to render >:[ ) %
000007d4 : 0055c663;   % 779: 		blt a1,t0,CORRECT_X_LEFT_TRAIL # If so, reduce width %
000007d5 : 006ecc63;   % 781: 		blt t4,t1,CORRECT_X_RIGHT_TRAIL # If so, reduce width %
000007d6 : 02c0006f;   % 782: 		j RENDER_ENTITY_TRAIL_CHECK_VERTICAL # Otherwise, the a1 and a3 arguments are already defined correctly, go check vertical		 %
000007d7 : 40b28eb3;   % 785: 			sub t4,t0,a1    # t4 will have map's current X - Old X %
000007d8 : 41d80833;   % 786: 			sub a6,a6,t4    # Reduce width %
000007d9 : 00500e33;   % 787: 			mv t3,t0        # t3 will recieve map's current X   %
000007da : 01c0006f;   % 788: 			j RENDER_ENTITY_TRAIL_CHECK_VERTICAL  # Go check vertical arguments		 %
000007db : 406e8eb3;   % 792: 			sub t4,t4,t1    # t4 = map's current X + 20 - (top left X related to matrix + rendering area width)  %
000007dc : 41d80833;   % 793: 			sub a6,a6,t4    # Reduce width %
000007dd : 00824e83;   % 794: 			lbu t4,8(tp)    # loads map's X offset  %
000007de : 01d02eb3;   % 795: 			slt t4,zero,t4  # 0 < x offset ? t4 = 1 : t4 = 0 %
000007df : 01d80833;   % 796: 			add a6,a6,t4    # add 1 to width if offset != 0 %
000007e0 : 06080263;   % 797: 			beqz a6, END_RENDER_ENTITY # if width is 0, end procedure %
000007e1 : 00724283;   % 802: 		lbu t0,7(tp)   # loads map's current Y   %
000007e2 : 00e60333;   % 803: 		add t1,a2,a4   # t1 (rightmost Y + 1) = top left Y related to matrix + rendering area width  %
000007e3 : 0462dc63;   % 804: 		bge t0,t1, END_RENDER_ENTITY # If t1 <= map's current Y, area is outside of screen (don't try to render >:[ ) %
000007e4 : 00f28e93;   % 805: 		addi t4,t0,15   # t1 = map's current Y + 15 %
000007e5 : 05d64863;   % 806: 		blt a2,t4, END_RENDER_ENTITY # If a2 > map's current Y + 15, area is outside of screen (don't try to render >:[ ) %
000007e6 : 00564663;   % 809: 			blt a2,t0,CORRECT_Y_TOP_TRAIL # If so, reduce width %
000007e7 : 006ecc63;   % 811: 			blt t4,t1,CORRECT_Y_BOTTOM_TRAIL # If so, reduce width %
000007e8 : fe5ff06f;   % 812: 			j RENDER_ENTITY_TRAIL_CHECK_VERTICAL # Otherwise, the a2 and a4 arguments are already defined correctly, go check vertical		 %
000007e9 : 40b28eb3;   % 815: 				sub t4,t0,a1    # t4 will have map's current Y - Old Y %
000007ea : 41d888b3;   % 816: 				sub a7,a7,t4    # Reduce height %
000007eb : 005003b3;   % 817: 				mv t2,t0        # t2 will recieve map's current Y   %
000007ec : 01c0006f;   % 818: 				j RENDER_ENTITY_TRAIL_START  # Render trail %
000007ed : 406e8eb3;   % 822: 				sub t4,t4,t1    # t4 = map's current Y + 20 - (top left Y related to matrix + rendering area width)  %
000007ee : 41d888b3;   % 823: 				sub a7,a7,t4    # Reduce width %
000007ef : 00924e83;   % 824: 				lbu t4,9(tp)    # loads map's Y offset  %
000007f0 : 01d02eb3;   % 825: 				slt t4,zero,t4  # 0 < Y offset ? t4 = 1 : t4 = 0 %
000007f1 : 01d888b3;   % 826: 				add a7,a7,t4    # add 1 to width if offset != 0 %
000007f2 : 00088e63;   % 827: 				beqz a7, END_RENDER_ENTITY # if width is 0, end procedure %
000007f3 : ffc10113;   % 832: 			addi sp,sp,-4 %
000007f4 : 00112023;   % 833: 			sw ra,0(sp) %
000007f5 : 00004317;   % 835: 			call SCENE_RENDER	# Calls SCENE_RENDER procedure %
000007f6 : 06c300e7;   % 835:  %
000007f7 : 00012083;   % 837: 			lw ra,0(sp) %
000007f8 : 00410113;   % 838: 			addi sp,sp,4 %
000007f9 : 00008067;   % 842: 	ret %
000007fa : ffc10113;   % 860: 	addi sp,sp,-4 %
000007fb : 00112023;   % 861: 	sw ra,0(sp) %
000007fc : 0fc10297;   % 863: 	la t0, Doors # Loads Doors address %
000007fd : 49c28293;   % 863:  %
000007fe : 0fc10217;   % 864: 	la tp, CURRENT_MAP # Loads CURRENT_MAP address %
000007ff : 10820213;   % 864:  %
00000800 : 0002a503;   % 865: 	lw a0,0(t0)   # Gets current map's doors address %
00000801 : 00054283;   % 866: 	lbu t0,0(a0)  # Loads number of doors in this map %
00000802 : 00150513;   % 867: 	addi a0,a0,1  # Goes to next byte (where doors from current map start) %
00000803 : 00000313;   % 868: 	li t1,0       # Counter for doors %
00000804 : 00054e03;   % 873: 		lbu t3, 0(a0)        # Loads door's X on matrix %
00000805 : 00624583;   % 874: 		lbu a1, 6(tp)        # Loads map's current X on matrix %
00000806 : 40be0eb3;   % 875: 		sub t4,t3,a1         # t4 = Door's X - Map's current X %
00000807 : 01400f13;   % 876: 		li t5,20 # Loads 20 (screen's width related to matrix) %
00000808 : 01eeea63;   % 877: 		bgtu t5,t4,RENDER_DOOR_UPDATE_LOOP_Y_CHECK # If the result is between 0 and 19 (inclusive), continue on loop %
00000809 : 01df1663;   % 879: 			bne t5,t4,GO_TO_NEXT_IN_RENDER_DOOR_UPDATE_LOOP   # If t4 != 20, iterate to next door %
0000080a : 00824e83;   % 880: 				lbu t4, 8(tp)                           # Loads map's X offset %
0000080b : 000e9463;   % 881: 				bnez t4,RENDER_DOOR_UPDATE_LOOP_Y_CHECK # If X offset != 0, continue on this loop %
0000080c : 0b00006f;   % 884: 					j NEXT_IN_RENDER_DOOR_UPDATE_LOOP %
0000080d : 00154383;   % 886: 			lbu t2, 1(a0)    # Loads door's Y on matrix %
0000080e : 00724603;   % 887: 			lbu a2, 7(tp)    # Loads map's current Y on matrix %
0000080f : 40c38eb3;   % 888: 			sub t4,t2,a2     # t4 = Door's top Y - Map's current Y %
00000810 : ffe00f13;   % 889: 			li t5,-2               # Loads -2 (lower threshold) %
00000811 : 01eeafb3;   % 890: 			slt t6,t4,t5           # t6 will be 0 if t4 >= -2 %
00000812 : 00f00f13;   % 891: 			li t5,15  # Loads 15 (screen's height related to matrix) %
00000813 : 01df2f33;   % 892: 			slt t5,t5,t4           # t5 will be 0 if t4 <= 15 %
00000814 : 01ff0f33;   % 893: 			add t5,t5,t6           # t5 = 0 only if -2 <= t4 <= 15  %
00000815 : 000f0463;   % 894: 			beqz t5, RENDER_DOOR_UPDATE_LOOP_Y_CHECK_2 # If -2 <= t4 <= 15, continue loop %
00000816 : 0880006f;   % 896: 				j NEXT_IN_RENDER_DOOR_UPDATE_LOOP %
00000817 : 000ed863;   % 899: 				bge t4,zero,RENDER_DOOR_UPDATE_LOOP_MIDDLE_TOP  # If t4 >= 0, go to RENDER_DOOR_UPDATE_LOOP_MIDDLE_TOP %
00000818 : 00000393;   % 901: 					li t2,0        # starting Y will be set to 0 %
00000819 : 003e8893;   % 902: 					addi a7,t4,3   # and height will be 1 (if t4 = -2) or 2 (if t4 = -1) %
0000081a : 0300006f;   % 903: 					j START_RENDER_DOOR_UPDATE %
0000081b : 00d00f13;   % 907: 					li t5, 13                                  %
0000081c : 01eed663;   % 908: 					bge t4,t5, RENDER_DOOR_UPDATE_LOOP_TOP_1 %
0000081d : 00300893;   % 911: 						li a7, 3    # Height of rendering area will be 3 in order to render it fully %
0000081e : 0200006f;   % 912: 						j START_RENDER_DOOR_UPDATE %
0000081f : 00924703;   % 916: 						lbu a4, 9(tp)   # Loads current Y offset on Map	 %
00000820 : 00f00f13;   % 917: 						li t5,15  # Loads 15 (screen's height related to matrix) %
00000821 : 41df08b3;   % 918: 						sub a7,t5,t4    # a7 = Screen's Height (15) - (Door's Y - Map's current Y)     %
00000822 : 00e02f33;   % 919: 						slt t5,zero,a4  # a4 > 0 ? t5 = 1 : t5 = 0 (only if a4 == 0) %
00000823 : 01e888b3;   % 920: 						add a7,a7,t5    # a7 (height of rendering area) will be increased by 1 if the map's Y offset isn't 0 %
00000824 : 00089463;   % 921: 						bnez a7,START_RENDER_DOOR_UPDATE # If the result isn't equal to 0, continue to rendering this door %
00000825 : 04c0006f;   % 923: 							j NEXT_IN_RENDER_DOOR_UPDATE_LOOP		                         %
00000826 : ff010113;   % 927: 			addi sp,sp,-16 %
00000827 : 00612623;   % 928: 			sw t1,12(sp) %
00000828 : 00512423;   % 929: 			sw t0,8(sp) %
00000829 : 00412223;   % 930: 			sw tp,4(sp) %
0000082a : 00a12023;   % 931: 			sw a0,0(sp) %
0000082b : 00022503;   % 933: 			lw a0,0(tp) %
0000082c : 00824683;   % 936: 			lbu a3, 8(tp)   # Loads current X offset on Map %
0000082d : 00924703;   % 937: 			lbu a4, 9(tp)   # Loads current Y offset on Map	 %
0000082e : 008007b3;   % 938: 			mv a5, s0		# Frame = s0 %
0000082f : 00100813;   % 939: 			li a6, 1        # Width of rendering area will always be 1 %
00000830 : 00000213;   % 943: 			li tp, 0        # Map won't be dislocated		 %
00000831 : 00000317;   % 944: 			call RENDER_MAP %
00000832 : 14c300e7;   % 944:  %
00000833 : 00c12303;   % 946: 			lw t1,12(sp) %
00000834 : 00812283;   % 947: 			lw t0,8(sp) %
00000835 : 00412203;   % 948: 			lw tp,4(sp) %
00000836 : 00012503;   % 949: 			lw a0,0(sp) %
00000837 : 01010113;   % 950: 			addi sp,sp,16 %
00000838 : 00450513;   % 953: 			addi a0,a0,4 # Going to the next door's address                                   %
00000839 : 00130313;   % 954: 			addi t1,t1,1 # Iterating counter by 1                                    %
0000083a : 00535463;   % 955: 			bge t1,t0, END_RENDER_DOOR_UPDATE # If all of the map's doors were checked, end loop                                   %
0000083b : f25ff06f;   % 956: 			j RENDER_DOOR_UPDATE_LOOP # otherwise, go back to the loop's beginning                      %
0000083c : 00012083;   % 960: 			lw ra,0(sp) %
0000083d : 00410113;   % 961: 			addi sp,sp,4 %
0000083e : 00008067;   % 963: 			ret %
0000083f : ffc10113;   % 981: 	addi sp,sp,-4 %
00000840 : 00112023;   % 982: 	sw ra,0(sp) %
00000841 : 0fc10297;   % 984: 	la t0, Frames # Loads Frames address %
00000842 : 3c828293;   % 984:  %
00000843 : 0fc10217;   % 985: 	la tp, CURRENT_MAP # Loads CURRENT_MAP address %
00000844 : ff420213;   % 985:  %
00000845 : 0002a503;   % 986: 	lw a0,0(t0)   # Gets current map's frames address %
00000846 : 00054283;   % 987: 	lbu t0,0(a0)  # Loads number of door frames in this map %
00000847 : 00150513;   % 988: 	addi a0,a0,1  # Goes to next byte (where door frames from current map start) %
00000848 : 00000313;   % 989: 	li t1,0       # Counter for door frames %
00000849 : 00054e03;   % 994: 		lbu t3, 0(a0)        # Loads door frame's X on matrix %
0000084a : 00624583;   % 995: 		lbu a1, 6(tp)        # Loads map's current X on matrix %
0000084b : 40be0eb3;   % 996: 		sub t4,t3,a1         # t4 = Door frame's X - Map's current X %
0000084c : 01400f13;   % 997: 		li t5,20 # Loads 20 (screen's width related to matrix) %
0000084d : 01eeea63;   % 998: 		bgtu t5,t4,RENDER_DOOR_FRAMES_LOOP_Y_CHECK # If the result is between 0 and 19 (inclusive), continue on loop %
0000084e : 01df1663;   % 1000: 			bne t5,t4,GO_TO_NEXT_IN_RENDER_DOOR_FRAMES_LOOP   # If t4 != 20, iterate to next door %
0000084f : 00824e83;   % 1001: 				lbu t4, 8(tp)                           # Loads map's X offset %
00000850 : 000e9463;   % 1002: 				bnez t4,RENDER_DOOR_FRAMES_LOOP_Y_CHECK # If X offset != 0, continue on this loop %
00000851 : 0b00006f;   % 1005: 					j NEXT_IN_RENDER_DOOR_FRAMES_LOOP %
00000852 : 00154383;   % 1007: 			lbu t2, 1(a0)    # Loads door frame's Y on matrix %
00000853 : 00724603;   % 1008: 			lbu a2, 7(tp)    # Loads map's current Y on matrix %
00000854 : 40c38eb3;   % 1009: 			sub t4,t2,a2     # t4 = Door frame's top Y - Map's current Y %
00000855 : ffe00f13;   % 1010: 			li t5,-2               # Loads -2 (lower threshold) %
00000856 : 01eeafb3;   % 1011: 			slt t6,t4,t5           # t6 will be 0 if t4 >= -2 %
00000857 : 00f00f13;   % 1012: 			li t5,15  # Loads 15 (screen's height related to matrix) %
00000858 : 01df2f33;   % 1013: 			slt t5,t5,t4           # t5 will be 0 if t4 <= 15 %
00000859 : 01ff0f33;   % 1014: 			add t5,t5,t6           # t5 = 0 only if -2 <= t4 <= 15  %
0000085a : 000f0463;   % 1015: 			beqz t5, RENDER_DOOR_FRAMES_LOOP_Y_CHECK_2 # If -2 <= t4 <= 15, continue loop %
0000085b : 0880006f;   % 1017: 				j NEXT_IN_RENDER_DOOR_FRAMES_LOOP %
0000085c : 000ed863;   % 1020: 				bge t4,zero,RENDER_DOOR_FRAMES_LOOP_MIDDLE_TOP  # If t4 >= 0, go to RENDER_DOOR_FRAMES_LOOP_MIDDLE_TOP %
0000085d : 00000393;   % 1022: 					li t2,0        # starting Y will be set to 0 %
0000085e : 003e8893;   % 1023: 					addi a7,t4,3   # and height will be 1 (if t4 = -2) or 2 (if t4 = -1) %
0000085f : 0300006f;   % 1024: 					j START_RENDER_DOOR_FRAMES %
00000860 : 00d00f13;   % 1028: 					li t5, 13                                  %
00000861 : 01eed663;   % 1029: 					bge t4,t5, RENDER_DOOR_FRAMES_LOOP_TOP_1 %
00000862 : 00300893;   % 1032: 						li a7, 3    # Height of rendering area will be 3 in order to render it fully %
00000863 : 0200006f;   % 1033: 						j START_RENDER_DOOR_FRAMES %
00000864 : 00924703;   % 1037: 						lbu a4, 9(tp)   # Loads current Y offset on Map	 %
00000865 : 00f00f13;   % 1038: 						li t5,15  # Loads 15 (screen's height related to matrix) %
00000866 : 41df08b3;   % 1039: 						sub a7,t5,t4    # a7 = Screen's Height (15) - (Door frame's Y - Map's current Y)     %
00000867 : 00e02f33;   % 1040: 						slt t5,zero,a4  # a4 > 0 ? t5 = 1 : t5 = 0 (only if a4 == 0) %
00000868 : 01e888b3;   % 1041: 						add a7,a7,t5    # a7 (height of rendering area) will be increased by 1 if the map's Y offset isn't 0 %
00000869 : 00089463;   % 1042: 						bnez a7,START_RENDER_DOOR_FRAMES # If the result isn't equal to 0, continue to rendering this door frame %
0000086a : 04c0006f;   % 1044: 							j NEXT_IN_RENDER_DOOR_FRAMES_LOOP		                         %
0000086b : ff010113;   % 1048: 			addi sp,sp,-16 %
0000086c : 00612623;   % 1049: 			sw t1,12(sp) %
0000086d : 00512423;   % 1050: 			sw t0,8(sp) %
0000086e : 00412223;   % 1051: 			sw tp,4(sp) %
0000086f : 00a12023;   % 1052: 			sw a0,0(sp) %
00000870 : 00022503;   % 1054: 			lw a0,0(tp) %
00000871 : 00824683;   % 1057: 			lbu a3, 8(tp)   # Loads current X offset on Map %
00000872 : 00924703;   % 1058: 			lbu a4, 9(tp)   # Loads current Y offset on Map	 %
00000873 : 008007b3;   % 1059: 			mv a5, s0		# Frame = s0 %
00000874 : 00100813;   % 1060: 			li a6, 1        # Width of rendering area will always be 1 %
00000875 : 00000213;   % 1064: 			li tp, 0        # Map won't be dislocated		 %
00000876 : 00000317;   % 1065: 			call RENDER_MAP %
00000877 : 038300e7;   % 1065:  %
00000878 : 00c12303;   % 1067: 			lw t1,12(sp) %
00000879 : 00812283;   % 1068: 			lw t0,8(sp) %
0000087a : 00412203;   % 1069: 			lw tp,4(sp) %
0000087b : 00012503;   % 1070: 			lw a0,0(sp) %
0000087c : 01010113;   % 1071: 			addi sp,sp,16 %
0000087d : 00650513;   % 1074: 			addi a0,a0,6 # Going to the next door frame's address                                   %
0000087e : 00130313;   % 1075: 			addi t1,t1,1 # Iterating counter by 1                                    %
0000087f : 00535463;   % 1076: 			bge t1,t0, END_RENDER_DOOR_FRAMES # If all of the map's doors were checked, end loop                                   %
00000880 : f25ff06f;   % 1077: 			j RENDER_DOOR_FRAMES_LOOP # otherwise, go back to the loop's beginning                      %
00000881 : 00012083;   % 1081: 			lw ra,0(sp) %
00000882 : 00410113;   % 1082: 			addi sp,sp,4 %
00000883 : 00008067;   % 1084: 			ret %
00000884 : fec10113;   % 1125: 	addi sp,sp,-20 %
00000885 : 00112823;   % 1126: 	sw ra,16(sp) %
00000886 : 01312623;   % 1127: 	sw s3,12(sp) %
00000887 : 01212423;   % 1128: 	sw s2,8(sp) %
00000888 : 00912223;   % 1129: 	sw s1,4(sp) %
00000889 : 00812023;   % 1130: 	sw s0,0(sp) %
0000088a : 00350293;   % 1132: 	addi t0,a0,3 	# skips first 3 bytes of information (goes to the actual matrix) %
0000088b : 00b28433;   % 1133: 	add s0, t0, a1 	# s0 = Matrix Address + Starting X on Matrix %
0000088c : 00154483;   % 1134: 	lbu s1,1(a0)	# s1 = matrix width %
0000088d : 02c482b3;   % 1135: 	mul t0,s1,a2    # t0 = Matrix Width x Starting Y on Matrix %
0000088e : 00540433;   % 1136: 	add s0, s0, t0	# s0 = Address to current X and Y on Matrix %
0000088f : 010e09b3;   % 1139: 	add s3,t3,a6 	# s3 will be compared with t3 (column counter) to go to next line %
00000890 : 000e0a63;   % 1140: 	beqz t3,RENDER_MAP_NoTrailX %
00000891 : 40be0e33;   % 1142: 	sub t3,t3,a1	# t3 now is the column counter related to the screen matrix %
00000892 : 010e09b3;   % 1143: 	add s3,t3,a6 %
00000893 : 01c40433;   % 1144: 	add s0, s0, t3 	# s0 = Matrix Address + Current X on Matrix %
00000894 : 0200006f;   % 1145: 	j RENDER_MAP_GetCurrentY %
00000895 : 00068e63;   % 1148: 	beqz a3, RENDER_MAP_GetCurrentY # If there's no X offset %
00000896 : 01400293;   % 1149: 	li t0, 20 %
00000897 : 00584a63;   % 1150: 	blt a6,t0, RENDER_MAP_GetCurrentY   # If width of rendering area is smaller than the screen's width, ignore %
00000898 : 00404863;   % 1151: 	blt zero,tp, RENDER_MAP_GetCurrentY # If map is dislocated, ignore the next step %
00000899 : 01058333;   % 1152: 	add t1,a1,a6    # t1 = Starting X + Width in tiles %
0000089a : 00930463;   % 1153: 	beq t1,s1, RENDER_MAP_GetCurrentY   # If map is on furthest X to the right, don't increase width %
0000089b : 00128993;   % 1154: 	addi s3,t0,1	# if rendering a full screen (20 wide) with offset, will need to render 21 tiles %
0000089c : 01138933;   % 1157: 	add s2,t2,a7 	# s2 will be compared with t2 (column counter) to go to next line %
0000089d : 00038c63;   % 1158: 	beqz t2,RENDER_MAP_NoTrailY %
0000089e : 40c383b3;   % 1160: 	sub t2,t2,a2	# t2 now is the column counter related to the screen matrix %
0000089f : 01138933;   % 1161: 	add s2,t2,a7 %
000008a0 : 027482b3;   % 1162: 	mul t0,s1,t2    # t0 = Matrix Width x Current Y on Matrix %
000008a1 : 00540433;   % 1163: 	add s0, s0, t0	# s0 = Address to current X and Y on Matrix %
000008a2 : 0140006f;   % 1164: 	j RENDER_MAP_LOOP %
000008a3 : 00070863;   % 1167: 	beqz a4, RENDER_MAP_LOOP # If there's an X offset %
000008a4 : 00f00293;   % 1168: 	li t0, 15 %
000008a5 : 0058c463;   % 1169: 	blt a7,t0 RENDER_MAP_LOOP # If height of rendering area is smaller than the screen's height, ignore %
000008a6 : 00128913;   % 1170: 	addi s2,t0,1	# if rendering a full screen (15 wide) with offset, will need to render 16 tiles %
000008a7 : 00044303;   % 1173: 	lbu t1,0(s0)	# loads byte stored on matrix for checking what is the tile %
000008a8 : 00031463;   % 1174: 	bnez t1,NotBackground %
000008a9 : 1980006f;   % 1175: 	j CONTINUE_RENDER_MAP %
000008aa : 02800293;   % 1178: 		li t0, 40      # Value where doors start %
000008ab : 0e535263;   % 1179: 		bge t1, t0, RENDER_DOOR # If it's a door %
000008ac : 00100293;   % 1180: 		li t0,1 %
000008ad : 02628063;   % 1181: 		beq t0,t1, RENDER_BREAK_BLOCK %
000008ae : 0fc10297;   % 1182: 		la t0, Tileset # Loads Tileset address to t0 %
000008af : 56c28293;   % 1182:  %
000008b0 : fff30313;   % 1183: 		addi t1,t1,-1  # t1 = Tile Number - 1 (so that if t1 = 1, 0 tiles will be skipped) %
000008b1 : 00831313;   % 1184: 		slli t1,t1,8   # t1 = (Tile Number - 1) x 256 %
000008b2 : 006282b3;   % 1185: 		add t0,t0,t1   # t0 will skip (Tile Number - 1) x 256 bytes (Tile Number - 1 tiles) %
000008b3 : 00000eb3;   % 1186: 		mv t4,zero     # t4 will hold the tile's sprite status (which will be zero) %
000008b4 : 16c0006f;   % 1187: 		j CONTINUE_RENDER_MAP %
000008b5 : 0fc10e97;   % 1190: 		la t4,NEXT_MAP # Loads NEXT_MAP address %
000008b6 : e38e8e93;   % 1190:  %
000008b7 : 00aecf03;   % 1191: 		lbu t5,10(t4)  # Gets the Render Next Map byte	 %
000008b8 : 000f0a63;   % 1192: 		beqz t5, RENDER_BREAK_BLOCK_CURRENT   # If Render Next Map Door == 0, render current map's door %
000008b9 : 0fc10297;   % 1194: 			la t0,Blocks_Next  # Loads blocks address %
000008ba : f2828293;   % 1194:  %
000008bb : 0002a283;   % 1195: 			lw t0,0(t0)        # and loads the breakable block address %
000008bc : 0100006f;   % 1196: 			j CONTINUE_RENDER_BREAK_BLOCK %
000008bd : 0fc10297;   % 1199: 			la t0,Blocks  # Loads blocks address %
000008be : f1428293;   % 1199:  %
000008bf : 0002a283;   % 1200: 			lw t0,0(t0)   # and loads the breakable block address %
000008c0 : 08028463;   % 1204: 			beqz t0,RENDER_BREAK_BLOCK_BACKGROUND %
000008c1 : 0012cf03;   % 1207: 			lbu t5,1(t0)  # Gets Y where blocks start %
000008c2 : 41e38f33;   % 1208: 			sub t5,t2,t5  # Sets current Y to be related to Y where blocks start %
000008c3 : 00cf0f33;   % 1209: 			add t5,t5,a2  # Corrects Y adding starting Y %
000008c4 : 0022ce83;   % 1211: 			lbu t4,2(t0)  # Loads width %
000008c5 : 03ee8eb3;   % 1212: 			mul t4,t4,t5  # and multiplies it by current Y	 %
000008c6 : 0002cf03;   % 1214: 			lbu t5,0(t0)  # Gets X where blocks start %
000008c7 : 41ee0f33;   % 1215: 			sub t5,t3,t5  # Sets current X to be related to X where blocks start %
000008c8 : 00bf0f33;   % 1216: 			add t5,t5,a1  # Corrects X adding starting X %
000008c9 : 01df0eb3;   % 1218: 			add t4,t5,t4  # adds X to it %
000008ca : 00428293;   % 1220: 			addi t0,t0,4  # Skip first 4 information bytes %
000008cb : 005e82b3;   % 1221: 			add t0,t4,t0  # and adds t4 to it %
000008cc : 0002ce83;   % 1223: 			lbu t4,0(t0)  # Loads t0  %
000008cd : 000e9a63;   % 1224: 			bnez t4, RENDER_BREAK_BLOCK_CHECK_EXPLOSION # If block isn't full, see if it's exploding %
000008ce : 0fc10297;   % 1225: 				la t0, Tileset # Loads Tileset address to t0 %
000008cf : 4ec28293;   % 1225:  %
000008d0 : 00000eb3;   % 1226: 				mv t4,zero     # t4 will hold the tile's sprite status (which will be zero) %
000008d1 : 0f80006f;   % 1227: 				j CONTINUE_RENDER_MAP  # Otherwise, render it %
000008d2 : 00100f13;   % 1229: 			RENDER_BREAK_BLOCK_CHECK_EXPLOSION: li t5,1 %
000008d3 : 01ee9e63;   % 1230: 			bne t4, t5, RENDER_BREAK_BLOCK_CHECK_EXPLOSION_2 # If block isn't in the first phase of breaking, see if it's in the second phase %
000008d4 : 001e8e93;   % 1231: 				addi t4,t4,1 # Sets block up for next phase %
000008d5 : 01d28023;   % 1232: 				sb t4,0(t0)  # and stores it %
000008d6 : 0fc10297;   % 1233: 				la t0, BreakBlock_Break1 # Loads BreakBlock_Break1 address to t0 %
000008d7 : 2cc28293;   % 1233:  %
000008d8 : 00000eb3;   % 1234: 				mv t4,zero               # t4 will hold the tile's sprite status (which will be zero) %
000008d9 : 0d80006f;   % 1235: 				j CONTINUE_RENDER_MAP    # Otherwise, render it %
000008da : 00100f13;   % 1237: 			RENDER_BREAK_BLOCK_CHECK_EXPLOSION_2: li t5,1 %
000008db : 01ee9e63;   % 1238: 			bne t4, t5, RENDER_BREAK_BLOCK_BACKGROUND # If block is destroyed, don't render it %
000008dc : 001e8e93;   % 1239: 				addi t4,t4,1 # Sets block up for next phase %
000008dd : 01d28023;   % 1240: 				sb t4,0(t0)  # and stores it %
000008de : 0fc10297;   % 1241: 				la t0, BreakBlock_Break2 # Loads BreakBlock_Break2 address to t0 %
000008df : 3ac28293;   % 1241:  %
000008e0 : 00000eb3;   % 1242: 				mv t4,zero               # t4 will hold the tile's sprite status (which will be zero) %
000008e1 : 0b80006f;   % 1243: 				j CONTINUE_RENDER_MAP    # Otherwise, render it %
000008e2 : 00000313;   % 1246: 				li t1,0   # Won't render %
000008e3 : 0b00006f;   % 1247: 				j CONTINUE_RENDER_MAP %
000008e4 : ffc10113;   % 1251: 		addi sp,sp,-4 %
000008e5 : 00412023;   % 1252: 		sw tp,0(sp) %
000008e6 : 00000fb3;   % 1255: 		mv t6,zero     # Resets counter %
000008e7 : 0fc10e97;   % 1256: 		la t4,NEXT_MAP # Loads NEXT_MAP address %
000008e8 : d70e8e93;   % 1256:  %
000008e9 : 00aecf03;   % 1257: 		lbu t5,10(t4)  # Gets the Render Next Map Door byte	 %
000008ea : 000f0e63;   % 1258: 		beqz t5, RENDER_DOOR_CURRENT   # If Render Next Map Door == 0, render current map's door %
000008eb : 0fc10e97;   % 1260: 			la t4, Doors_Next # Loads Doors_Next address %
000008ec : 0e4e8e93;   % 1260:  %
000008ed : 000eae83;   % 1261: 			lw t4,0(t4)	      # Gets the next map's door address %
000008ee : 000ecf03;   % 1262: 			lbu t5,0(t4)      # Gets the number of doors in this map %
000008ef : 001e8e93;   % 1263: 			addi t4,t4,1      # Starting address of the map's first door %
000008f0 : 0180006f;   % 1264: 			j RENDER_DOOR_LOOP %
000008f1 : 0fc10e97;   % 1267: 			la t4, Doors # Loads Doors address %
000008f2 : 0c8e8e93;   % 1267:  %
000008f3 : 000eae83;   % 1268: 			lw t4,0(t4)	 # Gets the current map's door address %
000008f4 : 000ecf03;   % 1269: 			lbu t5,0(t4) # Gets the number of doors in this map %
000008f5 : 001e8e93;   % 1270: 			addi t4,t4,1 # Starting address of the map's first door %
000008f6 : 000ec203;   % 1274: 			lbu tp, 0(t4) # Loads door's X on matrix %
000008f7 : 01c582b3;   % 1275: 			add t0,a1,t3  # Gets current X on map matrix %
000008f8 : 02521e63;   % 1276: 			bne tp, t0, NEXT_IN_DOOR_LOOP # If door's X isn't the same as current X, skip this door %
000008f9 : 001ec203;   % 1277: 			lbu tp, 1(t4) # Loads door's Y on matrix %
000008fa : 007602b3;   % 1278: 			add t0,a2,t2  # Gets current Y on map matrix %
000008fb : 40428233;   % 1279: 			sub tp,t0,tp  # tp needs to be equal to 0, 1 or 2 in order to be a tile from this door %
000008fc : 00200293;   % 1280: 			li t0,2 # 2 is the threshold to be compared with tp %
000008fd : 0242e463;   % 1281: 			bgtu tp,t0, NEXT_IN_DOOR_LOOP # If current Y is above the door's uppermost Y or bellow it's downmost Y, skip this door %
000008fe : 002ec203;   % 1283: 			lbu tp, 2(t4) # Loads door's state %
000008ff : 02525863;   % 1284: 			bge tp,t0, END_RENDER_DOOR_LOOP # If door is open (state = 2 -- >= 2 for containing errors) %
00000900 : 0fc10297;   % 1286: 				la t0, Tileset # Loads Tileset address to t0 %
00000901 : 42428293;   % 1286:  %
00000902 : fff30313;   % 1287: 				addi t1,t1,-1  # t1 = Tile Number - 1 (so that if t1 = 1, 0 tiles will be skipped) %
00000903 : 00430333;   % 1288: 				add t1,t1,tp   # t1 will change if door is opening (tp = 1) %
00000904 : 00831313;   % 1289: 				slli t1,t1,8   # t1 = (Tile Number - 1) x 256 %
00000905 : 006282b3;   % 1290: 				add t0,t0,t1   # t0 will skip (Tile Number - 1) x 256 bytes (Tile Number - 1 tiles)  %
00000906 : 0180006f;   % 1291: 				j END_RENDER_DOOR_LOOP_GLOBAL %
00000907 : 004e8e93;   % 1293: 				addi t4,t4,4 # Going to the next door's address %
00000908 : 001f8f93;   % 1294: 				addi t6,t6,1 # Iterating counter by 1 %
00000909 : 01efd463;   % 1295: 				bge t6,t5, END_RENDER_DOOR_LOOP # If all of the map's doors were checked, end loop %
0000090a : fb1ff06f;   % 1296: 				j RENDER_DOOR_LOOP # otherwise, go back to the loop's beginning %
0000090b : 00000333;   % 1299: 		mv t1,zero %
0000090c : 00000eb3;   % 1302: 		mv t4,zero    # t4 will hold the tile's sprite status (which will be zero) %
0000090d : 00012203;   % 1303: 		lw tp,0(sp) %
0000090e : 00410113;   % 1304: 		addi sp,sp,4 %
0000090f : fc810113;   % 1309: 	addi sp,sp,-56 %
00000910 : 03412a23;   % 1310: 	sw s4,52(sp) %
00000911 : 03312823;   % 1311: 	sw s3,48(sp) %
00000912 : 03212623;   % 1312: 	sw s2,44(sp) %
00000913 : 02912423;   % 1313: 	sw s1,40(sp) %
00000914 : 03112223;   % 1314: 	sw a7,36(sp) %
00000915 : 03012023;   % 1315: 	sw a6,32(sp) %
00000916 : 00e12e23;   % 1316: 	sw a4,28(sp) %
00000917 : 00d12c23;   % 1317: 	sw a3,24(sp) %
00000918 : 00c12a23;   % 1318: 	sw a2,20(sp) %
00000919 : 00b12823;   % 1319: 	sw a1,16(sp) %
0000091a : 00a12623;   % 1320: 	sw a0,12(sp) %
0000091b : 00712423;   % 1321: 	sw t2,8(sp) %
0000091c : 01c12223;   % 1322: 	sw t3,4(sp) %
0000091d : 00412023;   % 1323: 	sw tp,0(sp) %
0000091e : 00500533;   % 1326: 	mv a0, t0 # Moves t0 (storing tile address) to a0 %
0000091f : 01d00833;   % 1327: 	mv a6,t4  # Moves tmv t4 (tile's sprite status) to a6 %
00000920 : 01000293;   % 1330: 	li t0, 16 	# Tile size = 16 %
00000921 : 01c20fb3;   % 1331: 	add t6,tp,t3        # t6 gets t3 (current X) + tp (X dislocation) %
00000922 : 025f8eb3;   % 1332: 	mul t4,t6,t0		# t4 gets the X value relative to the screen ((t3 + tp) * tile size) %
00000923 : 02538f33;   % 1333: 	mul t5,t2,t0		# t5 gets the Y value relative to the screen (t2 (current Y) * tile size) %
00000924 : 00000f93;   % 1335: 	li t6,0 %
00000925 : 00069463;   % 1336: 	bnez a3, X_Offset 	# If there's a X offset %
00000926 : 02c0006f;   % 1337: 	j Check_Y_Offset %
00000927 : 004e02b3;   % 1339: 		add t0,t3,tp %
00000928 : 00029663;   % 1340: 		bnez t0, TryRightOffset  # If t3 (current colum, i.e., current X) = 0, it's on the left border %
00000929 : 00100f93;   % 1341: 		li t6,1			         # t6 = 1: Cropping leftmost tile %
0000092a : 0400006f;   % 1342: 		j START_RENDER_MAP  	 # start rendering process %
0000092b : 01400293;   % 1344: 		li t0, 20    # screen width related to matrix = 20 %
0000092c : 41c282b3;   % 1345: 		sub t0,t0,t3             # t0 = screen width - t3 (current X)  %
0000092d : 404282b3;   % 1346: 		sub t0,t0,tp             # t0 = screen width - t3 (current X) - tp (X dislocation)  %
0000092e : 00501463;   % 1347: 		bne zero, t0, NoX_Offset # If t0 <= 0 (t3 + tp >= 20), it's on the right border %
0000092f : 00200f93;   % 1348: 		li t6,2			 # t6 = 2: Cropping rightmost tile %
00000930 : 0280006f;   % 1350: 		j START_RENDER_MAP	 # start rendering process %
00000931 : 00071463;   % 1353: 	bnez a4, Y_Offset		 # Or a Y offset, go to offset operations %
00000932 : 0200006f;   % 1354: 	j START_RENDER_MAP %
00000933 : 00039663;   % 1357: 		bnez t2, TryBottomOffset # If t3 (current colum, i.e., current X) = 0, it's on the top border %
00000934 : 00100f93;   % 1358: 		li t6,1			 # t6 = 1: Cropping uppermost tile %
00000935 : 0140006f;   % 1359: 		j START_RENDER_MAP	 # start rendering process %
00000936 : 00f00293;   % 1361: 		li t0, 15   # screen height related to matrix = 15 %
00000937 : 00539463;   % 1362: 		bne t2, t0, NoY_Offset   # If t2 = 15, it's on the lower border %
00000938 : 00200f93;   % 1363: 		li t6,2			 # t6 = 2: Cropping lowermost tile %
00000939 : 0040006f;   % 1365: 		j START_RENDER_MAP	 # start rendering process %
0000093a : 06031863;   % 1368: 	bnez t1,NormalRender %
0000093b : 00000513;   % 1370: 		li a0, 0x00 		# Black %
0000093c : 01d005b3;   % 1371: 		mv a1, t4		# Top Left X %
0000093d : 01e00633;   % 1372: 		mv a2, t5		# Top Left Y	 %
0000093e : 00000833;   % 1373: 		mv a6, zero %
0000093f : 000f9463;   % 1375: 		bnez t6, CropColor  %
00000940 : 03c0006f;   % 1376: 		j NoCropColor %
00000941 : 00100813;   % 1378: 		li a6, 1 %
00000942 : ffff8f93;   % 1379: 		addi t6,t6,-1 %
00000943 : 000f9a63;   % 1380: 		bnez t6, RightBottomColorCrop %
00000944 : 01000293;   % 1382: 				li t0, 16	 %
00000945 : 40d286b3;   % 1383: 				sub a3,t0, a3		# a3 will hold rendering widht that is equal to the tile size (16) - X offset %
00000946 : 40e28733;   % 1384: 				sub a4,t0, a4		# a4 will hold rendering height that is equal to the tile size (16) - Y offset %
00000947 : 0300006f;   % 1385: 				j StartColorRender %
00000948 : 40d585b3;   % 1387: 				sub a1,a1,a3		# a1 will shift left the ammount of a3 (currently X offset)  %
00000949 : 40e60633;   % 1388: 				sub a2,a2,a4		# a2 will shift up the ammount of a4 (currently Y offset) %
0000094a : 00069463;   % 1390: 				bnez a3, CheckYColor # If X offset (a3) isn't zero, the widht for rendering the cropped tile will be the X offset %
0000094b : 01000693;   % 1391: 				li a3, 16	    # otherwise, it'll be the tile size %
0000094c : 00071463;   % 1393: 				bnez a4, EndRightBottomCropColor # If Y offset (a4) isn't zero, the widht for rendering the cropped tile will be the Y offset %
0000094d : 01000713;   % 1394: 				li a4, 16	    # otherwise, it'll be the tile size %
0000094e : 0140006f;   % 1396: 				j StartColorRender %
0000094f : 40d585b3;   % 1398: 			sub a1,a1,a3		# a1 will shift left the ammount of a3 (currently X offset)  %
00000950 : 40e60633;   % 1399: 			sub a2,a2,a4		# a2 will shift up the ammount of a4 (currently Y offset)	 %
00000951 : 01000693;   % 1400: 			li a3, 16	# Tile Width (Screen) %
00000952 : 01000713;   % 1401: 			li a4, 16	# Tile Height (Screen)	 %
00000953 : fffff317;   % 1404: 		call RENDER_COLOR %
00000954 : 47c300e7;   % 1404:  %
00000955 : 0840006f;   % 1405: 		j EndRender %
00000956 : 01d005b3;   % 1409: 		mv a1, t4		# Top Left X where tile will start rendering %
00000957 : 01e00633;   % 1410: 		mv a2, t5		# Top Left Y where tile will start rendering			 %
00000958 : 000f9463;   % 1413: 		bnez t6, Continue_Crop  %
00000959 : 0580006f;   % 1414: 		j Skip_Offset %
0000095a : 00100893;   % 1416: 		li a7,1			# Cropped Render operations %
0000095b : ffff8f93;   % 1417: 		addi t6,t6,-1		# After this, t6 = 0 or t6 = 1 %
0000095c : 020f9063;   % 1418: 		bnez t6, RightBottomCrop %
0000095d : 00d004b3;   % 1420: 			mv s1, a3		# s1 will store the X offset (where rendering will start from) %
0000095e : 00e00933;   % 1421: 			mv s2, a4		# s2 will store the Y offset (where rendering will start from) %
0000095f : 01000993;   % 1422: 			li s3, 16	# s3 = 16 %
00000960 : 01000a13;   % 1423: 			li s4, 16	# s4 = 16 %
00000961 : 409986b3;   % 1424: 			sub a3,s3, s1		# a3 will hold rendering widht that is equal to the tile size (16) - X offset %
00000962 : 41298733;   % 1425: 			sub a4,s3, s2		# a4 will hold rendering height that is equal to the tile size (16) - Y offset %
00000963 : 0440006f;   % 1426: 			j Start_NormalRender %
00000964 : 000004b3;   % 1428: 			mv s1,zero		# s1 = 0 (rendering will start from the left) %
00000965 : 00000933;   % 1429: 			mv s2,zero		# s2 = 0 (rendering will start from the top) %
00000966 : 01000993;   % 1430: 			li s3, 16	# s3 = 16 %
00000967 : 01000a13;   % 1431: 			li s4, 16	# s4 = 16 %
00000968 : 40d585b3;   % 1432: 			sub a1,a1,a3		# a1 will shift left the ammount of a3 (currently X offset)  %
00000969 : 40e60633;   % 1433: 			sub a2,a2,a4		# a2 will shift up the ammount of a4 (currently Y offset) %
0000096a : 00069463;   % 1435: 			bnez a3, CheckY # If X offset (a3) isn't zero, the widht for rendering the cropped tile will be the X offset %
0000096b : 01000693;   % 1436: 			li a3, 16	    # otherwise, it'll be the tile size %
0000096c : 00071463;   % 1438: 			bnez a4, EndRightBottomCrop # If Y offset (a4) isn't zero, the widht for rendering the cropped tile will be the Y offset %
0000096d : 01000713;   % 1439: 			li a4, 16	    # otherwise, it'll be the tile size %
0000096e : 0180006f;   % 1441: 			j Start_NormalRender %
0000096f : 40d585b3;   % 1444: 		sub a1,a1,a3		# a1 will shift left the ammount of a3 (currently X offset)  %
00000970 : 40e60633;   % 1445: 		sub a2,a2,a4		# a2 will shift up the ammount of a4 (currently Y offset)  %
00000971 : 01000693;   % 1446: 		li a3, 16	# Tile Width (Relative to Screen) %
00000972 : 01000713;   % 1447: 		li a4, 16	# Tile Height (Relative to Screen) %
00000973 : 000008b3;   % 1448: 		mv a7,zero		# Normal Render operations %
00000974 : fffff317;   % 1450: 		call RENDER_WORD %
00000975 : 36c300e7;   % 1450:  %
00000976 : 03412a03;   % 1454: 	lw s4,52(sp) %
00000977 : 03012983;   % 1455: 	lw s3,48(sp) %
00000978 : 02c12903;   % 1456: 	lw s2,44(sp) %
00000979 : 02812483;   % 1457: 	lw s1,40(sp) %
0000097a : 02412883;   % 1458: 	lw a7,36(sp) %
0000097b : 02012803;   % 1459: 	lw a6,32(sp) %
0000097c : 01c12703;   % 1460: 	lw a4,28(sp) %
0000097d : 01812683;   % 1461: 	lw a3,24(sp) %
0000097e : 01412603;   % 1462: 	lw a2,20(sp) %
0000097f : 01012583;   % 1463: 	lw a1,16(sp) %
00000980 : 00c12503;   % 1464: 	lw a0,12(sp) %
00000981 : 00812383;   % 1465: 	lw t2,8(sp) %
00000982 : 00412e03;   % 1466: 	lw t3,4(sp) %
00000983 : 00012203;   % 1467: 	lw tp,0(sp) %
00000984 : 03810113;   % 1468: 	addi sp,sp,56 %
00000985 : 001e0e13;   % 1471: 	addi t3,t3,1	# Increments column counter (current X on Matrix) %
00000986 : 00140413;   % 1472: 	addi s0,s0,1	# Goes to next byte %
00000987 : 013e5463;   % 1473: 	bge t3,s3,CONTINUE_LINE	# if column counter >= width, repeat %
00000988 : c7dff06f;   % 1474: 	j RENDER_MAP_LOOP	# if column counter < width, repeat %
00000989 : 00940433;   % 1477: 		add s0,s0,s1	# s0 = Current Address on Matrix + Matrix Width %
0000098a : 01400293;   % 1478: 		li t0, 20 %
0000098b : 00585863;   % 1479: 		bge a6,t0, MINUS_WIDTH # If width = 20, probably not on remove trail mode %
0000098c : 41040433;   % 1480: 		sub s0,s0,a6	# s0 = New Current Address on Matrix  %
0000098d : 410e0e33;   % 1481: 		sub t3,t3,a6	# t3 = 0 (resets column counter) %
0000098e : 00c0006f;   % 1482: 		j CONTINUE_LINE2 %
0000098f : 41340433;   % 1484: 		sub s0,s0,s3 %
00000990 : 00000e33;   % 1485: 		mv t3,zero	# t3 = 0 (resets column counter) %
00000991 : 00138393;   % 1488: 		addi t2,t2,1	# Increments line counter (current Y on Matrix) %
00000992 : 0123d463;   % 1489: 		bge t2,s2,CONTINUE_COLUMN # If height > line counter, repeat %
00000993 : c51ff06f;   % 1490: 		j RENDER_MAP_LOOP	  # Return to beggining of loop %
00000994 : 01012083;   % 1493: 		lw ra,16(sp)	 %
00000995 : 00c12983;   % 1494: 		lw s3,12(sp) %
00000996 : 00812903;   % 1495: 		lw s2,8(sp) %
00000997 : 00412483;   % 1496: 		lw s1,4(sp) %
00000998 : 00012403;   % 1497: 		lw s0,0(sp) %
00000999 : 01410113;   % 1498: 		addi sp,sp,20 %
0000099a : 00008067;   % 1500: 		ret %
0000099b : 0fc10517;   % 29:     la a0, BEAMS_ARRAY      # Loads BEAMS array %
0000099c : af250513;   % 29:  %
0000099d : 00054283;   % 30:     lbu t0,0(a0)            # Loads cooldown byte %
0000099e : 00028463;   % 31:     beqz t0,CONTINUE_BEAM_SPAWN # If on zero, spawn %
0000099f : 0e40006f;   % 32:         j END_BEAM_SPAWN_LOOP %
000009a0 : 0fc10597;   % 34:     la a1, PLYR_POS         # Loads Player Pos address %
000009a1 : a9a58593;   % 34:  %
000009a2 : 00300613;   % 35:     li a2, 3     # Loads total number of beams %
000009a3 : 00000693;   % 36:     li a3,0                 # Resets counter %
000009a4 : 00150513;   % 38:     addi a0,a0,1            # Skips cooldown byte %
000009a5 : 00054283;   % 40:         lbu t0, 0(a0)       # Loads enable byte %
000009a6 : 00028463;   % 41:         beqz t0, BEAM_SPAWN_LOOP_ACTIVATE # If current beam is disabled, activate it %
000009a7 : 0b40006f;   % 42:             j NEXT_IN_BEAM_SPAWN_LOOP     # Otherwise, go to next one in loop %
000009a8 : 0fc10297;   % 46:             la t0, BEAMS_ARRAY            # Loads BEAMS array %
000009a9 : abe28293;   % 46:  %
000009aa : 00200313;   % 47:             li t1, 2  # gets cooldown value %
000009ab : 00628023;   % 48:             sb t1,0(t0)                   # stores it %
000009ac : 0065c283;   % 51:             lbu t0, 6(a1)    # Loads player's X offset %
000009ad : 005501a3;   % 52:             sb t0, 3(a0)     # and stores it on beam's X offset %
000009ae : 0075c283;   % 54:             lbu t0, 7(a1)    # Loads player's Y offset %
000009af : 00550223;   % 55:             sb t0, 4(a0)     # and stores it on beam's Y offset %
000009b0 : 00100293;   % 57:             li t0,1          # Loads 1 (Enabled)  %
000009b1 : 00550023;   % 58:             sb t0,0(a0)      # stores in beam's enable byte %
000009b2 : 00e5c283;   % 61:             lbu t0, 14(a1)   # Loads vertical direction %
000009b3 : 02028663;   % 62:             beqz t0, BEAM_SPAWN_LOOP_ACTIVATE_CHECK_X_AXIS # If looking foward %
000009b4 : 0085c283;   % 65:                 lbu t0, 8(a1)    # Loads player's X %
000009b5 : 005502a3;   % 66:                 sb t0, 5(a0)     # and stores it on beam's X %
000009b6 : 00550323;   % 67:                 sb t0, 6(a0)     # and on beam's old X %
000009b7 : 00a5c283;   % 70:                 lbu t0, 10(a1)   # Loads player's Y %
000009b8 : fff28293;   % 71:                 addi t0,t0,-1    # goes up 1 tile %
000009b9 : 005503a3;   % 72:                 sb t0, 7(a0)     # and stores it on beam's Y %
000009ba : 00550423;   % 73:                 sb t0, 8(a0)     # and on beam's old Y %
000009bb : 00000293;   % 76:                 li t0,0          # Loads 0 (Up) %
000009bc : 005500a3;   % 77:                 sb t0,1(a0)      # and stores it on the direction byte %
000009bd : 06c0006f;   % 78:                 j END_BEAM_SPAWN_LOOP # break loop %
000009be : 00d5c283;   % 82:             lbu t0, 13(a1)   # Loads horizontal direction %
000009bf : 02029663;   % 83:             bnez t0,BEAM_SPAWN_LOOP_ACTIVATE_LEFT_AXIS   # If player is looking left %
000009c0 : 0085c283;   % 86:                 lbu t0, 8(a1)    # Loads player's X %
000009c1 : 00128293;   % 87:                 addi t0,t0,1     # goes 1 tile to the right %
000009c2 : 005502a3;   % 88:                 sb t0, 5(a0)     # and stores it on beam's X %
000009c3 : 00550323;   % 89:                 sb t0, 6(a0)     # and on beam's old X %
000009c4 : 00a5c283;   % 92:                 lbu t0, 10(a1)   # Loads player's Y %
000009c5 : 005503a3;   % 93:                 sb t0, 7(a0)     # and stores it on beam's Y %
000009c6 : 00550423;   % 94:                 sb t0, 8(a0)     # and on beam's old Y %
000009c7 : 00100293;   % 97:                 li t0,1          # Loads 1 (Right) %
000009c8 : 005500a3;   % 98:                 sb t0,1(a0)      # and stores it on the direction byte %
000009c9 : 03c0006f;   % 99:                 j END_BEAM_SPAWN_LOOP # break loop %
000009ca : 0085c283;   % 104:                 lbu t0, 8(a1)    # Loads player's X %
000009cb : fff28293;   % 105:                 addi t0,t0,-1    # goes 1 tile to the left %
000009cc : 005502a3;   % 106:                 sb t0, 5(a0)     # and stores it on beam's X %
000009cd : 00550323;   % 107:                 sb t0, 6(a0)     # and on beam's old X %
000009ce : 00a5c283;   % 110:                 lbu t0, 10(a1)   # Loads player's Y %
000009cf : 005503a3;   % 111:                 sb t0, 7(a0)     # and stores it on beam's Y %
000009d0 : 00550423;   % 112:                 sb t0, 8(a0)     # and on beam's old Y %
000009d1 : fff00293;   % 115:                 li t0,-1         # Loads -1 (Left) %
000009d2 : 005500a3;   % 116:                 sb t0,1(a0)      # and stores it on the direction byte %
000009d3 : 0140006f;   % 117:                 j END_BEAM_SPAWN_LOOP # break loop %
000009d4 : 00950513;   % 120:             addi a0,a0,9          # Going to the next beams address                                   %
000009d5 : 00168693;   % 121:             addi a3,a3,1                   # Iterating counter by 1                                    %
000009d6 : 00c6d463;   % 122:             bge a3,a2, END_BEAM_SPAWN_LOOP # If all of the beams were checked, end loop (don't attack)                                 %
000009d7 : f39ff06f;   % 123:             j BEAM_SPAWN_LOOP # otherwise, go back to the loop's beginning  %
000009d8 : 00008067;   % 127:         ret %
000009d9 : 0fc10517;   % 145:     la a0, BOMBS_ARRAY      # Loads BOMBS array %
000009da : a1650513;   % 145:  %
000009db : 00054283;   % 146:     lbu t0,0(a0)            # Loads cooldown byte %
000009dc : 00028463;   % 147:     beqz t0,CONTINUE_BOMB_SPAWN # If on zero, spawn %
000009dd : 0980006f;   % 148:         j END_BOMB_SPAWN_LOOP %
000009de : 0fc10597;   % 150:     la a1, PLYR_POS         # Loads Player Pos address %
000009df : 9a258593;   % 150:  %
000009e0 : 00300613;   % 151:     li a2, 3     # Loads total number of bombs %
000009e1 : 00000693;   % 152:     li a3,0                 # Resets counter %
000009e2 : 00150513;   % 154:     addi a0,a0,1            # Skips cooldown byte %
000009e3 : 00054283;   % 156:         lbu t0, 0(a0)       # Loads enable byte %
000009e4 : 00028463;   % 157:         beqz t0, BOMB_SPAWN_LOOP_ACTIVATE # If current bomb is disabled, activate it %
000009e5 : 0680006f;   % 158:             j NEXT_IN_BOMB_SPAWN_LOOP     # Otherwise, go to next one in loop %
000009e6 : 0fc10297;   % 162:             la t0, BOMBS_ARRAY            # Loads BOMBS array %
000009e7 : 9e228293;   % 162:  %
000009e8 : 00800313;   % 163:             li t1, 8  # gets cooldown value %
000009e9 : 00628023;   % 164:             sb t1,0(t0)                   # stores it %
000009ea : 00100293;   % 166:             li t0,1          # Loads 1 (Enabled)  %
000009eb : 00550023;   % 167:             sb t0,0(a0)      # stores in beam's enable byte %
000009ec : 0065c283;   % 170:             lbu t0, 6(a1)    # Loads player's X offset %
000009ed : 005501a3;   % 171:             sb t0, 3(a0)     # and stores it on bomb's X offset %
000009ee : 0075c283;   % 173:             lbu t0, 7(a1)    # Loads player's Y offset %
000009ef : 00550223;   % 174:             sb t0, 4(a0)     # and stores it on bomb's Y offset %
000009f0 : 0085c283;   % 177:             lbu t0, 8(a1)    # Loads player's X %
000009f1 : 005502a3;   % 178:             sb t0, 5(a0)     # and stores it on bomb's X %
000009f2 : 00550323;   % 179:             sb t0, 6(a0)     # and on bomb's old X %
000009f3 : 00a5c283;   % 182:             lbu t0, 10(a1)   # Loads player's Y %
000009f4 : 00128293;   % 183:             addi t0,t0,1     # goes down 1 tile %
000009f5 : 005503a3;   % 184:             sb t0, 7(a0)     # and stores it on bomb's Y %
000009f6 : 00550423;   % 185:             sb t0, 8(a0)     # and on bomb's old Y %
000009f7 : 00069663;   % 188:             bnez a3,BOMB_SPAWN_LOOP_NOT_BOMB_0 %
000009f8 : d0007d53;   % 190:                 fcvt.s.w fs10,zero # Resets Bomb's jump speed %
000009f9 : 0280006f;   % 191:                 j END_BOMB_SPAWN_LOOP # break loop    %
000009fa : 00100293;   % 193:             BOMB_SPAWN_LOOP_NOT_BOMB_0: li t0,1 %
000009fb : 00569663;   % 194:             bne a3,t0,BOMB_SPAWN_LOOP_NOT_BOMB_1 %
000009fc : d0007dd3;   % 196:                 fcvt.s.w fs11,zero # Resets Bomb's jump speed %
000009fd : 0180006f;   % 197:                 j END_BOMB_SPAWN_LOOP # break loop    %
000009fe : d00078d3;   % 201:                 fcvt.s.w fa7,zero # Resets Bomb's jump speed %
000009ff : 00950513;   % 205:             addi a0,a0,9          # Going to the next bombs address                                   %
00000a00 : 00168693;   % 206:             addi a3,a3,1                   # Iterating counter by 1                                    %
00000a01 : 00c6d463;   % 207:             bge a3,a2, END_BOMB_SPAWN_LOOP # If all of the bombs were checked, end loop (don't attack)                                 %
00000a02 : f85ff06f;   % 208:             j BOMB_SPAWN_LOOP # otherwise, go back to the loop's beginning  %
00000a03 : 00008067;   % 212:         ret %
00000a04 : ffc10113;   % 230:     addi sp,sp,-4 %
00000a05 : 00112023;   % 231:     sw ra,0(sp) %
00000a06 : 0fc10217;   % 233:     la tp, CURRENT_MAP  # Loads CURRENT_MAP address %
00000a07 : 8e820213;   % 233:  %
00000a08 : 0fc10517;   % 235:     la a0,BEAMS_ARRAY   # Loads Beams array %
00000a09 : 93e50513;   % 235:  %
00000a0a : 00150513;   % 236:     addi a0,a0,1        # skips cooldown byte %
00000a0b : 00000613;   % 238:     li a2,0             # resets counter %
00000a0c : 00300593;   % 239:     li a1,3  # gets number of beams in game %
00000a0d : 00000813;   % 241:         li a6,0      # Default sprite (normal beam, and not exploding) %
00000a0e : 00054383;   % 242:         lbu t2,0(a0) # Loads enable byte %
00000a0f : 00039463;   % 243:         bnez t2,BEAMS_OPERATIONS_LOOP_CONTINUE    # If enabled, %
00000a10 : 1280006f;   % 244:             j NEXT_IN_BEAMS_OPERATIONS_LOOP       # Otherwise, check other beams %
00000a11 : 00200293;   % 246:             li t0,2  # Loads "To be Disabled"  %
00000a12 : 00729663;   % 247:             bne t0,t2, BEAMS_OPERATIONS_LOOP_CONTINUE_2 # If state isn't "To be Disabled"  %
00000a13 : 00050023;   % 249:                 sb zero,0(a0) # Disables beam %
00000a14 : 1180006f;   % 250:                 j NEXT_IN_BEAMS_OPERATIONS_LOOP  # Check other beams %
00000a15 : 00300293;   % 253:             li t0,3  # Loads "Hit, to be Disabled"  %
00000a16 : 00729463;   % 254:             bne t0,t2, BEAMS_OPERATIONS_LOOP_CONTINUE_3   # If beam is trully enabled, %
00000a17 : 00100813;   % 256:                 li a6,1       # Beam will be rendered again, but exploding  %
00000a18 : fdc10113;   % 262:             addi sp,sp,-36 %
00000a19 : 00912023;   % 263:             sw s1,0(sp) %
00000a1a : 01212223;   % 264:             sw s2,4(sp) %
00000a1b : 01312423;   % 265:             sw s3,8(sp) %
00000a1c : 01412623;   % 266:             sw s4,12(sp) %
00000a1d : 00a12823;   % 267:             sw a0,16(sp) %
00000a1e : 00b12a23;   % 268:             sw a1,20(sp) %
00000a1f : 00c12c23;   % 269:             sw a2,24(sp) %
00000a20 : 00d12e23;   % 270:             sw a3,28(sp) %
00000a21 : 02412023;   % 271:             sw tp,32(sp) %
00000a22 : 00554583;   % 276:             lbu a1,5(a0) # Loads beam's current X %
00000a23 : 00624283;   % 277:             lbu t0,6(tp) # Loads map's current X %
00000a24 : 405585b3;   % 278:             sub a1,a1,t0 # Gets the X matrix related to the map's X (a1 = beam's X - map's X) %
00000a25 : 00459593;   % 279:             slli a1,a1,4 # Multiplies a5 by 16 in order to get X related to screen %
00000a26 : 00354283;   % 280:             lbu t0,3(a0) # Loads beam's X offset %
00000a27 : 005585b3;   % 281:             add a1,a1,t0 # Adds offset to position %
00000a28 : 00824283;   % 282:             lbu t0,8(tp) # Loads map's X offset %
00000a29 : 405585b3;   % 283:             sub a1,a1,t0 # and takes it from beam's position %
00000a2a : 00754603;   % 287:             lbu a2,7(a0) # Loads beam's current Y %
00000a2b : 00724303;   % 288:             lbu t1,7(tp) # Loads map's current Y %
00000a2c : 40660633;   % 289:             sub a2,a2,t1 # Gets the Y matrix related to the map's Y (a2 = beam's Y - map's Y) %
00000a2d : 00461613;   % 290:             slli a2,a2,4 # Multiplies a2 by 16 in order to get Y related to screen %
00000a2e : 00454283;   % 291:             lbu t0,4(a0) # Loads beam's Y offset %
00000a2f : 00560633;   % 292:             add a2,a2,t0 # Adds offset to position %
00000a30 : 00924303;   % 293:             lbu t1,9(tp) # Loads map's Y offset %
00000a31 : 40660633;   % 294:             sub a2,a2,t1 # and takes it from beam's position %
00000a32 : 01000693;   % 296:             li a3,16   # 16 = width of rendering area %
00000a33 : 01000713;   % 297:             li a4,16   # 16 = height of rendering area %
00000a34 : 008007b3;   % 298:             mv a5,s0          # gets frame to be rendered on %
00000a35 : 00150283;   % 300:             lb t0,1(a0)       # Loads direction byte %
00000a36 : 00028863;   % 301:             beqz t0,BEAMS_OPERATIONS_LOOP_RENDER_UP   # If beam is going up %
00000a37 : 0fc1e517;   % 302:                 la a0,Beam_Horizontal   # If beam is moving horizontally %
00000a38 : 8a050513;   % 302:  %
00000a39 : 00c0006f;   % 303:                 j BEAMS_OPERATIONS_LOOP_RENDER_START  # Render %
00000a3a : 0fc1e517;   % 306:                 la a0,Beam_Vertical     # If beam is moving vertically %
00000a3b : a9450513;   % 306:  %
00000a3c : 00000893;   % 310:                 li a7,0             # Normal render %
00000a3d : fffff317;   % 311:                 call RENDER_ENTITY  # Renders it %
00000a3e : 578300e7;   % 311:  %
00000a3f : 01012503;   % 313:             lw a0,16(sp)    # Restores a0 %
00000a40 : 00054383;   % 314:             lbu t2,0(a0)    # Loads enable byte %
00000a41 : 00300293;   % 315:             li t0,3         # Loads "Hit, to be Disabled"  %
00000a42 : 00729663;   % 316:             bne t0,t2, BEAMS_OPERATIONS_LOOP_MOVE   # If it wasn't in the "Hit" state %
00000a43 : 00050023;   % 318:                 sb zero,0(a0) # Disables beam %
00000a44 : 0300006f;   % 319:                 j BEAMS_OPERATIONS_LOOP_AFTER_OPERATIONS  # Check other beams %
00000a45 : 00022583;   % 324:             lw a1,0(tp) %
00000a46 : 00005317;   % 325:             call MOVE_BEAM                %
00000a47 : 7a8300e7;   % 325:  %
00000a48 : 00254283;   % 329:             lbu t0,2(a0)    # Gets number of times that it was rendered %
00000a49 : 00128293;   % 330:             addi t0,t0,1    # iterates it %
00000a4a : 00550123;   % 331:             sb t0,2(a0)     # and stores it back %
00000a4b : 00600313;   % 332:             li t1,6  # Loads number of times beam should render/move before being disabled %
00000a4c : 0062c863;   % 333:             blt t0,t1,BEAMS_OPERATIONS_LOOP_AFTER_OPERATIONS  # If it didn't surpass the threshold, finish this part of loop %
00000a4d : 00200313;   % 335:                 li t1,2        # Loads "To be Disabled"  %
00000a4e : 00650023;   % 336:                 sb t1,0(a0)    # and stores it on enable byte %
00000a4f : 00050123;   % 337:                 sb zero,2(a0)  # Resets render counter %
00000a50 : 00012483;   % 344:             lw s1,0(sp) %
00000a51 : 00412903;   % 345:             lw s2,4(sp) %
00000a52 : 00812983;   % 346:             lw s3,8(sp) %
00000a53 : 00c12a03;   % 347:             lw s4,12(sp) %
00000a54 : 01012503;   % 348:             lw a0,16(sp) %
00000a55 : 01412583;   % 349:             lw a1,20(sp) %
00000a56 : 01812603;   % 350:             lw a2,24(sp) %
00000a57 : 01c12683;   % 351:             lw a3,28(sp) %
00000a58 : 02012203;   % 352:             lw tp,32(sp) %
00000a59 : 02410113;   % 353:             addi sp,sp,36 %
00000a5a : 00950513;   % 357:             addi a0,a0,9  # Going to the next beam's address                                   %
00000a5b : 00160613;   % 358:             addi a2,a2,1            # Iterating counter by 1                                    %
00000a5c : 00b65463;   % 359:             bge a2,a1, END_BEAMS_OPERATIONS_LOOP # If all of the beams were checked, end loop (don't attack)                                 %
00000a5d : ec1ff06f;   % 360:             j BEAMS_OPERATIONS_LOOP # otherwise, go back to the loop's beginning  %
00000a5e : 00012083;   % 364:         lw ra,0(sp) %
00000a5f : 00410113;   % 365:         addi sp,sp,4 %
00000a60 : 00008067;   % 367:         ret %
00000a61 : ffc10113;   % 384:     addi sp,sp,-4 %
00000a62 : 00112023;   % 385:     sw ra,0(sp) %
00000a63 : 0fc0f217;   % 387:     la tp, CURRENT_MAP  # Loads CURRENT_MAP address %
00000a64 : 77420213;   % 387:  %
00000a65 : 0fc0f517;   % 389:     la a0,BOMBS_ARRAY   # Loads Bombs array %
00000a66 : 7e650513;   % 389:  %
00000a67 : 00150513;   % 390:     addi a0,a0,1        # skips cooldown byte %
00000a68 : 00000613;   % 392:     li a2,0             # resets counter %
00000a69 : 00300593;   % 393:     li a1,3  # gets number of bombs in game %
00000a6a : 00054383;   % 395:         lbu t2,0(a0) # Loads enable byte %
00000a6b : 00039463;   % 396:         bnez t2,BOMBS_OPERATIONS_LOOP_CONTINUE    # If enabled, %
00000a6c : 1b00006f;   % 397:             j NEXT_IN_BOMBS_OPERATIONS_LOOP       # Otherwise, check other bombs %
00000a6d : 00200293;   % 400:             li t0,2  # Loads "To be Disabled"  %
00000a6e : 06729463;   % 401:             bne t0,t2, BOMBS_OPERATIONS_LOOP_CONTINUE_2 # If state isn't "To be Disabled"  %
00000a6f : 00050023;   % 403:                 sb zero,0(a0) # Disables bomb %
00000a70 : fec10113;   % 406:                 addi sp,sp,-20 %
00000a71 : 00a12023;   % 407:                 sw a0,0(sp) %
00000a72 : 00b12223;   % 408:                 sw a1,4(sp) %
00000a73 : 00c12423;   % 409:                 sw a2,8(sp) %
00000a74 : 00d12623;   % 410:                 sw a3,12(sp) %
00000a75 : 00412823;   % 411:                 sw tp,16(sp) %
00000a76 : 00354583;   % 414:                 lbu a1,3(a0) # Loads bomb's X offset %
00000a77 : 00454603;   % 415:                 lbu a2,4(a0) # Loads bomb's Y offset %
00000a78 : 00554683;   % 416:                 lbu a3,5(a0) # Loads bomb's current X %
00000a79 : 00754703;   % 417:                 lbu a4,7(a0) # Loads bomb's current Y %
00000a7a : 00000793;   % 418:                 li a5,0      # No delay %
00000a7b : 00100513;   % 420:                 li a0, 1   # 1 - Big   %
00000a7c : 00000317;   % 421:                 call EXPLOSION_SPAWN %
00000a7d : 604300e7;   % 421:  %
00000a7e : 00012503;   % 423:                 lw a0,0(sp)  # Restores a0 for bomb collision %
00000a7f : 00005317;   % 424:                 call BOMB_COLLISION  # Will see if bomb hit an enemy/block %
00000a80 : 304300e7;   % 424:  %
00000a81 : 00012503;   % 426:                 lw a0,0(sp) %
00000a82 : 00412583;   % 427:                 lw a1,4(sp) %
00000a83 : 00812603;   % 428:                 lw a2,8(sp) %
00000a84 : 00c12683;   % 429:                 lw a3,12(sp) %
00000a85 : 01012203;   % 430:                 lw tp,16(sp) %
00000a86 : 01410113;   % 431:                 addi sp,sp,20 %
00000a87 : 1440006f;   % 434:                 j NEXT_IN_BOMBS_OPERATIONS_LOOP  # Check other bombs %
00000a88 : fdc10113;   % 439:             addi sp,sp,-36 %
00000a89 : 00912023;   % 440:             sw s1,0(sp) %
00000a8a : 01212223;   % 441:             sw s2,4(sp) %
00000a8b : 01312423;   % 442:             sw s3,8(sp) %
00000a8c : 01412623;   % 443:             sw s4,12(sp) %
00000a8d : 00a12823;   % 444:             sw a0,16(sp) %
00000a8e : 00b12a23;   % 445:             sw a1,20(sp) %
00000a8f : 00c12c23;   % 446:             sw a2,24(sp) %
00000a90 : 00d12e23;   % 447:             sw a3,28(sp) %
00000a91 : 02412023;   % 448:             sw tp,32(sp) %
00000a92 : 00061663;   % 452:             bnez a2,BOMBS_OPERATIONS_LOOP_NOT_BOMB_0 %
00000a93 : 21ad0553;   % 454:                 fmv.s fa0,fs10   # Moves BOMB_0's current Y speed to fa0  %
00000a94 : 0180006f;   % 455:                 j BOMBS_OPERATIONS_LOOP_MOVE  # Move %
00000a95 : 00100293;   % 457:             BOMBS_OPERATIONS_LOOP_NOT_BOMB_0: li t0,1 %
00000a96 : 00561663;   % 458:             bne a2,t0,BOMBS_OPERATIONS_LOOP_NOT_BOMB_1 %
00000a97 : 21bd8553;   % 460:                 fmv.s fa0,fs11   # Moves BOMB_1's current Y speed to fa0 %
00000a98 : 0080006f;   % 461:                 j BOMBS_OPERATIONS_LOOP_MOVE  # Move %
00000a99 : 21188553;   % 465:                 fmv.s fa0,fa7   # Moves BOMB_2's current Y speed to fa0 %
00000a9a : 00022583;   % 471:             lw a1,0(tp) %
00000a9b : 00006317;   % 472:             call MOVE_BOMB %
00000a9c : 850300e7;   % 472:  %
00000a9d : 01812603;   % 474:             lw a2,24(sp) # Getting Bomb's number back (counter) %
00000a9e : 00061663;   % 477:             bnez a2,BOMBS_OPERATIONS_AFTER_CHECK_NOT_BOMB_0 %
00000a9f : 20a50d53;   % 479:                 fmv.s fs10,fa0   # Saves BOMB_0's new Y speed from fa0  %
00000aa0 : 0180006f;   % 480:                 j BOMBS_OPERATIONS_AFTER_CHECK  # Finish move %
00000aa1 : 00100293;   % 482:             BOMBS_OPERATIONS_AFTER_CHECK_NOT_BOMB_0: li t0,1 %
00000aa2 : 00561663;   % 483:             bne a2,t0,BOMBS_OPERATIONS_AFTER_CHECK_NOT_BOMB_1 %
00000aa3 : 20a50dd3;   % 485:                 fmv.s fs11,fa0   # Saves BOMB_1's new Y speed from fa0  %
00000aa4 : 0080006f;   % 486:                 j BOMBS_OPERATIONS_AFTER_CHECK  # Finish move %
00000aa5 : 20a508d3;   % 490:                 fmv.s fa7,fa0   # Saves BOMB_2's new Y speed from fa0  %
00000aa6 : 01012503;   % 495:             lw a0,16(sp)    # Restores a0 %
00000aa7 : 02012203;   % 496:             lw tp,32(sp)    # Restores tp %
00000aa8 : 00554583;   % 500:             lbu a1,5(a0) # Loads bomb's current X %
00000aa9 : 00624283;   % 501:             lbu t0,6(tp) # Loads map's current X %
00000aaa : 405585b3;   % 502:             sub a1,a1,t0 # Gets the X matrix related to the map's X (a1 = bomb's X - map's X) %
00000aab : 00459593;   % 503:             slli a1,a1,4 # Multiplies a5 by 16 in order to get X related to screen %
00000aac : 00354283;   % 504:             lbu t0,3(a0) # Loads bomb's X offset %
00000aad : 005585b3;   % 505:             add a1,a1,t0 # Adds offset to position %
00000aae : 00824283;   % 506:             lbu t0,8(tp) # Loads map's X offset %
00000aaf : 405585b3;   % 507:             sub a1,a1,t0 # and takes it from bomb's position %
00000ab0 : 00754603;   % 511:             lbu a2,7(a0) # Loads bomb's current Y %
00000ab1 : 00724303;   % 512:             lbu t1,7(tp) # Loads map's current Y %
00000ab2 : 40660633;   % 513:             sub a2,a2,t1 # Gets the Y matrix related to the map's Y (a2 = bomb's Y - map's Y) %
00000ab3 : 00461613;   % 514:             slli a2,a2,4 # Multiplies a2 by 16 in order to get Y related to screen %
00000ab4 : 00454283;   % 515:             lbu t0,4(a0) # Loads bomb's Y offset %
00000ab5 : 00560633;   % 516:             add a2,a2,t0 # Adds offset to position %
00000ab6 : 00924303;   % 517:             lbu t1,9(tp) # Loads map's Y offset %
00000ab7 : 40660633;   % 518:             sub a2,a2,t1 # and takes it from bomb's position %
00000ab8 : 00460613;   % 519:             addi a2,a2,4 # Offsets sprite a little bit %
00000ab9 : 01000693;   % 521:             li a3,16   # 16 = width of rendering area %
00000aba : 01000713;   % 522:             li a4,16   # 16 = height of rendering area %
00000abb : 008007b3;   % 523:             mv a5,s0          # gets frame to be rendered on %
00000abc : 00150803;   % 525:             lb a6,1(a0)       # Loads status byte %
00000abd : 00184813;   % 526:             xori a6,a6,1      # Inverts it %
00000abe : 010500a3;   % 527:             sb a6,1(a0)       # and stores it %
00000abf : 0fc1e517;   % 529:             la a0,Bomb    %
00000ac0 : a8050513;   % 529:  %
00000ac1 : 00000893;   % 530:             li a7,0             # Normal render %
00000ac2 : fffff317;   % 531:             call RENDER_ENTITY  # Renders it %
00000ac3 : 364300e7;   % 531:  %
00000ac4 : 01012503;   % 534:             lw a0,16(sp)    # Restores a0 %
00000ac5 : 00254283;   % 535:             lbu t0,2(a0)    # Gets number of times that it was rendered (counter for exploding) %
00000ac6 : 00128293;   % 536:             addi t0,t0,1    # iterates it %
00000ac7 : 00550123;   % 537:             sb t0,2(a0)     # and stores it back %
00000ac8 : 01400313;   % 538:             li t1,20  # Loads number of times bomb should render/move before being disabled %
00000ac9 : 0062ca63;   % 539:             blt t0,t1,BOMBS_OPERATIONS_LOOP_AFTER_OPERATIONS  # If it didn't surpass the threshold, finish this part of loop %
00000aca : 00200313;   % 541:                 li t1,2        # Loads "To be Disabled"  %
00000acb : 00650023;   % 542:                 sb t1,0(a0)    # and stores it on enable byte %
00000acc : 000500a3;   % 543:                 sb zero,1(a0)  # Sets status to 0 %
00000acd : 00050123;   % 544:                 sb zero,2(a0)  # Resets render counter %
00000ace : 00012483;   % 551:             lw s1,0(sp) %
00000acf : 00412903;   % 552:             lw s2,4(sp) %
00000ad0 : 00812983;   % 553:             lw s3,8(sp) %
00000ad1 : 00c12a03;   % 554:             lw s4,12(sp) %
00000ad2 : 01012503;   % 555:             lw a0,16(sp) %
00000ad3 : 01412583;   % 556:             lw a1,20(sp) %
00000ad4 : 01812603;   % 557:             lw a2,24(sp) %
00000ad5 : 01c12683;   % 558:             lw a3,28(sp) %
00000ad6 : 02012203;   % 559:             lw tp,32(sp) %
00000ad7 : 02410113;   % 560:             addi sp,sp,36 %
00000ad8 : 00950513;   % 564:             addi a0,a0,9  # Going to the next bomb's address                                   %
00000ad9 : 00160613;   % 565:             addi a2,a2,1            # Iterating counter by 1                                    %
00000ada : 00b65463;   % 566:             bge a2,a1, END_BOMBS_OPERATIONS_LOOP # If all of the bombs were checked, end loop (don't attack)                                 %
00000adb : e3dff06f;   % 567:             j BOMBS_OPERATIONS_LOOP # otherwise, go back to the loop's beginning  %
00000adc : 00012083;   % 571:         lw ra,0(sp) %
00000add : 00410113;   % 572:         addi sp,sp,4 %
00000ade : 00008067;   % 574:         ret %
00000adf : ffc10113;   % 27:     addi sp,sp,-4 %
00000ae0 : 00112023;   % 28:     sw ra,0(sp) %
00000ae1 : 0fc0f297;   % 30:     la t0,MAP_INFO  %
00000ae2 : 58028293;   % 30:  %
00000ae3 : 0002c283;   % 31:     lbu t0,0(t0) %
00000ae4 : 00100313;   % 32:     li t1,1 %
00000ae5 : 00628463;   % 33:     beq t0,t1,CONTINUE_MARU_MARI_OPERATIONS %
00000ae6 : 0bc0006f;   % 34:         j END_MARU_MARI_OPERATIONS %
00000ae7 : 0fc0f297;   % 37:         la t0,PLYR_INFO  %
00000ae8 : 57c28293;   % 37:  %
00000ae9 : 0012c283;   % 38:         lbu t0,1(t0)                             # Loads player's number of abilities %
00000aea : 00028463;   % 39:         beqz t0,CONTINUE_MARU_MARI_OPERATIONS2   # Continue (ability wasn't aquired yet) %
00000aeb : 0a80006f;   % 40:             j END_MARU_MARI_OPERATIONS           # otherwise don't render %
00000aec : ff010113;   % 44:             addi sp,sp,-16 %
00000aed : 00912023;   % 45:             sw s1,0(sp) %
00000aee : 01212223;   % 46:             sw s2,4(sp) %
00000aef : 01312423;   % 47:             sw s3,8(sp) %
00000af0 : 01412623;   % 48:             sw s4,12(sp) %
00000af1 : 0fc0f217;   % 50:             la tp,CURRENT_MAP %
00000af2 : 53c20213;   % 50:  %
00000af3 : 00f00593;   % 53:             li a1,15    # Loads maru mari's current X %
00000af4 : 00624283;   % 54:             lbu t0,6(tp) # Loads map's current X %
00000af5 : 405585b3;   % 55:             sub a1,a1,t0 # Gets the X matrix related to the map's X (a1 = maru mari's X - map's X) %
00000af6 : 00459593;   % 56:             slli a1,a1,4 # Multiplies a5 by 16 in order to get X related to screen %
00000af7 : 00824283;   % 58:             lbu t0,8(tp) # Loads map's X offset %
00000af8 : 405585b3;   % 59:             sub a1,a1,t0 # and takes it from maru mari's position %
00000af9 : 00900613;   % 62:             li a2,9 # Loads maru mari's current Y %
00000afa : 00724303;   % 63:             lbu t1,7(tp) # Loads map's current Y %
00000afb : 40660633;   % 64:             sub a2,a2,t1 # Gets the Y matrix related to the map's Y (a2 = maru mari's Y - map's Y) %
00000afc : 00461613;   % 65:             slli a2,a2,4 # Multiplies a2 by 16 in order to get Y related to screen %
00000afd : 00924303;   % 67:             lbu t1,9(tp) # Loads map's Y offset %
00000afe : 40660633;   % 68:             sub a2,a2,t1 # and takes it from loot's position %
00000aff : 01000693;   % 70:             li a3,16     # Loads width          %
00000b00 : 01000713;   % 71:             li a4,16     # Loads height %
00000b01 : 008007b3;   % 72:             mv a5,s0            # gets frame to be rendered on %
00000b02 : 00000893;   % 73:             li a7,0             # Normal render %
00000b03 : 0fc0f297;   % 76:             la t0,MARU_MARI_INFO # Loads Maru Mari's info address %
00000b04 : 54c28293;   % 76:  %
00000b05 : 0002c803;   % 77:             lbu a6, 0(t0)        # Loads status sprite %
00000b06 : 00300e13;   % 78:             li t3, 3             # t3 = max_sprite %
00000b07 : 01c80863;   % 79:             beq a6,t3,RESET_MARU_MARI # If status == 3, reset it %
00000b08 : 00180813;   % 80:                 addi a6,a6,1     # Increments status  %
00000b09 : 01028023;   % 81:                 sb a6, 0(t0)     # Stores status sprite %
00000b0a : 0080006f;   % 82:                 j MARU_MARI_OPERATIONS_RENDER %
00000b0b : 00028023;   % 85:                 sb zero, 0(t0)   # Stores status sprite %
00000b0c : 0fc1e517;   % 89:                 la a0,MaruMari %
00000b0d : 54c50513;   % 89:  %
00000b0e : fffff317;   % 90:                 call RENDER_ENTITY  # Renders it %
00000b0f : 234300e7;   % 90:  %
00000b10 : 00012483;   % 93:             lw s1,0(sp) %
00000b11 : 00412903;   % 94:             lw s2,4(sp) %
00000b12 : 00812983;   % 95:             lw s3,8(sp) %
00000b13 : 00c12a03;   % 96:             lw s4,12(sp) %
00000b14 : 01010113;   % 97:             addi sp,sp,16 %
00000b15 : 00012083;   % 102:         lw ra,0(sp) %
00000b16 : 00410113;   % 103:         addi sp,sp,4 %
00000b17 : 00008067;   % 105:         ret      %
00000b18 : ffc10113;   % 133:     addi sp,sp,-4 %
00000b19 : 00112023;   % 134:     sw ra,0(sp) %
00000b1a : 0fc0f297;   % 136:     la t0,MAP_INFO  %
00000b1b : 49c28293;   % 136:  %
00000b1c : 0002c283;   % 137:     lbu t0,0(t0) %
00000b1d : 00600313;   % 138:     li t1,6 %
00000b1e : 00628463;   % 139:     beq t0,t1,CONTINUE_BOMB_POWER_OPERATIONS %
00000b1f : 0b40006f;   % 140:         j END_BOMB_POWER_OPERATIONS %
00000b20 : 0fc0f297;   % 143:         la t0,PLYR_INFO  %
00000b21 : 49828293;   % 143:  %
00000b22 : 0012c283;   % 144:         lbu t0,1(t0)                                # Loads player's number of abilities %
00000b23 : 00300313;   % 145:         li t1,3 %
00000b24 : 00629463;   % 146:         bne t0,t1,CONTINUE_BOMB_POWER_OPERATIONS2   # Continue (ability wasn't aquired yet) %
00000b25 : 09c0006f;   % 147:             j END_BOMB_POWER_OPERATIONS             # otherwise don't render %
00000b26 : 0fc0f297;   % 150:         la t0,BOMB_POWER_INFO  %
00000b27 : 4c228293;   % 150:  %
00000b28 : 0002c283;   % 151:         lbu t0,0(t0)                                # Loads whether capsule has been broken or not %
00000b29 : 00029463;   % 152:         bnez t0,CONTINUE_BOMB_POWER_OPERATIONS3  # Continue (capsule was broken) %
00000b2a : 0880006f;   % 153:             j END_BOMB_POWER_OPERATIONS             # otherwise don't render %
00000b2b : ff010113;   % 157:             addi sp,sp,-16 %
00000b2c : 00912023;   % 158:             sw s1,0(sp) %
00000b2d : 01212223;   % 159:             sw s2,4(sp) %
00000b2e : 01312423;   % 160:             sw s3,8(sp) %
00000b2f : 01412623;   % 161:             sw s4,12(sp) %
00000b30 : 0fc0f217;   % 163:             la tp,CURRENT_MAP %
00000b31 : 44020213;   % 163:  %
00000b32 : 00b00593;   % 166:             li a1,11    # Loads maru mari's current X %
00000b33 : 00624283;   % 167:             lbu t0,6(tp) # Loads map's current X %
00000b34 : 405585b3;   % 168:             sub a1,a1,t0 # Gets the X matrix related to the map's X (a1 = maru mari's X - map's X) %
00000b35 : 00459593;   % 169:             slli a1,a1,4 # Multiplies a5 by 16 in order to get X related to screen %
00000b36 : 00824283;   % 171:             lbu t0,8(tp) # Loads map's X offset %
00000b37 : 405585b3;   % 172:             sub a1,a1,t0 # and takes it from maru mari's position %
00000b38 : 00300613;   % 175:             li a2,3    # Loads maru mari's current Y %
00000b39 : 00724303;   % 176:             lbu t1,7(tp) # Loads map's current Y %
00000b3a : 40660633;   % 177:             sub a2,a2,t1 # Gets the Y matrix related to the map's Y (a2 = maru mari's Y - map's Y) %
00000b3b : 00461613;   % 178:             slli a2,a2,4 # Multiplies a2 by 16 in order to get Y related to screen %
00000b3c : 00924303;   % 180:             lbu t1,9(tp) # Loads map's Y offset %
00000b3d : 40660633;   % 181:             sub a2,a2,t1 # and takes it from loot's position %
00000b3e : 01000693;   % 183:             li a3,16     # Loads width          %
00000b3f : 01000713;   % 184:             li a4,16     # Loads height %
00000b40 : 008007b3;   % 185:             mv a5,s0            # Gets frame to be rendered on %
00000b41 : 00000813;   % 186:             li a6,0             # No status %
00000b42 : 00000893;   % 187:             li a7,0             # Normal render %
00000b43 : 0fc1f517;   % 189:             la a0,Bomb_Power %
00000b44 : b7050513;   % 189:  %
00000b45 : fffff317;   % 190:             call RENDER_ENTITY  # Renders it %
00000b46 : 158300e7;   % 190:  %
00000b47 : 00012483;   % 193:             lw s1,0(sp) %
00000b48 : 00412903;   % 194:             lw s2,4(sp) %
00000b49 : 00812983;   % 195:             lw s3,8(sp) %
00000b4a : 00c12a03;   % 196:             lw s4,12(sp) %
00000b4b : 01010113;   % 197:             addi sp,sp,16 %
00000b4c : 00012083;   % 202:         lw ra,0(sp) %
00000b4d : 00410113;   % 203:         addi sp,sp,4 %
00000b4e : 00008067;   % 205:         ret     %
00000b4f : ffc10113;   % 233:     addi sp,sp,-4 %
00000b50 : 00112023;   % 234:     sw ra,0(sp) %
00000b51 : 0fc0f297;   % 236:     la t0,MAP_INFO  %
00000b52 : 3c028293;   % 236:  %
00000b53 : 0002c283;   % 237:     lbu t0,0(t0) %
00000b54 : 00600313;   % 238:     li t1,6 %
00000b55 : 00628463;   % 239:     beq t0,t1,CONTINUE_ITEM_CAPSULE_OPERATIONS1 %
00000b56 : 0b80006f;   % 240:         j END_ITEM_CAPSULE_OPERATIONS %
00000b57 : 0fc0f297;   % 243:         la t0,ITEM_CAPSULE_INFO  %
00000b58 : 40028293;   % 243:  %
00000b59 : 0002c803;   % 244:         lbu a6,0(t0)                                # Loads whether capsule has been broken or not %
00000b5a : 00300313;   % 245:         li t1,3 %
00000b5b : 00681463;   % 246:         bne a6,t1,CONTINUE_ITEM_CAPSULE_OPERATIONS2   # Continue (capsule was broken) %
00000b5c : 0a00006f;   % 247:             j END_ITEM_CAPSULE_OPERATIONS             # otherwise don't render %
00000b5d : ff010113;   % 251:             addi sp,sp,-16 %
00000b5e : 00912023;   % 252:             sw s1,0(sp) %
00000b5f : 01212223;   % 253:             sw s2,4(sp) %
00000b60 : 01312423;   % 254:             sw s3,8(sp) %
00000b61 : 01412623;   % 255:             sw s4,12(sp) %
00000b62 : 0fc0f217;   % 257:             la tp,CURRENT_MAP %
00000b63 : 37820213;   % 257:  %
00000b64 : 00b00593;   % 260:             li a1,11    # Loads maru mari's current X %
00000b65 : 00624283;   % 261:             lbu t0,6(tp) # Loads map's current X %
00000b66 : 405585b3;   % 262:             sub a1,a1,t0 # Gets the X matrix related to the map's X (a1 = maru mari's X - map's X) %
00000b67 : 00459593;   % 263:             slli a1,a1,4 # Multiplies a5 by 16 in order to get X related to screen %
00000b68 : 00824283;   % 265:             lbu t0,8(tp) # Loads map's X offset %
00000b69 : 405585b3;   % 266:             sub a1,a1,t0 # and takes it from maru mari's position %
00000b6a : 00300613;   % 269:             li a2,3    # Loads maru mari's current Y %
00000b6b : 00724303;   % 270:             lbu t1,7(tp) # Loads map's current Y %
00000b6c : 40660633;   % 271:             sub a2,a2,t1 # Gets the Y matrix related to the map's Y (a2 = maru mari's Y - map's Y) %
00000b6d : 00461613;   % 272:             slli a2,a2,4 # Multiplies a2 by 16 in order to get Y related to screen %
00000b6e : 00924303;   % 274:             lbu t1,9(tp) # Loads map's Y offset %
00000b6f : 40660633;   % 275:             sub a2,a2,t1 # and takes it from loot's position %
00000b70 : 01000693;   % 277:             li a3,16     # Loads width          %
00000b71 : 01000713;   % 278:             li a4,16     # Loads height %
00000b72 : 008007b3;   % 279:             mv a5,s0            # Gets frame to be rendered on %
00000b73 : 00000893;   % 280:             li a7,0             # Normal render %
00000b74 : 0fc0f297;   % 282:             la t0,ITEM_CAPSULE_INFO  %
00000b75 : 38c28293;   % 282:  %
00000b76 : 00080a63;   % 283:             beqz a6, SKIP_CAPSULE_STATUS_UPDATE %
00000b77 : 00180813;   % 284:                 addi a6,a6,1 %
00000b78 : 01028023;   % 285:                 sb a6,0(t0)    # Stores resulting status %
00000b79 : 00300293;   % 286:                 li t0,3 %
00000b7a : 01028a63;   % 287:                 beq t0,a6,AFTER_CAPSULE_RENDER %
00000b7b : 0fc1e517;   % 289:             la a0,Item_Capsule %
00000b7c : 79050513;   % 289:  %
00000b7d : fffff317;   % 290:             call RENDER_ENTITY  # Renders it %
00000b7e : 078300e7;   % 290:  %
00000b7f : 00012483;   % 295:             lw s1,0(sp) %
00000b80 : 00412903;   % 296:             lw s2,4(sp) %
00000b81 : 00812983;   % 297:             lw s3,8(sp) %
00000b82 : 00c12a03;   % 298:             lw s4,12(sp) %
00000b83 : 01010113;   % 299:             addi sp,sp,16 %
00000b84 : 00012083;   % 304:         lw ra,0(sp) %
00000b85 : 00410113;   % 305:         addi sp,sp,4 %
00000b86 : 00008067;   % 307:         ret     %
00000b87 : 00051463;   % 334:     bnez a0,CONTINUE_LOOT_SPAWN   # If we actually want to spawn loot %
00000b88 : 09c0006f;   % 335:         j END_LOOT_SPAWN_LOOP     # Otherwise, finish procedure %
00000b89 : 00a00e33;   % 338:         mv t3, a0  # Moves explosion type to t3 %
00000b8a : 00b00eb3;   % 339:         mv t4, a1  # Moves X offset to t4 %
00000b8b : 00c00f33;   % 340:         mv t5, a2  # Moves Y offset to t5 %
00000b8c : 0fc0f517;   % 342:         la a0, LOOT_ARRAY      # Loads LOOT array %
00000b8d : 3ae50513;   % 342:  %
00000b8e : 00400593;   % 344:         li a1, 4      # Loads total number of loot %
00000b8f : 00000613;   % 345:         li a2,0                 # Resets counter %
00000b90 : 00254283;   % 347:             lbu t0, 2(a0)       # Loads enable byte %
00000b91 : 00028463;   % 348:             beqz t0, LOOT_SPAWN_LOOP_ACTIVATE # If current loot is disabled, activate it %
00000b92 : 0640006f;   % 349:                 j NEXT_IN_LOOT_SPAWN_LOOP     # Otherwise, go to next one in loop %
00000b93 : 00100293;   % 352:                 li t0,1          # Loads 1 (Enabled)  %
00000b94 : 00550123;   % 353:                 sb t0,2(a0)      # stores in explosion's enable byte %
00000b95 : fffe0e13;   % 355:                 addi t3,t3,-1    # If t3 = 1 -> t3 = 0. If t3 = 2 -> t3 = 1 %
00000b96 : 020e0a63;   % 356:                 beqz t3,SKIP_RANDOM_LOOT  # If the result is 0, spawn energy %
00000b97 : ff810113;   % 358:                     addi sp,sp,-8 %
00000b98 : 00a12023;   % 359:                     sw a0,0(sp) %
00000b99 : 00b12223;   % 360:                     sw a1,4(sp) %
00000b9a : 00a00593;   % 364:                     li a1,10                  # Range %
00000b9b : 08e00893;   % 365:                     li a7,142  # random integer within range ecall %
00000b9c : 00000073;   % 366:                     ecall %
00000b9d : 00a00e33;   % 367:                     mv t3,a0 %
00000b9e : 00012503;   % 370:                     lw a0,0(sp) %
00000b9f : 00412583;   % 371:                     lw a1,4(sp) %
00000ba0 : 00810113;   % 372:                     addi sp,sp,8 %
00000ba1 : 000e0463;   % 375:                     beqz t3,SKIP_RANDOM_LOOT   # If result is 0 (10%), spawn energy %
00000ba2 : 00100e13;   % 376:                         li t3,1                # otherwise (90%), spawn missile %
00000ba3 : 01c501a3;   % 380:                 sb t3,3(a0)      # Stores explosion's type (0 - Small, 1 - Big) %
00000ba4 : 01d50223;   % 382:                 sb t4, 4(a0)     # Stores explosion's X offset %
00000ba5 : 01e502a3;   % 383:                 sb t5, 5(a0)     # Stores explosion's Y offset %
00000ba6 : 00d50323;   % 385:                 sb a3, 6(a0)     # Stores explosion's X  %
00000ba7 : 00d503a3;   % 386:                 sb a3, 7(a0)     # Stores explosion's old X  %
00000ba8 : 00e50423;   % 388:                 sb a4, 8(a0)     # Stores explosion's Y  %
00000ba9 : 00e504a3;   % 389:                 sb a4, 9(a0)     # Stores explosion's old Y    %
00000baa : 0140006f;   % 391:                 j END_LOOT_SPAWN_LOOP # Break Loop        %
00000bab : 00a50513;   % 394:                 addi a0,a0,10           # Going to the next loot address                                   %
00000bac : 00160613;   % 395:                 addi a2,a2,1                   # Iterating counter by 1                                    %
00000bad : 00b65463;   % 396:                 bge a2,a1, END_LOOT_SPAWN_LOOP # If all of the loot were checked, end loop (don't spawn loot)                                 %
00000bae : f89ff06f;   % 397:                 j LOOT_SPAWN_LOOP # otherwise, go back to the loop's beginning  %
00000baf : 00008067;   % 401:         ret         %
00000bb0 : ffc10113;   % 420:     addi sp,sp,-4 %
00000bb1 : 00112023;   % 421:     sw ra,0(sp) %
00000bb2 : 0fc0f217;   % 423:     la tp, CURRENT_MAP      # Loads CURRENT_MAP address %
00000bb3 : 23820213;   % 423:  %
00000bb4 : 0fc0f517;   % 425:     la a0,LOOT_ARRAY   # Loads loot array %
00000bb5 : 30e50513;   % 425:  %
00000bb6 : 00000613;   % 427:     li a2,0                 # resets counter %
00000bb7 : 00400593;   % 428:     li a1,4       # gets number of loot in game %
00000bb8 : 00254383;   % 430:         lbu t2,2(a0) # Loads enable byte %
00000bb9 : 00039463;   % 431:         bnez t2,LOOT_OPERATIONS_LOOP_CONTINUE    # If enabled, %
00000bba : 0f00006f;   % 432:             j NEXT_IN_LOOT_OPERATIONS_LOOP       # Otherwise, check other loot %
00000bbb : fdc10113;   % 437:             addi sp,sp,-36 %
00000bbc : 00912023;   % 438:             sw s1,0(sp) %
00000bbd : 01212223;   % 439:             sw s2,4(sp) %
00000bbe : 01312423;   % 440:             sw s3,8(sp) %
00000bbf : 01412623;   % 441:             sw s4,12(sp) %
00000bc0 : 00a12823;   % 442:             sw a0,16(sp) %
00000bc1 : 00b12a23;   % 443:             sw a1,20(sp) %
00000bc2 : 00c12c23;   % 444:             sw a2,24(sp) %
00000bc3 : 00d12e23;   % 445:             sw a3,28(sp) %
00000bc4 : 02412023;   % 446:             sw tp,32(sp) %
00000bc5 : 00654583;   % 451:             lbu a1,6(a0) # Loads loot's current X %
00000bc6 : 00624283;   % 452:             lbu t0,6(tp) # Loads map's current X %
00000bc7 : 405585b3;   % 453:             sub a1,a1,t0 # Gets the X matrix related to the map's X (a1 = loot's X - map's X) %
00000bc8 : 00459593;   % 454:             slli a1,a1,4 # Multiplies a5 by 16 in order to get X related to screen %
00000bc9 : 00454283;   % 455:             lbu t0,4(a0) # Loads loot's X offset %
00000bca : 005585b3;   % 456:             add a1,a1,t0 # Adds offset to position %
00000bcb : 00824283;   % 457:             lbu t0,8(tp) # Loads map's X offset %
00000bcc : 405585b3;   % 458:             sub a1,a1,t0 # and takes it from loot's position %
00000bcd : 00854603;   % 461:             lbu a2,8(a0) # Loads loot's current Y %
00000bce : 00724303;   % 462:             lbu t1,7(tp) # Loads map's current Y %
00000bcf : 40660633;   % 463:             sub a2,a2,t1 # Gets the Y matrix related to the map's Y (a2 = loot's Y - map's Y) %
00000bd0 : 00461613;   % 464:             slli a2,a2,4 # Multiplies a2 by 16 in order to get Y related to screen %
00000bd1 : 00554283;   % 465:             lbu t0,5(a0) # Loads loot's Y offset %
00000bd2 : 00560633;   % 466:             add a2,a2,t0 # Adds offset to position %
00000bd3 : 00924303;   % 467:             lbu t1,9(tp) # Loads map's Y offset %
00000bd4 : 40660633;   % 468:             sub a2,a2,t1 # and takes it from loot's position %
00000bd5 : 01000693;   % 470:             li a3,16             %
00000bd6 : 01000713;   % 471:             li a4,16 %
00000bd7 : 008007b3;   % 472:             mv a5,s0     # gets frame to be rendered on %
00000bd8 : 00000893;   % 473:             li a7,0      # Normal render %
00000bd9 : 00055283;   % 475:             lhu t0,0(a0)      # Gets number of times that it was rendered (counter) %
00000bda : 0012f813;   % 476:             andi a6,t0,1      # Will be 1 if on an odd number of times, 0, if even %
00000bdb : 00354283;   % 478:             lbu t0,3(a0)      # Loads loot type %
00000bdc : 00029863;   % 479:             bnez t0,LOOT_OPERATIONS_LOOP_RENDER_MISSILE # If it's a missile collectible %
00000bdd : 0fc1e517;   % 480:                 la a0,Energy %
00000bde : e0850513;   % 480:  %
00000bdf : 00c0006f;   % 481:                 j START_LOOT_OPERATIONS_LOOP_RENDER %
00000be0 : 0fc1e517;   % 484:                 la a0,Missile_Collectable %
00000be1 : ffc50513;   % 484:  %
00000be2 : fffff317;   % 488:                 call RENDER_ENTITY  # Renders it %
00000be3 : ee4300e7;   % 488:  %
00000be4 : 01012503;   % 490:                 lw a0,16(sp)     # Restores a0 %
00000be5 : 00055283;   % 491:                 lhu t0,0(a0)     # Gets number of times that it was rendered (counter) %
00000be6 : 00128293;   % 492:                 addi t0,t0,1     # iterates it %
00000be7 : 00551023;   % 493:                 sh t0,0(a0)      # and stores it back %
00000be8 : 06400313;   % 495:                 li t1,100  # Loads number of times small explosion should render before being disabled %
00000be9 : 0062c663;   % 496:                 blt t0,t1,LOOT_OPERATIONS_LOOP_AFTER_OPERATIONS  # If it didn't surpass the threshold, finish this part of loop %
00000bea : 00051023;   % 498:                     sh zero,0(a0)  # Resets render counter %
00000beb : 00051123;   % 499:                     sh zero,2(a0)  # Disables loot %
00000bec : 00012483;   % 504:             lw s1,0(sp) %
00000bed : 00412903;   % 505:             lw s2,4(sp) %
00000bee : 00812983;   % 506:             lw s3,8(sp) %
00000bef : 00c12a03;   % 507:             lw s4,12(sp) %
00000bf0 : 01012503;   % 508:             lw a0,16(sp) %
00000bf1 : 01412583;   % 509:             lw a1,20(sp) %
00000bf2 : 01812603;   % 510:             lw a2,24(sp) %
00000bf3 : 01c12683;   % 511:             lw a3,28(sp) %
00000bf4 : 02012203;   % 512:             lw tp,32(sp) %
00000bf5 : 02410113;   % 513:             addi sp,sp,36 %
00000bf6 : 00a50513;   % 517:             addi a0,a0,10  # Going to the next bomb's address                                   %
00000bf7 : 00160613;   % 518:             addi a2,a2,1               # Iterating counter by 1                                    %
00000bf8 : 00b65463;   % 519:             bge a2,a1, END_LOOT_OPERATIONS_LOOP # If all of the bombs were checked, end loop (don't attack)                                 %
00000bf9 : efdff06f;   % 520:             j LOOT_OPERATIONS_LOOP # otherwise, go back to the loop's beginning  %
00000bfa : 00012083;   % 524:         lw ra,0(sp) %
00000bfb : 00410113;   % 525:         addi sp,sp,4 %
00000bfc : 00008067;   % 527:         ret %
00000bfd : 00a00e33;   % 557:     mv t3, a0  # Moves explosion type to t3 %
00000bfe : 00b00eb3;   % 558:     mv t4, a1  # Moves X offset to t4 %
00000bff : 00c00f33;   % 559:     mv t5, a2  # Moves Y offset to t5 %
00000c00 : 0fc0f517;   % 561:     la a0, EXPLOSION_ARRAY      # Loads EXPLOSION array %
00000c01 : 19650513;   % 561:  %
00000c02 : 00800593;   % 563:     li a1, 8     # Loads total number of explosions %
00000c03 : 00000613;   % 564:     li a2,0                     # Resets counter %
00000c04 : 00054283;   % 566:         lbu t0, 0(a0)       # Loads enable byte %
00000c05 : 00028463;   % 567:         beqz t0, EXPLOSION_SPAWN_LOOP_ACTIVATE # If current explosion is disabled, activate it %
00000c06 : 0340006f;   % 568:             j NEXT_IN_EXPLOSION_SPAWN_LOOP     # Otherwise, go to next one in loop %
00000c07 : 00100293;   % 571:             li t0,1          # Loads 1 (Enabled)  %
00000c08 : 00550023;   % 572:             sb t0,0(a0)      # stores in explosion's enable byte %
00000c09 : 01c500a3;   % 574:             sb t3,1(a0)      # Stores explosion's type (0 - Small, 1 - Big) %
00000c0a : 01d501a3;   % 576:             sb t4, 3(a0)     # Stores explosion's X offset %
00000c0b : 01e50223;   % 577:             sb t5, 4(a0)     # Stores explosion's Y offset %
00000c0c : 00d502a3;   % 579:             sb a3, 5(a0)     # Stores explosion's X  %
00000c0d : 00d50323;   % 580:             sb a3, 6(a0)     # Stores explosion's old X  %
00000c0e : 00e503a3;   % 582:             sb a4, 7(a0)     # Stores explosion's Y  %
00000c0f : 00e50423;   % 583:             sb a4, 8(a0)     # Stores explosion's old Y    %
00000c10 : 40f007b3;   % 585:             neg a5,a5        # If a5 > 0, a5 < 0 %
00000c11 : 00f50123;   % 586:             sb a5,2(a0)      # Sets counter (0 - normal / negative for delay) %
00000c12 : 0140006f;   % 587:             j END_EXPLOSION_SPAWN_LOOP # Break Loop        %
00000c13 : 00950513;   % 590:             addi a0,a0,9      # Going to the next explosion address                                   %
00000c14 : 00160613;   % 591:             addi a2,a2,1                   # Iterating counter by 1                                    %
00000c15 : 00b65463;   % 592:             bge a2,a1, END_EXPLOSION_SPAWN_LOOP # If all of the explosions were checked, end loop (don't spawn explosion)                                 %
00000c16 : fb9ff06f;   % 593:             j EXPLOSION_SPAWN_LOOP # otherwise, go back to the loop's beginning  %
00000c17 : 00008067;   % 597:         ret         %
00000c18 : ffc10113;   % 615:     addi sp,sp,-4 %
00000c19 : 00112023;   % 616:     sw ra,0(sp) %
00000c1a : 0fc0f217;   % 618:     la tp, CURRENT_MAP  # Loads CURRENT_MAP address %
00000c1b : 09820213;   % 618:  %
00000c1c : 0fc0f517;   % 620:     la a0,EXPLOSION_ARRAY   # Loads explosions array %
00000c1d : 12650513;   % 620:  %
00000c1e : 00000613;   % 622:     li a2,0                 # resets counter %
00000c1f : 00800593;   % 623:     li a1,8  # gets number of explosions in game %
00000c20 : 00054383;   % 625:         lbu t2,0(a0) # Loads enable byte %
00000c21 : 00039463;   % 626:         bnez t2,EXPLOSIONS_OPERATIONS_LOOP_CONTINUE    # If enabled, %
00000c22 : 1f40006f;   % 627:             j NEXT_IN_EXPLOSIONS_OPERATIONS_LOOP       # Otherwise, check other explosions %
00000c23 : fdc10113;   % 632:             addi sp,sp,-36 %
00000c24 : 00912023;   % 633:             sw s1,0(sp) %
00000c25 : 01212223;   % 634:             sw s2,4(sp) %
00000c26 : 01312423;   % 635:             sw s3,8(sp) %
00000c27 : 01412623;   % 636:             sw s4,12(sp) %
00000c28 : 00a12823;   % 637:             sw a0,16(sp) %
00000c29 : 00b12a23;   % 638:             sw a1,20(sp) %
00000c2a : 00c12c23;   % 639:             sw a2,24(sp) %
00000c2b : 00d12e23;   % 640:             sw a3,28(sp) %
00000c2c : 02412023;   % 641:             sw tp,32(sp) %
00000c2d : 00554583;   % 646:             lbu a1,5(a0) # Loads explosion's current X %
00000c2e : 00624283;   % 647:             lbu t0,6(tp) # Loads map's current X %
00000c2f : 405585b3;   % 648:             sub a1,a1,t0 # Gets the X matrix related to the map's X (a1 = explosion's X - map's X) %
00000c30 : 00459593;   % 649:             slli a1,a1,4 # Multiplies a5 by 16 in order to get X related to screen %
00000c31 : 00354283;   % 650:             lbu t0,3(a0) # Loads explosion's X offset %
00000c32 : 005585b3;   % 651:             add a1,a1,t0 # Adds offset to position %
00000c33 : 00824283;   % 652:             lbu t0,8(tp) # Loads map's X offset %
00000c34 : 405585b3;   % 653:             sub a1,a1,t0 # and takes it from explosion's position %
00000c35 : 00754603;   % 657:             lbu a2,7(a0) # Loads explosion's current Y %
00000c36 : 00724303;   % 658:             lbu t1,7(tp) # Loads map's current Y %
00000c37 : 40660633;   % 659:             sub a2,a2,t1 # Gets the Y matrix related to the map's Y (a2 = explosion's Y - map's Y) %
00000c38 : 00461613;   % 660:             slli a2,a2,4 # Multiplies a2 by 16 in order to get Y related to screen %
00000c39 : 00454283;   % 661:             lbu t0,4(a0) # Loads explosion's Y offset %
00000c3a : 00560633;   % 662:             add a2,a2,t0 # Adds offset to position %
00000c3b : 00924303;   % 663:             lbu t1,9(tp) # Loads map's Y offset %
00000c3c : 40660633;   % 664:             sub a2,a2,t1 # and takes it from explosion's position %
00000c3d : 00460613;   % 665:             addi a2,a2,4 # Offsets sprite a little bit %
00000c3e : 008007b3;   % 667:             mv a5,s0          # gets frame to be rendered on %
00000c3f : 00000893;   % 668:             li a7,0             # Normal render %
00000c40 : 00154283;   % 670:             lbu t0,1(a0)      # Loads explosion type %
00000c41 : 06029e63;   % 671:             bnez t0,EXPLOSIONS_OPERATIONS_LOOP_RENDER_BIG  # If it's a big explosion %
00000c42 : 00250283;   % 673:                 lb t0,2(a0)      # Gets number of times that it was rendered (counter) %
00000c43 : 0402c863;   % 674:                 blt t0,zero,AFTER_EXPLOSIONS_OPERATIONS_LOOP_RENDER_SMALL  # If it has a delay %
00000c44 : 00029e63;   % 675:                 bnez t0,EXPLOSIONS_OPERATIONS_LOOP_RENDER_SMALL_NOT_0  # If not on state 0 %
00000c45 : 0fc1d517;   % 677:                     la a0, Explosions_1   # Small explosion sprite %
00000c46 : 66850513;   % 677:  %
00000c47 : 01000693;   % 678:                     li a3,16      # 16 = width of rendering area %
00000c48 : 01000713;   % 679:                     li a4,16      # 16 = height of rendering area %
00000c49 : 00100813;   % 680:                     li a6, 1             # Small explosion section %
00000c4a : 02c0006f;   % 681:                     j START_EXPLOSIONS_OPERATIONS_LOOP_RENDER_SMALL # Render %
00000c4b : 00100313;   % 683:                 EXPLOSIONS_OPERATIONS_LOOP_RENDER_SMALL_NOT_0:  li t1,1 %
00000c4c : 00629463;   % 684:                 bne t0,t1,EXPLOSIONS_OPERATIONS_LOOP_RENDER_SMALL_NOT_1  # If not on state 1 %
00000c4d : 0280006f;   % 686:                     j AFTER_EXPLOSIONS_OPERATIONS_LOOP_RENDER_SMALL # Skip render %
00000c4e : 0fc1e517;   % 690:                     la a0, Explosions_2   # Big explosion sprite %
00000c4f : 84450513;   % 690:  %
00000c50 : ff858593;   % 691:                     addi a1,a1,-8        # Offsetting sprite %
00000c51 : ff860613;   % 692:                     addi a2,a2,-8        # Offsetting sprite %
00000c52 : 02000693;   % 693:                     li a3,32             # 32 = width of rendering area %
00000c53 : 02000713;   % 694:                     li a4,32             # 32 = height of rendering area %
00000c54 : 00000813;   % 695:                     li a6, 0             # There's only one sprite for it %
00000c55 : fffff317;   % 699:                     call RENDER_ENTITY  # Renders it %
00000c56 : d18300e7;   % 699:  %
00000c57 : 01012503;   % 702:                     lw a0,16(sp)    # Restores a0 %
00000c58 : 00250283;   % 703:                     lb t0,2(a0)     # Gets number of times that it was rendered (counter) %
00000c59 : 00128293;   % 704:                     addi t0,t0,1    # iterates it %
00000c5a : 00550123;   % 705:                     sb t0,2(a0)     # and stores it back %
00000c5b : 00300313;   % 706:                     li t1,3  # Loads number of times small explosion should render before being disabled %
00000c5c : 0e62c263;   % 707:                     blt t0,t1,EXPLOSIONS_OPERATIONS_LOOP_AFTER_OPERATIONS  # If it didn't surpass the threshold, finish this part of loop %
00000c5d : 00050023;   % 709:                         sb zero,0(a0)  # Disables explosion %
00000c5e : 00050123;   % 710:                         sb zero,2(a0)  # Resets render counter %
00000c5f : 0d80006f;   % 711:                         j EXPLOSIONS_OPERATIONS_LOOP_AFTER_OPERATIONS %
00000c60 : 00250283;   % 715:                 lb t0,2(a0)      # Gets number of times that it was rendered (counter) %
00000c61 : 0a02c863;   % 716:                 blt t0,zero,AFTER_EXPLOSIONS_OPERATIONS_LOOP_RENDER_BIG  # If it has a delay %
00000c62 : 00029e63;   % 717:                 bnez t0,EXPLOSIONS_OPERATIONS_LOOP_RENDER_BIG_NOT_0  # If not on state 0 %
00000c63 : 0fc1d517;   % 719:                     la a0, Explosions_1   # Small explosion sprite %
00000c64 : 5f050513;   % 719:  %
00000c65 : 01000693;   % 720:                     li a3, 16     # 16 = width of rendering area %
00000c66 : 01000713;   % 721:                     li a4, 16     # 16 = height of rendering area %
00000c67 : 00000813;   % 722:                     li a6, 0             # Bomb exploding section %
00000c68 : 08c0006f;   % 723:                     j START_EXPLOSIONS_OPERATIONS_LOOP_RENDER_BIG # Render %
00000c69 : 00100313;   % 725:                 EXPLOSIONS_OPERATIONS_LOOP_RENDER_BIG_NOT_0:  li t1,1 %
00000c6a : 00629463;   % 726:                 bne t0,t1,EXPLOSIONS_OPERATIONS_LOOP_RENDER_BIG_NOT_1  # If not on state 1 %
00000c6b : 0880006f;   % 728:                     j AFTER_EXPLOSIONS_OPERATIONS_LOOP_RENDER_BIG # Skips render %
00000c6c : 00200313;   % 730:                 EXPLOSIONS_OPERATIONS_LOOP_RENDER_BIG_NOT_1: li t1,2 %
00000c6d : 00629e63;   % 731:                 bne t0,t1,EXPLOSIONS_OPERATIONS_LOOP_RENDER_BIG_NOT_2  # If not on state 2 %
00000c6e : 0fc1d517;   % 733:                     la a0, Explosions_1   # Small explosion sprite %
00000c6f : 5c450513;   % 733:  %
00000c70 : 01000693;   % 734:                     li a3, 16     # 16 = width of rendering area %
00000c71 : 01000713;   % 735:                     li a4, 16     # 16 = height of rendering area %
00000c72 : 00100813;   % 736:                     li a6, 1             # Small explosion section %
00000c73 : 0600006f;   % 737:                     j START_EXPLOSIONS_OPERATIONS_LOOP_RENDER_BIG # Render %
00000c74 : 00300313;   % 739:                 EXPLOSIONS_OPERATIONS_LOOP_RENDER_BIG_NOT_2:  li t1,3 %
00000c75 : 00629463;   % 740:                 bne t0,t1,EXPLOSIONS_OPERATIONS_LOOP_RENDER_BIG_NOT_3  # If not on state 3 %
00000c76 : 05c0006f;   % 742:                     j AFTER_EXPLOSIONS_OPERATIONS_LOOP_RENDER_BIG # Skips render %
00000c77 : 00400313;   % 744:                 EXPLOSIONS_OPERATIONS_LOOP_RENDER_BIG_NOT_3: li t1,4 %
00000c78 : 02629263;   % 745:                 bne t0,t1,EXPLOSIONS_OPERATIONS_LOOP_RENDER_BIG_NOT_4  # If not on state 4 %
00000c79 : 0fc1d517;   % 747:                     la a0, Explosions_2   # Big explosion sprite %
00000c7a : 79850513;   % 747:  %
00000c7b : ff858593;   % 748:                     addi a1,a1,-8        # Offsetting sprite %
00000c7c : ff860613;   % 749:                     addi a2,a2,-8        # Offsetting sprite %
00000c7d : 02000693;   % 750:                     li a3,32             # 32 = width of rendering area %
00000c7e : 02000713;   % 751:                     li a4,32             # 32 = height of rendering area %
00000c7f : 00000813;   % 752:                     li a6, 0             # There's only one sprite for it %
00000c80 : 02c0006f;   % 753:                     j START_EXPLOSIONS_OPERATIONS_LOOP_RENDER_BIG # Render %
00000c81 : 00500313;   % 755:                 EXPLOSIONS_OPERATIONS_LOOP_RENDER_BIG_NOT_4:  li t1,5 %
00000c82 : 00629463;   % 756:                 bne t0,t1,EXPLOSIONS_OPERATIONS_LOOP_RENDER_BIG_NOT_5  # If not on state 5 %
00000c83 : 0280006f;   % 758:                     j AFTER_EXPLOSIONS_OPERATIONS_LOOP_RENDER_BIG # Skips render %
00000c84 : 0fc1d517;   % 762:                     la a0, Explosions_2   # Big explosion sprite %
00000c85 : 76c50513;   % 762:  %
00000c86 : ff858593;   % 763:                     addi a1,a1,-8        # Offsetting sprite %
00000c87 : ff860613;   % 764:                     addi a2,a2,-8        # Offsetting sprite %
00000c88 : 02000693;   % 765:                     li a3,32             # 32 = width of rendering area %
00000c89 : 02000713;   % 766:                     li a4,32             # 32 = height of rendering area %
00000c8a : 00000813;   % 767:                     li a6, 0             # There's only one sprite for it %
00000c8b : fffff317;   % 771:                     call RENDER_ENTITY  # Renders it %
00000c8c : c40300e7;   % 771:  %
00000c8d : 01012503;   % 774:                     lw a0,16(sp)    # Restores a0 %
00000c8e : 00250283;   % 775:                     lb t0,2(a0)    # Gets number of times that it was rendered (counter) %
00000c8f : 00128293;   % 776:                     addi t0,t0,1    # iterates it %
00000c90 : 00550123;   % 777:                     sb t0,2(a0)     # and stores it back %
00000c91 : 00700313;   % 778:                     li t1,7  # Loads number of times big explosion should render before being disabled %
00000c92 : 0062c663;   % 779:                     blt t0,t1,EXPLOSIONS_OPERATIONS_LOOP_AFTER_OPERATIONS  # If it didn't surpass the threshold, finish this part of loop %
00000c93 : 00050023;   % 781:                         sb zero,0(a0)  # Disables explosion %
00000c94 : 00050123;   % 782:                         sb zero,2(a0)  # Resets render counter %
00000c95 : 00012483;   % 787:             lw s1,0(sp) %
00000c96 : 00412903;   % 788:             lw s2,4(sp) %
00000c97 : 00812983;   % 789:             lw s3,8(sp) %
00000c98 : 00c12a03;   % 790:             lw s4,12(sp) %
00000c99 : 01012503;   % 791:             lw a0,16(sp) %
00000c9a : 01412583;   % 792:             lw a1,20(sp) %
00000c9b : 01812603;   % 793:             lw a2,24(sp) %
00000c9c : 01c12683;   % 794:             lw a3,28(sp) %
00000c9d : 02012203;   % 795:             lw tp,32(sp) %
00000c9e : 02410113;   % 796:             addi sp,sp,36 %
00000c9f : 00950513;   % 800:             addi a0,a0,9  # Going to the next bomb's address                                   %
00000ca0 : 00160613;   % 801:             addi a2,a2,1               # Iterating counter by 1                                    %
00000ca1 : 00b65463;   % 802:             bge a2,a1, END_EXPLOSIONS_OPERATIONS_LOOP # If all of the bombs were checked, end loop (don't attack)                                 %
00000ca2 : df9ff06f;   % 803:             j EXPLOSIONS_OPERATIONS_LOOP # otherwise, go back to the loop's beginning  %
00000ca3 : 00012083;   % 807:         lw ra,0(sp) %
00000ca4 : 00410113;   % 808:         addi sp,sp,4 %
00000ca5 : 00008067;   % 810:         ret %
00000ca6 : ffc10113;   % 10:     addi sp,sp,-4 %
00000ca7 : 00112023;   % 11:     sw ra,0(sp) %
00000ca8 : 0fc0f297;   % 13:     la t0,CURRENT_MAP             # Loads map address %
00000ca9 : e6028293;   % 13:  %
00000caa : 0042c283;   % 14:     lbu t0,4(t0)                  # and from it, loads map's number %
00000cab : 00700313;   % 15:     li t1,7                       # Loads 7 to compare with map's number %
00000cac : 02629063;   % 16:     bne t0,t1,SKIP_RIDLEY         # If not on map 7, skip Ridley >:D %
00000cad : 00000317;   % 17:         call RIDLEY_OPERATIONS    # Checks Ridley %
00000cae : 3f0300e7;   % 17:  %
00000caf : 00000317;   % 19:         call PLASMA_BREATH_OPERATIONS  # Checks Plasma Breaths (ITS.TEDIOUS.TO.KEEP.WRITING.PLASMA.BREATH.EVERY.TIME.I.CANT.TAKE.IT.ANYMOREEEE) %
00000cb0 : 630300e7;   % 19:  %
00000cb1 : 00012083;   % 21:             lw ra,0(sp) %
00000cb2 : 00410113;   % 22:             addi sp,sp,4 %
00000cb3 : 00008067;   % 24:         ret %
00000cb4 : 00000317;   % 26:     call ZOOMER_OPERATIONS        # Checks zoomers %
00000cb5 : 01c300e7;   % 26:  %
00000cb6 : 00000317;   % 28:     call RIPPER_OPERATIONS        # Checks rippers %
00000cb7 : 270300e7;   % 28:  %
00000cb8 : 00012083;   % 30:     lw ra,0(sp) %
00000cb9 : 00410113;   % 31:     addi sp,sp,4 %
00000cba : 00008067;   % 33: ret %
00000cbb : ffc10113;   % 51:     addi sp,sp,-4 %
00000cbc : 00112023;   % 52:     sw ra,0(sp) %
00000cbd : 0fc0f517;   % 54:     la a0,Zoomers  # Loads Zoomers address %
00000cbe : f4450513;   % 54:  %
00000cbf : 0fc0f217;   % 55:     la tp, CURRENT_MAP # Loads CURRENT_MAP address %
00000cc0 : e0420213;   % 55:  %
00000cc1 : 00052503;   % 57:     lw a0,0(a0)    # Loads the ZoomersA address over the Zoomers address %
00000cc2 : 00051463;   % 58:     bnez a0,CONTINUE_ZOOMER_OPERATIONS  # If there are zoomers in this map %
00000cc3 : 2300006f;   % 59:         j END_ZOOMER_OPERATIONS_LOOP    # If a0 = 0, there are no zoomers in this map %
00000cc4 : 00054583;   % 63:     lbu a1,0(a0)   # Loads number of Zoomers in current map %
00000cc5 : 00000613;   % 65:     li a2,0        # Counter for zoomers %
00000cc6 : 00150513;   % 66:     addi a0,a0,1   # Goes to next byte (where zoomers from current map start) %
00000cc7 : 00050283;   % 68:         lb t0,0(a0) # Loads zoomer's health %
00000cc8 : 00504463;   % 69:         blt zero,t0,CONTINUE_ZOOMER_OPERATIONS_LOOP # If zoomer is alive %
00000cc9 : 2080006f;   % 71:             j NEXT_IN_ZOOMER_OPERATIONS_LOOP %
00000cca : 00624283;   % 74:         lbu t0,6(tp) # Loads map's current X %
00000ccb : 00454783;   % 75:         lbu a5,4(a0) # Loads zoomer's current X %
00000ccc : 00400393;   % 76:         li t2,4  # Loads 4 (render distance) %
00000ccd : 40728e33;   % 77:         sub t3,t0,t2 # Gets leftmost threshold to manage zoomer %
00000cce : 1fc7ca63;   % 79:         blt a5,t3,NEXT_IN_ZOOMER_OPERATIONS_LOOP # If zoomer's X isn't inside left border, go to next %
00000ccf : 00728e33;   % 81:         add t3,t0,t2 # Calculate rightmost threshold to manage zoomer %
00000cd0 : 014e0e13;   % 82:         addi t3,t3,20 # finishing calculating threshold %
00000cd1 : 1fc7d463;   % 83:         bge a5,t3,NEXT_IN_ZOOMER_OPERATIONS_LOOP # If zoomer's X isn't inside right border, go to next %
00000cd2 : 00724303;   % 86:         lbu t1,7(tp) # Loads map's current Y %
00000cd3 : 00654703;   % 87:         lbu a4,6(a0) # Loads zoomer's current Y %
00000cd4 : 40730e33;   % 89:         sub t3,t1,t2 # Gets uppermost threshold to manage zoomer %
00000cd5 : 1dc74c63;   % 90:         blt a4,t3,NEXT_IN_ZOOMER_OPERATIONS_LOOP # If zoomer's X isn't inside upper border, go to next %
00000cd6 : 00730e33;   % 92:         add t3,t1,t2 # Calculate lowermost threshold to manage zoomer %
00000cd7 : 00fe0e13;   % 93:         addi t3,t3,15 # finishing calculating threshold %
00000cd8 : 1dc75663;   % 94:         bge a4,t3,NEXT_IN_ZOOMER_OPERATIONS_LOOP # If zoomer's X isn't inside lower border, go to next %
00000cd9 : fdc10113;   % 98:             addi sp,sp,-36 %
00000cda : 00912023;   % 99:             sw s1,0(sp) %
00000cdb : 01212223;   % 100:             sw s2,4(sp) %
00000cdc : 01312423;   % 101:             sw s3,8(sp) %
00000cdd : 01412623;   % 102:             sw s4,12(sp) %
00000cde : 00a12823;   % 103:             sw a0,16(sp) %
00000cdf : 00b12a23;   % 104:             sw a1,20(sp) %
00000ce0 : 00c12c23;   % 105:             sw a2,24(sp) %
00000ce1 : 00d12e23;   % 106:             sw a3,28(sp) %
00000ce2 : 02412023;   % 107:             sw tp,32(sp) %
00000ce3 : 00022583;   % 111:             lw a1,0(tp) %
00000ce4 : 00005317;   % 112:             call MOVE_ZOOMER %
00000ce5 : 060300e7;   % 112:  %
00000ce6 : 01012503;   % 115:             lw a0,16(sp) # Gets a0 from stack again %
00000ce7 : 02012203;   % 116:             lw tp,32(sp) # Gets tp from stack again %
00000ce8 : 00454583;   % 117:             lbu a1,4(a0) # Loads zoomer's current X %
00000ce9 : 00624283;   % 118:             lbu t0,6(tp) # Loads map's current X %
00000cea : 405585b3;   % 119:             sub a1,a1,t0 # Gets the X matrix related to the map's X (a1 = zoomer's X - map's X) %
00000ceb : 00459593;   % 120:             slli a1,a1,4 # Multiplies a5 by 16 in order to get X related to screen %
00000cec : 00254283;   % 121:             lbu t0,2(a0) # Loads zoomer's X offset %
00000ced : 005585b3;   % 122:             add a1,a1,t0 # Adds offset to position %
00000cee : 00824283;   % 123:             lbu t0,8(tp) # Loads map's X offset %
00000cef : 405585b3;   % 124:             sub a1,a1,t0 # and takes it from zoomer's position %
00000cf0 : 00654603;   % 128:             lbu a2,6(a0) # Loads zoomer's current Y %
00000cf1 : 00724303;   % 129:             lbu t1,7(tp) # Loads map's current Y %
00000cf2 : 40660633;   % 130:             sub a2,a2,t1 # Gets the Y matrix related to the map's Y (a2 = zoomer's Y - map's Y) %
00000cf3 : 00461613;   % 131:             slli a2,a2,4 # Multiplies a2 by 16 in order to get Y related to screen %
00000cf4 : 00354283;   % 132:             lbu t0,3(a0) # Loads zoomer's Y offset %
00000cf5 : 00560633;   % 133:             add a2,a2,t0 # Adds offset to position %
00000cf6 : 00924303;   % 134:             lbu t1,9(tp) # Loads map's Y offset %
00000cf7 : 40660633;   % 135:             sub a2,a2,t1 # and takes it from zoomer's position %
00000cf8 : 01000693;   % 137:             li a3,16   # 16 = width of rendering area %
00000cf9 : 01000713;   % 138:             li a4,16   # 16 = height of rendering area %
00000cfa : 008007b3;   % 139:             mv a5,s0          # gets frame to be rendered on %
00000cfb : 00854803;   % 141:             lbu a6,8(a0)      # Loads zoomer's status is its direction %
00000cfc : 00184813;   % 142:             xori a6,a6,1      # switches it %
00000cfd : 01050423;   % 143:             sb a6,8(a0)       # and stores it back for using next time %
00000cfe : 00154283;   % 145:             lbu t0,1(a0)      # gets zoomer's type number %
00000cff : 00a54303;   % 146:             lbu t1,10(a0)     # gets zoomer's platform %
00000d00 : 02031e63;   % 148:             bnez t1,ZOOMER_OPERATIONS_LOOP_TRY_LEFT %
00000d01 : 00029863;   % 150:                 bnez t0,ZOOMER_OPERATIONS_LOOP_DOWN_NOT_NORMAL %
00000d02 : 0fc1e517;   % 152:                     la a0,Zoomer_Down %
00000d03 : 57450513;   % 152:  %
00000d04 : 0e40006f;   % 153:                     j ZOOMER_OPERATIONS_LOOP_RENDER %
00000d05 : 00100393;   % 154:                 ZOOMER_OPERATIONS_LOOP_DOWN_NOT_NORMAL:li t2,1 %
00000d06 : 00729863;   % 155:                 bne t0,t2,ZOOMER_OPERATIONS_LOOP_DOWN_DAMAGE %
00000d07 : 0fc1f517;   % 157:                     la a0,Zoomer_Variant_Down %
00000d08 : d6050513;   % 157:  %
00000d09 : 0d00006f;   % 158:                     j ZOOMER_OPERATIONS_LOOP_RENDER %
00000d0a : ffe28293;   % 161:                     addi t0,t0,-2 # Reverts its sprite back to normal %
00000d0b : 005500a3;   % 162:                     sb t0,1(a0)   # and stores it back %
00000d0c : 0fc1f517;   % 163:                     la a0,Zoomer_Damage_Down %
00000d0d : 54c50513;   % 163:  %
00000d0e : 0bc0006f;   % 164:                     j ZOOMER_OPERATIONS_LOOP_RENDER %
00000d0f : 00100393;   % 166:             ZOOMER_OPERATIONS_LOOP_TRY_LEFT: li t2,1 %
00000d10 : 02731e63;   % 167:             bne t1,t2,ZOOMER_OPERATIONS_LOOP_TRY_UP %
00000d11 : 00029863;   % 169:                 bnez t0,ZOOMER_OPERATIONS_LOOP_LEFT_NOT_NORMAL %
00000d12 : 0fc1e517;   % 171:                     la a0,Zoomer_Left %
00000d13 : 73450513;   % 171:  %
00000d14 : 0a40006f;   % 172:                     j ZOOMER_OPERATIONS_LOOP_RENDER %
00000d15 : 00100393;   % 173:                 ZOOMER_OPERATIONS_LOOP_LEFT_NOT_NORMAL:li t2,1 %
00000d16 : 00729863;   % 174:                 bne t0,t2,ZOOMER_OPERATIONS_LOOP_LEFT_DAMAGE %
00000d17 : 0fc1f517;   % 176:                     la a0,Zoomer_Variant_Left %
00000d18 : f2050513;   % 176:  %
00000d19 : 0900006f;   % 177:                     j ZOOMER_OPERATIONS_LOOP_RENDER %
00000d1a : ffe28293;   % 180:                     addi t0,t0,-2 # Reverts its sprite back to normal %
00000d1b : 005500a3;   % 181:                     sb t0,1(a0)   # and stores it back %
00000d1c : 0fc1f517;   % 182:                     la a0,Zoomer_Damage_Left %
00000d1d : 70c50513;   % 182:  %
00000d1e : 07c0006f;   % 183:                     j ZOOMER_OPERATIONS_LOOP_RENDER %
00000d1f : 00200393;   % 185:             ZOOMER_OPERATIONS_LOOP_TRY_UP: li t2,2 %
00000d20 : 02731e63;   % 186:             bne t1,t2,ZOOMER_OPERATIONS_LOOP_RIGHT %
00000d21 : 00029863;   % 188:                 bnez t0,ZOOMER_OPERATIONS_LOOP_UP_NOT_NORMAL %
00000d22 : 0fc1f517;   % 190:                     la a0,Zoomer_Up %
00000d23 : 8f450513;   % 190:  %
00000d24 : 0640006f;   % 191:                     j ZOOMER_OPERATIONS_LOOP_RENDER %
00000d25 : 00100393;   % 192:                 ZOOMER_OPERATIONS_LOOP_UP_NOT_NORMAL:li t2,1 %
00000d26 : 00729863;   % 193:                 bne t0,t2,ZOOMER_OPERATIONS_LOOP_UP_DAMAGE %
00000d27 : 0fc1f517;   % 195:                     la a0,Zoomer_Variant_Up %
00000d28 : 0e050513;   % 195:  %
00000d29 : 0500006f;   % 196:                     j ZOOMER_OPERATIONS_LOOP_RENDER %
00000d2a : ffe28293;   % 199:                     addi t0,t0,-2 # Reverts its sprite back to normal %
00000d2b : 005500a3;   % 200:                     sb t0,1(a0)   # and stores it back %
00000d2c : 0fc20517;   % 201:                     la a0,Zoomer_Damage_Up %
00000d2d : 8cc50513;   % 201:  %
00000d2e : 03c0006f;   % 202:                     j ZOOMER_OPERATIONS_LOOP_RENDER %
00000d2f : 00029863;   % 206:                 bnez t0,ZOOMER_OPERATIONS_LOOP_RIGHT_NOT_NORMAL %
00000d30 : 0fc1f517;   % 208:                     la a0,Zoomer_Right %
00000d31 : abc50513;   % 208:  %
00000d32 : 02c0006f;   % 209:                     j ZOOMER_OPERATIONS_LOOP_RENDER %
00000d33 : 00100393;   % 210:                 ZOOMER_OPERATIONS_LOOP_RIGHT_NOT_NORMAL:li t2,1 %
00000d34 : 00729863;   % 211:                 bne t0,t2,ZOOMER_OPERATIONS_LOOP_RIGHT_DAMAGE %
00000d35 : 0fc1f517;   % 213:                     la a0,Zoomer_Variant_Right %
00000d36 : 2a850513;   % 213:  %
00000d37 : 0180006f;   % 214:                     j ZOOMER_OPERATIONS_LOOP_RENDER %
00000d38 : ffe28293;   % 217:                     addi t0,t0,-2 # Reverts its sprite back to normal %
00000d39 : 005500a3;   % 218:                     sb t0,1(a0)   # and stores it back %
00000d3a : 0fc20517;   % 219:                     la a0,Zoomer_Damage_Right %
00000d3b : a9450513;   % 219:  %
00000d3c : 0040006f;   % 220:                     j ZOOMER_OPERATIONS_LOOP_RENDER %
00000d3d : 00000893;   % 223:                 li a7,0             # Normal render %
00000d3e : fffff317;   % 224:                 call RENDER_ENTITY  # Renders it %
00000d3f : 974300e7;   % 224:  %
00000d40 : 0040006f;   % 225:                 j ZOOMER_OPERATIONS_LOOP_AFTER_OPERATIONS %
00000d41 : 00012483;   % 233:             lw s1,0(sp) %
00000d42 : 00412903;   % 234:             lw s2,4(sp) %
00000d43 : 00812983;   % 235:             lw s3,8(sp) %
00000d44 : 00c12a03;   % 236:             lw s4,12(sp) %
00000d45 : 01012503;   % 237:             lw a0,16(sp) %
00000d46 : 01412583;   % 238:             lw a1,20(sp) %
00000d47 : 01812603;   % 239:             lw a2,24(sp) %
00000d48 : 01c12683;   % 240:             lw a3,28(sp) %
00000d49 : 02012203;   % 241:             lw tp,32(sp) %
00000d4a : 02410113;   % 242:             addi sp,sp,36 %
00000d4b : 00c50513;   % 246:             addi a0,a0,12  # Going to the next zoomer's address                                   %
00000d4c : 00160613;   % 247:             addi a2,a2,1            # Iterating counter by 1                                    %
00000d4d : 00b65463;   % 248:             bge a2,a1, END_ZOOMER_OPERATIONS_LOOP # If all of the zoomers were checked, end loop                                   %
00000d4e : de5ff06f;   % 249:             j ZOOMER_OPERATIONS_LOOP # otherwise, go back to the loop's beginning                      %
00000d4f : 00012083;   % 253:         lw ra,0(sp) %
00000d50 : 00410113;   % 254:         addi sp,sp,4 %
00000d51 : 00008067;   % 256:         ret %
00000d52 : ffc10113;   % 276:     addi sp,sp,-4 %
00000d53 : 00112023;   % 277:     sw ra,0(sp) %
00000d54 : 0fc0f517;   % 280:     la a0,Rippers  # Loads Rippers address %
00000d55 : ea850513;   % 280:  %
00000d56 : 0fc0f217;   % 281:     la tp, CURRENT_MAP # Loads CURRENT_MAP address %
00000d57 : ba820213;   % 281:  %
00000d58 : 00052503;   % 283:     lw a0,0(a0)    # Loads the RippersA address over the Rippers address %
00000d59 : 00051463;   % 284:     bnez a0,CONTINUE_RIPPER_OPERATIONS    # If there are rippers in this map %
00000d5a : 1300006f;   % 285:         j END_RIPPER_OPERATIONS_LOOP      # If a0 = 0, there are no rippers in this map %
00000d5b : 00054583;   % 289:     lbu a1,0(a0)   # Loads number of Rippers in current map %
00000d5c : 00000613;   % 291:     li a2,0        # Counter for rippers %
00000d5d : 00150513;   % 292:     addi a0,a0,1   # Goes to next byte (where rippers from current map start) %
00000d5e : 00624283;   % 295:         lbu t0,6(tp) # Loads map's current X %
00000d5f : 00354783;   % 296:         lbu a5,3(a0) # Loads ripper's current X %
00000d60 : 00400393;   % 297:         li t2,4  # Loads 4 (render distance) %
00000d61 : 40728e33;   % 298:         sub t3,t0,t2 # Gets leftmost threshold to manage ripper %
00000d62 : 11c7c063;   % 299:         blt a5,t3,NEXT_IN_RIPPER_OPERATIONS_LOOP # If ripper's X isn't inside left border, go to next %
00000d63 : 00728e33;   % 301:         add t3,t0,t2 # Calculate rightmost threshold to manage ripper %
00000d64 : 014e0e13;   % 302:         addi t3,t3,20 # finishing calculating threshold %
00000d65 : 0fc7da63;   % 303:         bge a5,t3,NEXT_IN_RIPPER_OPERATIONS_LOOP # If ripper's X isn't inside right border, go to next %
00000d66 : 00724303;   % 306:         lbu t1,7(tp) # Loads map's current Y %
00000d67 : 00554703;   % 307:         lbu a4,5(a0) # Loads ripper's current Y %
00000d68 : 40730e33;   % 309:         sub t3,t1,t2 # Gets uppermost threshold to manage ripper %
00000d69 : 0fc74263;   % 310:         blt a4,t3,NEXT_IN_RIPPER_OPERATIONS_LOOP # If ripper's X isn't inside upper border, go to next %
00000d6a : 00730e33;   % 312:         add t3,t1,t2 # Calculate lowermost threshold to manage ripper %
00000d6b : 00fe0e13;   % 313:         addi t3,t3,15 # finishing calculating threshold %
00000d6c : 0dc75c63;   % 314:         bge a4,t3,NEXT_IN_RIPPER_OPERATIONS_LOOP # If ripper's X isn't inside lower border, go to next %
00000d6d : fdc10113;   % 318:             addi sp,sp,-36 %
00000d6e : 00912023;   % 319:             sw s1,0(sp) %
00000d6f : 01212223;   % 320:             sw s2,4(sp) %
00000d70 : 01312423;   % 321:             sw s3,8(sp) %
00000d71 : 01412623;   % 322:             sw s4,12(sp) %
00000d72 : 00a12823;   % 323:             sw a0,16(sp) %
00000d73 : 00b12a23;   % 324:             sw a1,20(sp) %
00000d74 : 00c12c23;   % 325:             sw a2,24(sp) %
00000d75 : 00d12e23;   % 326:             sw a3,28(sp) %
00000d76 : 02412023;   % 327:             sw tp,32(sp) %
00000d77 : 00022583;   % 331:             lw a1,0(tp) %
00000d78 : 00005317;   % 332:             call MOVE_RIPPER %
00000d79 : 370300e7;   % 332:  %
00000d7a : 01012503;   % 335:             lw a0,16(sp) # Gets a0 from stack again %
00000d7b : 02012203;   % 336:             lw tp,32(sp) # Gets tp from stack again %
00000d7c : 00354583;   % 337:             lbu a1,3(a0) # Loads ripper's current X %
00000d7d : 00624283;   % 338:             lbu t0,6(tp) # Loads map's current X %
00000d7e : 405585b3;   % 339:             sub a1,a1,t0 # Gets the X matrix related to the map's X (a1 = ripper's X - map's X) %
00000d7f : 00459593;   % 340:             slli a1,a1,4 # Multiplies a5 by 16 in order to get X related to screen %
00000d80 : 00254283;   % 341:             lbu t0,2(a0) # Loads ripper's X offset %
00000d81 : 005585b3;   % 342:             add a1,a1,t0 # Adds offset to position %
00000d82 : 00824283;   % 343:             lbu t0,8(tp) # Loads map's X offset %
00000d83 : 405585b3;   % 344:             sub a1,a1,t0 # and takes it from ripper's position %
00000d84 : 00554603;   % 348:             lbu a2,5(a0) # Loads ripper's current Y %
00000d85 : 00724303;   % 349:             lbu t1,7(tp) # Loads map's current Y %
00000d86 : 40660633;   % 350:             sub a2,a2,t1 # Gets the Y matrix related to the map's Y (a2 = ripper's Y - map's Y) %
00000d87 : 00461613;   % 351:             slli a2,a2,4 # Multiplies a2 by 16 in order to get Y related to screen %
00000d88 : 00924303;   % 353:             lbu t1,9(tp) # Loads map's Y offset %
00000d89 : 40660633;   % 354:             sub a2,a2,t1 # and takes it from ripper's position %
00000d8a : 01000693;   % 355:             li a3,16   # 16 = width of rendering area %
00000d8b : 01000713;   % 356:             li a4,16   # 16 = height of rendering area %
00000d8c : 008007b3;   % 357:             mv a5,s0          # gets frame to be rendered on %
00000d8d : 00154803;   % 358:             lbu a6,1(a0)      # ripper's status is its direction %
00000d8e : 00054503;   % 360:             lbu a0,0(a0)      # gets ripper's type number %
00000d8f : 00050863;   % 361:             beqz a0,RIPPER_OPERATIONS_LOOP_RENDER_NORMAL %
00000d90 : 0fc20517;   % 362:                 la a0,Ripper_Variant  # loads image address of red ripper %
00000d91 : d3c50513;   % 362:  %
00000d92 : 00c0006f;   % 363:                 j RIPPER_OPERATIONS_LOOP_RENDER %
00000d93 : 0fc20517;   % 365:                 la a0,Ripper  # loads image address of normal ripper %
00000d94 : b3050513;   % 365:  %
00000d95 : 00000893;   % 367:                 li a7,0             # Normal render %
00000d96 : fffff317;   % 368:                 call RENDER_ENTITY  # Renders it %
00000d97 : 814300e7;   % 368:  %
00000d98 : 00012483;   % 373:             lw s1,0(sp) %
00000d99 : 00412903;   % 374:             lw s2,4(sp) %
00000d9a : 00812983;   % 375:             lw s3,8(sp) %
00000d9b : 00c12a03;   % 376:             lw s4,12(sp) %
00000d9c : 01012503;   % 377:             lw a0,16(sp) %
00000d9d : 01412583;   % 378:             lw a1,20(sp) %
00000d9e : 01812603;   % 379:             lw a2,24(sp) %
00000d9f : 01c12683;   % 380:             lw a3,28(sp) %
00000da0 : 02012203;   % 381:             lw tp,32(sp) %
00000da1 : 02410113;   % 382:             addi sp,sp,36 %
00000da2 : 00750513;   % 386:             addi a0,a0,7  # Going to the next ripper's address                                   %
00000da3 : 00160613;   % 387:             addi a2,a2,1            # Iterating counter by 1                                    %
00000da4 : 00b65463;   % 388:             bge a2,a1, END_RIPPER_OPERATIONS_LOOP # If all of the rippers were checked, end loop                                   %
00000da5 : ee5ff06f;   % 389:             j RIPPER_OPERATIONS_LOOP # otherwise, go back to the loop's beginning                      %
00000da6 : 00012083;   % 393:         lw ra,0(sp) %
00000da7 : 00410113;   % 394:         addi sp,sp,4 %
00000da8 : 00008067;   % 396:         ret %
00000da9 : ffc10113;   % 414:     addi sp,sp,-4 %
00000daa : 00112023;   % 415:     sw ra,0(sp) %
00000dab : 0fc0f517;   % 418:     la a0,RIDLEY_INFO  # Loads Ridley's address %
00000dac : d9c50513;   % 418:  %
00000dad : 0fc0f217;   % 419:     la tp, CURRENT_MAP # Loads CURRENT_MAP address %
00000dae : a4c20213;   % 419:  %
00000daf : 00050283;   % 421:     lb t0,0(a0) # Loads Ridley's health %
00000db0 : 00504663;   % 422:     blt zero,t0,CONTINUE_RIDLEY_OPERATIONS # If Ridley is alive %
00000db1 : 00050023;   % 424:         sb zero,0(a0) # Stores zero on Ridley's health %
00000db2 : 2180006f;   % 425:         j END_RIDLEY_OPERATIONS %
00000db3 : fdc10113;   % 429:     addi sp,sp,-36 %
00000db4 : 00912023;   % 430:     sw s1,0(sp) %
00000db5 : 01212223;   % 431:     sw s2,4(sp) %
00000db6 : 01312423;   % 432:     sw s3,8(sp) %
00000db7 : 01412623;   % 433:     sw s4,12(sp) %
00000db8 : 00a12823;   % 434:     sw a0,16(sp) %
00000db9 : 00b12a23;   % 435:     sw a1,20(sp) %
00000dba : 00c12c23;   % 436:     sw a2,24(sp) %
00000dbb : 00d12e23;   % 437:     sw a3,28(sp) %
00000dbc : 02412023;   % 438:     sw tp,32(sp) %
00000dbd : 00022583;   % 442:     lw a1,0(tp) %
00000dbe : 00005317;   % 443:     call MOVE_RIDLEY %
00000dbf : 348300e7;   % 443:  %
00000dc0 : 01012503;   % 446:     lw a0,16(sp)     # Gets a0 from stack again %
00000dc1 : 02012203;   % 447:     lw tp,32(sp)     # Gets tp from stack again %
00000dc2 : 00900593;   % 448:     li a1,9   # Loads ridley's current X %
00000dc3 : fff58593;   % 449:     addi a1,a1,-1    # subtracts 1 from it (a sort of offset for rendering sprite in proper place) %
00000dc4 : 00624283;   % 450:     lbu t0,6(tp)     # Loads map's current X   %
00000dc5 : 405585b3;   % 451:     sub a1,a1,t0     # Gets the X matrix related to the map's X (a1 = ridley's X - map's X) %
00000dc6 : 00459593;   % 452:     slli a1,a1,4 # Multiplies a5 by 16 in order to get X related to screen %
00000dc7 : 00600293;   % 453:     li t0,6 # Loads ridley's X offset %
00000dc8 : 005585b3;   % 454:     add a1,a1,t0          # Adds offset to position %
00000dc9 : 00824283;   % 455:     lbu t0,8(tp)          # Loads map's X offset %
00000dca : 405585b3;   % 456:     sub a1,a1,t0          # and takes it from ridley's position %
00000dcb : 00354603;   % 460:     lbu a2,3(a0) # Loads ridley's current Y %
00000dcc : 00724303;   % 461:     lbu t1,7(tp) # Loads map's current Y %
00000dcd : 40660633;   % 462:     sub a2,a2,t1 # Gets the Y matrix related to the map's Y (a2 = ridley's Y - map's Y) %
00000dce : 00461613;   % 463:     slli a2,a2,4 # Multiplies a2 by 16 in order to get Y related to screen %
00000dcf : 00254283;   % 464:     lbu t0,2(a0) # Loads ridley's Y offset %
00000dd0 : 00560633;   % 465:     add a2,a2,t0 # Adds offset to position %
00000dd1 : 00924303;   % 466:     lbu t1,9(tp) # Loads map's Y offset %
00000dd2 : 40660633;   % 467:     sub a2,a2,t1 # and takes it from ridley's position %
00000dd3 : 02000693;   % 469:     li a3,32   # 16 = width of rendering area %
00000dd4 : 008007b3;   % 470:     mv a5,s0          # gets frame to be rendered on %
00000dd5 : 00554803;   % 472:     lbu a6,5(a0)      # Loads ridley's status is its direction %
00000dd6 : 00184813;   % 473:     xori a6,a6,1      # switches it %
00000dd7 : 010502a3;   % 474:     sb a6,5(a0)       # and stores it back for using next time %
00000dd8 : 05000293;   % 476:     li t0, 80              # Loads screen's Y threshold where jumping animation appears %
00000dd9 : 00154303;   % 477:     lbu t1,1(a0)                              # Gets ridley's type number %
00000dda : 02c2d463;   % 478:     bge t0,a2,RIDLEY_OPERATIONS_RENDER_JUMP   # If Y (a2) <= 80, render jumping animation %
00000ddb : 02800713;   % 480:         li a4,40   # 40 = height of rendering area %
00000ddc : 00031863;   % 481:         bnez t1,RIDLEY_OPERATIONS_RENDER_DAMAGE %
00000ddd : 0fc20517;   % 483:             la a0,Ridley %
00000dde : e0850513;   % 483:  %
00000ddf : 0340006f;   % 484:             j RIDLEY_OPERATIONS_RENDER %
00000de0 : 000500a3;   % 488:             sb zero,1(a0)             # Reverts to normal state %
00000de1 : 0fc21517;   % 489:             la a0,Ridley_Damage %
00000de2 : 3f850513;   % 489:  %
00000de3 : 0240006f;   % 490:             j RIDLEY_OPERATIONS_RENDER %
00000de4 : 03000713;   % 494:         li a4,48   # 48 = height of rendering area %
00000de5 : 00031863;   % 495:         bnez t1,RIDLEY_OPERATIONS_RENDER_JUMP_DAMAGE %
00000de6 : 0fc20517;   % 497:             la a0,Ridley_Jump %
00000de7 : 7e450513;   % 497:  %
00000de8 : 0100006f;   % 498:             j RIDLEY_OPERATIONS_RENDER %
00000de9 : 000500a3;   % 502:             sb zero,1(a0)             # Reverts to normal state %
00000dea : 0fc22517;   % 503:             la a0,Ridley_Damage_Jump %
00000deb : dd450513;   % 503:  %
00000dec : 00000893;   % 507:         li a7,0             # Normal render %
00000ded : ffffe317;   % 508:         call RENDER_ENTITY  # Renders it %
00000dee : 6b8300e7;   % 508:  %
00000def : 00900593;   % 511:     li a1,9                  # Range %
00000df0 : 08e00893;   % 512:     li a7,142  # random integer within range ecall %
00000df1 : 00000073;   % 513:     ecall %
00000df2 : 00500293;   % 514:     li t0,5                  # to compare with result (in a0) %
00000df3 : 00554463;   % 515:     blt a0,t0,RIDLEY_OPERATIONS_ATTACK  # 50% chance to attack %
00000df4 : 0fc0006f;   % 516:         j END_RIDLEY_OPERATIONS_PART_1  # 50% chance to not attack %
00000df5 : 01012503;   % 518:         lw a0,16(sp)      # Gets Ridley's address again %
00000df6 : 00a54283;   % 519:         lbu t0,10(a0)     # Loads attack cooldown byte %
00000df7 : 00028863;   % 520:         beqz t0,RIDLEY_OPERATIONS_ATTACK_CONTINUE  %
00000df8 : fff28293;   % 522:             addi t0,t0,-1   # Subtracs 1 from cooldown %
00000df9 : 00550523;   % 523:             sb t0,10(a0)    # and stores it back %
00000dfa : 0e40006f;   % 524:             j END_RIDLEY_OPERATIONS_PART_1 %
00000dfb : 00800293;   % 527:             li t0,8   # Resets ridley's cooldown %
00000dfc : 00550523;   % 528:             sb t0,10(a0)                   # and stores it back %
00000dfd : 0fc0f617;   % 530:             la a2,PLASMA_BREATH_ARRAY  # Loads Plasma breath array %
00000dfe : c6460613;   % 530:  %
00000dff : 00000293;   % 531:             li t0,0 # resets counter %
00000e00 : 00500313;   % 532:             li t1,5 # gets number of plasma breaths in game %
00000e01 : 01012503;   % 536:                 lw a0,16(sp)      # Gets Ridley's address again %
00000e02 : 00064383;   % 537:                 lbu t2,0(a2) # Loads enable byte %
00000e03 : 00038463;   % 538:                 beqz t2,PLASMA_SPAWN_LOOP_CONTINUE # If not enabled, enable current plasma breath %
00000e04 : 0ac0006f;   % 539:                     j NEXT_IN_PLASMA_SPAWN__LOOP   # Otherwise, check other plasma breaths %
00000e05 : 00100393;   % 543:                     li t2,1     # Enabled %
00000e06 : 00760023;   % 544:                     sb t2,0(a2) # stores enable byte %
00000e07 : 00600393;   % 547:                     li t2,6  # Loads 6 %
00000e08 : 000601a3;   % 548:                     sb zero,3(a2) # Stores 6 on X offset (since ridley's X offset is always 6) %
00000e09 : 00900393;   % 550:                     li t2,9  # Loads 10 %
00000e0a : 00138393;   % 551:                     addi t2,t2,1    # adds 1 to it %
00000e0b : 00760323;   % 552:                     sb t2,6(a2)     # Stores 11 on X (since ridley's X is always 10) %
00000e0c : 007603a3;   % 553:                     sb t2,7(a2)     # Stores 11 on old X (since ridley's X is always 10) %
00000e0d : 00254383;   % 556:                     lbu t2,2(a0)    # Loads ridley's Y offset %
00000e0e : 00760223;   % 557:                     sb t2,4(a2)     # Stores it on Y offset %
00000e0f : 00354383;   % 559:                     lbu t2,3(a0)    # Loads ridley's current Y %
00000e10 : 00760423;   % 560:                     sb t2,8(a2)     # Stores it on Y %
00000e11 : 007604a3;   % 561:                     sb t2,9(a2)     # Stores it on dol Y %
00000e12 : 00200593;   % 564:                     li a1,2                  # Range %
00000e13 : 08e00893;   % 565:                     li a7,142  # random integer within range ecall %
00000e14 : 00000073;   % 566:                     ecall %
00000e15 : 00150393;   % 568:                     addi t2,a0,1   # X movement will be between 1 and 3 (inclusive) %
00000e16 : 007600a3;   % 569:                     sb t2,1(a2)    # Stores it on X movement %
00000e17 : fff00393;   % 572:                     li t2,-1       # Loads -1 (Up) %
00000e18 : 00760123;   % 573:                     sb t2,2(a2)    # Stores it on MOVE_Y (Up) %
00000e19 : 00300593;   % 576:                     li a1,3                  # Range %
00000e1a : 08e00893;   % 577:                     li a7,142  # random integer within range ecall %
00000e1b : 00000073;   % 578:                     ecall %
00000e1c : ffa00393;   % 580:                     li t2,-6                 # Loads -8 (base speed) %
00000e1d : 00a383b3;   % 581:                     add t2,t2,a0             # Speed will be between -8 and -4 %
00000e1e : 00029663;   % 584:                     bnez t0,PLASMA_SPAWN_LOOP_NOT_PLASMA_0 %
00000e1f : d003fad3;   % 586:                         fcvt.s.w fs5,t2    # Sets PLASMA_0's Y speed  %
00000e20 : 04c0006f;   % 587:                         j END_RIDLEY_OPERATIONS_PART_1  # Break loop %
00000e21 : 00100313;   % 589:                     PLASMA_SPAWN_LOOP_NOT_PLASMA_0: li t1,1 %
00000e22 : 00629663;   % 590:                     bne t0,t1,PLASMA_SPAWN_LOOP_NOT_PLASMA_1 %
00000e23 : d003fb53;   % 592:                         fcvt.s.w fs6,t2    # Sets PLASMA_1's Y speed %
00000e24 : 03c0006f;   % 593:                         j END_RIDLEY_OPERATIONS_PART_1  # Break loop %
00000e25 : 00200313;   % 595:                     PLASMA_SPAWN_LOOP_NOT_PLASMA_1: li t1,2 %
00000e26 : 00629663;   % 596:                     bne t0,t1,PLASMA_SPAWN_LOOP_NOT_PLASMA_2 %
00000e27 : d003fbd3;   % 598:                         fcvt.s.w fs7,t2    # Sets PLASMA_2's Y speed %
00000e28 : 02c0006f;   % 599:                         j END_RIDLEY_OPERATIONS_PART_1  # Break loop %
00000e29 : 00300313;   % 601:                     PLASMA_SPAWN_LOOP_NOT_PLASMA_2: li t1,3 %
00000e2a : 00629663;   % 602:                     bne t0,t1,PLASMA_SPAWN_LOOP_NOT_PLASMA_3 %
00000e2b : d003fc53;   % 604:                         fcvt.s.w fs8,t2    # Sets PLASMA_3's Y speed %
00000e2c : 01c0006f;   % 605:                         j END_RIDLEY_OPERATIONS_PART_1  # Break loop %
00000e2d : d003fcd3;   % 609:                         fcvt.s.w fs9,t2    # Sets PLASMA_4's Y speed %
00000e2e : 0140006f;   % 610:                         j END_RIDLEY_OPERATIONS_PART_1  # Break loop %
00000e2f : 00a60613;   % 613:                     addi a2,a2,10  # Going to the next plasma breath address                                   %
00000e30 : 00128293;   % 614:                     addi t0,t0,1            # Iterating counter by 1                                    %
00000e31 : 0062d463;   % 615:                     bge t0,t1, END_RIDLEY_OPERATIONS_PART_1 # If all of the plasma breaths were checked, end loop (don't attack)                                 %
00000e32 : f3dff06f;   % 616:                     j PLASMA_SPAWN_LOOP # otherwise, go back to the loop's beginning  %
00000e33 : 00012483;   % 620:         lw s1,0(sp) %
00000e34 : 00412903;   % 621:         lw s2,4(sp) %
00000e35 : 00812983;   % 622:         lw s3,8(sp) %
00000e36 : 00c12a03;   % 623:         lw s4,12(sp) %
00000e37 : 02410113;   % 629:         addi sp,sp,36 %
00000e38 : 00012083;   % 634:         lw ra,0(sp) %
00000e39 : 00410113;   % 635:         addi sp,sp,4 %
00000e3a : 00008067;   % 637:         ret %
00000e3b : ffc10113;   % 656:     addi sp,sp,-4 %
00000e3c : 00112023;   % 657:     sw ra,0(sp) %
00000e3d : 0fc0f217;   % 659:     la tp, CURRENT_MAP         # Loads CURRENT_MAP address %
00000e3e : 80c20213;   % 659:  %
00000e3f : 0fc0f517;   % 661:     la a0,PLASMA_BREATH_ARRAY  # Loads Plasma breath array %
00000e40 : b5c50513;   % 661:  %
00000e41 : 00000613;   % 663:     li a2,0 # resets counter %
00000e42 : 00500593;   % 664:     li a1,5 # gets number of plasma breaths in game %
00000e43 : 00054383;   % 666:         lbu t2,0(a0) # Loads enable byte %
00000e44 : 00039463;   % 667:         bnez t2,PLASMA_BREATH_OPERATIONS_LOOP_CONTINUE    # If enabled, %
00000e45 : 1740006f;   % 668:             j NEXT_IN_PLASMA_BREATH_OPERATIONS_LOOP       # Otherwise, check other plasma breaths %
00000e46 : 00200293;   % 670:             li t0,2  # Loads "To be Disabled"  %
00000e47 : 00729663;   % 671:             bne t0,t2, PLASMA_BREATH_OPERATIONS_LOOP_CONTINUE_2   # If plasma breath is trully enabled, %
00000e48 : 00050023;   % 673:                 sb zero,0(a0) # Disables plasma breath %
00000e49 : 1640006f;   % 674:                 j NEXT_IN_PLASMA_BREATH_OPERATIONS_LOOP  # Check other plasma breaths %
00000e4a : fdc10113;   % 679:             addi sp,sp,-36 %
00000e4b : 00912023;   % 680:             sw s1,0(sp) %
00000e4c : 01212223;   % 681:             sw s2,4(sp) %
00000e4d : 01312423;   % 682:             sw s3,8(sp) %
00000e4e : 01412623;   % 683:             sw s4,12(sp) %
00000e4f : 00a12823;   % 684:             sw a0,16(sp) %
00000e50 : 00b12a23;   % 685:             sw a1,20(sp) %
00000e51 : 00c12c23;   % 686:             sw a2,24(sp) %
00000e52 : 00d12e23;   % 687:             sw a3,28(sp) %
00000e53 : 02412023;   % 688:             sw tp,32(sp) %
00000e54 : 00061663;   % 692:             bnez a2,PLASMA_BREATH_OPERATIONS_LOOP_NOT_PLASMA_0 %
00000e55 : 215a8553;   % 694:                 fmv.s fa0,fs5   # Moves PLASMA_0's current Y speed to fa0  %
00000e56 : 0380006f;   % 695:                 j PLASMA_BREATH_OPERATIONS_LOOP_MOVE  # Move %
00000e57 : 00100293;   % 697:             PLASMA_BREATH_OPERATIONS_LOOP_NOT_PLASMA_0: li t0,1 %
00000e58 : 00561663;   % 698:             bne a2,t0,PLASMA_BREATH_OPERATIONS_LOOP_NOT_PLASMA_1 %
00000e59 : 216b0553;   % 700:                 fmv.s fa0,fs6   # Moves PLASMA_1's current Y speed to fa0 %
00000e5a : 0280006f;   % 701:                 j PLASMA_BREATH_OPERATIONS_LOOP_MOVE  # Move %
00000e5b : 00200293;   % 703:             PLASMA_BREATH_OPERATIONS_LOOP_NOT_PLASMA_1: li t0,2 %
00000e5c : 00561663;   % 704:             bne a2,t0,PLASMA_BREATH_OPERATIONS_LOOP_NOT_PLASMA_2 %
00000e5d : 217b8553;   % 706:                 fmv.s fa0,fs7   # Moves PLASMA_2's current Y speed to fa0 %
00000e5e : 0180006f;   % 707:                 j PLASMA_BREATH_OPERATIONS_LOOP_MOVE  # Move %
00000e5f : 00300293;   % 709:             PLASMA_BREATH_OPERATIONS_LOOP_NOT_PLASMA_2: li t0,3 %
00000e60 : 00561663;   % 710:             bne a2,t0,PLASMA_BREATH_OPERATIONS_LOOP_NOT_PLASMA_3 %
00000e61 : 218c0553;   % 712:                 fmv.s fa0,fs8   # Moves PLASMA_3's current Y speed to fa0 %
00000e62 : 0080006f;   % 713:                 j PLASMA_BREATH_OPERATIONS_LOOP_MOVE  # Move %
00000e63 : 219c8553;   % 717:                 fmv.s fa0,fs9   # Moves PLASMA_4's current Y speed to fa0 %
00000e64 : 00022583;   % 723:             lw a1,0(tp) %
00000e65 : 00005317;   % 724:             call MOVE_PLASMA_BREATH %
00000e66 : 220300e7;   % 724:  %
00000e67 : 01812603;   % 726:             lw a2,24(sp) # Getting Plasma Breath's number back (counter) %
00000e68 : 00061663;   % 729:             bnez a2,PLASMA_BREATH_OPERATIONS_LOOP_AFTER_CHECK_NOT_PLASMA_0 %
00000e69 : 20a50ad3;   % 731:                 fmv.s fs5,fa0   # Saves PLASMA_0's new Y speed from fa0  %
00000e6a : 0380006f;   % 732:                 j PLASMA_BREATH_OPERATIONS_AFTER_CHECK  # Finish move %
00000e6b : 00100293;   % 734:             PLASMA_BREATH_OPERATIONS_LOOP_AFTER_CHECK_NOT_PLASMA_0: li t0,1 %
00000e6c : 00561663;   % 735:             bne a2,t0,PLASMA_BREATH_OPERATIONS_LOOP_AFTER_CHECK_NOT_PLASMA_1 %
00000e6d : 20a50b53;   % 737:                 fmv.s fs6,fa0   # Saves PLASMA_1's new Y speed from fa0  %
00000e6e : 0280006f;   % 738:                 j PLASMA_BREATH_OPERATIONS_AFTER_CHECK  # Finish move %
00000e6f : 00200293;   % 740:             PLASMA_BREATH_OPERATIONS_LOOP_AFTER_CHECK_NOT_PLASMA_1: li t0,2 %
00000e70 : 00561663;   % 741:             bne a2,t0,PLASMA_BREATH_OPERATIONS_LOOP_AFTER_CHECK_NOT_PLASMA_2 %
00000e71 : 20a50bd3;   % 743:                 fmv.s fs7,fa0   # Saves PLASMA_2's new Y speed from fa0  %
00000e72 : 0180006f;   % 744:                 j PLASMA_BREATH_OPERATIONS_AFTER_CHECK  # Finish move %
00000e73 : 00300293;   % 746:             PLASMA_BREATH_OPERATIONS_LOOP_AFTER_CHECK_NOT_PLASMA_2: li t0,3 %
00000e74 : 00561663;   % 747:             bne a2,t0,PLASMA_BREATH_OPERATIONS_LOOP_AFTER_CHECK_NOT_PLASMA_3 %
00000e75 : 20a50c53;   % 749:                 fmv.s fs8,fa0   # Saves PLASMA_3's new Y speed from fa0  %
00000e76 : 0080006f;   % 750:                 j PLASMA_BREATH_OPERATIONS_AFTER_CHECK  # Finish move %
00000e77 : 20a50cd3;   % 754:                 fmv.s fs9,fa0   # Saves PLASMA_0's new Y speed from fa0  %
00000e78 : 01012503;   % 761:             lw a0,16(sp) # Gets a0 from stack again %
00000e79 : 02012203;   % 762:             lw tp,32(sp) # Gets tp from stack again %
00000e7a : 00654583;   % 763:             lbu a1,6(a0) # Loads plasma breath's current X %
00000e7b : 00624283;   % 764:             lbu t0,6(tp) # Loads map's current X %
00000e7c : 405585b3;   % 765:             sub a1,a1,t0 # Gets the X matrix related to the map's X (a1 = plasma breath's X - map's X) %
00000e7d : 00459593;   % 766:             slli a1,a1,4 # Multiplies a5 by 16 in order to get X related to screen %
00000e7e : 00354283;   % 767:             lbu t0,3(a0) # Loads plasma breath's X offset %
00000e7f : 005585b3;   % 768:             add a1,a1,t0 # Adds offset to position %
00000e80 : 00824283;   % 769:             lbu t0,8(tp) # Loads map's X offset %
00000e81 : 405585b3;   % 770:             sub a1,a1,t0 # and takes it from plasma breath's position %
00000e82 : 00854603;   % 775:             lbu a2,8(a0) # Loads plasma breath's current Y %
00000e83 : 00724303;   % 776:             lbu t1,7(tp) # Loads map's current Y %
00000e84 : 40660633;   % 777:             sub a2,a2,t1 # Gets the Y matrix related to the map's Y (a2 = plasma breath's Y - map's Y) %
00000e85 : 00461613;   % 778:             slli a2,a2,4 # Multiplies a2 by 16 in order to get Y related to screen %
00000e86 : 00454283;   % 779:             lbu t0,4(a0) # Loads plasma breath's Y offset %
00000e87 : 00560633;   % 780:             add a2,a2,t0 # Adds offset to position %
00000e88 : 00924303;   % 781:             lbu t1,9(tp) # Loads map's Y offset %
00000e89 : 40660633;   % 782:             sub a2,a2,t1 # and takes it from plasma breath's position %
00000e8a : 01000693;   % 784:             li a3,16   # 16 = width of rendering area %
00000e8b : 01000713;   % 785:             li a4,16   # 16 = height of rendering area %
00000e8c : 008007b3;   % 786:             mv a5,s0          # gets frame to be rendered on %
00000e8d : 00554803;   % 788:             lbu a6,5(a0)      # Loads plasma breath's status %
00000e8e : 00180813;   % 789:             addi a6,a6,1      # adds 1 to it %
00000e8f : 00300293;   % 790:             li t0,3 %
00000e90 : 0102d463;   % 791:             bge t0,a6,PLASMA_BREATH_OPERATIONS_LOOP_SKIP_STATUS_CORRECTION  # If a6 <= 3, continue %
00000e91 : 00000813;   % 792:                 li a6,0       # resets a6 to 0 %
00000e92 : 010502a3;   % 794:             sb a6,5(a0)       # and stores it back for using next time %
00000e93 : 0fc22517;   % 796:             la a0,Plasma_Breath %
00000e94 : 73050513;   % 796:  %
00000e95 : 00000893;   % 797:             li a7,0             # Normal render %
00000e96 : ffffe317;   % 798:             call RENDER_ENTITY  # Renders it %
00000e97 : 414300e7;   % 798:  %
00000e98 : 00012483;   % 803:             lw s1,0(sp) %
00000e99 : 00412903;   % 804:             lw s2,4(sp) %
00000e9a : 00812983;   % 805:             lw s3,8(sp) %
00000e9b : 00c12a03;   % 806:             lw s4,12(sp) %
00000e9c : 01012503;   % 807:             lw a0,16(sp) %
00000e9d : 01412583;   % 808:             lw a1,20(sp) %
00000e9e : 01812603;   % 809:             lw a2,24(sp) %
00000e9f : 01c12683;   % 810:             lw a3,28(sp) %
00000ea0 : 02012203;   % 811:             lw tp,32(sp) %
00000ea1 : 02410113;   % 812:             addi sp,sp,36 %
00000ea2 : 00a50513;   % 816:                     addi a0,a0,10  # Going to the next plasma breath's address                                   %
00000ea3 : 00160613;   % 817:                     addi a2,a2,1            # Iterating counter by 1                                    %
00000ea4 : 00b65463;   % 818:                     bge a2,a1, END_PLASMA_BREATH_OPERATIONS_LOOP # If all of the plasma breaths were checked, end loop (don't attack)                                 %
00000ea5 : e79ff06f;   % 819:                     j PLASMA_BREATH_OPERATIONS_LOOP # otherwise, go back to the loop's beginning  %
00000ea6 : 00012083;   % 823:         lw ra,0(sp) %
00000ea7 : 00410113;   % 824:         addi sp,sp,4 %
00000ea8 : 00008067;   % 826:         ret %
00000ea9 : 0fc0e217;   % 842:     la tp,CURRENT_MAP %
00000eaa : 65c20213;   % 842:  %
00000eab : 00424883;   % 843:     lbu a7,4(tp)       # Loads current map's number %
00000eac : 0fc0e517;   % 844:     la a0 Zoomers %
00000ead : 78850513;   % 844:  %
00000eae : 0fc0e317;   % 846:     la t1,NEXT_MAP %
00000eaf : 65430313;   % 846:  %
00000eb0 : 00a34383;   % 847: 	lbu t2,10(t1)      # Loads render Next Map's %
00000eb1 : 00038c63;   % 848:     beqz t2,NOT_NEXT_MAP %
00000eb2 : 0fc0e217;   % 849:         la tp,NEXT_MAP %
00000eb3 : 64420213;   % 849:  %
00000eb4 : 00424883;   % 850:         lbu a7,4(tp)       # Loads current map's number %
00000eb5 : 0fc0e517;   % 851:         la a0,Zoomers_Next %
00000eb6 : 76850513;   % 851:  %
00000eb7 : 00700293;   % 854:     li t0,7        # Loads 7 for comparision %
00000eb8 : 01129463;   % 855:     bne t0,a7, START_ZOOMERS_RESET %
00000eb9 : 3490006f;   % 856:         j RESET_RIDLEY %
00000eba : 00052503;   % 859:     lw a0,0(a0)    # Loads the ZoomersA address over the Zoomers address %
00000ebb : 00051463;   % 860:     bnez a0,CONTINUE_ZOOMER_RESET  # If there are zoomers in this map %
00000ebc : 3310006f;   % 861:         j END_RESET_ZOOMER_LOOP    # If a0 = 0, there are no zoomers in this map %
00000ebd : 00054583;   % 865:     lbu a1,0(a0)   # Loads number of Zoomers in current map %
00000ebe : 00000613;   % 867:     li a2,0        # Counter for zoomers %
00000ebf : 00150513;   % 868:     addi a0,a0,1   # Goes to next byte (where zoomers from current map start) %
00000ec0 : 00100293;   % 870:         li t0, 1  %
00000ec1 : 01129463;   % 871:         bne t0, a7, SKIP_MAP1_RESET_ZOOMER_LOOP  %
00000ec2 : 02c0006f;   % 872:         j RESET_ZOOMER_LOOP_MAP1 %
00000ec3 : 00200293;   % 875:             li t0, 2  %
00000ec4 : 01129463;   % 876:             bne t0, a7, SKIP_MAP2_RESET_ZOOMER_LOOP  %
00000ec5 : 1f00006f;   % 877:             j RESET_ZOOMER_LOOP_MAP2 %
00000ec6 : 00300293;   % 880:             li t0, 3  %
00000ec7 : 01129463;   % 881:             bne t0, a7, SKIP_MAP3_RESET_ZOOMER_LOOP  %
00000ec8 : 4980006f;   % 882:             j RESET_ZOOMER_LOOP_MAP3 %
00000ec9 : 00400293;   % 885:             li t0, 4 %
00000eca : 01129463;   % 886:             bne t0, a7, SKIP_MAP4_RESET_ZOOMER_LOOP  %
00000ecb : 65c0006f;   % 887:             j RESET_ZOOMER_LOOP_MAP4 %
00000ecc : 1b50006f;   % 890:             j RESET_ZOOMER_LOOP_MAP5 %
00000ecd : 04061663;   % 894:             bnez a2,RESET_ZOOMER_LOOP_MAP1_NOT_0 %
00000ece : 00600293;   % 896:                 li t0,6 %
00000ecf : 00550023;   % 897:                 sb t0,0(a0) %
00000ed0 : 000500a3;   % 898:                 sb zero,1(a0) %
00000ed1 : 00050123;   % 899:                 sb zero,2(a0) %
00000ed2 : 000501a3;   % 900:                 sb zero,3(a0) %
00000ed3 : 02200293;   % 901:                 li t0,34 %
00000ed4 : 00550223;   % 902:                 sb t0,4(a0) %
00000ed5 : 000502a3;   % 903:                 sb zero,5(a0) %
00000ed6 : 00700293;   % 904:                 li t0,7 %
00000ed7 : 00550323;   % 905:                 sb t0,6(a0) %
00000ed8 : 000503a3;   % 906:                 sb zero,7(a0) %
00000ed9 : 00050423;   % 907:                 sb zero,8(a0) %
00000eda : 00100293;   % 908:                 li t0,1 %
00000edb : 005504a3;   % 909:                 sb t0,9(a0) %
00000edc : 00300293;   % 910:                 li t0,3 %
00000edd : 00550523;   % 911:                 sb t0,10(a0) %
00000ede : 000505a3;   % 912:                 sb zero,11(a0) %
00000edf : 2950006f;   % 913:                 j NEXT_IN_RESET_ZOOMER_LOOP %
00000ee0 : 00100293;   % 915:             RESET_ZOOMER_LOOP_MAP1_NOT_0: li t0,1 %
00000ee1 : 04c29463;   % 916:             bne t0,a2,RESET_ZOOMER_LOOP_MAP1_NOT_1 %
00000ee2 : 00600293;   % 918:                 li t0,6 %
00000ee3 : 00550023;   % 919:                 sb t0,0(a0) %
00000ee4 : 000500a3;   % 920:                 sb zero,1(a0) %
00000ee5 : 00050123;   % 921:                 sb zero,2(a0) %
00000ee6 : 000501a3;   % 922:                 sb zero,3(a0) %
00000ee7 : 02000293;   % 923:                 li t0,32 %
00000ee8 : 00550223;   % 924:                 sb t0,4(a0) %
00000ee9 : 000502a3;   % 925:                 sb zero,5(a0) %
00000eea : 00500293;   % 926:                 li t0,5 %
00000eeb : 00550323;   % 927:                 sb t0,6(a0) %
00000eec : 000503a3;   % 928:                 sb zero,7(a0) %
00000eed : 00050423;   % 929:                 sb zero,8(a0) %
00000eee : 000504a3;   % 930:                 sb zero,9(a0) %
00000eef : 00100293;   % 931:                 li t0,1 %
00000ef0 : 00550523;   % 932:                 sb t0,10(a0) %
00000ef1 : 005505a3;   % 933:                 sb t0,11(a0) %
00000ef2 : 2490006f;   % 934:                 j NEXT_IN_RESET_ZOOMER_LOOP %
00000ef3 : 00200293;   % 936:             RESET_ZOOMER_LOOP_MAP1_NOT_1: li t0,2 %
00000ef4 : 04c29663;   % 937:             bne t0,a2,RESET_ZOOMER_LOOP_MAP1_NOT_2 %
00000ef5 : 00600293;   % 939:                 li t0,6 %
00000ef6 : 00550023;   % 940:                 sb t0,0(a0) %
00000ef7 : 000500a3;   % 941:                 sb zero,1(a0) %
00000ef8 : 00050123;   % 942:                 sb zero,2(a0) %
00000ef9 : 000501a3;   % 943:                 sb zero,3(a0) %
00000efa : 00900293;   % 944:                 li t0,9 %
00000efb : 00550223;   % 945:                 sb t0,4(a0) %
00000efc : 000502a3;   % 946:                 sb zero,5(a0) %
00000efd : 00700293;   % 947:                 li t0,7 %
00000efe : 00550323;   % 948:                 sb t0,6(a0) %
00000eff : 000503a3;   % 949:                 sb zero,7(a0) %
00000f00 : 00050423;   % 950:                 sb zero,8(a0) %
00000f01 : 00100293;   % 951:                 li t0,1 %
00000f02 : 005504a3;   % 952:                 sb t0,9(a0) %
00000f03 : 00550523;   % 953:                 sb t0,10(a0) %
00000f04 : 00100293;   % 954:                 li t0,1 %
00000f05 : 005505a3;   % 955:                 sb t0,11(a0) %
00000f06 : 1f90006f;   % 956:                 j NEXT_IN_RESET_ZOOMER_LOOP %
00000f07 : 00300293;   % 958:             RESET_ZOOMER_LOOP_MAP1_NOT_2: li t0,3 %
00000f08 : 04c29663;   % 959:             bne t0,a2,RESET_ZOOMER_LOOP_MAP1_NOT_3 %
00000f09 : 00600293;   % 961:                 li t0,6 %
00000f0a : 00550023;   % 962:                 sb t0,0(a0) %
00000f0b : 000500a3;   % 963:                 sb zero,1(a0) %
00000f0c : 00050123;   % 964:                 sb zero,2(a0) %
00000f0d : 000501a3;   % 965:                 sb zero,3(a0) %
00000f0e : 03700293;   % 966:                 li t0,55 %
00000f0f : 00550223;   % 967:                 sb t0,4(a0) %
00000f10 : 000502a3;   % 968:                 sb zero,5(a0) %
00000f11 : 00200293;   % 969:                 li t0,2 %
00000f12 : 00550323;   % 970:                 sb t0,6(a0) %
00000f13 : 000503a3;   % 971:                 sb zero,7(a0) %
00000f14 : 00050423;   % 972:                 sb zero,8(a0) %
00000f15 : 00100293;   % 973:                 li t0,1 %
00000f16 : 005504a3;   % 974:                 sb t0,9(a0) %
00000f17 : 00200293;   % 975:                 li t0,2 %
00000f18 : 00550523;   % 976:                 sb t0,10(a0) %
00000f19 : 000505a3;   % 977:                 sb zero,11(a0) %
00000f1a : 1a90006f;   % 978:                 j NEXT_IN_RESET_ZOOMER_LOOP %
00000f1b : 00400293;   % 980:             RESET_ZOOMER_LOOP_MAP1_NOT_3: li t0,4 %
00000f1c : 04c29863;   % 981:             bne t0,a2,RESET_ZOOMER_LOOP_MAP1_NOT_4 %
00000f1d : 00600293;   % 983:                 li t0,6 %
00000f1e : 00550023;   % 984:                 sb t0,0(a0) %
00000f1f : 000500a3;   % 985:                 sb zero,1(a0) %
00000f20 : 00050123;   % 986:                 sb zero,2(a0) %
00000f21 : 000501a3;   % 987:                 sb zero,3(a0) %
00000f22 : 03700293;   % 988:                 li t0,55 %
00000f23 : 00550223;   % 989:                 sb t0,4(a0) %
00000f24 : 000502a3;   % 990:                 sb zero,5(a0) %
00000f25 : 00900293;   % 991:                 li t0,9 %
00000f26 : 00550323;   % 992:                 sb t0,6(a0) %
00000f27 : 000503a3;   % 993:                 sb zero,7(a0) %
00000f28 : 00050423;   % 994:                 sb zero,8(a0) %
00000f29 : 00100293;   % 995:                 li t0,1 %
00000f2a : 005504a3;   % 996:                 sb t0,9(a0) %
00000f2b : 00200293;   % 997:                 li t0,2 %
00000f2c : 00550523;   % 998:                 sb t0,10(a0) %
00000f2d : 00100293;   % 999:                 li t0,1 %
00000f2e : 005505a3;   % 1000:                 sb t0,11(a0) %
00000f2f : 1550006f;   % 1001:                 j NEXT_IN_RESET_ZOOMER_LOOP %
00000f30 : 00600293;   % 1005:                 li t0,6 %
00000f31 : 00550023;   % 1006:                 sb t0,0(a0) %
00000f32 : 000500a3;   % 1007:                 sb zero,1(a0) %
00000f33 : 00050123;   % 1008:                 sb zero,2(a0) %
00000f34 : 000501a3;   % 1009:                 sb zero,3(a0) %
00000f35 : 03000293;   % 1010:                 li t0,48 %
00000f36 : 00550223;   % 1011:                 sb t0,4(a0) %
00000f37 : 000502a3;   % 1012:                 sb zero,5(a0) %
00000f38 : 00c00293;   % 1013:                 li t0,12 %
00000f39 : 00550323;   % 1014:                 sb t0,6(a0) %
00000f3a : 000503a3;   % 1015:                 sb zero,7(a0) %
00000f3b : 00050423;   % 1016:                 sb zero,8(a0) %
00000f3c : 00100293;   % 1017:                 li t0,1 %
00000f3d : 005504a3;   % 1018:                 sb t0,9(a0) %
00000f3e : 00050523;   % 1019:                 sb zero,10(a0) %
00000f3f : 000505a3;   % 1020:                 sb zero,11(a0) %
00000f40 : 1110006f;   % 1021:                 j NEXT_IN_RESET_ZOOMER_LOOP %
00000f41 : 04061463;   % 1024:         bnez a2,RESET_ZOOMER_LOOP_MAP2_NOT_0 %
00000f42 : 00600293;   % 1026:                 li t0,6 %
00000f43 : 00550023;   % 1027:                 sb t0,0(a0) %
00000f44 : 000500a3;   % 1028:                 sb zero,1(a0) %
00000f45 : 00050123;   % 1029:                 sb zero,2(a0) %
00000f46 : 000501a3;   % 1030:                 sb zero,3(a0) %
00000f47 : 00f00293;   % 1031:                 li t0,15 %
00000f48 : 00550223;   % 1032:                 sb t0,4(a0) %
00000f49 : 000502a3;   % 1033:                 sb zero,5(a0) %
00000f4a : 00500293;   % 1034:                 li t0,5 %
00000f4b : 00550323;   % 1035:                 sb t0,6(a0) %
00000f4c : 000503a3;   % 1036:                 sb zero,7(a0) %
00000f4d : 00050423;   % 1037:                 sb zero,8(a0) %
00000f4e : 000504a3;   % 1038:                 sb zero,9(a0) %
00000f4f : 00050523;   % 1039:                 sb zero,10(a0) %
00000f50 : 00100293;   % 1040:                 li t0,1 %
00000f51 : 005505a3;   % 1041:                 sb t0,11(a0) %
00000f52 : 0c90006f;   % 1042:                 j NEXT_IN_RESET_ZOOMER_LOOP %
00000f53 : 00100293;   % 1044:             RESET_ZOOMER_LOOP_MAP2_NOT_0: li t0,1 %
00000f54 : 04c29463;   % 1045:             bne t0,a2,RESET_ZOOMER_LOOP_MAP2_NOT_1 %
00000f55 : 00600293;   % 1047:                 li t0,6 %
00000f56 : 00550023;   % 1048:                 sb t0,0(a0) %
00000f57 : 000500a3;   % 1049:                 sb zero,1(a0) %
00000f58 : 00050123;   % 1050:                 sb zero,2(a0) %
00000f59 : 000501a3;   % 1051:                 sb zero,3(a0) %
00000f5a : 00900293;   % 1052:                 li t0,9 %
00000f5b : 00550223;   % 1053:                 sb t0,4(a0) %
00000f5c : 000502a3;   % 1054:                 sb zero,5(a0) %
00000f5d : 00700293;   % 1055:                 li t0,7 %
00000f5e : 00550323;   % 1056:                 sb t0,6(a0) %
00000f5f : 000503a3;   % 1057:                 sb zero,7(a0) %
00000f60 : 00050423;   % 1058:                 sb zero,8(a0) %
00000f61 : 00100293;   % 1059:                 li t0,1 %
00000f62 : 005504a3;   % 1060:                 sb t0,9(a0) %
00000f63 : 00050523;   % 1061:                 sb zero,10(a0) %
00000f64 : 000505a3;   % 1062:                 sb zero,11(a0) %
00000f65 : 07d0006f;   % 1063:                 j NEXT_IN_RESET_ZOOMER_LOOP %
00000f66 : 00200293;   % 1065:             RESET_ZOOMER_LOOP_MAP2_NOT_1: li t0,2 %
00000f67 : 04c29463;   % 1066:             bne t0,a2,RESET_ZOOMER_LOOP_MAP2_NOT_2 %
00000f68 : 00600293;   % 1068:                 li t0,6 %
00000f69 : 00550023;   % 1069:                 sb t0,0(a0) %
00000f6a : 000500a3;   % 1070:                 sb zero,1(a0) %
00000f6b : 00050123;   % 1071:                 sb zero,2(a0) %
00000f6c : 000501a3;   % 1072:                 sb zero,3(a0) %
00000f6d : 00400293;   % 1073:                 li t0,4 %
00000f6e : 00550223;   % 1074:                 sb t0,4(a0) %
00000f6f : 000502a3;   % 1075:                 sb zero,5(a0) %
00000f70 : 00900293;   % 1076:                 li t0,9 %
00000f71 : 00550323;   % 1077:                 sb t0,6(a0) %
00000f72 : 000503a3;   % 1078:                 sb zero,7(a0) %
00000f73 : 00050423;   % 1079:                 sb zero,8(a0) %
00000f74 : 000504a3;   % 1080:                 sb zero,9(a0) %
00000f75 : 00100293;   % 1081:                 li t0,1 %
00000f76 : 00550523;   % 1082:                 sb t0,10(a0) %
00000f77 : 000505a3;   % 1083:                 sb zero,11(a0) %
00000f78 : 0310006f;   % 1084:                 j NEXT_IN_RESET_ZOOMER_LOOP %
00000f79 : 00300293;   % 1086:             RESET_ZOOMER_LOOP_MAP2_NOT_2: li t0,3 %
00000f7a : 04c29663;   % 1087:             bne t0,a2,RESET_ZOOMER_LOOP_MAP2_NOT_3 %
00000f7b : 00600293;   % 1089:                 li t0,6 %
00000f7c : 00550023;   % 1090:                 sb t0,0(a0) %
00000f7d : 000500a3;   % 1091:                 sb zero,1(a0) %
00000f7e : 00050123;   % 1092:                 sb zero,2(a0) %
00000f7f : 000501a3;   % 1093:                 sb zero,3(a0) %
00000f80 : 00c00293;   % 1094:                 li t0,12 %
00000f81 : 00550223;   % 1095:                 sb t0,4(a0) %
00000f82 : 000502a3;   % 1096:                 sb zero,5(a0) %
00000f83 : 00b00293;   % 1097:                 li t0,11 %
00000f84 : 00550323;   % 1098:                 sb t0,6(a0) %
00000f85 : 000503a3;   % 1099:                 sb zero,7(a0) %
00000f86 : 00050423;   % 1100:                 sb zero,8(a0) %
00000f87 : 00100293;   % 1101:                 li t0,1 %
00000f88 : 005504a3;   % 1102:                 sb t0,9(a0) %
00000f89 : 00050523;   % 1103:                 sb zero,10(a0) %
00000f8a : 00100293;   % 1104:                 li t0,1 %
00000f8b : 005505a3;   % 1105:                 sb t0,11(a0) %
00000f8c : 7e00006f;   % 1106:                 j NEXT_IN_RESET_ZOOMER_LOOP %
00000f8d : 00400293;   % 1108:             RESET_ZOOMER_LOOP_MAP2_NOT_3: li t0,4 %
00000f8e : 04c29863;   % 1109:             bne t0,a2,RESET_ZOOMER_LOOP_MAP2_NOT_4 %
00000f8f : 00c00293;   % 1111:                 li t0,12 %
00000f90 : 00550023;   % 1112:                 sb t0,0(a0) %
00000f91 : 00100293;   % 1113:                 li t0,1 %
00000f92 : 005500a3;   % 1114:                 sb t0,1(a0) %
00000f93 : 00050123;   % 1115:                 sb zero,2(a0) %
00000f94 : 000501a3;   % 1116:                 sb zero,3(a0) %
00000f95 : 00600293;   % 1117:                 li t0,6 %
00000f96 : 00550223;   % 1118:                 sb t0,4(a0) %
00000f97 : 000502a3;   % 1119:                 sb zero,5(a0) %
00000f98 : 01200293;   % 1120:                 li t0,18 %
00000f99 : 00550323;   % 1121:                 sb t0,6(a0) %
00000f9a : 000503a3;   % 1122:                 sb zero,7(a0) %
00000f9b : 00050423;   % 1123:                 sb zero,8(a0) %
00000f9c : 00100293;   % 1124:                 li t0,1 %
00000f9d : 005504a3;   % 1125:                 sb t0,9(a0) %
00000f9e : 00300293;   % 1126:                 li t0,3 %
00000f9f : 00550523;   % 1127:                 sb t0,10(a0) %
00000fa0 : 000505a3;   % 1128:                 sb zero,11(a0) %
00000fa1 : 78c0006f;   % 1129:                 j NEXT_IN_RESET_ZOOMER_LOOP %
00000fa2 : 00500293;   % 1131:             RESET_ZOOMER_LOOP_MAP2_NOT_4: li t0,5 %
00000fa3 : 04c29463;   % 1132:             bne t0,a2,RESET_ZOOMER_LOOP_MAP2_NOT_5 %
00000fa4 : 00600293;   % 1134:                 li t0,6 %
00000fa5 : 00550023;   % 1135:                 sb t0,0(a0) %
00000fa6 : 000500a3;   % 1136:                 sb zero,1(a0) %
00000fa7 : 00050123;   % 1137:                 sb zero,2(a0) %
00000fa8 : 000501a3;   % 1138:                 sb zero,3(a0) %
00000fa9 : 00c00293;   % 1139:                 li t0,12 %
00000faa : 00550223;   % 1140:                 sb t0,4(a0) %
00000fab : 000502a3;   % 1141:                 sb zero,5(a0) %
00000fac : 01600293;   % 1142:                 li t0,22 %
00000fad : 00550323;   % 1143:                 sb t0,6(a0) %
00000fae : 000503a3;   % 1144:                 sb zero,7(a0) %
00000faf : 00050423;   % 1145:                 sb zero,8(a0) %
00000fb0 : 000504a3;   % 1146:                 sb zero,9(a0) %
00000fb1 : 00050523;   % 1147:                 sb zero,10(a0) %
00000fb2 : 00100293;   % 1148:                 li t0,1 %
00000fb3 : 005505a3;   % 1149:                 sb t0,11(a0) %
00000fb4 : 7400006f;   % 1150:                 j NEXT_IN_RESET_ZOOMER_LOOP    %
00000fb5 : 00600293;   % 1152:             RESET_ZOOMER_LOOP_MAP2_NOT_5: li t0,6 %
00000fb6 : 04c29463;   % 1153:             bne t0,a2,RESET_ZOOMER_LOOP_MAP2_NOT_6 %
00000fb7 : 00c00293;   % 1155:                 li t0,12 %
00000fb8 : 00550023;   % 1156:                 sb t0,0(a0) %
00000fb9 : 00100293;   % 1157:                 li t0,1 %
00000fba : 005500a3;   % 1158:                 sb t0,1(a0) %
00000fbb : 00050123;   % 1159:                 sb zero,2(a0) %
00000fbc : 000501a3;   % 1160:                 sb zero,3(a0) %
00000fbd : 00400293;   % 1161:                 li t0,4 %
00000fbe : 00550223;   % 1162:                 sb t0,4(a0) %
00000fbf : 000502a3;   % 1163:                 sb zero,5(a0) %
00000fc0 : 01c00293;   % 1164:                 li t0,28 %
00000fc1 : 00550323;   % 1165:                 sb t0,6(a0) %
00000fc2 : 000503a3;   % 1166:                 sb zero,7(a0) %
00000fc3 : 00050423;   % 1167:                 sb zero,8(a0) %
00000fc4 : 000504a3;   % 1168:                 sb zero,9(a0) %
00000fc5 : 00050523;   % 1169:                 sb zero,10(a0) %
00000fc6 : 000505a3;   % 1170:                 sb zero,11(a0) %
00000fc7 : 6f40006f;   % 1171:                 j NEXT_IN_RESET_ZOOMER_LOOP      %
00000fc8 : 00700293;   % 1173:             RESET_ZOOMER_LOOP_MAP2_NOT_6: li t0,7 %
00000fc9 : 04c29863;   % 1174:             bne t0,a2,RESET_ZOOMER_LOOP_MAP2_NOT_7 %
00000fca : 00c00293;   % 1176:                 li t0,12 %
00000fcb : 00550023;   % 1177:                 sb t0,0(a0) %
00000fcc : 00100293;   % 1178:                 li t0,1 %
00000fcd : 005500a3;   % 1179:                 sb t0,1(a0) %
00000fce : 00050123;   % 1180:                 sb zero,2(a0) %
00000fcf : 000501a3;   % 1181:                 sb zero,3(a0) %
00000fd0 : 00700293;   % 1182:                 li t0,7 %
00000fd1 : 00550223;   % 1183:                 sb t0,4(a0) %
00000fd2 : 000502a3;   % 1184:                 sb zero,5(a0) %
00000fd3 : 02100293;   % 1185:                 li t0,33 %
00000fd4 : 00550323;   % 1186:                 sb t0,6(a0) %
00000fd5 : 000503a3;   % 1187:                 sb zero,7(a0) %
00000fd6 : 00050423;   % 1188:                 sb zero,8(a0) %
00000fd7 : 00100293;   % 1189:                 li t0,1 %
00000fd8 : 005504a3;   % 1190:                 sb t0,9(a0) %
00000fd9 : 00050523;   % 1191:                 sb zero,10(a0) %
00000fda : 00100293;   % 1192:                 li t0,1 %
00000fdb : 005505a3;   % 1193:                 sb t0,11(a0) %
00000fdc : 6a00006f;   % 1194:                 j NEXT_IN_RESET_ZOOMER_LOOP   %
00000fdd : 00600293;   % 1198:                 li t0,6 %
00000fde : 00550023;   % 1199:                 sb t0,0(a0) %
00000fdf : 000500a3;   % 1200:                 sb zero,1(a0) %
00000fe0 : 00050123;   % 1201:                 sb zero,2(a0) %
00000fe1 : 000501a3;   % 1202:                 sb zero,3(a0) %
00000fe2 : 01100293;   % 1203:                 li t0,17 %
00000fe3 : 00550223;   % 1204:                 sb t0,4(a0) %
00000fe4 : 000502a3;   % 1205:                 sb zero,5(a0) %
00000fe5 : 02200293;   % 1206:                 li t0,34 %
00000fe6 : 00550323;   % 1207:                 sb t0,6(a0) %
00000fe7 : 000503a3;   % 1208:                 sb zero,7(a0) %
00000fe8 : 00050423;   % 1209:                 sb zero,8(a0) %
00000fe9 : 000504a3;   % 1210:                 sb zero,9(a0) %
00000fea : 00300293;   % 1211:                 li t0,3 %
00000feb : 00550523;   % 1212:                 sb t0,10(a0) %
00000fec : 000505a3;   % 1213:                 sb zero,11(a0) %
00000fed : 65c0006f;   % 1214:                 j NEXT_IN_RESET_ZOOMER_LOOP         %
00000fee : 04061663;   % 1217:         bnez a2,RESET_ZOOMER_LOOP_MAP3_NOT_0 %
00000fef : 00600293;   % 1219:                 li t0,6 %
00000ff0 : 00550023;   % 1220:                 sb t0,0(a0) %
00000ff1 : 000500a3;   % 1221:                 sb zero,1(a0) %
00000ff2 : 00050123;   % 1222:                 sb zero,2(a0) %
00000ff3 : 000501a3;   % 1223:                 sb zero,3(a0) %
00000ff4 : 00200293;   % 1224:                 li t0,2 %
00000ff5 : 00550223;   % 1225:                 sb t0,4(a0) %
00000ff6 : 000502a3;   % 1226:                 sb zero,5(a0) %
00000ff7 : 00a00293;   % 1227:                 li t0,10 %
00000ff8 : 00550323;   % 1228:                 sb t0,6(a0) %
00000ff9 : 000503a3;   % 1229:                 sb zero,7(a0) %
00000ffa : 00050423;   % 1230:                 sb zero,8(a0) %
00000ffb : 00100293;   % 1231:                 li t0,1 %
00000ffc : 005504a3;   % 1232:                 sb t0,9(a0) %
00000ffd : 00100293;   % 1233:                 li t0,1 %
00000ffe : 00550523;   % 1234:                 sb t0,10(a0) %
00000fff : 000505a3;   % 1235:                 sb zero,11(a0) %
00001000 : 6100006f;   % 1236:                 j NEXT_IN_RESET_ZOOMER_LOOP %
00001001 : 00100293;   % 1238:             RESET_ZOOMER_LOOP_MAP3_NOT_0: li t0,1 %
00001002 : 04c29663;   % 1239:             bne t0,a2,RESET_ZOOMER_LOOP_MAP3_NOT_1 %
00001003 : 00600293;   % 1241:                 li t0,6 %
00001004 : 00550023;   % 1242:                 sb t0,0(a0) %
00001005 : 000500a3;   % 1243:                 sb zero,1(a0) %
00001006 : 00050123;   % 1244:                 sb zero,2(a0) %
00001007 : 000501a3;   % 1245:                 sb zero,3(a0) %
00001008 : 01200293;   % 1246:                 li t0,18 %
00001009 : 00550223;   % 1247:                 sb t0,4(a0) %
0000100a : 000502a3;   % 1248:                 sb zero,5(a0) %
0000100b : 00c00293;   % 1249:                 li t0,12 %
0000100c : 00550323;   % 1250:                 sb t0,6(a0) %
0000100d : 000503a3;   % 1251:                 sb zero,7(a0) %
0000100e : 00050423;   % 1252:                 sb zero,8(a0) %
0000100f : 00100293;   % 1253:                 li t0,1 %
00001010 : 005504a3;   % 1254:                 sb t0,9(a0) %
00001011 : 00050523;   % 1255:                 sb zero,10(a0) %
00001012 : 00100293;   % 1256:                 li t0,1 %
00001013 : 005505a3;   % 1257:                 sb t0,11(a0) %
00001014 : 5c00006f;   % 1258:                 j NEXT_IN_RESET_ZOOMER_LOOP %
00001015 : 00200293;   % 1260:             RESET_ZOOMER_LOOP_MAP3_NOT_1: li t0,2 %
00001016 : 04c29663;   % 1261:             bne t0,a2,RESET_ZOOMER_LOOP_MAP3_NOT_2 %
00001017 : 00600293;   % 1263:                 li t0,6 %
00001018 : 00550023;   % 1264:                 sb t0,0(a0) %
00001019 : 000500a3;   % 1265:                 sb zero,1(a0) %
0000101a : 00050123;   % 1266:                 sb zero,2(a0) %
0000101b : 000501a3;   % 1267:                 sb zero,3(a0) %
0000101c : 01f00293;   % 1268:                 li t0,31 %
0000101d : 00550223;   % 1269:                 sb t0,4(a0) %
0000101e : 000502a3;   % 1270:                 sb zero,5(a0) %
0000101f : 00200293;   % 1271:                 li t0,2 %
00001020 : 00550323;   % 1272:                 sb t0,6(a0) %
00001021 : 000503a3;   % 1273:                 sb zero,7(a0) %
00001022 : 00050423;   % 1274:                 sb zero,8(a0) %
00001023 : 00100293;   % 1275:                 li t0,1 %
00001024 : 005504a3;   % 1276:                 sb t0,9(a0) %
00001025 : 00300293;   % 1277:                 li t0,3 %
00001026 : 00550523;   % 1278:                 sb t0,10(a0) %
00001027 : 000505a3;   % 1279:                 sb zero,11(a0) %
00001028 : 5700006f;   % 1280:                 j NEXT_IN_RESET_ZOOMER_LOOP %
00001029 : 00300293;   % 1282:             RESET_ZOOMER_LOOP_MAP3_NOT_2: li t0,3 %
0000102a : 04c29663;   % 1283:             bne t0,a2,RESET_ZOOMER_LOOP_MAP3_NOT_3 %
0000102b : 00600293;   % 1285:                 li t0,6 %
0000102c : 00550023;   % 1286:                 sb t0,0(a0) %
0000102d : 000500a3;   % 1287:                 sb zero,1(a0) %
0000102e : 00050123;   % 1288:                 sb zero,2(a0) %
0000102f : 000501a3;   % 1289:                 sb zero,3(a0) %
00001030 : 02800293;   % 1290:                 li t0,40 %
00001031 : 00550223;   % 1291:                 sb t0,4(a0) %
00001032 : 000502a3;   % 1292:                 sb zero,5(a0) %
00001033 : 00300293;   % 1293:                 li t0,3 %
00001034 : 00550323;   % 1294:                 sb t0,6(a0) %
00001035 : 000503a3;   % 1295:                 sb zero,7(a0) %
00001036 : 00050423;   % 1296:                 sb zero,8(a0) %
00001037 : 000504a3;   % 1297:                 sb zero,9(a0) %
00001038 : 00200293;   % 1298:                 li t0,2 %
00001039 : 00550523;   % 1299:                 sb t0,10(a0) %
0000103a : 00100293;   % 1300:                 li t0,1 %
0000103b : 005505a3;   % 1301:                 sb t0,11(a0) %
0000103c : 5200006f;   % 1302:                 j NEXT_IN_RESET_ZOOMER_LOOP %
0000103d : 00400293;   % 1304:             RESET_ZOOMER_LOOP_MAP3_NOT_3: li t0,4 %
0000103e : 04c29663;   % 1305:             bne t0,a2,RESET_ZOOMER_LOOP_MAP3_NOT_4 %
0000103f : 00600293;   % 1307:                 li t0,6 %
00001040 : 00550023;   % 1308:                 sb t0,0(a0) %
00001041 : 000500a3;   % 1309:                 sb zero,1(a0) %
00001042 : 00050123;   % 1310:                 sb zero,2(a0) %
00001043 : 000501a3;   % 1311:                 sb zero,3(a0) %
00001044 : 02b00293;   % 1312:                 li t0,43 %
00001045 : 00550223;   % 1313:                 sb t0,4(a0) %
00001046 : 000502a3;   % 1314:                 sb zero,5(a0) %
00001047 : 00c00293;   % 1315:                 li t0,12 %
00001048 : 00550323;   % 1316:                 sb t0,6(a0) %
00001049 : 000503a3;   % 1317:                 sb zero,7(a0) %
0000104a : 00050423;   % 1318:                 sb zero,8(a0) %
0000104b : 00100293;   % 1319:                 li t0,1 %
0000104c : 005504a3;   % 1320:                 sb t0,9(a0) %
0000104d : 00050523;   % 1321:                 sb zero,10(a0) %
0000104e : 00100293;   % 1322:                 li t0,1 %
0000104f : 005505a3;   % 1323:                 sb t0,11(a0) %
00001050 : 4d00006f;   % 1324:                 j NEXT_IN_RESET_ZOOMER_LOOP %
00001051 : 00600293;   % 1328:                 li t0,6 %
00001052 : 00550023;   % 1329:                 sb t0,0(a0) %
00001053 : 000500a3;   % 1330:                 sb zero,1(a0) %
00001054 : 00050123;   % 1331:                 sb zero,2(a0) %
00001055 : 000501a3;   % 1332:                 sb zero,3(a0) %
00001056 : 03000293;   % 1333:                 li t0,48 %
00001057 : 00550223;   % 1334:                 sb t0,4(a0) %
00001058 : 000502a3;   % 1335:                 sb zero,5(a0) %
00001059 : 00100293;   % 1336:                 li t0,1 %
0000105a : 00550323;   % 1337:                 sb t0,6(a0) %
0000105b : 000503a3;   % 1338:                 sb zero,7(a0) %
0000105c : 00050423;   % 1339:                 sb zero,8(a0) %
0000105d : 00100293;   % 1340:                 li t0,1 %
0000105e : 005504a3;   % 1341:                 sb t0,9(a0) %
0000105f : 00550523;   % 1342:                 sb t0,10(a0) %
00001060 : 000505a3;   % 1343:                 sb zero,11(a0) %
00001061 : 48c0006f;   % 1344:                 j NEXT_IN_RESET_ZOOMER_LOOP     %
00001062 : 04061663;   % 1348:         bnez a2,RESET_ZOOMER_LOOP_MAP4_NOT_0 %
00001063 : 00600293;   % 1350:                 li t0,6 %
00001064 : 00550023;   % 1351:                 sb t0,0(a0) %
00001065 : 000500a3;   % 1352:                 sb zero,1(a0) %
00001066 : 00050123;   % 1353:                 sb zero,2(a0) %
00001067 : 000501a3;   % 1354:                 sb zero,3(a0) %
00001068 : 00500293;   % 1355:                 li t0,5 %
00001069 : 00550223;   % 1356:                 sb t0,4(a0) %
0000106a : 000502a3;   % 1357:                 sb zero,5(a0) %
0000106b : 02900293;   % 1358:                 li t0,41 %
0000106c : 00550323;   % 1359:                 sb t0,6(a0) %
0000106d : 000503a3;   % 1360:                 sb zero,7(a0) %
0000106e : 00050423;   % 1361:                 sb zero,8(a0) %
0000106f : 000504a3;   % 1362:                 sb zero,9(a0) %
00001070 : 00300293;   % 1363:                 li t0,3 %
00001071 : 00550523;   % 1364:                 sb t0,10(a0) %
00001072 : 00100293;   % 1365:                 li t0,1 %
00001073 : 005505a3;   % 1366:                 sb t0,11(a0) %
00001074 : 4400006f;   % 1367:                 j NEXT_IN_RESET_ZOOMER_LOOP %
00001075 : 00100293;   % 1369:             RESET_ZOOMER_LOOP_MAP4_NOT_0: li t0,1 %
00001076 : 04c29463;   % 1370:             bne t0,a2,RESET_ZOOMER_LOOP_MAP4_NOT_1 %
00001077 : 00c00293;   % 1372:                 li t0,12 %
00001078 : 00550023;   % 1373:                 sb t0,0(a0) %
00001079 : 00100293;   % 1374:                 li t0,1 %
0000107a : 005500a3;   % 1375:                 sb t0,1(a0) %
0000107b : 00050123;   % 1376:                 sb zero,2(a0) %
0000107c : 000501a3;   % 1377:                 sb zero,3(a0) %
0000107d : 00f00293;   % 1378:                 li t0,15 %
0000107e : 00550223;   % 1379:                 sb t0,4(a0) %
0000107f : 000502a3;   % 1380:                 sb zero,5(a0) %
00001080 : 02600293;   % 1381:                 li t0,38 %
00001081 : 00550323;   % 1382:                 sb t0,6(a0) %
00001082 : 000503a3;   % 1383:                 sb zero,7(a0) %
00001083 : 00050423;   % 1384:                 sb zero,8(a0) %
00001084 : 000504a3;   % 1385:                 sb zero,9(a0) %
00001085 : 00050523;   % 1386:                 sb zero,10(a0) %
00001086 : 000505a3;   % 1387:                 sb zero,11(a0) %
00001087 : 3f40006f;   % 1388:                 j NEXT_IN_RESET_ZOOMER_LOOP %
00001088 : 00200293;   % 1390:             RESET_ZOOMER_LOOP_MAP4_NOT_1: li t0,2 %
00001089 : 04c29663;   % 1391:             bne t0,a2,RESET_ZOOMER_LOOP_MAP4_NOT_2 %
0000108a : 00600293;   % 1393:                 li t0,6 %
0000108b : 00550023;   % 1394:                 sb t0,0(a0) %
0000108c : 000500a3;   % 1395:                 sb zero,1(a0) %
0000108d : 00050123;   % 1396:                 sb zero,2(a0) %
0000108e : 000501a3;   % 1397:                 sb zero,3(a0) %
0000108f : 00800293;   % 1398:                 li t0,8 %
00001090 : 00550223;   % 1399:                 sb t0,4(a0) %
00001091 : 000502a3;   % 1400:                 sb zero,5(a0) %
00001092 : 02100293;   % 1401:                 li t0,33 %
00001093 : 00550323;   % 1402:                 sb t0,6(a0) %
00001094 : 000503a3;   % 1403:                 sb zero,7(a0) %
00001095 : 00050423;   % 1404:                 sb zero,8(a0) %
00001096 : 00100293;   % 1405:                 li t0,1 %
00001097 : 005504a3;   % 1406:                 sb t0,9(a0) %
00001098 : 00100293;   % 1407:                 li t0,1 %
00001099 : 00050523;   % 1408:                 sb zero,10(a0) %
0000109a : 005505a3;   % 1409:                 sb t0,11(a0) %
0000109b : 3a40006f;   % 1410:                 j NEXT_IN_RESET_ZOOMER_LOOP %
0000109c : 00300293;   % 1412:             RESET_ZOOMER_LOOP_MAP4_NOT_2: li t0,3 %
0000109d : 04c29663;   % 1413:             bne t0,a2,RESET_ZOOMER_LOOP_MAP4_NOT_3 %
0000109e : 00c00293;   % 1415:                 li t0,12 %
0000109f : 00550023;   % 1416:                 sb t0,0(a0) %
000010a0 : 00100293;   % 1417:                 li t0,1 %
000010a1 : 005500a3;   % 1418:                 sb t0,1(a0) %
000010a2 : 00050123;   % 1419:                 sb zero,2(a0) %
000010a3 : 000501a3;   % 1420:                 sb zero,3(a0) %
000010a4 : 00a00293;   % 1421:                 li t0,10 %
000010a5 : 00550223;   % 1422:                 sb t0,4(a0) %
000010a6 : 000502a3;   % 1423:                 sb zero,5(a0) %
000010a7 : 01a00293;   % 1424:                 li t0,26 %
000010a8 : 00550323;   % 1425:                 sb t0,6(a0) %
000010a9 : 000503a3;   % 1426:                 sb zero,7(a0) %
000010aa : 00050423;   % 1427:                 sb zero,8(a0) %
000010ab : 000504a3;   % 1428:                 sb zero,9(a0) %
000010ac : 00100293;   % 1429:                 li t0,1 %
000010ad : 00550523;   % 1430:                 sb t0,10(a0) %
000010ae : 000505a3;   % 1431:                 sb zero,11(a0) %
000010af : 3540006f;   % 1432:                 j NEXT_IN_RESET_ZOOMER_LOOP %
000010b0 : 00400293;   % 1434:             RESET_ZOOMER_LOOP_MAP4_NOT_3: li t0,4 %
000010b1 : 04c29663;   % 1435:             bne t0,a2,RESET_ZOOMER_LOOP_MAP4_NOT_4 %
000010b2 : 00600293;   % 1437:                 li t0,6 %
000010b3 : 00550023;   % 1438:                 sb t0,0(a0) %
000010b4 : 000500a3;   % 1439:                 sb zero,1(a0) %
000010b5 : 00050123;   % 1440:                 sb zero,2(a0) %
000010b6 : 000501a3;   % 1441:                 sb zero,3(a0) %
000010b7 : 00a00293;   % 1442:                 li t0,10 %
000010b8 : 00550223;   % 1443:                 sb t0,4(a0) %
000010b9 : 000502a3;   % 1444:                 sb zero,5(a0) %
000010ba : 01600293;   % 1445:                 li t0,22 %
000010bb : 00550323;   % 1446:                 sb t0,6(a0) %
000010bc : 000503a3;   % 1447:                 sb zero,7(a0) %
000010bd : 00050423;   % 1448:                 sb zero,8(a0) %
000010be : 00100293;   % 1449:                 li t0,1 %
000010bf : 005504a3;   % 1450:                 sb t0,9(a0) %
000010c0 : 00050523;   % 1451:                 sb zero,10(a0) %
000010c1 : 00100293;   % 1452:                 li t0,1 %
000010c2 : 005505a3;   % 1453:                 sb t0,11(a0) %
000010c3 : 3040006f;   % 1454:                 j NEXT_IN_RESET_ZOOMER_LOOP %
000010c4 : 00500293;   % 1456:             RESET_ZOOMER_LOOP_MAP4_NOT_4: li t0,5 %
000010c5 : 04c29663;   % 1457:             bne t0,a2,RESET_ZOOMER_LOOP_MAP4_NOT_5 %
000010c6 : 00c00293;   % 1459:                 li t0,12 %
000010c7 : 00550023;   % 1460:                 sb t0,0(a0) %
000010c8 : 00100293;   % 1461:                 li t0,1 %
000010c9 : 005500a3;   % 1462:                 sb t0,1(a0) %
000010ca : 00050123;   % 1463:                 sb zero,2(a0) %
000010cb : 000501a3;   % 1464:                 sb zero,3(a0) %
000010cc : 00400293;   % 1465:                 li t0,4 %
000010cd : 00550223;   % 1466:                 sb t0,4(a0) %
000010ce : 000502a3;   % 1467:                 sb zero,5(a0) %
000010cf : 01500293;   % 1468:                 li t0,21 %
000010d0 : 00550323;   % 1469:                 sb t0,6(a0) %
000010d1 : 000503a3;   % 1470:                 sb zero,7(a0) %
000010d2 : 00050423;   % 1471:                 sb zero,8(a0) %
000010d3 : 000504a3;   % 1472:                 sb zero,9(a0) %
000010d4 : 00050523;   % 1473:                 sb zero,10(a0) %
000010d5 : 00100293;   % 1474:                 li t0,1 %
000010d6 : 005505a3;   % 1475:                 sb t0,11(a0) %
000010d7 : 2b40006f;   % 1476:                 j NEXT_IN_RESET_ZOOMER_LOOP    %
000010d8 : 00600293;   % 1478:             RESET_ZOOMER_LOOP_MAP4_NOT_5: li t0,6 %
000010d9 : 04c29463;   % 1479:             bne t0,a2,RESET_ZOOMER_LOOP_MAP4_NOT_6 %
000010da : 00600293;   % 1481:                 li t0,6 %
000010db : 00550023;   % 1482:                 sb t0,0(a0) %
000010dc : 000500a3;   % 1483:                 sb zero,1(a0) %
000010dd : 00050123;   % 1484:                 sb zero,2(a0) %
000010de : 000501a3;   % 1485:                 sb zero,3(a0) %
000010df : 01100293;   % 1486:                 li t0,17 %
000010e0 : 00550223;   % 1487:                 sb t0,4(a0) %
000010e1 : 000502a3;   % 1488:                 sb zero,5(a0) %
000010e2 : 01500293;   % 1489:                 li t0,21 %
000010e3 : 00550323;   % 1490:                 sb t0,6(a0) %
000010e4 : 000503a3;   % 1491:                 sb zero,7(a0) %
000010e5 : 00050423;   % 1492:                 sb zero,8(a0) %
000010e6 : 000504a3;   % 1493:                 sb zero,9(a0) %
000010e7 : 00300293;   % 1494:                 li t0,3 %
000010e8 : 00550523;   % 1495:                 sb t0,10(a0) %
000010e9 : 000505a3;   % 1496:                 sb zero,11(a0) %
000010ea : 2680006f;   % 1497:                 j NEXT_IN_RESET_ZOOMER_LOOP      %
000010eb : 00700293;   % 1499:             RESET_ZOOMER_LOOP_MAP4_NOT_6: li t0,7 %
000010ec : 04c29863;   % 1500:             bne t0,a2,RESET_ZOOMER_LOOP_MAP4_NOT_7 %
000010ed : 00c00293;   % 1502:                 li t0,12 %
000010ee : 00550023;   % 1503:                 sb t0,0(a0) %
000010ef : 00100293;   % 1504:                 li t0,1 %
000010f0 : 005500a3;   % 1505:                 sb t0,1(a0) %
000010f1 : 00050123;   % 1506:                 sb zero,2(a0) %
000010f2 : 000501a3;   % 1507:                 sb zero,3(a0) %
000010f3 : 00c00293;   % 1508:                 li t0,12 %
000010f4 : 00550223;   % 1509:                 sb t0,4(a0) %
000010f5 : 000502a3;   % 1510:                 sb zero,5(a0) %
000010f6 : 00f00293;   % 1511:                 li t0,15 %
000010f7 : 00550323;   % 1512:                 sb t0,6(a0) %
000010f8 : 000503a3;   % 1513:                 sb zero,7(a0) %
000010f9 : 00050423;   % 1514:                 sb zero,8(a0) %
000010fa : 00100293;   % 1515:                 li t0,1 %
000010fb : 005504a3;   % 1516:                 sb t0,9(a0) %
000010fc : 00200293;   % 1517:                 li t0,2 %
000010fd : 00550523;   % 1518:                 sb t0,10(a0) %
000010fe : 000505a3;   % 1519:                 sb zero,11(a0) %
000010ff : 2140006f;   % 1520:                 j NEXT_IN_RESET_ZOOMER_LOOP   %
00001100 : 00800293;   % 1522:             RESET_ZOOMER_LOOP_MAP4_NOT_7: li t0,8 %
00001101 : 04c29463;   % 1523:             bne t0,a2,RESET_ZOOMER_LOOP_MAP4_NOT_8 %
00001102 : 00600293;   % 1525:                 li t0,6 %
00001103 : 00550023;   % 1526:                 sb t0,0(a0) %
00001104 : 000500a3;   % 1527:                 sb zero,1(a0) %
00001105 : 00050123;   % 1528:                 sb zero,2(a0) %
00001106 : 000501a3;   % 1529:                 sb zero,3(a0) %
00001107 : 00700293;   % 1530:                 li t0,7 %
00001108 : 00550223;   % 1531:                 sb t0,4(a0) %
00001109 : 000502a3;   % 1532:                 sb zero,5(a0) %
0000110a : 00b00293;   % 1533:                 li t0,11 %
0000110b : 00550323;   % 1534:                 sb t0,6(a0) %
0000110c : 000503a3;   % 1535:                 sb zero,7(a0) %
0000110d : 00050423;   % 1536:                 sb zero,8(a0) %
0000110e : 000504a3;   % 1537:                 sb zero,9(a0) %
0000110f : 00050523;   % 1538:                 sb zero,10(a0) %
00001110 : 00100293;   % 1539:                 li t0,1 %
00001111 : 005505a3;   % 1540:                 sb t0,11(a0) %
00001112 : 1c80006f;   % 1541:                 j NEXT_IN_RESET_ZOOMER_LOOP     %
00001113 : 00900293;   % 1543:             RESET_ZOOMER_LOOP_MAP4_NOT_8: li t0,9 %
00001114 : 04c29463;   % 1544:             bne t0,a2,RESET_ZOOMER_LOOP_MAP4_NOT_9 %
00001115 : 00600293;   % 1546:                 li t0,6 %
00001116 : 00550023;   % 1547:                 sb t0,0(a0) %
00001117 : 000500a3;   % 1548:                 sb zero,1(a0) %
00001118 : 00050123;   % 1549:                 sb zero,2(a0) %
00001119 : 000501a3;   % 1550:                 sb zero,3(a0) %
0000111a : 00500293;   % 1551:                 li t0,5 %
0000111b : 00550223;   % 1552:                 sb t0,4(a0) %
0000111c : 000502a3;   % 1553:                 sb zero,5(a0) %
0000111d : 00800293;   % 1554:                 li t0,8 %
0000111e : 00550323;   % 1555:                 sb t0,6(a0) %
0000111f : 000503a3;   % 1556:                 sb zero,7(a0) %
00001120 : 00050423;   % 1557:                 sb zero,8(a0) %
00001121 : 000504a3;   % 1558:                 sb zero,9(a0) %
00001122 : 00100293;   % 1559:                 li t0,1 %
00001123 : 00550523;   % 1560:                 sb t0,10(a0) %
00001124 : 000505a3;   % 1561:                 sb zero,11(a0) %
00001125 : 17c0006f;   % 1562:                 j NEXT_IN_RESET_ZOOMER_LOOP  %
00001126 : 00c00293;   % 1566:                 li t0,12 %
00001127 : 00550023;   % 1567:                 sb t0,0(a0) %
00001128 : 00100293;   % 1568:                 li t0,1 %
00001129 : 005500a3;   % 1569:                 sb t0,1(a0) %
0000112a : 00050123;   % 1570:                 sb zero,2(a0) %
0000112b : 000501a3;   % 1571:                 sb zero,3(a0) %
0000112c : 00800293;   % 1572:                 li t0,8 %
0000112d : 00550223;   % 1573:                 sb t0,4(a0) %
0000112e : 000502a3;   % 1574:                 sb zero,5(a0) %
0000112f : 00300293;   % 1575:                 li t0,3 %
00001130 : 00550323;   % 1576:                 sb t0,6(a0) %
00001131 : 000503a3;   % 1577:                 sb zero,7(a0) %
00001132 : 00050423;   % 1578:                 sb zero,8(a0) %
00001133 : 00100293;   % 1579:                 li t0,1 %
00001134 : 005504a3;   % 1580:                 sb t0,9(a0) %
00001135 : 00050523;   % 1581:                 sb zero,10(a0) %
00001136 : 00100293;   % 1582:                 li t0,1 %
00001137 : 005505a3;   % 1583:                 sb t0,11(a0) %
00001138 : 1300006f;   % 1584:                 j NEXT_IN_RESET_ZOOMER_LOOP      %
00001139 : 04061663;   % 1587:         bnez a2,RESET_ZOOMER_LOOP_MAP5_NOT_0 %
0000113a : 00600293;   % 1589:                 li t0,6 %
0000113b : 00550023;   % 1590:                 sb t0,0(a0) %
0000113c : 000500a3;   % 1591:                 sb zero,1(a0) %
0000113d : 00050123;   % 1592:                 sb zero,2(a0) %
0000113e : 000501a3;   % 1593:                 sb zero,3(a0) %
0000113f : 01e00293;   % 1594:                 li t0,30 %
00001140 : 00550223;   % 1595:                 sb t0,4(a0) %
00001141 : 000502a3;   % 1596:                 sb zero,5(a0) %
00001142 : 00c00293;   % 1597:                 li t0,12 %
00001143 : 00550323;   % 1598:                 sb t0,6(a0) %
00001144 : 000503a3;   % 1599:                 sb zero,7(a0) %
00001145 : 00050423;   % 1600:                 sb zero,8(a0) %
00001146 : 00100293;   % 1601:                 li t0,1 %
00001147 : 005504a3;   % 1602:                 sb t0,9(a0) %
00001148 : 00050523;   % 1603:                 sb zero,10(a0) %
00001149 : 00100293;   % 1604:                 li t0,1 %
0000114a : 005505a3;   % 1605:                 sb t0,11(a0) %
0000114b : 0e40006f;   % 1606:                 j NEXT_IN_RESET_ZOOMER_LOOP %
0000114c : 00100293;   % 1608:             RESET_ZOOMER_LOOP_MAP5_NOT_0: li t0,1 %
0000114d : 04c29663;   % 1609:             bne t0,a2,RESET_ZOOMER_LOOP_MAP5_NOT_1 %
0000114e : 00c00293;   % 1611:                 li t0,12 %
0000114f : 00550023;   % 1612:                 sb t0,0(a0) %
00001150 : 00100293;   % 1613:                 li t0,1 %
00001151 : 005500a3;   % 1614:                 sb t0,1(a0) %
00001152 : 00050123;   % 1615:                 sb zero,2(a0) %
00001153 : 000501a3;   % 1616:                 sb zero,3(a0) %
00001154 : 01500293;   % 1617:                 li t0,21 %
00001155 : 00550223;   % 1618:                 sb t0,4(a0) %
00001156 : 000502a3;   % 1619:                 sb zero,5(a0) %
00001157 : 00c00293;   % 1620:                 li t0,12 %
00001158 : 00550323;   % 1621:                 sb t0,6(a0) %
00001159 : 000503a3;   % 1622:                 sb zero,7(a0) %
0000115a : 00050423;   % 1623:                 sb zero,8(a0) %
0000115b : 000504a3;   % 1624:                 sb zero,9(a0) %
0000115c : 00050523;   % 1625:                 sb zero,10(a0) %
0000115d : 00100293;   % 1626:                 li t0,1 %
0000115e : 005505a3;   % 1627:                 sb t0,11(a0) %
0000115f : 0940006f;   % 1628:                 j NEXT_IN_RESET_ZOOMER_LOOP %
00001160 : 00200293;   % 1630:             RESET_ZOOMER_LOOP_MAP5_NOT_1: li t0,2 %
00001161 : 04c29463;   % 1631:             bne t0,a2,RESET_ZOOMER_LOOP_MAP5_NOT_2 %
00001162 : 00600293;   % 1633:                 li t0,6 %
00001163 : 00550023;   % 1634:                 sb t0,0(a0) %
00001164 : 000500a3;   % 1635:                 sb zero,1(a0) %
00001165 : 00050123;   % 1636:                 sb zero,2(a0) %
00001166 : 000501a3;   % 1637:                 sb zero,3(a0) %
00001167 : 01300293;   % 1638:                 li t0,19 %
00001168 : 00550223;   % 1639:                 sb t0,4(a0) %
00001169 : 000502a3;   % 1640:                 sb zero,5(a0) %
0000116a : 00c00293;   % 1641:                 li t0,12 %
0000116b : 00550323;   % 1642:                 sb t0,6(a0) %
0000116c : 000503a3;   % 1643:                 sb zero,7(a0) %
0000116d : 00050423;   % 1644:                 sb zero,8(a0) %
0000116e : 00100293;   % 1645:                 li t0,1 %
0000116f : 005504a3;   % 1646:                 sb t0,9(a0) %
00001170 : 00050523;   % 1647:                 sb zero,10(a0) %
00001171 : 000505a3;   % 1648:                 sb zero,11(a0) %
00001172 : 0480006f;   % 1649:                 j NEXT_IN_RESET_ZOOMER_LOOP %
00001173 : 00600293;   % 1653:                 li t0,6 %
00001174 : 00550023;   % 1654:                 sb t0,0(a0) %
00001175 : 000500a3;   % 1655:                 sb zero,1(a0) %
00001176 : 00050123;   % 1656:                 sb zero,2(a0) %
00001177 : 000501a3;   % 1657:                 sb zero,3(a0) %
00001178 : 00900293;   % 1658:                 li t0,9 %
00001179 : 00550223;   % 1659:                 sb t0,4(a0) %
0000117a : 000502a3;   % 1660:                 sb zero,5(a0) %
0000117b : 00800293;   % 1661:                 li t0,8 %
0000117c : 00550323;   % 1662:                 sb t0,6(a0) %
0000117d : 000503a3;   % 1663:                 sb zero,7(a0) %
0000117e : 00050423;   % 1664:                 sb zero,8(a0) %
0000117f : 00100293;   % 1665:                 li t0,1 %
00001180 : 005504a3;   % 1666:                 sb t0,9(a0) %
00001181 : 00550523;   % 1667:                 sb t0,10(a0) %
00001182 : 005505a3;   % 1668:                 sb t0,11(a0) %
00001183 : 0040006f;   % 1669:                 j NEXT_IN_RESET_ZOOMER_LOOP %
00001184 : 00c50513;   % 1674:             addi a0,a0,12  # Going to the next zoomer's address                                   %
00001185 : 00160613;   % 1675:             addi a2,a2,1            # Iterating counter by 1                                    %
00001186 : 00b65463;   % 1676:             bge a2,a1, END_RESET_ZOOMER_LOOP # If all of the zoomers were checked, end loop                                   %
00001187 : ce4ff06f;   % 1677:             j RESET_ZOOMER_LOOP # otherwise, go back to the loop's beginning                      %
00001188 : 00700293;   % 1685:     li t0,7 %
00001189 : 00589463;   % 1686:     bne a7,t0,RESET_RIDLEY %
0000118a : 0680006f;   % 1687:         j END_RESET_PLASMA_BREATH_LOOP %
0000118b : 0fc0e297;   % 1690:         la t0, RIDLEY_INFO %
0000118c : e1c28293;   % 1690:  %
0000118d : 01e00313;   % 1691:         li t1, 30 %
0000118e : 00628023;   % 1692:         sb t1, 0(t0)            # Restores Ridley's health points %
0000118f : 00a00313;   % 1693:         li t1,10 %
00001190 : 00628123;   % 1694:         sb t1,2(t0)             # Restores Ridley's Y offset %
00001191 : 00500313;   % 1695:         li t1,5 %
00001192 : 006281a3;   % 1696:         sb t1,3(t0)             # Restores Ridley's Y %
00001193 : 00628223;   % 1697:         sb t1,4(t0)             # Restores Ridley's old Y %
00001194 : 00028323;   % 1698:         sb zero,6(t0)           # Restores Ridley's ground position %
00001195 : 000283a3;   % 1699:         sb zero,7(t0)           # Restores Ridley's MOVE_Y %
00001196 : 00028423;   % 1700:         sb zero,8(t0)           # Restores Ridley's JUMP %
00001197 : 01400313;   % 1701:         li t1, 20 %
00001198 : 006284a3;   % 1702:         sb t1,9(t0)             # Restores Ridley's jump cooldown %
00001199 : 00800313;   % 1703:         li t1,8 %
0000119a : 00628523;   % 1704:         sb t1,10(t0)            # Restores Ridley's attack cooldown %
0000119b : 0fc0e517;   % 1706:     la a0,PLASMA_BREATH_ARRAY  # Loads Plasma breath array %
0000119c : dec50513;   % 1706:  %
0000119d : 00000613;   % 1707:     li a2,0 # resets counter %
0000119e : 00500593;   % 1708:     li a1,5 # gets number of plasma breaths in game %
0000119f : 00050023;   % 1710:         sb zero,0(a0)   # Disables it %
000011a0 : 00a50513;   % 1713:             addi a0,a0,10  # Going to the next plasma breath's address                                   %
000011a1 : 00160613;   % 1714:             addi a2,a2,1            # Iterating counter by 1                                    %
000011a2 : 00b65463;   % 1715:             bge a2,a1, END_RESET_PLASMA_BREATH_LOOP # If all of the plasma breaths were checked, end loop (don't attack)                                 %
000011a3 : ff1ff06f;   % 1716:             j RESET_PLASMA_BREATH_LOOP # otherwise, go back to the loop's beginning  %
000011a4 : 00008067;   % 1719:     ret %
000011a5 : 0420d073;   % 137: 	csrwi ucause,1		# caso ocorra dropdown vai gerar exce��o de instru��o inv�lida %
000011a6 : ff810113;   % 139: ExceptionHandling:	addi 	sp, sp, -8 	# salva 2 registradores utilizados para comparar ucause %
000011a7 : 00512023;   % 140: 	sw 	t0, 0(sp) %
000011a8 : 01a12223;   % 141: 	sw 	s10, 4(sp) %
000011a9 : 04202d73;   % 143: 	csrr	s10,ucause     # le o ucause e salva em s10 %
000011aa : 00800293;   % 145: 	li 	t0, 8 %
000011ab : 01a29a63;   % 146: 	bne 	t0, s10, errorExceptions  	# N�o � ecall - nem precisa arrumar a pilha! %
000011ac : 00012283;   % 148: 	lw 	t0, 0(sp)			# � ecall %
000011ad : 00412d03;   % 149:     	lw 	s10, 4(sp)  			# recupera registradores usados %
000011ae : 00810113;   % 150:     	addi 	sp, sp, 8			 %
000011af : 2080006f;   % 151: 	j 	ecallException %
000011b0 : 04302df3;   % 157: errorExceptions: csrr 	s11, utval      # le o utval da exce��o e salva em s11	 %
000011b1 : 0c000513;   % 158: 	addi 	a0, zero, 0xc0 		## printa tela de azul %
000011b2 : 00000593;   % 159: 	addi 	a1, zero, 0 %
000011b3 : 09400893;   % 160: 	addi 	a7, zero, 148 %
000011b4 : 3bc010ef;   % 161: 	jal 	clsCLS %
000011b5 : 00000293;   % 164: End_Cause0:	li 	t0, 0 %
000011b6 : 03a29463;   % 165: 		bne 	t0, s10, End_Cause1 %
000011b7 : 0fc23517;   % 166: 		la 	a0, Cause0 %
000011b8 : 82450513;   % 166:  %
000011b9 : 00000593;   % 167: 		li 	a1, 0 %
000011ba : 00100613;   % 168: 		li 	a2, 1 %
000011bb : 0000c6b7;   % 169: 		li 	a3, 0x0000c0ff %
000011bc : 0ff68693;   % 169:  %
000011bd : 00000793;   % 170: 		li 	a5,0 %
000011be : 195000ef;   % 171: 		jal	printString %
000011bf : 18c0006f;   % 172: 		j	End_uepc %
000011c0 : 00100293;   % 175: End_Cause1:	li 	t0, 1 %
000011c1 : 03a29463;   % 176: 		bne 	t0, s10, End_Cause2 %
000011c2 : 0fc23517;   % 177: 		la 	a0, Cause1 %
000011c3 : 82150513;   % 177:  %
000011c4 : 00000593;   % 178: 		li 	a1, 0 %
000011c5 : 00100613;   % 179: 		li 	a2, 1 %
000011c6 : 0000c6b7;   % 180: 		li 	a3, 0x0000c0ff %
000011c7 : 0ff68693;   % 180:  %
000011c8 : 00000793;   % 181: 		li 	a5,0 %
000011c9 : 169000ef;   % 182: 		jal	printString	 %
000011ca : 1600006f;   % 183: 		j	End_uepc %
000011cb : 00200293;   % 186: End_Cause2:	li 	t0, 2 %
000011cc : 03a29863;   % 187: 		bne 	t0, s10, End_Cause4 %
000011cd : 0fc23517;   % 188: 		la 	a0, Cause2 %
000011ce : 81850513;   % 188:  %
000011cf : 00000593;   % 189: 		li 	a1, 0 %
000011d0 : 00100613;   % 190: 		li 	a2, 1 %
000011d1 : 0000c6b7;   % 191: 		li 	a3, 0x0000c0ff %
000011d2 : 0ff68693;   % 191:  %
000011d3 : 00000793;   % 192: 		li 	a5,0 %
000011d4 : 13d000ef;   % 193: 		jal	printString %
000011d5 : 0fc23517;   % 195: 		la 	a0, Instr %
000011d6 : 8be50513;   % 195:  %
000011d7 : 0fc0006f;   % 196: 		j	End_utval %
000011d8 : 00400293;   % 199: End_Cause4:	addi 	t0, zero, 4 %
000011d9 : 03a29863;   % 200: 		bne	t0, s10, End_Cause5 %
000011da : 0fc23517;   % 201: 		la 	a0, Cause4 %
000011db : 80150513;   % 201:  %
000011dc : 00000593;   % 202: 		li 	a1, 0 %
000011dd : 00100613;   % 203: 		li 	a2, 1 %
000011de : 0000c6b7;   % 204: 		li 	a3, 0x0000c0ff %
000011df : 0ff68693;   % 204:  %
000011e0 : 00000793;   % 205: 		li 	a5,0 %
000011e1 : 109000ef;   % 206: 		jal	printString %
000011e2 : 0fc23517;   % 208: 		la 	a0, Addrs %
000011e3 : 88250513;   % 208:  %
000011e4 : 0c80006f;   % 209: 		j	End_utval %
000011e5 : 00500293;   % 212: End_Cause5:	li 	t0, 5 %
000011e6 : 03a29863;   % 213: 		bne 	t0, s10, End_Cause6 %
000011e7 : 0fc22517;   % 214: 		la 	a0, Cause5 %
000011e8 : 7ef50513;   % 214:  %
000011e9 : 00000593;   % 215: 		li 	a1, 0 %
000011ea : 00100613;   % 216: 		li 	a2, 1 %
000011eb : 0000c6b7;   % 217: 		li 	a3, 0x0000c0ff %
000011ec : 0ff68693;   % 217:  %
000011ed : 00000793;   % 218: 		li 	a5,0 %
000011ee : 0d5000ef;   % 219: 		jal	printString	 %
000011ef : 0fc23517;   % 221: 		la 	a0, Addrs %
000011f0 : 84e50513;   % 221:  %
000011f1 : 0940006f;   % 222: 		j	End_utval %
000011f2 : 00600293;   % 225: End_Cause6:	li 	t0, 6 %
000011f3 : 03a29863;   % 226: 		bne 	t0, s10, End_Cause7 %
000011f4 : 0fc22517;   % 227: 		la 	a0, Cause6 %
000011f5 : 7d750513;   % 227:  %
000011f6 : 00000593;   % 228: 		li 	a1, 0 %
000011f7 : 00100613;   % 229: 		li 	a2, 1 %
000011f8 : 0000c6b7;   % 230: 		li 	a3, 0x0000c0ff %
000011f9 : 0ff68693;   % 230:  %
000011fa : 00000793;   % 231: 		li 	a5,0 %
000011fb : 0a1000ef;   % 232: 		jal	printString %
000011fc : 0fc23517;   % 234: 		la 	a0, Addrs %
000011fd : 81a50513;   % 234:  %
000011fe : 0600006f;   % 235: 		j	End_utval %
000011ff : 00700293;   % 238: End_Cause7:	li 	t0, 7 %
00001200 : 03a29863;   % 239: 		bne 	t0, s10, End_CauseD %
00001201 : 0fc22517;   % 240: 		la 	a0, Cause7 %
00001202 : 7c650513;   % 240:  %
00001203 : 00000593;   % 241: 		li 	a1, 0 %
00001204 : 00100613;   % 242: 		li 	a2, 1 %
00001205 : 0000c6b7;   % 243: 		li 	a3, 0x0000c0ff %
00001206 : 0ff68693;   % 243:  %
00001207 : 00000793;   % 244: 		li 	a5,0 %
00001208 : 06d000ef;   % 245: 		jal	printString %
00001209 : 0fc22517;   % 247: 		la 	a0, Addrs %
0000120a : 7e650513;   % 247:  %
0000120b : 02c0006f;   % 248: 		j	End_utval %
0000120c : 0fc22517;   % 251: End_CauseD: 	la 	a0, CauseD %
0000120d : 7b750513;   % 251:  %
0000120e : 00000593;   % 252: 		li 	a1, 0 %
0000120f : 00100613;   % 253: 		li 	a2, 1 %
00001210 : 0000c6b7;   % 254: 		li 	a3, 0x0000c0ff %
00001211 : 0ff68693;   % 254:  %
00001212 : 00000793;   % 255: 		li 	a5,0 %
00001213 : 041000ef;   % 256: 		jal	printString %
00001214 : 0fc22517;   % 258: 		la 	a0, Addrs %
00001215 : 7ba50513;   % 258:  %
00001216 : 00000593;   % 261: End_utval:	li 	a1, 0 %
00001217 : 01800613;   % 262: 		li 	a2, 24 %
00001218 : 0000c6b7;   % 263: 		li 	a3, 0x000c0ff %
00001219 : 0ff68693;   % 263:  %
0000121a : 00000793;   % 264: 		li 	a5,0 %
0000121b : 021000ef;   % 265: 		jal	printString %
0000121c : 01b00533;   % 267: 		mv 	a0, s11 %
0000121d : 03800593;   % 268: 		li 	a1, 56 %
0000121e : 01800613;   % 269: 		li 	a2, 24 %
0000121f : 0000c6b7;   % 270: 		li 	a3, 0x0000c0ff %
00001220 : 0ff68693;   % 270:  %
00001221 : 794000ef;   % 271: 		jal 	printHex %
00001222 : 0fc22517;   % 274: End_uepc: 	la 	a0, PC 		# Imprime o pc em que a exce��o ocorreu %
00001223 : 77d50513;   % 274:  %
00001224 : 00000593;   % 275: 		li 	a1, 0 %
00001225 : 00c00613;   % 276: 		li 	a2, 12 %
00001226 : 0000c6b7;   % 277: 		li 	a3, 0x000c0ff %
00001227 : 0ff68693;   % 277:  %
00001228 : 00000793;   % 278: 		li 	a5,0 %
00001229 : 7e8000ef;   % 279: 		jal	printString %
0000122a : 04102573;   % 281: 		csrr 	a0, uepc	# Le uepc	 %
0000122b : 01c00593;   % 282: 		li	a1, 28 %
0000122c : 00c00613;   % 283: 		li 	a2, 12 %
0000122d : 0000c6b7;   % 284: 		li 	a3, 0x0000c0ff %
0000122e : 0ff68693;   % 284:  %
0000122f : 75c000ef;   % 285: 		jal 	printHex	 %
00001230 : 2800006f;   % 287: 		j goToExit 		# encerra execu��o %
00001231 : ef810113;   % 294: ecallException:   addi    sp, sp, -264              # Salva todos os registradores na pilha %
00001232 : 00112023;   % 295:     sw     x1,    0(sp) %
00001233 : 00212223;   % 296:     sw     x2,    4(sp) %
00001234 : 00312423;   % 297:     sw     x3,    8(sp) %
00001235 : 00412623;   % 298:     sw     x4,   12(sp) %
00001236 : 00512823;   % 299:     sw     x5,   16(sp) %
00001237 : 00612a23;   % 300:     sw     x6,   20(sp) %
00001238 : 00712c23;   % 301:     sw     x7,   24(sp) %
00001239 : 00812e23;   % 302:     sw     x8,   28(sp) %
0000123a : 02912023;   % 303:     sw     x9,   32(sp) %
0000123b : 02a12223;   % 304:     sw     x10,  36(sp) %
0000123c : 02b12423;   % 305:     sw     x11,  40(sp) %
0000123d : 02c12623;   % 306:     sw     x12,  44(sp) %
0000123e : 02d12823;   % 307:     sw     x13,  48(sp) %
0000123f : 02e12a23;   % 308:     sw     x14,  52(sp) %
00001240 : 02f12c23;   % 309:     sw     x15,  56(sp) %
00001241 : 03012e23;   % 310:     sw     x16,  60(sp) %
00001242 : 05112023;   % 311:     sw     x17,  64(sp) %
00001243 : 05212223;   % 312:     sw     x18,  68(sp) %
00001244 : 05312423;   % 313:     sw     x19,  72(sp) %
00001245 : 05412623;   % 314:     sw     x20,  76(sp) %
00001246 : 05512823;   % 315:     sw     x21,  80(sp) %
00001247 : 05612a23;   % 316:     sw     x22,  84(sp) %
00001248 : 05712c23;   % 317:     sw     x23,  88(sp) %
00001249 : 05812e23;   % 318:     sw     x24,  92(sp) %
0000124a : 07912023;   % 319:     sw     x25,  96(sp) %
0000124b : 07a12223;   % 320:     sw     x26, 100(sp) %
0000124c : 07b12423;   % 321:     sw     x27, 104(sp) %
0000124d : 07c12623;   % 322:     sw     x28, 108(sp) %
0000124e : 07d12823;   % 323:     sw     x29, 112(sp) %
0000124f : 07e12a23;   % 324:     sw     x30, 116(sp) %
00001250 : 07f12c23;   % 325:     sw     x31, 120(sp) %
00001251 : 30102c73;   % 326: <22> csrr s8, misa %
00001252 : 020c7c13;   % 326: <23> andi s8, s8, 0x020 %
00001253 : 080c0263;   % 326: <24> beqz s8, ecallException.pula %
00001254 : 06012e27;   % 327:     fsw    f0,  124(sp) %
00001255 : 08112027;   % 328:     fsw    f1,  128(sp) %
00001256 : 08212227;   % 329:     fsw    f2,  132(sp) %
00001257 : 08312427;   % 330:     fsw    f3,  136(sp) %
00001258 : 08412627;   % 331:     fsw    f4,  140(sp) %
00001259 : 08512827;   % 332:     fsw    f5,  144(sp) %
0000125a : 08612a27;   % 333:     fsw    f6,  148(sp) %
0000125b : 08712c27;   % 334:     fsw    f7,  152(sp) %
0000125c : 08812e27;   % 335:     fsw    f8,  156(sp) %
0000125d : 0a912027;   % 336:     fsw    f9,  160(sp) %
0000125e : 0aa12227;   % 337:     fsw    f10, 164(sp) %
0000125f : 0ab12427;   % 338:     fsw    f11, 168(sp) %
00001260 : 0ac12627;   % 339:     fsw    f12, 172(sp) %
00001261 : 0ad12827;   % 340:     fsw    f13, 176(sp) %
00001262 : 0ae12a27;   % 341:     fsw    f14, 180(sp) %
00001263 : 0af12c27;   % 342:     fsw    f15, 184(sp) %
00001264 : 0b012e27;   % 343:     fsw    f16, 188(sp) %
00001265 : 0d112027;   % 344:     fsw    f17, 192(sp) %
00001266 : 0d212227;   % 345:     fsw    f18, 196(sp) %
00001267 : 0d312427;   % 346:     fsw    f19, 200(sp) %
00001268 : 0d412627;   % 347:     fsw    f20, 204(sp) %
00001269 : 0d512827;   % 348:     fsw    f21, 208(sp) %
0000126a : 0d612a27;   % 349:     fsw    f22, 212(sp) %
0000126b : 0d712c27;   % 350:     fsw    f23, 216(sp) %
0000126c : 0d812e27;   % 351:     fsw    f24, 220(sp) %
0000126d : 0f912027;   % 352:     fsw    f25, 224(sp) %
0000126e : 0fa12227;   % 353:     fsw    f26, 228(sp) %
0000126f : 0fb12427;   % 354:     fsw    f27, 232(sp) %
00001270 : 0fc12627;   % 355:     fsw    f28, 236(sp) %
00001271 : 0fd12827;   % 356:     fsw    f29, 240(sp) %
00001272 : 0fe12a27;   % 357:     fsw    f30, 244(sp) %
00001273 : 0ff12c27;   % 358:     fsw    f31, 248(sp) %
00001274 : 000002b3;   % 361:     add     t0, zero, zero %
00001275 : 00000333;   % 362:     add     t1, zero, zero %
00001276 : 000003b3;   % 363:     add     t2, zero, zero %
00001277 : 00000e33;   % 364:     add     t3, zero, zero %
00001278 : 00000eb3;   % 365:     add     t4, zero, zero %
00001279 : 00000f33;   % 366:     add     t5, zero, zero %
0000127a : 00000fb3;   % 367:     add     t6, zero, zero %
0000127b : 00a00293;   % 372:     addi    t0, zero, 10 %
0000127c : 15128863;   % 373:     beq     t0, a7, goToExit          # ecall exit %
0000127d : 06e00293;   % 374:     addi    t0, zero, 110 %
0000127e : 15128463;   % 375:     beq     t0, a7, goToExit          # ecall exit %
0000127f : 00100293;   % 377:     addi    t0, zero, 1               # ecall 1 = print int %
00001280 : 15128c63;   % 378:     beq     t0, a7, goToPrintInt %
00001281 : 06500293;   % 379:     addi    t0, zero, 101             # ecall 1 = print int %
00001282 : 15128863;   % 380:     beq     t0, a7, goToPrintInt %
00001283 : 00200293;   % 382:     addi    t0, zero, 2               # ecall 2 = print float %
00001284 : 17128063;   % 383:     beq     t0, a7, goToPrintFloat %
00001285 : 06600293;   % 384:     addi    t0, zero, 102             # ecall 2 = print float %
00001286 : 15128c63;   % 385:     beq     t0, a7, goToPrintFloat %
00001287 : 00300293;   % 387:     addi    t0, zero, 3               # ecall 3 = print double %
00001288 : 17128263;   % 388:     beq     t0, a7, goToPrintDouble %
00001289 : 06700293;   % 389:     addi    t0, zero, 103             # ecall 2 = print double %
0000128a : 15128e63;   % 390:     beq     t0, a7, goToPrintDouble %
0000128b : 00400293;   % 392:     addi    t0, zero, 4               # ecall 4 = print string %
0000128c : 13128863;   % 393:     beq     t0, a7, goToPrintString %
0000128d : 06800293;   % 394:     addi    t0, zero, 104             # ecall 4 = print string %
0000128e : 13128463;   % 395:     beq     t0, a7, goToPrintString %
0000128f : 00500293;   % 397:     addi    t0, zero, 5               # ecall 5 = read int %
00001290 : 17128063;   % 398:     beq     t0, a7, goToReadInt %
00001291 : 06900293;   % 399:     addi    t0, zero, 105             # ecall 5 = read int %
00001292 : 15128c63;   % 400:     beq     t0, a7, goToReadInt %
00001293 : 00600293;   % 402:     addi    t0, zero, 6               # ecall 6 = read float %
00001294 : 17128063;   % 403:     beq     t0, a7, goToReadFloat %
00001295 : 06a00293;   % 404:     addi    t0, zero, 106             # ecall 6 = read float %
00001296 : 15128c63;   % 405:     beq     t0, a7, goToReadFloat %
00001297 : 00700293;   % 407:     addi    t0, zero, 7               # ecall 7 = read Double %
00001298 : 17128263;   % 408:     beq     t0, a7, goToReadDouble %
00001299 : 06b00293;   % 409:     addi    t0, zero, 107             # ecall 7 = read Double %
0000129a : 15128e63;   % 410:     beq     t0, a7, goToReadDouble %
0000129b : 00800293;   % 412:     addi    t0, zero, 8               # ecall 8 = read string %
0000129c : 13128c63;   % 413:     beq     t0, a7, goToReadString %
0000129d : 06c00293;   % 414:     addi    t0, zero, 108             # ecall 8 = read string %
0000129e : 13128863;   % 415:     beq     t0, a7, goToReadString %
0000129f : 00b00293;   % 417:     addi    t0, zero, 11              # ecall 11 = print char %
000012a0 : 0f128463;   % 418:     beq     t0, a7, goToPrintChar %
000012a1 : 06f00293;   % 419:     addi    t0, zero, 111             # ecall 11 = print char %
000012a2 : 0f128063;   % 420:     beq     t0, a7, goToPrintChar %
000012a3 : 00c00293;   % 422:     addi    t0, zero, 12              # ecall 12 = read char %
000012a4 : 11128463;   % 423:     beq     t0, a7, goToReadChar %
000012a5 : 07000293;   % 424:     addi    t0, zero, 112             # ecall 12 = read char %
000012a6 : 11128063;   % 425:     beq     t0, a7, goToReadChar %
000012a7 : 01e00293;   % 428:     addi    t0, zero, 30              # ecall 30 = time %
000012a8 : 15128c63;   % 429:     beq     t0, a7, goToTime %
000012a9 : 08200293;   % 430:     addi    t0, zero, 130             # ecall 30 = time %
000012aa : 15128863;   % 431:     beq     t0, a7, goToTime %
000012ab : 01f00293;   % 433:     addi    t0, zero, 31              # ecall 31 = MIDI out %
000012ac : 13128c63;   % 434:     beq     t0, a7, goToMidiOut       # Generate tone and return immediately %
000012ad : 08300293;   % 435:     addi    t0, zero, 131             # ecall 31 = MIDI out %
000012ae : 13128863;   % 436:     beq     t0, a7, goToMidiOut %
000012af : 02000293;   % 438:     addi    t0, zero, 32              # ecall 32 = sleep %
000012b0 : 15128063;   % 439:     beq     t0, a7, goToSleep %
000012b1 : 08400293;   % 440:     addi    t0, zero, 132             # ecall 32 = sleep %
000012b2 : 13128c63;   % 441:     beq     t0, a7, goToSleep %
000012b3 : 02100293;   % 443:     addi    t0, zero, 33              # ecall 33 = MIDI out synchronous %
000012b4 : 13128063;   % 444:     beq     t0, a7, goToMidiOutSync   # Generate tone and return upon tone completion %
000012b5 : 08500293;   % 445:     addi    t0, zero, 133             # ecall 33 = MIDI out synchronous %
000012b6 : 11128c63;   % 446:     beq     t0, a7, goToMidiOutSync %
000012b7 : 02200293;   % 448:     addi    t0, zero, 34       		# ecall 34 = print hex %
000012b8 : 0f128c63;   % 449:     beq     t0, a7, goToPrintHex %
000012b9 : 08600293;   % 450:     addi    t0, zero, 134		# ecall 34 = print hex %
000012ba : 0f128863;   % 451:     beq     t0, a7, goToPrintHex %
000012bb : 02400293;   % 459:     addi    t0, zero, 36              # ecall 36 = PrintIntUnsigned %
000012bc : 0f128863;   % 460:     beq     t0, a7, goToPrintIntUnsigned %
000012bd : 08800293;   % 461:     addi    t0, zero, 136             # ecall 36 = PrintIntUnsigned %
000012be : 0f128463;   % 462:     beq     t0, a7, goToPrintIntUnsigned %
000012bf : 02900293;   % 465:     addi    t0, zero, 41              # ecall 41 = random %
000012c0 : 11128463;   % 466:     beq     t0, a7, goToRandom %
000012c1 : 08d00293;   % 467:     addi    t0, zero, 141             # ecall 41 = random %
000012c2 : 11128063;   % 468:     beq     t0, a7, goToRandom %
000012c3 : 02a00293;   % 470:     addi    t0, zero, 42              # ecall 41 = random %
000012c4 : 11128063;   % 471:     beq     t0, a7, goToRandom2 %
000012c5 : 08e00293;   % 472:     addi    t0, zero, 142             # ecall 41 = random %
000012c6 : 0f128c63;   % 473:     beq     t0, a7, goToRandom2 %
000012c7 : 02f00293;   % 476:     addi    t0, zero, 47              # ecall 47 = DrawLine %
000012c8 : 11128063;   % 477:     beq     t0, a7, goToBRES %
000012c9 : 09300293;   % 478:     addi    t0, zero, 147              # ecall 47 = DrawLine %
000012ca : 0f128c63;   % 479:     beq     t0, a7, goToBRES     %
000012cb : 03000293;   % 481:     addi    t0, zero, 48              # ecall 48 = CLS %
000012cc : 0f128463;   % 482:     beq     t0, a7, goToCLS %
000012cd : 09400293;   % 483:     addi    t0, zero, 148              # ecall 48 = CLS %
000012ce : 0f128063;   % 484:     beq     t0, a7, goToCLS %
000012cf : 1f8000ef;   % 489:     jal NaoExisteEcall  # ecall inexistente %
000012d0 : 10008c37;   % 492: <9> li s8, 0x10008000	# carrega tp %
000012d1 : 000c0c13;   % 492:  %
000012d2 : 01819663;   % 492: <10> bne gp, s8, goToExitDE2	# Na DE1 gp = 0 ! N�o tem segmento .extern %
000012d3 : 00a00893;   % 493: 			li 	a7, 10			# chama o ecall normal do Rars %
000012d4 : 00000073;   % 494: 			ecall				# exit ecall	 %
000012d5 : 0000006f;   % 495: 	goToExitDE2:	j 	goToExitDE2		# trava o processador : N�o tem sistema operacional! %
000012d6 : 244000ef;   % 497: 	goToPrintInt:	jal     printInt               	# chama printInt %
000012d7 : 0cc0006f;   % 498: 			j       endEcall %
000012d8 : 52c000ef;   % 500: 	goToPrintString: jal     printString           	# chama printString %
000012d9 : 0c40006f;   % 501: 			 j       endEcall %
000012da : 56c000ef;   % 503: 	goToPrintChar:	jal     printChar		# chama printChar %
000012db : 0bc0006f;   % 504: 			j       endEcall %
000012dc : 30102c73;   % 506: <22> csrr s8, misa %
000012dd : 020c7c13;   % 506: <23> andi s8, s8, 0x020 %
000012de : 1a0c0e63;   % 506: <24> beqz s8, NaoExisteEcall %
000012df : 1ed000ef;   % 507: 			jal     printFloat		# chama printFloat %
000012e0 : 0a80006f;   % 508: 			j       endEcall %
000012e1 : 30102c73;   % 510: <22> csrr s8, misa %
000012e2 : 020c7c13;   % 510: <23> andi s8, s8, 0x020 %
000012e3 : 1a0c0463;   % 510: <24> beqz s8, NaoExisteEcall %
000012e4 : 3dd000ef;   % 511: 			jal     printDouble		# chama printDuble %
000012e5 : 0940006f;   % 512: 			j       endEcall %
000012e6 : 688000ef;   % 515: 	goToReadChar:	jal     readChar              	# chama readChar %
000012e7 : 08c0006f;   % 516: 			j       endEcall %
000012e8 : 7b0000ef;   % 518: 	goToReadInt:   	jal     readInt                 # chama readInt %
000012e9 : 0840006f;   % 519: 			j       endEcall %
000012ea : 718000ef;   % 521: 	goToReadString:	jal     readString              # chama readString %
000012eb : 07c0006f;   % 522: 			j       endEcall %
000012ec : 30102c73;   % 524: <22> csrr s8, misa %
000012ed : 020c7c13;   % 524: <23> andi s8, s8, 0x020 %
000012ee : 160c0e63;   % 524: <24> beqz s8, NaoExisteEcall %
000012ef : 3b9000ef;   % 525: 			jal     readFloat               # chama readFloat %
000012f0 : 0680006f;   % 526: 			j       endEcall %
000012f1 : 30102c73;   % 528: <22> csrr s8, misa %
000012f2 : 020c7c13;   % 528: <23> andi s8, s8, 0x020 %
000012f3 : 160c0463;   % 528: <24> beqz s8, NaoExisteEcall %
000012f4 : 3a1000ef;   % 529: 			jal     readDouble               # chama readDouble %
000012f5 : 0540006f;   % 530: 			j       endEcall %
000012f6 : 440000ef;   % 533: 	goToPrintHex:	jal     printHex                # chama printHex %
000012f7 : 04c0006f;   % 534: 			j       endEcall %
000012f8 : 0c4010ef;   % 536: 	goToPrintIntUnsigned: 	jal	printIntUnsigned	# chama Print Unsigned Int %
000012f9 : 0440006f;   % 537: 				j	endEcall   %
000012fa : 079000ef;   % 539: 	goToMidiOut:	jal     midiOut                 # chama MIDIout %
000012fb : 03c0006f;   % 540: 			j       endEcall %
000012fc : 0e9000ef;   % 542: 	goToMidiOutSync: jal     midiOutSync   		# chama MIDIoutSync %
000012fd : 0340006f;   % 543: 			 j       endEcall %
000012fe : 5e1000ef;   % 545: 	goToTime:	jal     Time                    # chama time %
000012ff : 02c0006f;   % 546: 			j       endEcall %
00001300 : 5fd000ef;   % 548: 	goToSleep:	jal     Sleep                  	# chama sleep %
00001301 : 0240006f;   % 549: 			j       endEcall %
00001302 : 621000ef;   % 551: 	goToRandom:	jal     Random                 	# chama random %
00001303 : 01c0006f;   % 552: 			j       endEcall %
00001304 : 641000ef;   % 554: 	goToRandom2:	jal     Random2                 # chama random2 %
00001305 : 0140006f;   % 555: 			j       endEcall %
00001306 : 675000ef;   % 557: 	goToCLS:	jal     clsCLS                 	# chama CLS %
00001307 : 00c0006f;   % 558: 			j       endEcall %
00001308 : 6c9000ef;   % 560: 	goToBRES:	jal     BRESENHAM               # chama BRESENHAM %
00001309 : 0040006f;   % 561: 			j       endEcall    	 %
0000130a : 00012083;   % 565: endEcall:  	lw	x1,   0(sp)  # recupera QUASE todos os registradores na pilha %
0000130b : 00412103;   % 566: 		lw	x2,   4(sp)	 %
0000130c : 00812183;   % 567: 		lw	x3,   8(sp)	 %
0000130d : 00c12203;   % 568: 		lw	x4,  12(sp)      	 %
0000130e : 01012283;   % 569: 		lw	x5,  16(sp)      	 %
0000130f : 01412303;   % 570: 		lw	x6,  20(sp)	 %
00001310 : 01812383;   % 571: 		lw	x7,  24(sp) %
00001311 : 01c12403;   % 572: 		lw	x8,  28(sp) %
00001312 : 02012483;   % 573: 		lw	x9,  32(sp) %
00001313 : 02c12603;   % 576: 		lw     x12, 44(sp) %
00001314 : 03012683;   % 577: 		lw     x13, 48(sp) %
00001315 : 03412703;   % 578: 		lw     x14, 52(sp) %
00001316 : 03812783;   % 579: 		lw     x15, 56(sp) %
00001317 : 03c12803;   % 580: 		lw     x16, 60(sp) %
00001318 : 04012883;   % 581: 		lw     x17, 64(sp) %
00001319 : 04412903;   % 582: 		lw     x18, 68(sp) %
0000131a : 04812983;   % 583: 		lw     x19, 72(sp) %
0000131b : 04c12a03;   % 584: 		lw     x20, 76(sp) %
0000131c : 05012a83;   % 585: 		lw     x21, 80(sp) %
0000131d : 05412b03;   % 586: 		lw     x22, 84(sp) %
0000131e : 05812b83;   % 587: 		lw     x23, 88(sp) %
0000131f : 05c12c03;   % 588: 		lw     x24, 92(sp) %
00001320 : 06012c83;   % 589: 		lw     x25, 96(sp) %
00001321 : 06412d03;   % 590: 		lw     x26, 100(sp) %
00001322 : 06812d83;   % 591: 		lw     x27, 104(sp) %
00001323 : 06c12e03;   % 592: 		lw     x28, 108(sp) %
00001324 : 07012e83;   % 593: 		lw     x29, 112(sp) %
00001325 : 07412f03;   % 594: 		lw     x30, 116(sp) %
00001326 : 07812f83;   % 595: 		lw     x31, 120(sp) %
00001327 : 30102c73;   % 596: <22> csrr s8, misa %
00001328 : 020c7c13;   % 596: <23> andi s8, s8, 0x020 %
00001329 : 060c0e63;   % 596: <24> beqz s8, endEcall.pula %
0000132a : 07c12007;   % 597: 		flw    f0,  124(sp) %
0000132b : 08012087;   % 598: 		flw    f1,  128(sp) %
0000132c : 08412107;   % 599: 		flw    f2,  132(sp) %
0000132d : 08812187;   % 600: 		flw    f3,  136(sp) %
0000132e : 08c12207;   % 601: 		flw    f4,  140(sp) %
0000132f : 09012287;   % 602: 		flw    f5,  144(sp) %
00001330 : 09412307;   % 603: 		flw    f6,  148(sp) %
00001331 : 09812387;   % 604: 		flw    f7,  152(sp) %
00001332 : 09c12407;   % 605: 		flw    f8,  156(sp) %
00001333 : 0a012487;   % 606: 		flw    f9,  160(sp) %
00001334 : 0ac12607;   % 609: 		flw    f12, 172(sp) %
00001335 : 0b012687;   % 610: 		flw    f13, 176(sp) %
00001336 : 0b412707;   % 611: 		flw    f14, 180(sp) %
00001337 : 0b812787;   % 612: 		flw    f15, 184(sp) %
00001338 : 0bc12807;   % 613: 		flw    f16, 188(sp) %
00001339 : 0c012887;   % 614: 		flw    f17, 192(sp) %
0000133a : 0c412907;   % 615: 		flw    f18, 196(sp) %
0000133b : 0c812987;   % 616: 		flw    f19, 200(sp) %
0000133c : 0cc12a07;   % 617: 		flw    f20, 204(sp) %
0000133d : 0d012a87;   % 618: 		flw    f21, 208(sp) %
0000133e : 0d412b07;   % 619: 		flw    f22, 212(sp) %
0000133f : 0d812b87;   % 620: 		flw    f23, 216(sp) %
00001340 : 0dc12c07;   % 621: 		flw    f24, 220(sp) %
00001341 : 0e012c87;   % 622: 		flw    f25, 224(sp) %
00001342 : 0e412d07;   % 623: 		flw    f26, 228(sp) %
00001343 : 0e812d87;   % 624: 		flw    f27, 232(sp) %
00001344 : 0ec12e07;   % 625: 		flw    f28, 236(sp) %
00001345 : 0f012e87;   % 626: 		flw    f29, 240(sp) %
00001346 : 0f412f07;   % 627: 		flw    f30, 244(sp) %
00001347 : 0f812f87;   % 628: 		flw    f31, 248(sp) %
00001348 : 10810113;   % 630: endEcall.pula:	addi    sp, sp, 264 %
00001349 : 04102273;   % 632: 		csrr 	tp, uepc 	# le o valor de EPC salvo no registrador uepc (reg 65) %
0000134a : 00420213;   % 633: 		addi 	tp, tp, 4	# soma 4 para obter a instrucao seguinte ao ecall %
0000134b : 04121073;   % 634: 		csrw 	tp, uepc	# coloca no registrador uepc %
0000134c : 00200073;   % 635: 		uret			# retorna PC=uepc %
0000134d : 0c000513;   % 643: NaoExisteEcall: addi 	a0, zero, 0xc0 		## printa tela de azul %
0000134e : 00000593;   % 644: 		addi 	a1, zero, 0 %
0000134f : 01100833;   % 645: 		mv 	a6, a7 %
00001350 : 09400893;   % 646: 		addi 	a7, zero, 148 %
00001351 : 549000ef;   % 647: 		jal 	clsCLS %
00001352 : 0fc22517;   % 648:   		la 	a0, CauseE %
00001353 : 2af50513;   % 648:  %
00001354 : 00000593;   % 649: 		li 	a1, 0 %
00001355 : 00100613;   % 650: 		li 	a2, 1 %
00001356 : 0000c6b7;   % 651: 		li 	a3, 0x0000c0ff %
00001357 : 0ff68693;   % 651:  %
00001358 : 00000793;   % 652: 		li 	a5,0 %
00001359 : 328000ef;   % 653: 		jal	printString %
0000135a : 01000533;   % 654: 		mv 	a0, a6 %
0000135b : 06800593;   % 655: 		li 	a1, 104 %
0000135c : 00100613;   % 656: 		li 	a2, 1 %
0000135d : 0000c6b7;   % 657: 		li 	a3, 0x0000c0ff %
0000135e : 0ff68693;   % 657:  %
0000135f : 020000ef;   % 658: 		jal 	printInt %
00001360 : 04102573;   % 659: 		csrr	a0,uepc %
00001361 : 08800593;   % 660: 		li 	a1, 136 %
00001362 : 00100613;   % 661: 		li 	a2, 1 %
00001363 : 0000c6b7;   % 662: 		li 	a3, 0x0000c0ff %
00001364 : 0ff68693;   % 662:  %
00001365 : 284000ef;   % 663: 		jal 	printHex		 %
00001366 : da9ff06f;   % 664: 		j 	goToExit %
00001367 : ffc10113;   % 676: printInt:	addi 	sp, sp, -4			# Aloca espaco %
00001368 : 00112023;   % 677: 		sw 	ra, 0(sp)			# salva ra %
00001369 : 0fc22297;   % 678: 		la 	t0, TempBuffer			# carrega o Endereco do Buffer da String %
0000136a : f1428293;   % 678:  %
0000136b : 00055a63;   % 680: 		bge 	a0, zero, ehposprintInt		# Se eh positvo %
0000136c : 02d00313;   % 681: 		li 	t1, '-'				# carrega o sinal - %
0000136d : 00628023;   % 682: 		sb 	t1, 0(t0)			# coloca no buffer %
0000136e : 00128293;   % 683: 		addi 	t0, t0, 1			# incrementa endereco do buffer %
0000136f : 40a00533;   % 684: 		sub 	a0, zero, a0			# torna o numero positivo %
00001370 : 00a00393;   % 686: ehposprintInt:  li 	t2, 10				# carrega numero 10 %
00001371 : 00000313;   % 687: 		li 	t1, 0				# carrega numero de digitos com 0 %
00001372 : 30102c73;   % 689: <29> csrr s8, misa %
00001373 : 00cc5c13;   % 689: <30> srli s8, s8, 12 %
00001374 : 001c7c13;   % 689: <31> andi s8, s8, 0x001 %
00001375 : 1e0c1863;   % 689: <32> bnez s8, printInt.pula1 %
00001376 : ff410113;   % 690: <99> addi 	sp,sp,-12 %
00001377 : 00a12023;   % 690: <100> sw	a0,0(sp) %
00001378 : 00b12223;   % 690: <101> sw	a1,4(sp) %
00001379 : 00c12423;   % 690: <102> sw	a2,8(sp) %
0000137a : 00a00633;   % 690: <103> mv 	a2,a0 %
0000137b : 41f65593;   % 690: <104> srai 	a1,a2,31 %
0000137c : 00c00533;   % 690: <105> mv 	a0,a2 %
0000137d : 00058463;   % 690: <106> beqz 	a1,div10.pula1_M8 %
0000137e : 40c00533;   % 690: <107> neg 	a0,a2 %
0000137f : ff010113;   % 690: <65> addi 	sp, sp, -16 %
00001380 : 00a12023;   % 690: <66> sw	a0, 0(sp) %
00001381 : 00e12223;   % 690: <67> sw	a4, 4(sp) %
00001382 : 00f12423;   % 690: <68> sw	a5, 8(sp) %
00001383 : 00112623;   % 690: <69> sw	ra, 12(sp) %
00001384 : 00a00533;   % 690: <70> mv 	a0, a0 %
00001385 : 00155713;   % 690: <71> srli    a4,a0,1 %
00001386 : 00255793;   % 690: <72> srli    a5,a0,2 %
00001387 : 00f707b3;   % 690: <73> add     a5,a4,a5 %
00001388 : 0047d713;   % 690: <74> srli    a4,a5,4 %
00001389 : 00f70733;   % 690: <75> add     a4,a4,a5 %
0000138a : 00875793;   % 690: <76> srli    a5,a4,8 %
0000138b : 00e78733;   % 690: <77> add     a4,a5,a4 %
0000138c : 01075793;   % 690: <78> srli    a5,a4,16 %
0000138d : 00e787b3;   % 690: <79> add     a5,a5,a4 %
0000138e : 0037d793;   % 690: <80> srli    a5,a5,3 %
0000138f : 00279713;   % 690: <81> slli    a4,a5,2 %
00001390 : 00f70733;   % 690: <82> add     a4,a4,a5 %
00001391 : 00171713;   % 690: <83> slli    a4,a4,1 %
00001392 : 40e50533;   % 690: <84> sub     a0,a0,a4 %
00001393 : 00a53513;   % 690: <85> sltiu   a0,a0,10 %
00001394 : 00154513;   % 690: <86> xori    a0,a0,1 %
00001395 : 00f50533;   % 690: <87> add     a0,a0,a5 %
00001396 : 04051073;   % 690: <88> csrw	a0,uscratch %
00001397 : 00012503;   % 690: <89> lw	a0, 0(sp) %
00001398 : 00412703;   % 690: <90> lw	a4, 4(sp) %
00001399 : 00812783;   % 690: <91> lw	a5, 8(sp) %
0000139a : 00c12083;   % 690: <92> lw	ra, 12(sp) %
0000139b : 01010113;   % 690: <93> addi 	sp, sp, 16 %
0000139c : 04002ef3;   % 690: <94> csrr	t4,uscratch %
0000139d : 00058463;   % 690: <109> beqz 	a1,div10.pula2_M8 %
0000139e : 41d00eb3;   % 690: <110> neg 	t4,t4 %
0000139f : 040e9073;   % 690: <111> div10.pula2_M8:	csrw	t4,uscratch %
000013a0 : 00012503;   % 690: <112> lw	a0,0(sp) %
000013a1 : 00412583;   % 690: <113> lw 	a1,4(sp) %
000013a2 : 00812603;   % 690: <114> lw	a2,8(sp) %
000013a3 : 00c10113;   % 690: <115> addi 	sp,sp,12 %
000013a4 : 04002ef3;   % 690: <116> csrr	t4,uscratch %
000013a5 : ff010113;   % 691: <145> addi 	sp,sp,-16 %
000013a6 : 00a12023;   % 691: <146> sw	a0,0(sp) %
000013a7 : 00b12223;   % 691: <147> sw	a1,4(sp) %
000013a8 : 00c12423;   % 691: <148> sw	a2,8(sp) %
000013a9 : 00d12623;   % 691: <149> sw	a3,12(sp) %
000013aa : 00a006b3;   % 691: <151> mv 	a3,a0 %
000013ab : 00a00613;   % 691: <152> li 	a2,10 %
000013ac : ff410113;   % 691: <99> addi 	sp,sp,-12 %
000013ad : 00a12023;   % 691: <100> sw	a0,0(sp) %
000013ae : 00b12223;   % 691: <101> sw	a1,4(sp) %
000013af : 00c12423;   % 691: <102> sw	a2,8(sp) %
000013b0 : 00d00633;   % 691: <103> mv 	a2,a3 %
000013b1 : 41f65593;   % 691: <104> srai 	a1,a2,31 %
000013b2 : 00c00533;   % 691: <105> mv 	a0,a2 %
000013b3 : 00058463;   % 691: <106> beqz 	a1,div10.pula1_M11 %
000013b4 : 40c00533;   % 691: <107> neg 	a0,a2 %
000013b5 : ff010113;   % 691: <65> addi 	sp, sp, -16 %
000013b6 : 00a12023;   % 691: <66> sw	a0, 0(sp) %
000013b7 : 00e12223;   % 691: <67> sw	a4, 4(sp) %
000013b8 : 00f12423;   % 691: <68> sw	a5, 8(sp) %
000013b9 : 00112623;   % 691: <69> sw	ra, 12(sp) %
000013ba : 00a00533;   % 691: <70> mv 	a0, a0 %
000013bb : 00155713;   % 691: <71> srli    a4,a0,1 %
000013bc : 00255793;   % 691: <72> srli    a5,a0,2 %
000013bd : 00f707b3;   % 691: <73> add     a5,a4,a5 %
000013be : 0047d713;   % 691: <74> srli    a4,a5,4 %
000013bf : 00f70733;   % 691: <75> add     a4,a4,a5 %
000013c0 : 00875793;   % 691: <76> srli    a5,a4,8 %
000013c1 : 00e78733;   % 691: <77> add     a4,a5,a4 %
000013c2 : 01075793;   % 691: <78> srli    a5,a4,16 %
000013c3 : 00e787b3;   % 691: <79> add     a5,a5,a4 %
000013c4 : 0037d793;   % 691: <80> srli    a5,a5,3 %
000013c5 : 00279713;   % 691: <81> slli    a4,a5,2 %
000013c6 : 00f70733;   % 691: <82> add     a4,a4,a5 %
000013c7 : 00171713;   % 691: <83> slli    a4,a4,1 %
000013c8 : 40e50533;   % 691: <84> sub     a0,a0,a4 %
000013c9 : 00a53513;   % 691: <85> sltiu   a0,a0,10 %
000013ca : 00154513;   % 691: <86> xori    a0,a0,1 %
000013cb : 00f50533;   % 691: <87> add     a0,a0,a5 %
000013cc : 04051073;   % 691: <88> csrw	a0,uscratch %
000013cd : 00012503;   % 691: <89> lw	a0, 0(sp) %
000013ce : 00412703;   % 691: <90> lw	a4, 4(sp) %
000013cf : 00812783;   % 691: <91> lw	a5, 8(sp) %
000013d0 : 00c12083;   % 691: <92> lw	ra, 12(sp) %
000013d1 : 01010113;   % 691: <93> addi 	sp, sp, 16 %
000013d2 : 04002573;   % 691: <94> csrr	a0,uscratch %
000013d3 : 00058463;   % 691: <109> beqz 	a1,div10.pula2_M11 %
000013d4 : 40a00533;   % 691: <110> neg 	a0,a0 %
000013d5 : 04051073;   % 691: <111> div10.pula2_M11:	csrw	a0,uscratch %
000013d6 : 00012503;   % 691: <112> lw	a0,0(sp) %
000013d7 : 00412583;   % 691: <113> lw 	a1,4(sp) %
000013d8 : 00812603;   % 691: <114> lw	a2,8(sp) %
000013d9 : 00c10113;   % 691: <115> addi 	sp,sp,12 %
000013da : 04002573;   % 691: <116> csrr	a0,uscratch %
000013db : ff410113;   % 691: <45> addi 	sp, sp, -12 %
000013dc : 00a12023;   % 691: <46> sw	a0, 0(sp) %
000013dd : 00b12223;   % 691: <47> sw	a1, 4(sp) %
000013de : 00112423;   % 691: <48> sw	ra, 8(sp) %
000013df : 00a00533;   % 691: <50> mv 	a0, a0 %
000013e0 : 00c005b3;   % 691: <51> mv 	a1, a2 %
000013e1 : 701000ef;   % 691: <52> jal 	__mulsi3 %
000013e2 : 04051073;   % 691: <53> csrw	a0,uscratch %
000013e3 : 00012503;   % 691: <55> lw	a0, 0(sp) %
000013e4 : 00412583;   % 691: <56> lw	a1, 4(sp) %
000013e5 : 00812083;   % 691: <57> lw	ra, 8(sp) %
000013e6 : 00c10113;   % 691: <58> addi 	sp, sp, 12 %
000013e7 : 040025f3;   % 691: <59> csrr	a1,uscratch %
000013e8 : 40b68e33;   % 691: <155> sub 	t3,a3,a1 %
000013e9 : 040e1073;   % 691: <157> csrw	t3,uscratch %
000013ea : 00012503;   % 691: <158> lw	a0,0(sp) %
000013eb : 00412583;   % 691: <159> lw 	a1,4(sp) %
000013ec : 00812603;   % 691: <160> lw	a2,8(sp) %
000013ed : 00c12683;   % 691: <161> lw 	a3,12(sp) %
000013ee : 01010113;   % 691: <162> addi 	sp,sp,16 %
000013ef : 04002e73;   % 691: <163> csrr	t3,uscratch %
000013f0 : 00c0006f;   % 692: 		j 	printInt.pula1d %
000013f1 : 02754eb3;   % 693: printInt.pula1:	div 	t4, a0, t2			# divide por 10 (quociente) %
000013f2 : 02756e33;   % 694: 		rem 	t3, a0, t2			# resto %
000013f3 : ffc10113;   % 695: printInt.pula1d:addi 	sp, sp, -4			# aloca espaco na pilha %
000013f4 : 01c12023;   % 696: 		sw 	t3, 0(sp)			# coloca resto na pilha %
000013f5 : 01d00533;   % 697: 		mv 	a0, t4				# atualiza o numero com o quociente %
000013f6 : 00130313;   % 698: 		addi 	t1, t1, 1			# incrementa o contador de digitos %
000013f7 : de0516e3;   % 699: 		bne 	a0, zero, loop1printInt		# verifica se o numero eh zero %
000013f8 : 00012383;   % 701: loop2printInt:	lw 	t2, 0(sp)			# le digito da pilha %
000013f9 : 00410113;   % 702: 		addi 	sp, sp, 4			# libera espaco %
000013fa : 03038393;   % 703: 		addi 	t2, t2, 48			# converte o digito para ascii %
000013fb : 00728023;   % 704: 		sb 	t2, 0(t0)			# coloca caractere no buffer %
000013fc : 00128293;   % 705: 		addi 	t0, t0, 1			# incrementa endereco do buffer %
000013fd : fff30313;   % 706: 		addi 	t1, t1, -1			# decrementa contador de digitos %
000013fe : fe0314e3;   % 707: 		bne 	t1, zero, loop2printInt		# eh o ultimo? %
000013ff : 00028023;   % 708: 		sb 	zero, 0(t0)			# insere \NULL na string %
00001400 : 0fc22517;   % 710: 		la 	a0, TempBuffer			# Endereco do buffer da srting %
00001401 : cb850513;   % 710:  %
00001402 : 084000ef;   % 711: 		jal	printString			# chama o print string %
00001403 : 00012083;   % 713: 		lw 	ra, 0(sp)			# recupera a %
00001404 : 00410113;   % 714: 		addi 	sp, sp, 4			# libera espaco %
00001405 : 00008067;   % 715: fimprintInt:	ret					# retorna %
00001406 : ffc10113;   % 727: printHex:	addi    sp, sp, -4    		# aloca espaco %
00001407 : 00112023;   % 728:     		sw      ra, 0(sp)		# salva ra %
00001408 : 00a002b3;   % 729: 		mv 	t0, a0			# Inteiro de 32 bits a ser impresso em Hexa %
00001409 : 0fc22317;   % 730: 		la 	t1, TabelaHexASCII	# endereco da tabela HEX->ASCII %
0000140a : e9430313;   % 730:  %
0000140b : 0fc22397;   % 731: 		la 	t2, TempBuffer		# onde a string sera montada %
0000140c : c8c38393;   % 731:  %
0000140d : 03000e13;   % 733: 		li 	t3,'0'			# Caractere '0' %
0000140e : 01c38023;   % 734: 		sb 	t3,0(t2)		# Escreve '0' no Buffer da String %
0000140f : 07800e13;   % 735: 		li 	t3,'x'			# Caractere 'x' %
00001410 : 01c380a3;   % 736: 		sb 	t3,1(t2)		# Escreve 'x' no Buffer da String %
00001411 : 00238393;   % 737: 		addi 	t2,t2,2			# novo endereco inicial da string %
00001412 : 01c00e13;   % 739: 		li 	t3, 28			# contador de nibble   inicio = 28 %
00001413 : 020e4263;   % 740: loopprintHex:	blt 	t3, zero, fimloopprintHex	# terminou? t3<0? %
00001414 : 01c2deb3;   % 741: 		srl 	t4, t0, t3		# desloca o nibble para direita %
00001415 : 00fefe93;   % 742: 		andi 	t4, t4, 0x000F		# mascara o nibble	 %
00001416 : 01d30eb3;   % 743: 		add 	t4, t1, t4		# endereco do ascii do nibble %
00001417 : 000e8e83;   % 744: 		lb 	t4, 0(t4)		# le ascii do nibble %
00001418 : 01d38023;   % 745: 		sb 	t4, 0(t2)		# armazena o ascii do nibble no buffer da string %
00001419 : 00138393;   % 746: 		addi 	t2, t2, 1		# incrementa o endereco do buffer %
0000141a : ffce0e13;   % 747: 		addi 	t3, t3, -4		# decrementa o numero do nibble %
0000141b : fe1ff06f;   % 748: 		j 	loopprintHex %
0000141c : 00038023;   % 750: fimloopprintHex: sb 	zero,0(t2)		# grava \null na string %
0000141d : 0fc22517;   % 751: 		la 	a0, TempBuffer		# Argumento do print String %
0000141e : c4450513;   % 751:  %
0000141f : 010000ef;   % 752: 		jal	printString		# Chama o print string %
00001420 : 00012083;   % 754: 		lw 	ra, 0(sp)		# recupera ra %
00001421 : 00410113;   % 755: 		addi 	sp, sp, 4		# libera espaco %
00001422 : 00008067;   % 756: fimprintHex:	ret				# retorna %
00001423 : ff810113;   % 767: printString:	addi	sp, sp, -8			# aloca espaco %
00001424 : 00112023;   % 768:     		sw	ra, 0(sp)			# salva ra %
00001425 : 00812223;   % 769:     		sw	s0, 4(sp)			# salva s0 %
00001426 : 00a00433;   % 770:     		mv	s0, a0              		# s0 = endereco do caractere na string %
00001427 : 00040503;   % 772: loopprintString:lb	a0, 0(s0)                 	# le em a0 o caracter a ser impresso %
00001428 : 02050263;   % 774:     		beq     a0, zero, fimloopprintString	# string ASCIIZ termina com NULL %
00001429 : 030000ef;   % 776:     		jal     printChar       		# imprime char %
0000142a : 00858593;   % 778: 		addi    a1, a1, 8                 	# incrementa a coluna %
0000142b : 13900f93;   % 779: 		li 	t6, 313		 %
0000142c : 01f5c663;   % 780: 		blt	a1, t6, NaoPulaLinha	    	# se ainda tiver lugar na linha %
0000142d : 00860613;   % 781:     		addi    a2, a2, 8                 	# incrementa a linha %
0000142e : 000005b3;   % 782:     		mv    	a1, zero			# volta a coluna zero %
0000142f : 00140413;   % 784: NaoPulaLinha:	addi    s0, s0, 1			# proximo caractere %
00001430 : fddff06f;   % 785:     		j       loopprintString       		# volta ao loop %
00001431 : 00012083;   % 787: fimloopprintString:	lw      ra, 0(sp)    		# recupera ra %
00001432 : 00012403;   % 788: 			lw 	s0, 0(sp)		# recupera s0 original %
00001433 : 00810113;   % 789:     			addi    sp, sp, 8		# libera espaco %
00001434 : 00008067;   % 790: fimprintString:	ret      	    			# retorna %
00001435 : 0ff00e93;   % 813: printChar:	li 	t4, 0xFF	# t4 temporario %
00001436 : 008e9e93;   % 814: 		slli 	t4, t4, 8	# t4 = 0x0000FF00 (no RARS, nao podemos fazer diretamente "andi rd, rs1, 0xFF00") %
00001437 : 01d6ff33;   % 815: 		and    	t5, a3, t4   	# t5 obtem cor de fundo %
00001438 : 008f5f13;   % 816:     		srli	t5, t5, 8	# numero da cor de fundo %
00001439 : 0ff6ff93;   % 817: 		andi   	t6, a3, 0xFF    # t6 obtem cor de frente %
0000143a : 02000213;   % 819: 		li 	tp, ' ' %
0000143b : 00454863;   % 820: 		blt 	a0, tp, printChar.NAOIMPRIMIVEL	# ascii menor que 32 nao eh imprimivel %
0000143c : 07e00213;   % 821: 		li 	tp, '~' %
0000143d : 00a24463;   % 822: 		bgt	a0, tp, printChar.NAOIMPRIMIVEL	# ascii Maior que 126  nao eh imprimivel %
0000143e : 0080006f;   % 823:     		j       printChar.IMPRIMIVEL %
0000143f : 02000513;   % 825: printChar.NAOIMPRIMIVEL: li      a0, 32		# Imprime espaco %
00001440 : 14000213;   % 827: printChar.IMPRIMIVEL:	li	tp, 320		# Num colunas 320 %
00001441 : 30102c73;   % 828: <29> csrr s8, misa %
00001442 : 00cc5c13;   % 828: <30> srli s8, s8, 12 %
00001443 : 001c7c13;   % 828: <31> andi s8, s8, 0x001 %
00001444 : 020c1e63;   % 828: <32> bnez s8, printChar.mul1 %
00001445 : ff410113;   % 829: <45> addi 	sp, sp, -12 %
00001446 : 00a12023;   % 829: <46> sw	a0, 0(sp) %
00001447 : 00b12223;   % 829: <47> sw	a1, 4(sp) %
00001448 : 00112423;   % 829: <48> sw	ra, 8(sp) %
00001449 : 00400533;   % 829: <50> mv 	a0, tp %
0000144a : 00c005b3;   % 829: <51> mv 	a1, a2 %
0000144b : 559000ef;   % 829: <52> jal 	__mulsi3 %
0000144c : 04051073;   % 829: <53> csrw	a0,uscratch %
0000144d : 00012503;   % 829: <55> lw	a0, 0(sp) %
0000144e : 00412583;   % 829: <56> lw	a1, 4(sp) %
0000144f : 00812083;   % 829: <57> lw	ra, 8(sp) %
00001450 : 00c10113;   % 829: <58> addi 	sp, sp, 12 %
00001451 : 04002ef3;   % 829: <59> csrr	t4,uscratch %
00001452 : 0080006f;   % 830: 			j printChar.mul1d %
00001453 : 02c20eb3;   % 831: printChar.mul1:		mul     t4, tp, a2			# multiplica a2x320  t4 = coordenada y %
00001454 : 00be8eb3;   % 832: printChar.mul1d:	add     t4, t4, a1               	# t4 = 320*y + x %
00001455 : 007e8e93;   % 833: 			addi    t4, t4, 7                 	# t4 = 320*y + (x+7) %
00001456 : ff000237;   % 834: 			li      tp, 0xFF000000          	# Endereco de inicio da memoria VGA0 %
00001457 : 00020213;   % 834:  %
00001458 : 00070663;   % 835: 			beq 	a4, zero, printChar.PULAFRAME		# Verifica qual o frame a ser usado em a4 %
00001459 : ff100237;   % 836: 			li      tp, 0xFF100000          	# Endereco de inicio da memoria VGA1 %
0000145a : 00020213;   % 836:  %
0000145b : 004e8eb3;   % 837: printChar.PULAFRAME:	add     t4, t4, tp               	# t4 = endereco de impressao do ultimo pixel da primeira linha do char %
0000145c : fe050393;   % 838: 			addi    t2, a0, -32               	# indice do char na memoria %
0000145d : 00339393;   % 839: 			slli    t2, t2, 3                 	# offset em bytes em relacao ao endereco inicial %
0000145e : 00079863;   % 840: 			bnez    a5, printChar.PS2P      # se a5 != 0, usar outra fonte   ---> pode fazer outros beqs caso queira adicionar fontes %
0000145f : 0fc21e17;   % 841: 			la      t3, LabelTabChar		# endereco dos caracteres na memoria %
00001460 : 420e0e13;   % 841:  %
00001461 : 00c0006f;   % 842: 			j printChar.endereco            # ir para calculo final do endereco %
00001462 : 0fc21e17;   % 845: 			la      t3, LabelTabCharPS2P     # Fonte alternativa %
00001463 : 72ce0e13;   % 845:  %
00001464 : 01c383b3;   % 848: 			add     t2, t2, t3               	# endereco do caractere na memoria %
00001465 : 0003ae03;   % 849: 			lw      t3, 0(t2)                 	# carrega a primeira word do char %
00001466 : 00400293;   % 850: 			li 	t0, 4				# i=4 %
00001467 : 02028e63;   % 852: printChar.forChar1I:	beq     t0, zero, printChar.endForChar1I # if(i == 0) end for i %
00001468 : 00800313;   % 853:     			addi    t1, zero, 8               	# j = 8 %
00001469 : 02030463;   % 855: printChar.forChar1J:	beq     t1, zero, printChar.endForChar1J # if(j == 0) end for j %
0000146a : 001e7c93;   % 856:         		andi    s9, t3, 0x001			# primeiro bit do caracter %
0000146b : 001e5e13;   % 857:         		srli    t3, t3, 1             		# retira o primeiro bit %
0000146c : 000c8663;   % 858:         		beq     s9, zero, printChar.printCharPixelbg1	# pixel eh fundo? %
0000146d : 01fe8023;   % 859:         		sb      t6, 0(t4)             		# imprime pixel com cor de frente %
0000146e : 0080006f;   % 860:         		j       printChar.endCharPixel1 %
0000146f : 01ee8023;   % 861: printChar.printCharPixelbg1:	sb      t5, 0(t4)                # imprime pixel com cor de fundo %
00001470 : fff30313;   % 862: printChar.endCharPixel1: addi    t1, t1, -1                	# j-- %
00001471 : fffe8e93;   % 863:     			addi    t4, t4, -1                	# t4 aponta um pixel para a esquerda %
00001472 : fddff06f;   % 864:     			j       printChar.forChar1J		# vollta novo pixel %
00001473 : fff28293;   % 866: printChar.endForChar1J: addi    t0, t0, -1 		# i-- %
00001474 : 148e8e93;   % 867:     			addi    t4, t4, 328           	# 2**12 + 8 %
00001475 : fc9ff06f;   % 868:     			j       printChar.forChar1I	# volta ao loop %
00001476 : 0043ae03;   % 870: printChar.endForChar1I:	lw      t3, 4(t2)           	# carrega a segunda word do char %
00001477 : 00400293;   % 871: 			li 	t0, 4			# i = 4 %
00001478 : 02028e63;   % 872: printChar.forChar2I:    beq     t0, zero, printChar.endForChar2I  # if(i == 0) end for i %
00001479 : 00800313;   % 873:     			addi    t1, zero, 8             # j = 8 %
0000147a : 02030463;   % 875: printChar.forChar2J:	beq	t1, zero, printChar.endForChar2J # if(j == 0) end for j %
0000147b : 001e7c93;   % 876:         		andi    s9, t3, 0x001	    		# pixel a ser impresso %
0000147c : 001e5e13;   % 877:         		srli    t3, t3, 1                 	# desloca para o proximo %
0000147d : 000c8663;   % 878:         		beq     s9, zero, printChar.printCharPixelbg2 # pixel eh fundo? %
0000147e : 01fe8023;   % 879:         		sb      t6, 0(t4)			# imprime cor frente %
0000147f : 0080006f;   % 880:         		j       printChar.endCharPixel2		# volta ao loop %
00001480 : 01ee8023;   % 882: printChar.printCharPixelbg2:	sb      t5, 0(t4)		# imprime cor de fundo %
00001481 : fff30313;   % 884: printChar.endCharPixel2:	addi    t1, t1, -1		# j-- %
00001482 : fffe8e93;   % 885:     				addi    t4, t4, -1              # t4 aponta um pixel para a esquerda %
00001483 : fddff06f;   % 886:     				j       printChar.forChar2J %
00001484 : fff28293;   % 888: printChar.endForChar2J:	addi	t0, t0, -1 		# i-- %
00001485 : 148e8e93;   % 889:     			addi    t4, t4, 328		# %
00001486 : fc9ff06f;   % 890:     			j       printChar.forChar2I	# volta ao loop %
00001487 : 00008067;   % 892: printChar.endForChar2I:	ret				# retorna %
00001488 : 00000013;   % 901: readChar: 		nop %
00001489 : ff2002b7;   % 905: readCharKDMMIO:		li 	t0, 0xFF200000			# Execucao com Polling do KD MMIO %
0000148a : 00028293;   % 905:  %
0000148b : 0002a503;   % 907: loopReadCharKDMMIO:  	lw     	a0, 0(t0)   			# le o bit de flag do teclado %
0000148c : 00157513;   % 908: 			andi 	a0, a0, 0x0001			# mascara bit 0 %
0000148d : fe050ce3;   % 909: 			beqz    a0, loopReadCharKDMMIO  	# testa se uma tecla foi pressionada %
0000148e : 0042a503;   % 910:    			lw 	a0, 4(t0)			# le o ascii da tecla pressionada %
0000148f : 0800006f;   % 911: 			j fimreadChar				# fim Read Char %
00001490 : ff2002b7;   % 917: readCharDE2:  	li      t0, 0xFF200100 			# Endereco buffer0 %
00001491 : 10028293;   % 917:  %
00001492 : 0002a303;   % 918:     		lw     	t1, 0(t0)				# conteudo inicial do buffer %
00001493 : 0002a383;   % 920: loopReadChar:  	lw     	t2, 0(t0)   				# le buffer teclado %
00001494 : 00639663;   % 921: 		bne     t2, t1, buffermodificadoChar    	# testa se o buffer foi modificado %
00001495 : 00700333;   % 923: atualizaBufferChar:  mv t1, t2			# atualiza o buffer com o novo valor %
00001496 : ff5ff06f;   % 924:     		j       loopReadChar		# loop de principal de leitura  %
00001497 : 0ff00f13;   % 926: buffermodificadoChar:	li t5, 0xFF %
00001498 : 008f1f13;   % 927: 	slli 	t5, t5, 8			# t5 = 0x0000FF00 %
00001499 : 01e3fe33;   % 928: 	and    	t3, t2, t5 			# mascara o 2o scancode %
0000149a : 0000f237;   % 929: 	li 	tp, 0x0000F000 %
0000149b : 00020213;   % 929:  %
0000149c : 024e0063;   % 930: 	beq     t3, tp, teclasoltaChar		# eh 0xF0 no 2o scancode? tecla foi solta %
0000149d : 0ff00213;   % 931: 	li	tp, 0x000000FF %
0000149e : 0043fe33;   % 932: 	and	t3, t2, tp			# mascara 1o scancode	(essa podemos fazer diretamente) %
0000149f : 01200213;   % 933: 	li	tp, 0x00000012 %
000014a0 : fc4e1ae3;   % 934:     	bne 	t3, tp, atualizaBufferChar	# nao eh o SHIFT que esta pressionado ? volta a ler  %
000014a1 : 0fc22417;   % 935: 	la      s0, LabelScanCodeShift		# se for SHIFT que esta pressionado atualiza o endereco da tabel %
000014a2 : 9ae40413;   % 935:  %
000014a3 : fc9ff06f;   % 936:     	j       atualizaBufferChar		# volta a ler %
000014a4 : 0ff3fe13;   % 938: teclasoltaChar:		andi t3, t2, 0x00FF		# mascara o 1o scancode %
000014a5 : 08000213;   % 939: 	li	tp, 0x00000080 %
000014a6 : fbc24ee3;   % 940:   	bgt	t3, tp, atualizaBufferChar		# se o scancode for > 0x80 entao nao eh imprimivel! %
000014a7 : 01200213;   % 941:   	li	tp, 0x00000012 %
000014a8 : 004e1863;   % 942: 	bne 	t3, tp, naoehshiftChar			# nao foi o shift que foi solto? entao processa %
000014a9 : 0fc22417;   % 943: 	la 	s0, LabelScanCode			# shift foi solto atualiza o endereco da tabela %
000014aa : 90840413;   % 943:  %
000014ab : fa9ff06f;   % 944: 	j 	atualizaBufferChar			# volta a ler %
000014ac : 01c40e33;   % 946: naoehshiftChar:	   	add     t3, s0, t3              # endereco na tabela de scancode da tecla com ou sem shift %
000014ad : 000e0503;   % 947:     	lb      a0, 0(t3)				# le o ascii do caracter para a0 %
000014ae : f8050ee3;   % 948:     	beq     a0, zero, atualizaBufferChar		# se for caractere nao imprimivel volta a ler %
000014af : 00008067;   % 950: fimreadChar: 	ret			# retorna %
000014b0 : ff810113;   % 962: readString: 	addi 	sp, sp, -8			# reserva espaco na pilha %
000014b1 : 00812223;   % 963: 		sw 	s0, 4(sp)			# salva s0 %
000014b2 : 00112023;   % 964: 		sw 	ra, 0(sp)			# salva ra %
000014b3 : 00000693;   % 965: 		li 	a3, 0				# zera o contador de caracteres digitados %
000014b4 : 00a00933;   % 966: 		mv 	s2, a0				# salva o endereco inicial %
000014b5 : 0fc22417;   % 967:     		la      s0, LabelScanCode      		# Endereco da tabela de scancode inicial para readChar %
000014b6 : 8d840413;   % 967:  %
000014b7 : 04d58c63;   % 969: loopreadString: beq 	a1, a3, fimreadString   	# buffer cheio fim %
000014b8 : ff810113;   % 971: 		addi 	sp, sp, -8 %
000014b9 : 00112023;   % 972: 		sw 	ra, 0(sp)			# salva ra %
000014ba : 00a12223;   % 973: 		sw 	a0, 4(sp)			# salva a0 pois ele sera reescrito em readChar %
000014bb : f35ff0ef;   % 974: 		jal 	readChar			# le um caracter do teclado (retorno em a0) %
000014bc : 00a00fb3;   % 975: 		mv 	t6, a0				# t6 eh a letra lida em readChar %
000014bd : 00012083;   % 976: 		lw 	ra, 0(sp) %
000014be : 00412503;   % 977: 		lw 	a0, 4(sp) %
000014bf : 00810113;   % 978: 		addi 	sp, sp, 8 %
000014c0 : 00800213;   % 980: 		li 	tp, 0x08			 %
000014c1 : 004f9c63;   % 981: 		bne	t6, tp, PulaBackSpace		# Se nao for BACKSPACE %
000014c2 : fcd00ae3;   % 982: 		beq	zero, a3, loopreadString	# Se n�o tem nenhum caractere no buffer apenas volta a ler %
000014c3 : fff68693;   % 983: 		addi	a3, a3, -1			# diminui contador %
000014c4 : fff50513;   % 984: 		addi 	a0, a0, -1			# diminui endereco do buffer %
000014c5 : 00050023;   % 985: 		sb 	zero, 0(a0)			# coloca zero no caractere anterior %
000014c6 : fc5ff06f;   % 986: 		j loopreadString %
000014c7 : 00a00213;   % 988: PulaBackSpace:	li	tp, 0x0A %
000014c8 : 004f8a63;   % 989: 		beq 	t6, tp, fimreadString		# se for tecla ENTER fim %
000014c9 : 01f50023;   % 990: 		sb 	t6, 0(a0)			# grava no buffer %
000014ca : 00168693;   % 991: 		addi 	a3, a3, 1			# incrementa contador %
000014cb : 00150513;   % 992: 		addi 	a0, a0, 1			# incrementa endereco no buffer %
000014cc : fadff06f;   % 993: 		j loopreadString			# volta a ler outro caractere %
000014cd : 00050023;   % 995: fimreadString: 	sb 	zero, 0(a0)			# grava NULL no buffer %
000014ce : fff50613;   % 996: 		addi 	a2, a0, -1			# Para que a2 tenha o endereco do ultimo caractere digitado %
000014cf : 01200533;   % 997: 		mv	a0, s2				# a0 volta a ter o endereco inicial da string %
000014d0 : 00012083;   % 998: 		lw 	ra, 0(sp)			# recupera ra %
000014d1 : 00412403;   % 999: 		lw	s0, 4(sp)			# recupera s0 %
000014d2 : 00810113;   % 1000: 		addi 	sp, sp, 8			# libera espaco %
000014d3 : 00008067;   % 1001: 		ret					# retorna %
000014d4 : ffc10113;   % 1010: readInt: 	addi 	sp,sp,-4		# reserva espaco na pilha %
000014d5 : 00112023;   % 1011: 	sw 	ra, 0(sp)			# salva ra %
000014d6 : 0fc22517;   % 1012: 	la 	a0, TempBuffer			# Endereco do buffer de string %
000014d7 : 96050513;   % 1012:  %
000014d8 : 00a00593;   % 1013: 	li 	a1, 10				# numero maximo de digitos %
000014d9 : f5dff0ef;   % 1014: 	jal 	readString			# le uma string de ate 10 digitos, a3 numero de digitos %
000014da : 00c002b3;   % 1015: 	mv 	t0, a2				# copia endereco do ultimo digito %
000014db : 00a00393;   % 1016: 	li 	t2, 10				# dez %
000014dc : 00100e13;   % 1017: 	li 	t3, 1				# dezenas, centenas, etc %
000014dd : 00000533;   % 1018: 	mv 	a0, zero			# zera o numero %
000014de : 0c068e63;   % 1020: loopReadInt: 	beq	a3,zero, fimReadInt	# Leu todos os digitos %
000014df : 00028303;   % 1021: 	lb 	t1, (t0)			# le um digito %
000014e0 : 02d00213;   % 1022: 	li	tp, 0x0000002D %
000014e1 : 0c430663;   % 1023: 	beq 	t1, tp, ehnegReadInt		# = '-' %
000014e2 : 02b00213;   % 1024: 	li	tp, 0x0000002B %
000014e3 : 0c430463;   % 1025: 	beq 	t1, tp, ehposReadInt		# = '+' %
000014e4 : 03000213;   % 1026: 	li	tp, 0x00000030 %
000014e5 : 0a434c63;   % 1027: 	blt 	t1, tp, naoehReadInt		# <'0' %
000014e6 : 03900213;   % 1028: 	li	tp, 0x00000039 %
000014e7 : 0a624863;   % 1029: 	bgt 	t1, tp, naoehReadInt		# >'9' %
000014e8 : fd030313;   % 1030: 	addi 	t1, t1, -48			# transforma ascii em numero %
000014e9 : 30102c73;   % 1031: <29> csrr s8, misa %
000014ea : 00cc5c13;   % 1031: <30> srli s8, s8, 12 %
000014eb : 001c7c13;   % 1031: <31> andi s8, s8, 0x001 %
000014ec : 020c1e63;   % 1031: <32> bnez s8, readInt.mul1 %
000014ed : ff410113;   % 1032: <45> addi 	sp, sp, -12 %
000014ee : 00a12023;   % 1032: <46> sw	a0, 0(sp) %
000014ef : 00b12223;   % 1032: <47> sw	a1, 4(sp) %
000014f0 : 00112423;   % 1032: <48> sw	ra, 8(sp) %
000014f1 : 00600533;   % 1032: <50> mv 	a0, t1 %
000014f2 : 01c005b3;   % 1032: <51> mv 	a1, t3 %
000014f3 : 2b9000ef;   % 1032: <52> jal 	__mulsi3 %
000014f4 : 04051073;   % 1032: <53> csrw	a0,uscratch %
000014f5 : 00012503;   % 1032: <55> lw	a0, 0(sp) %
000014f6 : 00412583;   % 1032: <56> lw	a1, 4(sp) %
000014f7 : 00812083;   % 1032: <57> lw	ra, 8(sp) %
000014f8 : 00c10113;   % 1032: <58> addi 	sp, sp, 12 %
000014f9 : 04002373;   % 1032: <59> csrr	t1,uscratch %
000014fa : 0080006f;   % 1033: 	j readInt.mul1d %
000014fb : 03c30333;   % 1034: readInt.mul1: 	mul 	t1, t1, t3			# multiplica por dezenas/centenas %
000014fc : 00650533;   % 1035: readInt.mul1d:	add 	a0, a0, t1			# soma no numero %
000014fd : 30102c73;   % 1036: <29> csrr s8, misa %
000014fe : 00cc5c13;   % 1036: <30> srli s8, s8, 12 %
000014ff : 001c7c13;   % 1036: <31> andi s8, s8, 0x001 %
00001500 : 020c1e63;   % 1036: <32> bnez s8, readInt.mul2 %
00001501 : ff410113;   % 1037: <45> addi 	sp, sp, -12 %
00001502 : 00a12023;   % 1037: <46> sw	a0, 0(sp) %
00001503 : 00b12223;   % 1037: <47> sw	a1, 4(sp) %
00001504 : 00112423;   % 1037: <48> sw	ra, 8(sp) %
00001505 : 01c00533;   % 1037: <50> mv 	a0, t3 %
00001506 : 007005b3;   % 1037: <51> mv 	a1, t2 %
00001507 : 269000ef;   % 1037: <52> jal 	__mulsi3 %
00001508 : 04051073;   % 1037: <53> csrw	a0,uscratch %
00001509 : 00012503;   % 1037: <55> lw	a0, 0(sp) %
0000150a : 00412583;   % 1037: <56> lw	a1, 4(sp) %
0000150b : 00812083;   % 1037: <57> lw	ra, 8(sp) %
0000150c : 00c10113;   % 1037: <58> addi 	sp, sp, 12 %
0000150d : 04002e73;   % 1037: <59> csrr	t3,uscratch %
0000150e : 0080006f;   % 1038: 	j readInt.mul2d %
0000150f : 027e0e33;   % 1039: readInt.mul2: 	mul 	t3, t3, t2			# proxima dezena/centena %
00001510 : fff28293;   % 1040: readInt.mul2d:	addi 	t0, t0, -1			# busca o digito anterior %
00001511 : fff68693;   % 1041: 	addi	a3, a3, -1			# reduz o contador de digitos  %
00001512 : f31ff06f;   % 1042: 	j 	loopReadInt			# volta para buscar proximo digito %
00001513 : 0080006f;   % 1045: 		j fimReadInt			# como nao esta implmentado apenas retorna %
00001514 : 40a00533;   % 1047: ehnegReadInt:	sub a0,zero,a0			# se for negativo %
00001515 : 00012083;   % 1051: fimReadInt:	lw 	ra, 0(sp)		# recupera ra %
00001516 : 00410113;   % 1052: 		addi 	sp, sp, 4		# libera espaco %
00001517 : 00008067;   % 1053: 		ret				# fim ReadInt %
00001518 : 10008c37;   % 1073: <9> li s8, 0x10008000	# carrega tp %
00001519 : 000c0c13;   % 1073:  %
0000151a : 01819863;   % 1073: <10> bne gp, s8, midiOutDE2	# Na DE1 gp = 0 ! N�o tem segmento .extern %
0000151b : 01f00893;   % 1075: 	li a7,31		# Chama o ecall normal %
0000151c : 00000073;   % 1076: 	ecall %
0000151d : 0600006f;   % 1077: 	j fimmidiOut %
0000151e : ff2002b7;   % 1079: midiOutDE2:	li      t0, 0xFF200178 %
0000151f : 17828293;   % 1079:  %
00001520 : 00000333;   % 1080:     		add     t1, zero, zero %
00001521 : 00f67393;   % 1085:    	 	andi    t2, a2, 0x0000000F %
00001522 : 01b39393;   % 1086:     		slli    t2, t2, 27 %
00001523 : 00736333;   % 1087:     		or      t1, t1, t2 %
00001524 : 07f6f393;   % 1090:     		andi    t2, a3, 0x0000007F %
00001525 : 01439393;   % 1091:     		slli    t2, t2, 20 %
00001526 : 00736333;   % 1092:     		or      t1, t1, t2 %
00001527 : 07f57393;   % 1095:     		andi    t2, a0, 0x0000007F %
00001528 : 00d39393;   % 1096:     		slli    t2, t2, 13 %
00001529 : 00736333;   % 1097:     		or      t1, t1, t2 %
0000152a : 1ff00e93;   % 1100: 		li 	t4, 0x1FF %
0000152b : 004e9e93;   % 1101: 		slli 	t4, t4, 4 %
0000152c : 00fe8e93;   % 1102: 		addi 	t4, t4, 0x00F			# t4 = 0x00001FFF %
0000152d : 01d5f3b3;   % 1103:     		and    	t2, a1, t4 %
0000152e : 00736333;   % 1104:     		or      t1, t1, t2 %
0000152f : 0040006f;   % 1107:     		j       SintMidOut %
00001530 : 0062a023;   % 1109: SintMidOut:	sw	t1, 0(t0) %
00001531 : ff2003b7;   % 1112: 	    		li      t2, 0xFF20017C %
00001532 : 17c38393;   % 1112:  %
00001533 : 0003ae03;   % 1113: Check_AUD_DACLRCK:     	lw      t3, 0(t2) %
00001534 : fe0e0ee3;   % 1114:     			beq     t3, zero, Check_AUD_DACLRCK %
00001535 : 00008067;   % 1116: fimmidiOut:    		ret %
00001536 : 10008c37;   % 1134: <9> li s8, 0x10008000	# carrega tp %
00001537 : 000c0c13;   % 1134:  %
00001538 : 01819863;   % 1134: <10> bne gp, s8, midiOutSyncDE2	# Na DE1 gp = 0 ! N�o tem segmento .extern %
00001539 : 02100893;   % 1136: 	li a7,33		# Chama o ecall normal %
0000153a : 00000073;   % 1137: 	ecall %
0000153b : 0780006f;   % 1138: 	j fimmidiOutSync %
0000153c : ff2002b7;   % 1140: midiOutSyncDE2:	li      t0, 0xFF200178 %
0000153d : 17828293;   % 1140:  %
0000153e : 00000333;   % 1141:     		add     t1, zero, zero %
0000153f : 08000337;   % 1144:     		lui    	t1, 0x08000 %
00001540 : 00431313;   % 1145: 		slli	t1,t1,4 %
00001541 : 00f67393;   % 1148:     		andi    t2, a2, 0x00F %
00001542 : 01b39393;   % 1149:     		slli    t2, t2, 27 %
00001543 : 00736333;   % 1150:     		or      t1, t1, t2 %
00001544 : 07f6f393;   % 1153:     		andi    t2, a3, 0x07F %
00001545 : 01439393;   % 1154:     		slli    t2, t2, 20 %
00001546 : 00736333;   % 1155:     		or      t1, t1, t2 %
00001547 : 07f57393;   % 1158:     		andi    t2, a0, 0x07F %
00001548 : 00d39393;   % 1159:     		slli    t2, t2, 13 %
00001549 : 00736333;   % 1160:     		or      t1, t1, t2 %
0000154a : 1ff00e93;   % 1163: 		li 	t4, 0x1FF %
0000154b : 004e9e93;   % 1164: 		slli 	t4, t4, 4 %
0000154c : 00fe8e93;   % 1165: 		addi 	t4, t4, 0x00F			# t4 = 0x00001FFF %
0000154d : 01d5f3b3;   % 1166:     		and    	t2, a1, t4 %
0000154e : 00736333;   % 1167:     		or      t1, t1, t2 %
0000154f : 0040006f;   % 1170:     		j       SintMidOutSync %
00001550 : 0062a023;   % 1172: SintMidOutSync:	sw	t1, 0(t0) %
00001551 : ff2003b7;   % 1175:     		li      t2, 0xFF20017C %
00001552 : 17c38393;   % 1175:  %
00001553 : ff200eb7;   % 1176:     		li      t4, 0xFF200180 %
00001554 : 180e8e93;   % 1176:  %
00001555 : 0003ae03;   % 1178: Check_AUD_DACLRCKSync:	lw      t3, 0(t2) %
00001556 : fe0e0ee3;   % 1179:     			beq     t3, zero, Check_AUD_DACLRCKSync %
00001557 : 000eaf03;   % 1181: Melody:     	lw      t5, 0(t4) %
00001558 : fe0f1ee3;   % 1182:     		bne     t5, zero, Melody %
00001559 : 00008067;   % 1184: fimmidiOutSync:	ret %
0000155a : ffc10113;   % 1194: printFloat:	addi 	sp, sp, -4 %
0000155b : 00112023;   % 1195: 		sw 	ra, 0(sp)				# salva ra %
0000155c : 0fc21417;   % 1196: 		la 	s0, TempBuffer %
0000155d : 74840413;   % 1196:  %
0000155e : 02b00293;   % 1199: 		li 	t0, '+'			# define sinal '+' %
0000155f : e00504d3;   % 1200: 		fmv.x.s s1, fa0			# recupera o numero float sem conversao %
00001560 : 01f4d493;   % 1201: 		srli	s1, s1, 31		# bit 31(sinal) em bit 0, numero eh negativo s1=1 %
00001561 : 00048463;   % 1202: 		beq 	s1, zero, ehposprintFloat	# eh positivo s1=0 %
00001562 : 02d00293;   % 1203: 		li 	t0, '-'				# define sinal '-' %
00001563 : 00540023;   % 1204: ehposprintFloat: sb 	t0, 0(s0)			# coloca sinal no buffer %
00001564 : 00140413;   % 1205: 		addi 	s0, s0, 1			# incrementa o endereco do buffer %
00001565 : e00502d3;   % 1208: 		 fmv.x.s t0, fa0			# recupera o numero float sem conversao %
00001566 : 7f800337;   % 1209: 		 lui	t1, 0x7F800 %
00001567 : 0062f2b3;   % 1210: 		 and 	t0, t0, t1   			# mascara com 0111 1111 1000 0000 0000 0000... %
00001568 : 00129293;   % 1211: 		 slli 	t0, t0, 1			# tira o sinal do numero %
00001569 : 0182d293;   % 1212: 		 srli 	t0, t0, 24			# recupera o expoente %
0000156a : e0050353;   % 1215: 		fmv.x.s t1, fa0				# recupera o numero float sem conversao %
0000156b : 008003b7;   % 1216: 		li 	t2, 0x007FFFFF			# t2 = 0x007FFFFF %
0000156c : fff38393;   % 1216:  %
0000156d : 00737333;   % 1217: 		and 	t1, t1, t2			# mascara com 0000 0000 0111 1111 1111... 		  %
0000156e : 14028c63;   % 1219: 		beq 	t0, zero, ehExp0printFloat	# Expoente = 0 %
0000156f : 0ff00213;   % 1220: 		li	tp, 0x000000FF			# TP = 255 %
00001570 : 16428c63;   % 1221: 		beq 	t0, tp, ehExp255printFloat	# Expoente = 255 %
00001571 : 20a52053;   % 1225: 		fabs.s 		ft0, fa0		# ft0 recebe o modulo  de x %
00001572 : 00100213;   % 1226: 		li		tp, 1 %
00001573 : d00270d3;   % 1227: 		fcvt.s.w 	ft1, tp			# ft1 recebe o numero 1.0 %
00001574 : 00a00213;   % 1228: 		li		tp, 10 %
00001575 : d0027353;   % 1229: 		fcvt.s.w 	ft6, tp			# ft6 recebe o numero 10.0 %
00001576 : 00200213;   % 1230: 		li		tp, 2 %
00001577 : d0027e53;   % 1231: 		fcvt.s.w 	ft8, tp %
00001578 : 19c0f3d3;   % 1232: 		fdiv.s		ft7, ft1, ft8		# ft7 recebe o numero 0.5 %
00001579 : a0101ed3;   % 1234: 		flt.s 	t4, ft0, ft1		# ft0 < 1.0 ? Se sim, E deve ser negativo %
0000157a : 000e9663;   % 1235: 		bnez	t4, menor1printFloat	# se a comparacao deu true (1), pula %
0000157b : 20630153;   % 1236: 		fmv.s 	ft2, ft6		# ft2  fator de multiplicacao = 10 %
0000157c : 02c0006f;   % 1237: 		j 	cont2printFloat		# vai para expoente positivo %
0000157d : 1860f153;   % 1238: menor1printFloat: fdiv.s ft2,ft1,ft6		# ft2 fator multiplicativo = 0.1 %
0000157e : 20000253;   % 1241: cont1printFloat: 	fmv.s 	ft4, ft0			# inicia com o numero x  %
0000157f : 201081d3;   % 1242: 		 	fmv.s 	ft3, ft1			# contador comeca em 1 %
00001580 : 18227253;   % 1243: loop1printFloat: 	fdiv.s 	ft4, ft4, ft2			# divide o numero pelo fator multiplicativo %
00001581 : a0120e53;   % 1244: 		 	fle.s 	t3, ft4, ft1			# o numero eh > que 1? entao fim %
00001582 : 000e0663;   % 1245: 		 	beq 	t3,zero, fimloop1printFloat %
00001583 : 0011f1d3;   % 1246: 		 	fadd.s 	ft3, ft3, ft1			# incrementa o contador %
00001584 : ff1ff06f;   % 1247: 		 	j 	loop1printFloat			# volta ao loop %
00001585 : 18227253;   % 1249: fimloop1printFloat: 	fdiv.s 	ft4, ft4, ft2			# ajusta o numero %
00001586 : 0200006f;   % 1250: 		 	j 	intprintFloat			# vai para imprimir a parte inteira %
00001587 : 20000253;   % 1253: cont2printFloat:	fmv.s 	 ft4, ft0			# inicia com o numero x  %
00001588 : d00071d3;   % 1254: 		 	fcvt.s.w ft3, zero			# contador comeca em 0 %
00001589 : a0621e53;   % 1255: loop2printFloat:  	flt.s 	 t3, ft4, ft6			# resultado eh < que 10? entao fim %
0000158a : 18227253;   % 1256: 			fdiv.s 	 ft4, ft4, ft2			# divide o numero pelo fator multiplicativo %
0000158b : 000e1663;   % 1257: 			bne 	 t3, zero, intprintFloat %
0000158c : 0011f1d3;   % 1258: 		 	fadd.s 	 ft3, ft3, ft1			# incrementa o contador %
0000158d : ff1ff06f;   % 1259: 		 	j 	 loop2printFloat %
0000158e : 10227253;   % 1265: intprintFloat:		fmul.s 		ft4, ft4, ft2		# ajusta o numero %
0000158f : 08727253;   % 1266: 			fsub.s		ft4, ft4, ft7		# tira 0.5, dessa forma sempre ao converter estaremos fazendo floor %
00001590 : c00272d3;   % 1267: 		  	fcvt.w.s	t0, ft4			# coloca floor de ft4 em t0 %
00001591 : 00727253;   % 1268: 			fadd.s		ft4, ft4, ft7		# readiciona 0.5 %
00001592 : 00029463;   % 1269: 			bnez		t0, pulaeh1print	# para corrigir multiplos inteiros de 10! %
00001593 : 00100293;   % 1270: 			li 		t0, 1 %
00001594 : 03028293;   % 1271: pulaeh1print:		addi 		t0, t0, 48		# converte para ascii			 %
00001595 : 00540023;   % 1272: 			sb 		t0, 0(s0)		# coloca no buffer %
00001596 : 00140413;   % 1273: 		  	addi 		s0, s0, 1		# incrementta o buffer %
00001597 : 02e00293;   % 1276: 		  	li 	t0, '.'				# carrega o '.' %
00001598 : 00540023;   % 1277: 		  	sb 	t0, 0(s0)			# coloca no buffer %
00001599 : 00140413;   % 1278: 		  	addi 	s0, s0, 1			# incrementa o buffer %
0000159a : 00800313;   % 1281: 		  	li 		t1, 8				# contador de digitos  -  8 casas decimais %
0000159b : 04030a63;   % 1282: loopfracprintFloat:  	beq 		t1, zero, fimfracprintFloat	# fim dos digitos? %
0000159c : 08727253;   % 1283: 			fsub.s		ft4, ft4, ft7			# tira 0.5 %
0000159d : c0027f53;   % 1284: 			fcvt.w.s 	t5, ft4				# floor de ft4 %
0000159e : 00727253;   % 1285: 			fadd.s		ft4, ft4, ft7			# readiciona 0.5 %
0000159f : d00f72d3;   % 1286: 			fcvt.s.w	ft5, t5				# reconverte em float so com a parte inteira %
000015a0 : 085272d3;   % 1287: 		  	fsub.s 		ft5, ft4, ft5			# parte fracionaria %
000015a1 : 1062f2d3;   % 1288: 		  	fmul.s 		ft5, ft5, ft6			# mult x 10 %
000015a2 : 0872f2d3;   % 1289: 			fsub.s		ft5, ft5, ft7			# tira 0.5 %
000015a3 : c002f2d3;   % 1290: 			fcvt.w.s	t0, ft5				# coloca floor de ft5 em 10 %
000015a4 : 03028293;   % 1291: 		  	addi 		t0, t0, 48			# converte para ascii %
000015a5 : 03000213;   % 1293: 			li 		tp, 48 %
000015a6 : 0042c663;   % 1294: 			blt		t0, tp, pulaprtFloat1	# testa se eh menor que '0' %
000015a7 : 03900213;   % 1295: 			li		tp, 57 %
000015a8 : 00525463;   % 1296: 			ble		t0, tp, pulaprtFloat2	# testa se eh menor ou igual que '9' %
000015a9 : 03000293;   % 1297: pulaprtFloat1:		li		t0, 48			# define como '0'		  			  	 %
000015aa : 00540023;   % 1299: pulaprtFloat2:	  	sb 		t0, 0(s0)			# coloca no buffer %
000015ab : 00140413;   % 1300: 		  	addi 		s0, s0, 1			# incrementa endereco %
000015ac : fff30313;   % 1301: 		  	addi 		t1, t1, -1			# decrementa contador %
000015ad : 0072f2d3;   % 1302: 			fadd.s		ft5, ft5, ft7			# reincrementa 0.5 %
000015ae : 20528253;   % 1303: 		  	fmv.s 		ft4, ft5			# coloca o numero em ft4 %
000015af : fb1ff06f;   % 1304: 		  	j 		loopfracprintFloat		# volta ao loop %
000015b0 : 04500293;   % 1307: fimfracprintFloat: 	li 	t0,'E'			# carrega 'E' %
000015b1 : 00540023;   % 1308: 			sb 	t0, 0(s0)		# coloca no buffer %
000015b2 : 00140413;   % 1309: 			addi 	s0, s0, 1		# incrementa endereco %
000015b3 : 02b00293;   % 1312: 		  	li 	t0, '+'				# carrega '+' %
000015b4 : 000e8463;   % 1313: 		  	beqz 	t4, expposprintFloat		# nao eh negativo? %
000015b5 : 02d00293;   % 1314: 		  	li 	t0, '-'				# carrega '-' %
000015b6 : 00540023;   % 1315: expposprintFloat: 	sb 	t0, 0(s0)			# coloca no buffer %
000015b7 : 00140413;   % 1316: 		  	addi 	s0, s0, 1			#incrementa endereco %
000015b8 : 00a00313;   % 1319: 			li 	t1, 10				# carrega 10	 %
000015b9 : c001f253;   % 1320: 			fcvt.w.s  tp, ft3			# passa ft3 para t0 %
000015ba : 026242b3;   % 1321: 			div 	t0, tp, t1			# divide por 10 (dezena) %
000015bb : 026263b3;   % 1322: 			rem	t2, tp, t1			# t0 = quociente, t2 = resto %
000015bc : 03028293;   % 1323: 			addi 	t0, t0, 48			# converte para ascii %
000015bd : 00540023;   % 1324: 			sb 	t0, 0(s0)			# coloca no buffer %
000015be : 03038393;   % 1325: 			addi 	t2, t2, 48			# converte para ascii %
000015bf : 007400a3;   % 1326: 			sb 	t2, 1(s0)			# coloca no buffer %
000015c0 : 00040123;   % 1327: 			sb 	zero, 2(s0)			# insere \NULL da string %
000015c1 : 0fc21517;   % 1328: 			la 	a0, TempBuffer			# endereco do Buffer										 %
000015c2 : 5b450513;   % 1328:  %
000015c3 : 0500006f;   % 1329: 	  		j 	fimprintFloat			# imprime a string %
000015c4 : 00030e63;   % 1331: ehExp0printFloat: 	beq 	t1, zero, eh0printFloat		# Verifica se eh zero %
000015c5 : 0fc21517;   % 1333: ehDesnormprintFloat: 	la 	a0, NumDesnormP			# string numero desnormalizado positivo %
000015c6 : 7b750513;   % 1333:  %
000015c7 : 04048063;   % 1334: 			beq 	s1, zero, fimprintFloat		# o sinal eh 1? entao eh negativo %
000015c8 : 0fc21517;   % 1335: 		 	la 	a0, NumDesnormN			# string numero desnormalizado negativo %
000015c9 : 7b450513;   % 1335:  %
000015ca : 0340006f;   % 1336: 			j 	fimprintFloat			# imprime a string %
000015cb : 0fc21517;   % 1338: eh0printFloat:		la 	a0, NumZero			# string do zero %
000015cc : 7b150513;   % 1338:  %
000015cd : 0280006f;   % 1339: 			j 	fimprintFloat 	 		# imprime a string %
000015ce : 00030863;   % 1341: ehExp255printFloat: 	beq 	t1, zero, ehInfprintFloat	# se mantissa eh zero entao eh Infinito %
000015cf : 0fc21517;   % 1343: ehNaNprintfFloat:	la 	a0, NumNaN			# string do NaN %
000015d0 : 7c050513;   % 1343:  %
000015d1 : 0180006f;   % 1344: 			j 	fimprintFloat			# imprime string %
000015d2 : 0fc21517;   % 1346: ehInfprintFloat:	la 	a0, NumInfP			# string do infinito positivo %
000015d3 : 7a050513;   % 1346:  %
000015d4 : 00048663;   % 1347: 			beq 	s1, zero, fimprintFloat		# o sinal eh 1? entao eh negativo %
000015d5 : 0fc21517;   % 1348: 			la 	a0, NumInfN			# string do infinito negativo %
000015d6 : 79e50513;   % 1348:  %
000015d7 : 931ff0ef;   % 1352: 			jal	printString			# imprime a string em a0 %
000015d8 : 00012083;   % 1353: 			lw 	ra, 0(sp)			# recupera ra %
000015d9 : 00410113;   % 1354: 			addi 	sp, sp, 4			# libera espaco %
000015da : 00008067;   % 1355: 			ret					# retorna %
000015db : 00008067;   % 1373: 			ret %
000015dc : 00008067;   % 1391: 			ret %
000015dd : ffc10113;   % 1402: readFloat: addi sp, sp, -4			# aloca espaco %
000015de : 00112023;   % 1403: 	sw 	ra, 0(sp)			# salva ra %
000015df : 0fc21517;   % 1404: 	la 	a0, TempBuffer			# endereco do FloatBuffer %
000015e0 : 53c50513;   % 1404:  %
000015e1 : 02000593;   % 1405: 	li 	a1, 32				# numero maximo de caracteres %
000015e2 : b39ff0ef;   % 1406: 	jal	readString			# le string, retorna a2 ultimo endereco e a3 numero de caracteres %
000015e3 : 00c00433;   % 1407: 	mv 	s0, a2				# ultimo endereco da string (antes do \0) %
000015e4 : 00d004b3;   % 1408: 	mv 	s1, a3				# numero de caracteres digitados %
000015e5 : 0fc21b97;   % 1409: 	la	s7, TempBuffer			# Endereco do primeiro caractere %
000015e6 : 524b8b93;   % 1409:  %
000015e7 : 017002b3;   % 1411: lePrimeiroreadFloat:	mv 	t0, s7		# Endereco de Inicio %
000015e8 : 00028303;   % 1412: 	lb 	t1, 0(t0)				# le primeiro caractere %
000015e9 : 06500213;   % 1413: 	li	tp, 'e'					# TP = 101 = 'e' %
000015ea : 02430863;   % 1414: 	beq 	t1, tp, insere0AreadFloat		# insere '0' antes %
000015eb : 04500213;   % 1415: 	li 	tp, 'E'					# TP = 69 = 'E' %
000015ec : 02430463;   % 1416: 	beq 	t1, tp, insere0AreadFloat		# insere '0' antes %
000015ed : 02e00213;   % 1417: 	li	tp, '.'					# TP = 46 = '.' %
000015ee : 02430063;   % 1418: 	beq 	t1, tp, insere0AreadFloat		#  insere '0' antes %
000015ef : 02b00213;   % 1419: 	li	tp, '+'					# TP = 43 = '+' %
000015f0 : 00430863;   % 1420: 	beq 	t1, tp, pulaPrimreadChar		# pula o primeiro caractere %
000015f1 : 02d00213;   % 1421: 	li	tp, '-'					# TP = 45 = '-' %
000015f2 : 00430463;   % 1422: 	beq 	t1, tp, pulaPrimreadChar %
000015f3 : 03c0006f;   % 1423: 	j leUltimoreadFloat %
000015f4 : 001b8b93;   % 1425: pulaPrimreadChar: addi s7,s7,1			# incrementa o endereco inicial %
000015f5 : fc9ff06f;   % 1426: 		  j lePrimeiroreadFloat		# volta a testar o novo primeiro caractere %
000015f6 : 008002b3;   % 1428: insere0AreadFloat: mv t0, s0			# endereco do ultimo caractere %
000015f7 : 00140413;   % 1429: 		   addi s0, s0, 1		# desloca o ultimo endereco para o proximo %
000015f8 : 00148493;   % 1430: 	   	   addi s1, s1, 1		# incrementa o num. caracteres %
000015f9 : 000400a3;   % 1431: 	   	   sb 	zero, 1(s0)		# \NULL do final de string %
000015fa : 01700f33;   % 1432: 	   	   mv t5, s7			# primeiro caractere %
000015fb : 01e28a63;   % 1433: insere0Aloop:	   beq 	t0, t5, saiinsere0AreadFloat	# chegou no inicio entao fim %
000015fc : 00028303;   % 1434: 		   lb 	t1, 0(t0)		# le caractere %
000015fd : 006280a3;   % 1435: 		   sb 	t1, 1(t0)		# escreve no proximo %
000015fe : fff28293;   % 1436: 		   addi t0, t0, -1		# decrementa endereco %
000015ff : ff1ff06f;   % 1437: 		   j insere0Aloop		# volta ao loop %
00001600 : 03000313;   % 1438: saiinsere0AreadFloat: li t1, '0'		# ascii '0' %
00001601 : 00628023;   % 1439: 		   sb t1, 0(t0)			# escreve '0' no primeiro caractere %
00001602 : 00040303;   % 1441: leUltimoreadFloat: lb  	t1, 0(s0)			# le ultimo caractere %
00001603 : 06500213;   % 1442: 		li	tp, 'e'				# TP = 101 = 'e' %
00001604 : 00430c63;   % 1443: 		beq 	t1, tp, insere0PreadFloat	# insere '0' depois %
00001605 : 04500213;   % 1444: 		li 	tp, 'E'				# TP = 69 = 'E' %
00001606 : 00430863;   % 1445: 		beq 	t1, tp, insere0PreadFloat	# insere '0' depois %
00001607 : 02e00213;   % 1446: 		li	tp, '.'				# TP = 46 = '.' %
00001608 : 00430463;   % 1447: 		beq 	t1, tp, insere0PreadFloat	# insere '0' depois %
00001609 : 0180006f;   % 1448: 		j 	inicioreadFloat %
0000160a : 00140413;   % 1450: insere0PreadFloat: addi	s0, s0, 1		# desloca o ultimo endereco para o proximo %
0000160b : 00148493;   % 1451: 	   	   addi	s1, s1, 1		# incrementa o num. caracteres %
0000160c : 03000313;   % 1452: 		   li 	t1,'0'			# ascii '0' %
0000160d : 00640023;   % 1453: 		   sb 	t1,0(s0)		# escreve '0' no ultimo %
0000160e : 000400a3;   % 1454: 		   sb 	zero,1(s0)		# \null do final de string %
0000160f : d0007553;   % 1456: inicioreadFloat:  fcvt.s.w 	fa0, zero	# fa0 Resultado inicialmente zero %
00001610 : 00a00293;   % 1457: 		li 	t0, 10			# inteiro 10	 %
00001611 : d002f353;   % 1458: 		fcvt.s.w 	ft6, t0		# ft6 contem sempre o numero cte 10.0000 %
00001612 : 00100293;   % 1459: 		li 	t0, 1			# inteiro 1 %
00001613 : d002f0d3;   % 1460: 		fcvt.s.w 	ft1, t0		# ft1 contem sempre o numero cte 1.0000	 %
00001614 : 00140993;   % 1463: procuraEreadFloat:	addi 	s3, s0, 1			# inicialmente nao tem 'e' ou 'E' na string (fora da string) %
00001615 : 017002b3;   % 1464: 			mv 	t0, s7				# endereco inicial %
00001616 : 02828263;   % 1465: loopEreadFloat: 	beq 	t0, s0, naotemEreadFloat	# sai se nao encontrou 'e' %
00001617 : 00028303;   % 1466: 			lb 	t1, 0(t0)			# le o caractere %
00001618 : 06500213;   % 1467: 			li	tp, 'e'				# TP = 101 = 'e' %
00001619 : 00430a63;   % 1468: 			beq 	t1, tp, ehEreadFloat		# tem 'e' %
0000161a : 04500213;   % 1469: 			li 	tp, 'E'				# TP = 69 = 'E' %
0000161b : 00430663;   % 1470: 			beq	t1, tp, ehEreadFloat		# tem 'E' %
0000161c : 00128293;   % 1471: 			addi 	t0, t0, 1			# incrementa endereco %
0000161d : fe5ff06f;   % 1472: 			j 	loopEreadFloat			# volta ao loop %
0000161e : 005009b3;   % 1473: ehEreadFloat: 		mv 	s3, t0				# endereco do 'e' ou 'E' na string %
0000161f : 01300933;   % 1477: procuraPontoreadFloat:	mv 	s2, s3				# local inicial do ponto na string (='e' se existir) ou fora da string	 %
00001620 : 017002b3;   % 1478: 			mv 	t0, s7				# endereco inicial %
00001621 : 00828e63;   % 1479: loopPontoreadFloat: 	beq 	t0, s0, naotemPontoreadFloat	# sai se nao encontrou '.' %
00001622 : 00028303;   % 1480: 			lb 	t1, 0(t0)			# le o caractere %
00001623 : 02e00213;   % 1481: 			li	tp, '.'				# TP = 46 = '.' %
00001624 : 00430663;   % 1482: 			beq 	t1, tp, ehPontoreadFloat	# tem '.' %
00001625 : 00128293;   % 1483: 			addi 	t0, t0, 1			# incrementa endereco %
00001626 : fedff06f;   % 1484: 			j 	loopPontoreadFloat		# volta ao loop %
00001627 : 00500933;   % 1485: ehPontoreadFloat: 	mv 	s2, t0				# endereco do '.' na string %
00001628 : d0007153;   % 1489: intreadFloat:		fcvt.s.w 	ft2, zero		# zera parte inteira %
00001629 : fff90293;   % 1490: 			addi 	t0, s2, -1			# endereco do caractere antes do ponto %
0000162a : 201081d3;   % 1491: 			fmv.s 	ft3, ft1			# ft3 contem unidade/dezenas/centenas		 %
0000162b : 01700f33;   % 1492: 			mv 	t5, s7				# Primeiro Endereco %
0000162c : 03e2ca63;   % 1493: loopintreadFloat: 	blt 	t0, t5, fimintreadFloat		# sai se o endereco for < inicio da string %
0000162d : 00028303;   % 1494: 			lb 	t1, 0(t0)			# le o caracter %
0000162e : 03000213;   % 1495: 			li	tp, '0'				# TP = 48 = '0' %
0000162f : 10434863;   % 1496: 			blt 	t1, tp, erroreadFloat		# nao eh caractere valido para numero %
00001630 : 03900213;   % 1497: 			li	tp, '9'				# TP = 57 = '9' %
00001631 : 10624463;   % 1498: 			bgt 	t1, tp, erroreadFloat		# nao eh caractere valido para numero %
00001632 : fd030313;   % 1499: 			addi 	t1, t1, -48			# converte ascii para decimal %
00001633 : d0037153;   % 1500: 			fcvt.s.w  ft2, t1			# digito lido em float %
00001634 : 10317153;   % 1502: 			fmul.s 	ft2,ft2,ft3			# multiplica por un/dezena/centena %
00001635 : 00257553;   % 1503: 			fadd.s 	fa0,fa0,ft2			# soma no resultado %
00001636 : 1061f1d3;   % 1504: 			fmul.s 	ft3,ft3,ft6			# proxima dezena/centena %
00001637 : fff28293;   % 1506: 			addi 	t0,t0,-1			# endereco anterior %
00001638 : fd1ff06f;   % 1507: 			j 	loopintreadFloat		# volta ao loop %
00001639 : d0007153;   % 1511: fracreadFloat:		fcvt.s.w 	ft2, zero		# zera parte fracionaria %
0000163a : 00190293;   % 1512: 			addi 	t0, s2, 1			# endereco depois do ponto %
0000163b : 1860f1d3;   % 1513: 			fdiv.s 	ft3, ft1, ft6			# ft3 inicial 0.1 %
0000163c : 0332da63;   % 1515: loopfracreadFloat: 	bge 	t0, s3, fimfracreadFloat	# endereco eh 'e' 'E' ou >ultimo %
0000163d : 00028303;   % 1516: 			lb 	t1, 0(t0)			# le o caracter %
0000163e : 03000213;   % 1517: 			li	tp, '0'				# TP = 48 = '0' %
0000163f : 0c434863;   % 1518: 			blt 	t1, tp, erroreadFloat		# nao eh valido %
00001640 : 03900213;   % 1519: 			li	tp, '9'				# TP = 57 = '9' %
00001641 : 0c624463;   % 1520: 			bgt 	t1, tp, erroreadFloat		# nao eh valido %
00001642 : fd030313;   % 1521: 			addi 	t1, t1, -48			# converte ascii para decimal %
00001643 : d0037153;   % 1522: 			fcvt.s.w 	ft2, t1			# digito lido em float		 %
00001644 : 10317153;   % 1524: 			fmul.s 	ft2, ft2, ft3			# multiplica por ezena/centena %
00001645 : 00257553;   % 1525: 			fadd.s 	fa0, fa0, ft2			# soma no resultado %
00001646 : 1861f1d3;   % 1526: 			fdiv.s 	ft3, ft3, ft6			# proxima frac un/dezena/centena %
00001647 : 00128293;   % 1528: 			addi 	t0, t0, 1			# proximo endereco %
00001648 : fd1ff06f;   % 1529: 			j 	loopfracreadFloat		# volta ao loop		 %
00001649 : d0007153;   % 1534: potreadFloat:		fcvt.s.w 	ft2, zero		# zera potencia %
0000164a : 00198293;   % 1535: 			addi 	t0, s3, 1			# endereco seguinte ao 'e' %
0000164b : 00000a13;   % 1536: 			li 	s4, 0				# sinal do expoente positivo %
0000164c : 00028303;   % 1537: 			lb 	t1, 0(t0)			# le o caractere seguinte ao 'e' %
0000164d : 02d00213;   % 1538: 			li	tp, '-'				# TP = 45 = '-' %
0000164e : 00430863;   % 1539: 			beq	t1, tp, potsinalnegreadFloat	# sinal do expoente esta escrito e eh positivo %
0000164f : 02b00213;   % 1540: 			li	tp, '+'				# TP = 43 = '+' %
00001650 : 00430663;   % 1541: 			beq 	t1, tp, potsinalposreadFloat	# sinal do expoente eh negativo %
00001651 : 00c0006f;   % 1542: 			j 	pulapotsinalreadFloat		# nao esta escrito o sinal do expoente %
00001652 : 00100a13;   % 1543: potsinalnegreadFloat:	li 	s4, 1				# s4=1 expoente negativo %
00001653 : 00128293;   % 1544: potsinalposreadFloat:	addi 	t0, t0, 1			# se tiver '-' ou '+' avanca para o proximo endereco %
00001654 : 00500ab3;   % 1545: pulapotsinalreadFloat:	mv 	s5, t0 				# Neste ponto s5 contem o endereco do primeiro digito da pot e s4 o sinal do expoente		 %
00001655 : 201081d3;   % 1547: 			fmv.s 	ft3, ft1			# ft3 un/dez/cen = 1 %
00001656 : 00000393;   % 1550: expreadFloat:		li 	t2, 0				# zera expoente %
00001657 : 008002b3;   % 1551: 			mv 	t0, s0				# endereco do ultimo caractere da string %
00001658 : 00a00e13;   % 1552: 			li 	t3, 10				# numero dez %
00001659 : 00100e93;   % 1553: 			li 	t4, 1				# und/dez/cent %
0000165a : 0352c063;   % 1555: loopexpreadFloat:	blt 	t0, s5, fimexpreadFloat		# ainda nao eh o endereco do primeiro digito? %
0000165b : 00028303;   % 1556: 			lb 	t1, 0(t0)			# le o caracter %
0000165c : fd030313;   % 1557: 			addi 	t1, t1, -48			# converte ascii para decimal %
0000165d : 03d30333;   % 1558: 			mul 	t1, t1, t4			# mul digito %
0000165e : 006383b3;   % 1559: 			add 	t2, t2, t1			# soma ao exp %
0000165f : 03ce8eb3;   % 1560: 			mul 	t4, t4, t3			# proxima casa decimal %
00001660 : fff28293;   % 1561: 			addi 	t0, t0, -1			# endereco anterior %
00001661 : fe5ff06f;   % 1562: 			j loopexpreadFloat			# volta ao loop %
00001662 : 20108153;   % 1566: 			fmv.s 	ft2, ft1			# numero 10^exp  inicial=1 %
00001663 : 206301d3;   % 1567: 			fmv.s 	ft3, ft6			# se o sinal for + ft3 eh 10 %
00001664 : 00000213;   % 1568: 			li	tp, 0x00000000			# TP = ZERO %
00001665 : 004a0463;   % 1569: 			beq 	s4, tp, sinalexpPosreadFloat	# se sinal exp positivo %
00001666 : 1860f1d3;   % 1570: 			fdiv.s 	ft3, ft1, ft6			# se o final for - ft3 eh 0.1 %
00001667 : 00000293;   % 1571: sinalexpPosreadFloat:	li 	t0, 0				# contador  %
00001668 : 00728863;   % 1572: sinalexpreadFloat: 	beq 	t0, t2, fimsinalexpreadFloat	# se chegou ao fim %
00001669 : 10317153;   % 1573: 			fmul.s 	ft2, ft2, ft3			# multiplica pelo fator 10 ou 0.1 %
0000166a : 00128293;   % 1574: 			addi 	t0, t0, 1			# incrementa o contador %
0000166b : ff5ff06f;   % 1575: 			j 	sinalexpreadFloat %
0000166c : 10257553;   % 1578: 		fmul.s 	fa0, fa0, ft2		# multiplicacao final! %
0000166d : 0fc21297;   % 1580: 		la 	t0, TempBuffer		# ajuste final do sinal do numero %
0000166e : 30428293;   % 1580:  %
0000166f : 00028303;   % 1581: 		lb 	t1, 0(t0)		# le primeiro caractere %
00001670 : 02d00213;   % 1582: 		li	tp, '-'			# TP = 45 = '-' %
00001671 : 00431463;   % 1583: 		bne 	t1, tp, fimreadFloat	# nao eh '-' entao fim %
00001672 : 20a51553;   % 1584: 		fneg.s 	fa0, fa0		# nega o numero float %
00001673 : 00012083;   % 1587: fimreadFloat: 	lw 	ra, 0(sp)		# recupera ra %
00001674 : 00410113;   % 1588: 		addi 	sp, sp, 4		# libera espaco %
00001675 : 00008067;   % 1589: 		ret				# retorna %
00001676 : 10008c37;   % 1597: <9> li s8, 0x10008000	# carrega tp %
00001677 : 000c0c13;   % 1597:  %
00001678 : 01819863;   % 1597: <10> bne gp, s8, Time.DE1	# Na DE1 gp = 0 ! N�o tem segmento .extern %
00001679 : 01e00893;   % 1598: 	li 	a7, 30				# Chama o ecall do Rars %
0000167a : 00000073;   % 1599: 	ecall %
0000167b : 00008067;   % 1600: 	ret					# saida %
0000167c : c0102573;   % 1602: Time.DE1:	csrr a0, time			#  Le time LOW %
0000167d : c81025f3;   % 1603: 		csrr a1, timeh 			#  Le time HIGH %
0000167e : 00008067;   % 1604: 		ret %
0000167f : 10008c37;   % 1611: <9> li s8, 0x10008000	# carrega tp %
00001680 : 000c0c13;   % 1611:  %
00001681 : 01819863;   % 1611: <10> bne gp, s8, Sleep.DE1	# Na DE1 gp = 0 ! N�o tem segmento .extern %
00001682 : 02000893;   % 1612: 	li 	a7, 32				# Chama o ecall do Rars %
00001683 : 00000073;   % 1613: 	ecall %
00001684 : 00008067;   % 1614: 	ret					#Saida %
00001685 : c01022f3;   % 1616: Sleep.DE1:	csrr 	t0, time		# Le o tempo do sistema %
00001686 : 00a28333;   % 1617: 		add 	t1, t0, a0		# soma com o tempo solicitado %
00001687 : c01022f3;   % 1618: Sleep.Loop:	csrr	t0, time		# Le o tempo do sistema %
00001688 : fe62eee3;   % 1619: 		bltu	t0, t1, Sleep.Loop	# t0<t1 ? %
00001689 : 00008067;   % 1620: 		ret %
0000168a : 10008c37;   % 1628: <9> li s8, 0x10008000	# carrega tp %
0000168b : 000c0c13;   % 1628:  %
0000168c : 01819863;   % 1628: <10> bne gp, s8, Random.DE1	# Na DE1 gp = 0 ! N�o tem segmento .extern %
0000168d : 02900893;   % 1629: 	li 	a7,41			# Chama o ecall do Rars %
0000168e : 00000073;   % 1630: 	ecall	 %
0000168f : 00008067;   % 1631: 	ret				# saida %
00001690 : ff2002b7;   % 1633: Random.DE1: 	li 	t0, 0xFF200514	# carrega endereco do LFSR %
00001691 : 51428293;   % 1633:  %
00001692 : 0002a503;   % 1634: 		lw 	a0, 0(t0)	# le a word em a0 %
00001693 : 00008067;   % 1635: 		ret			# retorna %
00001694 : 10008c37;   % 1645: <9> li s8, 0x10008000	# carrega tp %
00001695 : 000c0c13;   % 1645:  %
00001696 : 01819863;   % 1645: <10> bne gp, s8, Random2.DE1	# Na DE1 gp = 0 ! N�o tem segmento .extern %
00001697 : 02a00893;   % 1646: 		li 	a7,42			# Chama o ecall do Rars %
00001698 : 00000073;   % 1647: 		ecall	 %
00001699 : 00008067;   % 1648: 		ret				# saida %
0000169a : ff2002b7;   % 1650: Random2.DE1: 	li 	t0, 0xFF200514	# carrega endereco do LFSR %
0000169b : 51428293;   % 1650:  %
0000169c : 0002a503;   % 1651: 		lw 	a0, 0(t0)	# le a word em a0 %
0000169d : ffc10113;   % 1652: 		addi sp,sp,-4 %
0000169e : 00112023;   % 1653: 		sw ra,0(sp) %
0000169f : 4b8000ef;   % 1654: 		jal 	__umodsi3 %
000016a0 : 00012083;   % 1656: 		lw ra,0(sp) %
000016a1 : 00410113;   % 1657: 		addi sp,sp,4 %
000016a2 : 00008067;   % 1658: 		ret			# retorna %
000016a3 : 00058c63;   % 1669: clsCLS:	beq 	a1, zero, CLS.frame0 %
000016a4 : ff100337;   % 1670: 	li      t1, 0xFF100000              # Memoria VGA 1 %
000016a5 : 00030313;   % 1670:  %
000016a6 : ff1133b7;   % 1671:    	li      t2, 0xFF112C00 %
000016a7 : c0038393;   % 1671:  %
000016a8 : 0140006f;   % 1672:    	j 	CLS.pula %
000016a9 : ff000337;   % 1673: CLS.frame0: 	li      t1, 0xFF000000           # Memoria VGA 0 %
000016aa : 00030313;   % 1673:  %
000016ab : ff0133b7;   % 1674:    	    	li      t2, 0xFF012C00   	 %
000016ac : c0038393;   % 1674:  %
000016ad : 0ff57513;   % 1675: CLS.pula:	andi    a0, a0, 0x00FF %
000016ae : 00a002b3;   % 1678:  		mv 	t0, a0 %
000016af : 00851513;   % 1679:  		slli 	a0, a0, 8 %
000016b0 : 00a2e2b3;   % 1680:  		or 	t0, t0, a0 %
000016b1 : 00851513;   % 1681:  		slli 	a0, a0, 8 %
000016b2 : 00a2e2b3;   % 1682:  		or 	t0, t0, a0 %
000016b3 : 00851513;   % 1683:  		slli 	a0, a0, 8 %
000016b4 : 00a2e2b3;   % 1684:  		or 	t0, t0, a0 %
000016b5 : 00730863;   % 1686: CLS.for:	beq     t1, t2, CLS.fim %
000016b6 : 00532023;   % 1687: 		sw      t0, 0(t1) %
000016b7 : 00430313;   % 1688:     		addi    t1, t1, 4 %
000016b8 : ff5ff06f;   % 1689:     		j       CLS.for %
000016b9 : 00008067;   % 1690: CLS.fim:	ret %
000016ba : ff000837;   % 1699: BRESENHAM: 	li	a6, 0xFF000000           	# Memoria VGA 0 %
000016bb : 00080813;   % 1699:  %
000016bc : 00078663;   % 1700: 	   	beq	a5, zero, pulaBRES %
000016bd : ff100837;   % 1701: 	   	li 	a6, 0xFF100000              # Memoria VGA 1 %
000016be : 00080813;   % 1701:  %
000016bf : 14000893;   % 1703: pulaBRES: 	li 	a7, 320 %
000016c0 : 40b682b3;   % 1704: 	  	sub 	t0, a3, a1 %
000016c1 : 0002d463;   % 1705: 	  	bge 	t0, zero, PULAABRES %
000016c2 : 405002b3;   % 1706: 	  	sub 	t0, zero, t0 %
000016c3 : 40a60333;   % 1707: PULAABRES:	sub 	t1, a2, a0 %
000016c4 : 00035463;   % 1708: 	   	bge  	t1, zero, PULABBRES %
000016c5 : 40600333;   % 1709: 	   	sub  	t1, zero, t1	 %
000016c6 : 0262d263;   % 1710: PULABBRES: 	bge  	t0, t1, PULACBRES %
000016c7 : 00a65e63;   % 1711: 	   	ble  	a0, a2, PULAC1BRES %
000016c8 : 00a007b3;   % 1712: 	   	mv 	a5, a0 %
000016c9 : 00c00533;   % 1713: 	   	mv 	a0, a2 %
000016ca : 00f00633;   % 1714: 	   	mv 	a2, a5 %
000016cb : 00b007b3;   % 1715: 	   	mv	a5, a1 %
000016cc : 00d005b3;   % 1716: 	   	mv 	a1, a3 %
000016cd : 00f006b3;   % 1717: 	   	mv 	a3, a5 %
000016ce : 0240006f;   % 1718: PULAC1BRES:	j PLOTLOWBRES %
000016cf : 00b6de63;   % 1720: PULACBRES: 	ble  	a1, a3, PULAC2BRES %
000016d0 : 00a007b3;   % 1721: 	   	mv 	a5, a0 %
000016d1 : 00c00533;   % 1722: 	   	mv 	a0, a2 %
000016d2 : 00f00633;   % 1723: 	   	mv 	a2, a5 %
000016d3 : 00b007b3;   % 1724: 	   	mv 	a5, a1 %
000016d4 : 00d005b3;   % 1725: 	   	mv 	a1, a3 %
000016d5 : 00f006b3;   % 1726: 	   	mv 	a3, a5 %
000016d6 : 0a80006f;   % 1727: PULAC2BRES:	j PLOTHIGHBRES %
000016d7 : 40a602b3;   % 1729: PLOTLOWBRES:	sub 	t0, a2, a0		# dx=x1-x0 %
000016d8 : 40b68333;   % 1730: 	 	sub 	t1, a3, a1		# dy y1-y0 %
000016d9 : 00100393;   % 1731: 	 	li  	t2, 1			# yi=1 %
000016da : 00035663;   % 1732: 	 	bge 	t1, zero, PULA1BRES	# dy>=0 PULA %
000016db : fff00393;   % 1733: 	 	li  	t2, -1			# yi=-1 %
000016dc : 40600333;   % 1734: 	 	sub 	t1, zero, t1		# dy=-dy %
000016dd : 00131e13;   % 1735: PULA1BRES:	slli 	t3, t1, 1		# 2*dy %
000016de : 405e0e33;   % 1736: 		sub 	t3, t3, t0		# D=2*dy-dx %
000016df : 00b00eb3;   % 1737: 		mv 	t4, a1			# y=y0 %
000016e0 : 00a00f33;   % 1738: 		mv 	t5, a0			# x=x0 %
000016e1 : 30102c73;   % 1740: <29> csrr s8, misa %
000016e2 : 00cc5c13;   % 1740: <30> srli s8, s8, 12 %
000016e3 : 001c7c13;   % 1740: <31> andi s8, s8, 0x001 %
000016e4 : 020c1e63;   % 1740: <32> bnez s8, BRESENHAM.mul1 %
000016e5 : ff410113;   % 1741: <45> addi 	sp, sp, -12 %
000016e6 : 00a12023;   % 1741: <46> sw	a0, 0(sp) %
000016e7 : 00b12223;   % 1741: <47> sw	a1, 4(sp) %
000016e8 : 00112423;   % 1741: <48> sw	ra, 8(sp) %
000016e9 : 01d00533;   % 1741: <50> mv 	a0, t4 %
000016ea : 011005b3;   % 1741: <51> mv 	a1, a7 %
000016eb : 2d8000ef;   % 1741: <52> jal 	__mulsi3 %
000016ec : 04051073;   % 1741: <53> csrw	a0,uscratch %
000016ed : 00012503;   % 1741: <55> lw	a0, 0(sp) %
000016ee : 00412583;   % 1741: <56> lw	a1, 4(sp) %
000016ef : 00812083;   % 1741: <57> lw	ra, 8(sp) %
000016f0 : 00c10113;   % 1741: <58> addi 	sp, sp, 12 %
000016f1 : 04002ff3;   % 1741: <59> csrr	t6,uscratch %
000016f2 : 0080006f;   % 1742: 		j BRESENHAM.mul1d %
000016f3 : 031e8fb3;   % 1743: BRESENHAM.mul1:	mul 	t6, t4, a7		# y*320 %
000016f4 : 01ef8fb3;   % 1744: BRESENHAM.mul1d:add 	t6, t6, t5		# y*320+x %
000016f5 : 010f8fb3;   % 1745: 		add 	t6, t6, a6		# 0xFF000000+y*320+x %
000016f6 : 00ef8023;   % 1746: 		sb 	a4, 0(t6)		# plot com cor a4 %
000016f7 : 01c05863;   % 1748: 		ble 	t3, zero, PULA2BRES	# D<=0 %
000016f8 : 007e8eb3;   % 1749: 		add 	t4, t4, t2		# y=y+yi %
000016f9 : 00129f93;   % 1750: 		slli 	t6, t0, 1		# 2*dx %
000016fa : 41fe0e33;   % 1751: 		sub 	t3, t3, t6		# D=D-2dx %
000016fb : 00131f93;   % 1752: PULA2BRES:	slli 	t6, t1, 1		# 2*dy %
000016fc : 01fe0e33;   % 1753: 		add 	t3, t3, t6		# D=D+2dx %
000016fd : 001f0f13;   % 1754: 		addi	t5, t5, 1 %
000016fe : f8cf16e3;   % 1755: 		bne 	t5, a2, LOOPx1BRES %
000016ff : 00008067;   % 1756: 		ret %
00001700 : 40a602b3;   % 1758: PLOTHIGHBRES: 	sub 	t0, a2, a0		# dx=x1-x0 %
00001701 : 40b68333;   % 1759: 	 	sub 	t1, a3, a1		# dy y1-y0 %
00001702 : 00100393;   % 1760: 	 	li 	t2, 1			# xi=1 %
00001703 : 0002d663;   % 1761: 	 	bge 	t0, zero, PULA3BRES	# dy>=0 PULA %
00001704 : fff00393;   % 1762: 	 	li 	t2, -1			# xi=-1 %
00001705 : 405002b3;   % 1763: 	 	sub 	t0, zero, t0		# dx=-dx %
00001706 : 00129e13;   % 1764: PULA3BRES:	slli 	t3, t0, 1		# 2*dx %
00001707 : 406e0e33;   % 1765: 		sub 	t3, t3, t1		# D=2*dx-d1 %
00001708 : 00a00eb3;   % 1766: 		mv 	t4, a0			# x=x0 %
00001709 : 00b00f33;   % 1767: 		mv 	t5, a1			# y=y0 %
0000170a : 30102c73;   % 1769: <29> csrr s8, misa %
0000170b : 00cc5c13;   % 1769: <30> srli s8, s8, 12 %
0000170c : 001c7c13;   % 1769: <31> andi s8, s8, 0x001 %
0000170d : 020c1e63;   % 1769: <32> bnez s8, BRESENHAM.mul2 %
0000170e : ff410113;   % 1770: <45> addi 	sp, sp, -12 %
0000170f : 00a12023;   % 1770: <46> sw	a0, 0(sp) %
00001710 : 00b12223;   % 1770: <47> sw	a1, 4(sp) %
00001711 : 00112423;   % 1770: <48> sw	ra, 8(sp) %
00001712 : 01e00533;   % 1770: <50> mv 	a0, t5 %
00001713 : 011005b3;   % 1770: <51> mv 	a1, a7 %
00001714 : 234000ef;   % 1770: <52> jal 	__mulsi3 %
00001715 : 04051073;   % 1770: <53> csrw	a0,uscratch %
00001716 : 00012503;   % 1770: <55> lw	a0, 0(sp) %
00001717 : 00412583;   % 1770: <56> lw	a1, 4(sp) %
00001718 : 00812083;   % 1770: <57> lw	ra, 8(sp) %
00001719 : 00c10113;   % 1770: <58> addi 	sp, sp, 12 %
0000171a : 04002ff3;   % 1770: <59> csrr	t6,uscratch %
0000171b : 0080006f;   % 1771: 		j BRESENHAM.mul2d %
0000171c : 031f0fb3;   % 1772: BRESENHAM.mul2:	mul 	t6, t5, a7		# y*320 %
0000171d : 01df8fb3;   % 1773: BRESENHAM.mul2d:add 	t6, t6, t4		# y*320+x %
0000171e : 010f8fb3;   % 1774: 		add 	t6, t6, a6		# 0xFF000000+y*320+x %
0000171f : 00ef8023;   % 1775: 		sb 	a4, 0(t6)		# plot com cor a4 %
00001720 : 01c05863;   % 1777: 		ble 	t3, zero, PULA4BRES	# D<=0 %
00001721 : 007e8eb3;   % 1778: 		add 	t4, t4, t2		# x=x+xi %
00001722 : 00131f93;   % 1779: 		slli 	t6, t1, 1		# 2*dy %
00001723 : 41fe0e33;   % 1780: 		sub 	t3, t3, t6		# D=D-2dy %
00001724 : 00129f93;   % 1781: PULA4BRES: 	slli 	t6, t0, 1		# 2*dy %
00001725 : 01fe0e33;   % 1782: 		add 	t3, t3, t6		# D=D+2dx %
00001726 : 001f0f13;   % 1783: 		addi 	t5, t5, 1 %
00001727 : f8df16e3;   % 1784: 		bne 	t5, a3, LOOPx2BRES %
00001728 : 00008067;   % 1785: 		ret		 %
00001729 : ffc10113;   % 1800: printIntUnsigned:	addi 	sp, sp, -4		# Aloca espaco %
0000172a : 00112023;   % 1801: 		sw 	ra, 0(sp)			# salva ra %
0000172b : 0fc21297;   % 1802: 		la 	t0, TempBuffer			# carrega o Endereco do Buffer da String %
0000172c : 00c28293;   % 1802:  %
0000172d : 00a00393;   % 1804: 		li 	t2, 10				# carrega numero 10 %
0000172e : 00000313;   % 1805: 		li 	t1, 0				# carrega numero de digitos com 0 %
0000172f : 30102c73;   % 1807: <29> csrr s8, misa %
00001730 : 00cc5c13;   % 1807: <30> srli s8, s8, 12 %
00001731 : 001c7c13;   % 1807: <31> andi s8, s8, 0x001 %
00001732 : 160c1463;   % 1807: <32> bnez s8, printIntUnsigned.pula1 %
00001733 : ff010113;   % 1808: <65> addi 	sp, sp, -16 %
00001734 : 00a12023;   % 1808: <66> sw	a0, 0(sp) %
00001735 : 00e12223;   % 1808: <67> sw	a4, 4(sp) %
00001736 : 00f12423;   % 1808: <68> sw	a5, 8(sp) %
00001737 : 00112623;   % 1808: <69> sw	ra, 12(sp) %
00001738 : 00a00533;   % 1808: <70> mv 	a0, a0 %
00001739 : 00155713;   % 1808: <71> srli    a4,a0,1 %
0000173a : 00255793;   % 1808: <72> srli    a5,a0,2 %
0000173b : 00f707b3;   % 1808: <73> add     a5,a4,a5 %
0000173c : 0047d713;   % 1808: <74> srli    a4,a5,4 %
0000173d : 00f70733;   % 1808: <75> add     a4,a4,a5 %
0000173e : 00875793;   % 1808: <76> srli    a5,a4,8 %
0000173f : 00e78733;   % 1808: <77> add     a4,a5,a4 %
00001740 : 01075793;   % 1808: <78> srli    a5,a4,16 %
00001741 : 00e787b3;   % 1808: <79> add     a5,a5,a4 %
00001742 : 0037d793;   % 1808: <80> srli    a5,a5,3 %
00001743 : 00279713;   % 1808: <81> slli    a4,a5,2 %
00001744 : 00f70733;   % 1808: <82> add     a4,a4,a5 %
00001745 : 00171713;   % 1808: <83> slli    a4,a4,1 %
00001746 : 40e50533;   % 1808: <84> sub     a0,a0,a4 %
00001747 : 00a53513;   % 1808: <85> sltiu   a0,a0,10 %
00001748 : 00154513;   % 1808: <86> xori    a0,a0,1 %
00001749 : 00f50533;   % 1808: <87> add     a0,a0,a5 %
0000174a : 04051073;   % 1808: <88> csrw	a0,uscratch %
0000174b : 00012503;   % 1808: <89> lw	a0, 0(sp) %
0000174c : 00412703;   % 1808: <90> lw	a4, 4(sp) %
0000174d : 00812783;   % 1808: <91> lw	a5, 8(sp) %
0000174e : 00c12083;   % 1808: <92> lw	ra, 12(sp) %
0000174f : 01010113;   % 1808: <93> addi 	sp, sp, 16 %
00001750 : 04002ef3;   % 1808: <94> csrr	t4,uscratch %
00001751 : ff010113;   % 1809: <122> addi 	sp,sp,-16 %
00001752 : 00a12023;   % 1809: <123> sw	a0,0(sp) %
00001753 : 00b12223;   % 1809: <124> sw	a1,4(sp) %
00001754 : 00c12423;   % 1809: <125> sw	a2,8(sp) %
00001755 : 00d12623;   % 1809: <126> sw	a3,12(sp) %
00001756 : 00a006b3;   % 1809: <128> mv 	a3,a0 %
00001757 : 00a00613;   % 1809: <129> li 	a2,10 %
00001758 : ff010113;   % 1809: <65> addi 	sp, sp, -16 %
00001759 : 00a12023;   % 1809: <66> sw	a0, 0(sp) %
0000175a : 00e12223;   % 1809: <67> sw	a4, 4(sp) %
0000175b : 00f12423;   % 1809: <68> sw	a5, 8(sp) %
0000175c : 00112623;   % 1809: <69> sw	ra, 12(sp) %
0000175d : 00d00533;   % 1809: <70> mv 	a0, a3 %
0000175e : 00155713;   % 1809: <71> srli    a4,a0,1 %
0000175f : 00255793;   % 1809: <72> srli    a5,a0,2 %
00001760 : 00f707b3;   % 1809: <73> add     a5,a4,a5 %
00001761 : 0047d713;   % 1809: <74> srli    a4,a5,4 %
00001762 : 00f70733;   % 1809: <75> add     a4,a4,a5 %
00001763 : 00875793;   % 1809: <76> srli    a5,a4,8 %
00001764 : 00e78733;   % 1809: <77> add     a4,a5,a4 %
00001765 : 01075793;   % 1809: <78> srli    a5,a4,16 %
00001766 : 00e787b3;   % 1809: <79> add     a5,a5,a4 %
00001767 : 0037d793;   % 1809: <80> srli    a5,a5,3 %
00001768 : 00279713;   % 1809: <81> slli    a4,a5,2 %
00001769 : 00f70733;   % 1809: <82> add     a4,a4,a5 %
0000176a : 00171713;   % 1809: <83> slli    a4,a4,1 %
0000176b : 40e50533;   % 1809: <84> sub     a0,a0,a4 %
0000176c : 00a53513;   % 1809: <85> sltiu   a0,a0,10 %
0000176d : 00154513;   % 1809: <86> xori    a0,a0,1 %
0000176e : 00f50533;   % 1809: <87> add     a0,a0,a5 %
0000176f : 04051073;   % 1809: <88> csrw	a0,uscratch %
00001770 : 00012503;   % 1809: <89> lw	a0, 0(sp) %
00001771 : 00412703;   % 1809: <90> lw	a4, 4(sp) %
00001772 : 00812783;   % 1809: <91> lw	a5, 8(sp) %
00001773 : 00c12083;   % 1809: <92> lw	ra, 12(sp) %
00001774 : 01010113;   % 1809: <93> addi 	sp, sp, 16 %
00001775 : 04002573;   % 1809: <94> csrr	a0,uscratch %
00001776 : ff410113;   % 1809: <45> addi 	sp, sp, -12 %
00001777 : 00a12023;   % 1809: <46> sw	a0, 0(sp) %
00001778 : 00b12223;   % 1809: <47> sw	a1, 4(sp) %
00001779 : 00112423;   % 1809: <48> sw	ra, 8(sp) %
0000177a : 00a00533;   % 1809: <50> mv 	a0, a0 %
0000177b : 00c005b3;   % 1809: <51> mv 	a1, a2 %
0000177c : 094000ef;   % 1809: <52> jal 	__mulsi3 %
0000177d : 04051073;   % 1809: <53> csrw	a0,uscratch %
0000177e : 00012503;   % 1809: <55> lw	a0, 0(sp) %
0000177f : 00412583;   % 1809: <56> lw	a1, 4(sp) %
00001780 : 00812083;   % 1809: <57> lw	ra, 8(sp) %
00001781 : 00c10113;   % 1809: <58> addi 	sp, sp, 12 %
00001782 : 040025f3;   % 1809: <59> csrr	a1,uscratch %
00001783 : 40b68e33;   % 1809: <132> sub 	t3,a3,a1 %
00001784 : 040e1073;   % 1809: <134> csrw	t3,uscratch %
00001785 : 00012503;   % 1809: <135> lw	a0,0(sp) %
00001786 : 00412583;   % 1809: <136> lw 	a1,4(sp) %
00001787 : 00812603;   % 1809: <137> lw	a2,8(sp) %
00001788 : 00c12683;   % 1809: <138> lw	a3,12(sp) %
00001789 : 01010113;   % 1809: <139> addi 	sp,sp,16 %
0000178a : 04002e73;   % 1809: <140> csrr	t3,uscratch %
0000178b : 00c0006f;   % 1810: 			j	printIntUnsigned.pula1d %
0000178c : 02755eb3;   % 1811: printIntUnsigned.pula1:	divu 	t4, a0, t2			# divide por 10 (quociente) %
0000178d : 02757e33;   % 1812: 			remu 	t3, a0, t2			# resto %
0000178e : ffc10113;   % 1813: printIntUnsigned.pula1d:addi 	sp, sp, -4			# aloca espaco na pilha %
0000178f : 01c12023;   % 1814: 		sw 	t3, 0(sp)			# coloca resto na pilha %
00001790 : 01d00533;   % 1815: 		mv 	a0, t4				# atualiza o numero com o quociente %
00001791 : 00130313;   % 1816: 		addi 	t1, t1, 1			# incrementa o contador de digitos %
00001792 : e6051ae3;   % 1817: 		bne 	a0, zero, printIntUnsigned.loop1# verifica se o numero eh zero %
00001793 : 00012383;   % 1819: printIntUnsigned.loop2:	lw 	t2, 0(sp)		# le digito da pilha %
00001794 : 00410113;   % 1820: 		addi 	sp, sp, 4			# libera espaco %
00001795 : 03038393;   % 1821: 		addi 	t2, t2, 48			# converte o digito para ascii %
00001796 : 00728023;   % 1822: 		sb 	t2, 0(t0)			# coloca caractere no buffer %
00001797 : 00128293;   % 1823: 		addi 	t0, t0, 1			# incrementa endereco do buffer %
00001798 : fff30313;   % 1824: 		addi 	t1, t1, -1			# decrementa contador de digitos %
00001799 : fe0314e3;   % 1825: 		bne 	t1, zero, printIntUnsigned.loop2# eh o ultimo? %
0000179a : 00028023;   % 1826: 		sb 	zero, 0(t0)			# insere \NULL na string %
0000179b : 0fc21517;   % 1828: 		la 	a0, TempBuffer			# Endereco do buffer da srting %
0000179c : e4c50513;   % 1828:  %
0000179d : a18ff0ef;   % 1829: 		jal	printString			# chama o print string %
0000179e : 00012083;   % 1831: 		lw 	ra, 0(sp)			# recupera a %
0000179f : 00410113;   % 1832: 		addi 	sp, sp, 4			# libera espaco %
000017a0 : 00008067;   % 1833: printIntUnsigned.fim:	ret %
000017a1 : ff410113;   % 1845: __mulsi3:	addi 	sp,sp,-12 %
000017a2 : 00b12023;   % 1846: 		sw 	a1,0(sp) %
000017a3 : 00e12223;   % 1847: 		sw 	a4,4(sp) %
000017a4 : 00f12423;   % 1848: 		sw	a5,8(sp) %
000017a5 : 00a007b3;   % 1850: 	 	mv      a5,a0 %
000017a6 : 00000513;   % 1851:         	li      a0,0 %
000017a7 : 00078e63;   % 1852: mulsi3.L4: 	beqz    a5,mulsi3.L1 %
000017a8 : 0017f713;   % 1853:         	andi    a4,a5,1 %
000017a9 : 00070463;   % 1854:         	beqz    a4,mulsi3.L3 %
000017aa : 00b50533;   % 1855:         	add     a0,a0,a1 %
000017ab : 0017d793;   % 1856: mulsi3.L3: 	srli    a5,a5,1 %
000017ac : 00159593;   % 1857:         	slli    a1,a1,1 %
000017ad : fe9ff06f;   % 1858:         	j       mulsi3.L4 %
000017ae : 00012583;   % 1860: mulsi3.L1: 	lw 	a1,0(sp) %
000017af : 00412703;   % 1861: 		lw	a4,4(sp) %
000017b0 : 00812783;   % 1862: 		lw	a5,8(sp) %
000017b1 : 00c10113;   % 1863: 		addi 	sp,sp,12 %
000017b2 : 00008067;   % 1864: 		ret %
000017b3 : ff010113;   % 1868: __udivsi3:	addi 	sp,sp,-16 %
000017b4 : 00b12023;   % 1869: 		sw 	a1,0(sp) %
000017b5 : 00d12223;   % 1870: 		sw	a3,4(sp) %
000017b6 : 00e12423;   % 1871: 		sw 	a4,8(sp) %
000017b7 : 00f12623;   % 1872: 		sw	a5,12(sp) %
000017b8 : 00a00733;   % 1874:  		mv      a4,a0 %
000017b9 : 00155693;   % 1875:         	srli    a3,a0,1 %
000017ba : 00100793;   % 1876:         	li      a5,1 %
000017bb : 00b6e863;   % 1877: udivsi3.L3:    	bltu    a3,a1,udivsi3.L6 %
000017bc : 00179793;   % 1878:         	slli    a5,a5,1 %
000017bd : 00159593;   % 1879:         	slli    a1,a1,1 %
000017be : ff5ff06f;   % 1880:         	j       udivsi3.L3 %
000017bf : 00000513;   % 1881: udivsi3.L6:    	li      a0,0 %
000017c0 : 00078e63;   % 1882: udivsi3.L2:   	beqz    a5,udivsi3.L1 %
000017c1 : 00b76663;   % 1883:         	bltu    a4,a1,udivsi3.L5 %
000017c2 : 40b70733;   % 1884:         	sub     a4,a4,a1 %
000017c3 : 00f50533;   % 1885:         	add     a0,a0,a5 %
000017c4 : 0017d793;   % 1886: udivsi3.L5:    	srli    a5,a5,1 %
000017c5 : 0015d593;   % 1887:         	srli    a1,a1,1 %
000017c6 : fe9ff06f;   % 1888:         	j       udivsi3.L2 %
000017c7 : 00012583;   % 1890: udivsi3.L1: 	lw 	a1,0(sp) %
000017c8 : 00412683;   % 1891: 		lw	a3,4(sp) %
000017c9 : 00812703;   % 1892: 		lw	a4,8(sp) %
000017ca : 00c12783;   % 1893: 		lw	a5,12(sp) %
000017cb : 01010113;   % 1894: 		addi 	sp,sp,16 %
000017cc : 00008067;   % 1895:     		ret %
000017cd : ff410113;   % 1898: __umodsi3:	addi	sp, sp, -12 %
000017ce : 00512023;   % 1899: 		sw 	t0, 0(sp) %
000017cf : 00612223;   % 1900: 		sw 	t1, 4(sp) %
000017d0 : 00112423;   % 1901: 		sw 	ra, 8(sp) %
000017d1 : 00a002b3;   % 1902: 	 	mv 	t0, a0		# dividendo %
000017d2 : 00b00333;   % 1903: 		mv 	t1, a1		# divisor %
000017d3 : f81ff0ef;   % 1904: 		jal 	__udivsi3 %
000017d4 : 006005b3;   % 1905: 		mv 	a1, t1		# quociente * divisor %
000017d5 : f31ff0ef;   % 1906: 		jal 	__mulsi3 %
000017d6 : 40a28533;   % 1907: 		sub 	a0, t0, a0	# dividendo-quociente*divisor %
000017d7 : 00012283;   % 1908: 		lw 	t0, 0(sp) %
000017d8 : 00412303;   % 1909: 		lw 	t1, 4(sp) %
000017d9 : 00812083;   % 1910: 		lw 	ra, 8(sp) %
000017da : 00c10113;   % 1911: 		addi 	sp, sp, 12 %
000017db : 00008067;   % 1912: 		ret %
000017dc : ff010113;   % 1915: __divsi3:	addi	sp, sp, -16 %
000017dd : 00512023;   % 1916: 		sw 	t0, 0(sp) %
000017de : 00612223;   % 1917: 		sw 	t1, 4(sp) %
000017df : 00712423;   % 1918: 		sw 	t2, 8(sp) %
000017e0 : 00112623;   % 1919: 		sw 	ra, 12(sp) %
000017e1 : 41f55293;   % 1920: 		srai	t0,a0,31	# indica se a0 � pos(0) ou neg (2^32-1) %
000017e2 : 41f5d313;   % 1921: 		srai 	t1,a1,31	# indica se a1 � pos(0) ou neg (2^32-1) %
000017e3 : 0062c3b3;   % 1922: 		xor	t2,t0,t1	# indica se deve(!=0) ou n�o(==0) inverter o sinal do resultado %
000017e4 : 00028463;   % 1923: 		beqz 	t0,divsi3.pula1 %
000017e5 : 40a00533;   % 1924: 		neg	a0,a0		# nega %
000017e6 : 00030463;   % 1925: divsi3.pula1:	beqz 	t1,divsi3.pula2 %
000017e7 : 40b005b3;   % 1926: 		neg	a1,a1		# nega %
000017e8 : f2dff0ef;   % 1927: divsi3.pula2:	jal 	__udivsi3	# divis�o unsigned %
000017e9 : 00038463;   % 1928: 		beqz	t2, divsi3.pula3	 %
000017ea : 40a00533;   % 1929: 		neg	a0,a0		# nega %
000017eb : 00012283;   % 1930: divsi3.pula3:	lw 	t0, 0(sp) %
000017ec : 00412303;   % 1931: 		lw 	t1, 4(sp) %
000017ed : 00812383;   % 1932: 		lw 	t2, 8(sp) %
000017ee : 00c12083;   % 1933: 		lw 	ra, 12(sp) %
000017ef : 01010113;   % 1934: 		addi 	sp, sp, 16 %
000017f0 : 00008067;   % 1935: 		ret %
000017f1 : ff410113;   % 1938: __modsi3:	addi	sp, sp, -12 %
000017f2 : 00512023;   % 1939: 		sw 	t0, 0(sp) %
000017f3 : 00612223;   % 1940: 		sw 	t1, 4(sp) %
000017f4 : 00112423;   % 1941: 		sw 	ra, 8(sp) %
000017f5 : 41f55293;   % 1942: 		srai	t0,a0,31	# indica se a0 � pos(0) ou neg (2^32-1) %
000017f6 : 41f5d313;   % 1943: 		srai 	t1,a1,31	# indica se a1 � pos(0) ou neg (2^32-1) %
000017f7 : 00028463;   % 1944: 		beqz 	t0,modsi3.pula1 %
000017f8 : 40a00533;   % 1945: 		neg	a0,a0		# nega %
000017f9 : 00030463;   % 1946: modsi3.pula1:	beqz 	t1,modsi3.pula2 %
000017fa : 40b005b3;   % 1947: 		neg	a1,a1		# nega %
000017fb : f49ff0ef;   % 1948: modsi3.pula2:	jal 	__umodsi3	# resto unsigned %
000017fc : 00028463;   % 1949: 		beqz	t0, modsi3.pula3	# sinal do dividendo	 %
000017fd : 40a00533;   % 1950: 		neg	a0,a0		# nega %
000017fe : 00012283;   % 1951: modsi3.pula3:	lw 	t0, 0(sp) %
000017ff : 00412303;   % 1952: 		lw 	t1, 4(sp) %
00001800 : 00812083;   % 1953: 		lw 	ra, 8(sp) %
00001801 : 00c10113;   % 1954: 		addi 	sp, sp, 12 %
00001802 : 00008067;   % 1955: 		ret																				 %
00001803 : 0fc0c297;   % 12: 	la t0, CURRENT_MAP  # Loads CURRENT_MAP's address %
00001804 : 0f428293;   % 12:  %
00001805 : 0052c303;   % 13: 	lbu t1, 5(t0)       # Loads on t1 the CURRENT_MAP's rendering byte %
00001806 : 00200313;   % 14: 	li t1,2 %
00001807 : 00300393;   % 15: 	li t2,3				# Loads number 3 -- related to "switch map" operation %
00001808 : 00734463;   % 16: 	blt t1,t2 CHECK_MAP_MOVE_RENDER_1 # If the rendering byte is 0, 1 or 2 %
00001809 : 00008067;   % 17: 		ret				# If the rendering byte isn't <= 2 %
0000180a : 00030a63;   % 19: 		beqz t1, END_MAP_MOVE_RENDER # If the rendering byte is 0 %
0000180b : 00000513;   % 21: 			li a0, 0	   # in order to render map normally %
0000180c : fff30313;   % 22: 			addi t1,t1,-1  # subtracting 1 from t1 so that if t1 = 2 -> t1 = 1 (will be rendered  %
0000180d : 006282a3;   % 24: 			sb t1,5(t0)	   # Stores the new CURRENT_MAP's rendering byte %
0000180e : 0080006f;   % 25: 			j SCENE_RENDER # Starts scene rendering procedure %
0000180f : 00008067;   % 28: 		ret                %
00001810 : ffc10113;   % 48:     addi sp,sp,-4 %
00001811 : 00112023;   % 49:     sw ra, 0(sp) %
00001812 : 00051c63;   % 51: 	bnez a0, SKIP_SCENE_RENDER_ARGUMENTS # If a0 = 1, the arguments bellow have already been set %
00001813 : 008007b3;   % 53: 		mv a5,s0	# Current frame %
00001814 : 01400813;   % 54: 		li a6, 20	# Screen Width = 20 %
00001815 : 00f00893;   % 55: 		li a7, 15	# Screen Height = 15 %
00001816 : 00000e13;   % 56: 		li t3, 0	# Starting X for rendering (top left, related to Matrix) %
00001817 : 00000393;   % 57: 		li t2, 0	# Starting Y for rendering (top left, related to Matrix) %
00001818 : 0fc0c297;   % 60:     la t0, CURRENT_MAP  # Loads CURRENT_MAP's address %
00001819 : 0a028293;   % 60:  %
0000181a : 0002a503;   % 61:     lw a0, 0(t0) 	# a0 now has the Map Address %
0000181b : 0062c583;   % 63:     lbu a1, 6(t0)   # Loads current X on Map (starting X on Matrix (top left)) %
0000181c : 0072c603;   % 64:     lbu a2, 7(t0)   # Loads current Y on Map (starting Y on Matrix (top left))	 %
0000181d : 0082c683;   % 65:     lbu a3, 8(t0)   # Loads current X offset on Map %
0000181e : 0092c703;   % 66:     lbu a4, 9(t0)   # Loads current Y offset on Map %
0000181f : 00000213;   % 67: 	li tp, 0        # Map won't be dislocated %
00001820 : ffffc317;   % 69: 	call RENDER_MAP %
00001821 : 190300e7;   % 69:  %
00001822 : 00012083;   % 72: 	lw ra, 0(sp) %
00001823 : 00410113;   % 73:     addi sp,sp,4 %
00001824 : 00008067;   % 75:     ret %
00001825 : 0fc0c317;   % 91: 	la t1, NEXT_MAP  # Gets NEXT_MAP address %
00001826 : 07830313;   % 91:  %
00001827 : 0fc0cf17;   % 92: 	la t5, CURRENT_MAP  # Gets CURRENT_MAP address %
00001828 : 064f0f13;   % 92:  %
00001829 : 00254383;   % 93: 	lbu t2,2(a0)     # Gets next map's number %
0000182a : 00730223;   % 94: 	sb t2,4(t1)      # and stores it in NEXT_MAP %
0000182b : 00354e03;   % 95: 	lbu t3,3(a0)     # Gets next map's door number %
0000182c : 01c304a3;   % 96: 	sb t3,9(t1)      # and stores it in NEXT_MAP %
0000182d : 002e1e13;   % 97: 	slli t3,t3,2     # t3 has the number of bytes to be skipped after finding door address %
0000182e : 001e0e13;   % 98: 	addi t3,t3,1     # t3 has the number of bytes to be skipped after finding door address and skiping number of doors byte %
0000182f : 00100293;   % 101: 	li t0, 1  %
00001830 : 04729463;   % 102:     bne t0, t2, SKIP_NEXT_MAP1  %
00001831 : 0fc10297;   % 103: 		la t0, Map1   # If next map is Map1 %
00001832 : a6028293;   % 103:  %
00001833 : 00532023;   % 104: 		sw t0,0(t1)   # Store it into NEXT_MAP %
00001834 : 0fc0c397;   % 105: 		la t2,Doors1  # Gets Doors1 address  %
00001835 : 3c438393;   % 105:  %
00001836 : 0fc0ce97;   % 107: 		la t4,Zoomers_Next   # Zoomers address %
00001837 : 164e8e93;   % 107:  %
00001838 : 0fc0c217;   % 108: 		la tp,Zoomers1       # Loads Zoomers1 address for Map 1 %
00001839 : 16020213;   % 108:  %
0000183a : 004ea023;   % 109: 		sw tp,0(t4)          # and stores it %
0000183b : 0fc0ce97;   % 111: 		la t4,Rippers_Next   # Rippers address %
0000183c : 310e8e93;   % 111:  %
0000183d : 000ea023;   % 112: 		sw zero,0(t4)   # Stores 0 to it (no rippers) %
0000183e : 0fc0ce97;   % 114: 		la t4,Blocks_Next    # Blocks address %
0000183f : 114e8e93;   % 114:  %
00001840 : 000ea023;   % 115: 		sw zero,0(t4)        # there are no blocks in this map %
00001841 : 1e00006f;   % 117:     	j CONTINUE_CHANGE_MAP %
00001842 : 00200293;   % 119:         li t0, 2  %
00001843 : 04729c63;   % 120:         bne t0, t2, SKIP_NEXT_MAP2  %
00001844 : 0fc10297;   % 121: 			la t0, Map2   # If next map is Map2 %
00001845 : d9b28293;   % 121:  %
00001846 : 00532023;   % 122: 			sw t0,0(t1)   # Store it into NEXT_MAP %
00001847 : 0fc0ce97;   % 124: 			la t4,Zoomers_Next   # Zoomers address %
00001848 : 120e8e93;   % 124:  %
00001849 : 0fc0c217;   % 125: 			la tp,Zoomers2       # Loads Zoomers2 address for Map 2 %
0000184a : 16520213;   % 125:  %
0000184b : 004ea023;   % 126: 			sw tp,0(t4)          # and stores it %
0000184c : 0fc0ce97;   % 128: 			la t4,Rippers_Next   # Rippers address %
0000184d : 2cce8e93;   % 128:  %
0000184e : 0fc0c217;   % 129: 			la tp,Rippers2       # Loads Rippers2 address for Map 2 %
0000184f : 2c820213;   % 129:  %
00001850 : 004ea023;   % 130: 			sw tp,0(t4)          # and stores it %
00001851 : 0fc0ce97;   % 132: 			la t4,Blocks_Next    # Blocks address %
00001852 : 0c8e8e93;   % 132:  %
00001853 : 0fc0c217;   % 133: 			la tp,Blocks2   # Loads Blocks2 address for Map 2 %
00001854 : 0c420213;   % 133:  %
00001855 : 004ea023;   % 134: 			sw tp,0(t4)     # and stores it %
00001856 : 0fc0c397;   % 136: 			la t2,Doors2  # Gets Doors2 address  %
00001857 : 34138393;   % 136:  %
00001858 : 1840006f;   % 137: 			j CONTINUE_CHANGE_MAP %
00001859 : 00300293;   % 140:         li t0, 3  %
0000185a : 04729463;   % 141:         bne t0, t2, SKIP_NEXT_MAP3  %
0000185b : 0fc10297;   % 142: 			la t0, Map3   # If next map is Map3 %
0000185c : 0c628293;   % 142:  %
0000185d : 00532023;   % 143: 			sw t0,0(t1)   # Store it into NEXT_MAP %
0000185e : 0fc0c397;   % 144: 			la t2,Doors3  # Gets Doors3 address  %
0000185f : 32e38393;   % 144:  %
00001860 : 0fc0ce97;   % 146: 			la t4,Zoomers_Next   # Zoomers address %
00001861 : 0bce8e93;   % 146:  %
00001862 : 0fc0c217;   % 147: 			la tp,Zoomers3       # Loads Zoomers3 address for Map 3 %
00001863 : 16e20213;   % 147:  %
00001864 : 004ea023;   % 148: 			sw tp,0(t4)          # and stores it %
00001865 : 0fc0ce97;   % 150: 			la t4,Rippers_Next   # Rippers address %
00001866 : 268e8e93;   % 150:  %
00001867 : 000ea023;   % 151: 			sw zero,0(t4)   # Stores 0 to it (no rippers) %
00001868 : 0fc0ce97;   % 153: 			la t4,Blocks_Next    # Blocks address %
00001869 : 06ce8e93;   % 153:  %
0000186a : 000ea023;   % 154: 			sw zero,0(t4)        # there are no blocks in this map %
0000186b : 1380006f;   % 156: 			j CONTINUE_CHANGE_MAP %
0000186c : 00400293;   % 159:         li t0, 4   %
0000186d : 04729863;   % 160:         bne t0, t2, SKIP_NEXT_MAP4  %
0000186e : 0fc10297;   % 161: 			la t0, Map4   # If next map is Map4 %
0000186f : 40128293;   % 161:  %
00001870 : 00532023;   % 162: 			sw t0,0(t1)   # Store it into NEXT_MAP %
00001871 : 0fc0c397;   % 163: 			la t2,Doors4  # Gets Doors4 address   %
00001872 : 2eb38393;   % 163:  %
00001873 : 0fc0ce97;   % 165: 			la t4,Zoomers_Next   # Zoomers address %
00001874 : 070e8e93;   % 165:  %
00001875 : 0fc0c217;   % 166: 			la tp,Zoomers4       # Loads Zoomers4 address for Map 4 %
00001876 : 16b20213;   % 166:  %
00001877 : 004ea023;   % 167: 			sw tp,0(t4)          # and stores it %
00001878 : 0fc0ce97;   % 169: 			la t4,Rippers_Next   # Rippers address %
00001879 : 21ce8e93;   % 169:  %
0000187a : 0fc0c217;   % 170: 			la tp,Rippers4       # Loads Rippers4 address for Map 4 %
0000187b : 23c20213;   % 170:  %
0000187c : 004ea023;   % 171: 			sw tp,0(t4)          # and stores it %
0000187d : 0fc0ce97;   % 173: 			la t4,Blocks_Next    # Blocks address %
0000187e : 018e8e93;   % 173:  %
0000187f : 000ea023;   % 174: 			sw zero,0(t4)        # there are no blocks in this map %
00001880 : 0e40006f;   % 176: 			j CONTINUE_CHANGE_MAP %
00001881 : 00500293;   % 179:         li t0, 5  %
00001882 : 04729463;   % 180:         bne t0, t2, SKIP_NEXT_MAP5  %
00001883 : 0fc10297;   % 181: 			la t0, Map5   # If next map is Map5 %
00001884 : 73428293;   % 181:  %
00001885 : 00532023;   % 182: 			sw t0,0(t1)   # Store it into NEXT_MAP %
00001886 : 0fc0c397;   % 183: 			la t2,Doors5  # Gets Doors5 address   %
00001887 : 2a038393;   % 183:  %
00001888 : 0fc0ce97;   % 185: 			la t4,Zoomers_Next   # Zoomers address %
00001889 : 01ce8e93;   % 185:  %
0000188a : 0fc0c217;   % 186: 			la tp,Zoomers5       # Loads Zoomers5 address for Map 5 %
0000188b : 19c20213;   % 186:  %
0000188c : 004ea023;   % 187: 			sw tp,0(t4)          # and stores it %
0000188d : 0fc0ce97;   % 189: 			la t4,Rippers_Next   # Rippers address %
0000188e : 1c8e8e93;   % 189:  %
0000188f : 000ea023;   % 190: 			sw zero,0(t4)   # Stores 0 to it (no rippers) %
00001890 : 0fc0ce97;   % 192: 			la t4,Blocks_Next    # Blocks address %
00001891 : fcce8e93;   % 192:  %
00001892 : 000ea023;   % 193: 			sw zero,0(t4)        # there are no blocks in this map %
00001893 : 0980006f;   % 195: 			j CONTINUE_CHANGE_MAP %
00001894 : 00600293;   % 198:         li t0, 6 %
00001895 : 04729063;   % 199:         bne t0, t2, SKIP_NEXT_MAP6 %
00001896 : 0fc11297;   % 200: 			la t0, Map6   # If next map is Map6 %
00001897 : 94328293;   % 200:  %
00001898 : 00532023;   % 201: 			sw t0,0(t1)   # Store it into NEXT_MAP %
00001899 : 0fc0c397;   % 202: 			la t2,Doors6  # Gets Doors6 address   %
0000189a : 25d38393;   % 202:  %
0000189b : 0fc0ce97;   % 204: 			la t4,Zoomers_Next   # Zoomers address %
0000189c : fd0e8e93;   % 204:  %
0000189d : 000ea023;   % 205: 			sw zero,0(t4)          # and stores it %
0000189e : 0fc0ce97;   % 207: 			la t4,Rippers_Next   # Rippers address %
0000189f : 184e8e93;   % 207:  %
000018a0 : 000ea023;   % 208: 			sw zero,0(t4)   # Stores 0 to it (no rippers) %
000018a1 : 0fc0ce97;   % 210: 			la t4,Blocks_Next    # Blocks address %
000018a2 : f88e8e93;   % 210:  %
000018a3 : 000ea023;   % 211: 			sw zero,0(t4)        # there are no blocks in this map %
000018a4 : 0540006f;   % 213: 			j CONTINUE_CHANGE_MAP %
000018a5 : 00700293;   % 216: 		li t0, 7  %
000018a6 : 04729063;   % 217: 		bne t0, t2, SKIP_NEXT_MAP7  %
000018a7 : 0fc11297;   % 218: 			la t0, Map7   # If next map is Map7 %
000018a8 : a2e28293;   % 218:  %
000018a9 : 00532023;   % 219: 			sw t0,0(t1)   # Store it into NEXT_MAP %
000018aa : 0fc0c397;   % 220: 			la t2,Doors7  # Gets Doors7 address  %
000018ab : 21e38393;   % 220:  %
000018ac : 0fc0ce97;   % 222: 			la t4,Zoomers_Next   # Zoomers address %
000018ad : f8ce8e93;   % 222:  %
000018ae : 000ea023;   % 223: 			sw zero,0(t4)          # and stores it %
000018af : 0fc0ce97;   % 225: 			la t4,Rippers_Next   # Rippers address %
000018b0 : 140e8e93;   % 225:  %
000018b1 : 000ea023;   % 226: 			sw zero,0(t4)   # Stores 0 to it (no rippers) %
000018b2 : 0fc0ce97;   % 228: 			la t4,Blocks_Next    # Blocks address %
000018b3 : f44e8e93;   % 228:  %
000018b4 : 000ea023;   % 229: 			sw zero,0(t4)        # there are no blocks in this map %
000018b5 : 0100006f;   % 231: 			j CONTINUE_CHANGE_MAP %
000018b6 : fe010113;   % 235: 		addi sp,sp,-32  # Restoring unchanged %
000018b7 : 00000513;   % 236: 		li a0,0         # Player won't be able to move %
000018b8 : 8f8fb06f;   % 237: 		j ERROR_ON_SWITCH %
000018b9 : 02010113;   % 240: 	addi sp,sp,32    # Freeing stack since it won't return to Physics %
000018ba : 0012ce83;   % 242: 	lbu t4,1(t0)     # Gets next map's width %
000018bb : 0fc0c297;   % 244: 	la t0, Doors_Next # Gets Next Doors	address %
000018bc : 1a428293;   % 244:  %
000018bd : 0072a023;   % 245: 	sw t2,0(t0)       # and stores t2 (the DoorsA address) in it %
000018be : 007e03b3;   % 247: 	add t2,t3,t2     # t2 has the address of destination door (DoorsA) %
000018bf : 0013c283;   % 248: 	lbu t0,1(t2)     # Gets door's Y %
000018c0 : ffb28293;   % 249: 	addi t0,t0,-5    # Gets screen's matrix top left Y %
000018c1 : 005303a3;   % 250: 	sb t0,7(t1)      # Stores Y on NEXT_MAP %
000018c2 : 000302a3;   % 252: 	sb zero,5(t1)    # Number of iterations %
000018c3 : 00054e03;   % 253: 	lbu t3,0(a0)     # Loads door frame's current X position %
000018c4 : 000e0e63;   % 254: 	beqz t3, SWITCH_TOWARDS_LEFT  # If door frame is on the left (t3 = 0), next map is on the left %
000018c5 : 000f0523;   % 256: 		sb zero,10(t5)    # Stores 0 in the X dislocation for current map %
000018c6 : 000f05a3;   % 257: 		sb zero,11(t5)    # Stores switch direction (next map is on the right) %
000018c7 : 00030323;   % 258: 		sb zero,6(t1)     # Stores furthest X to the left of next map (0) on NEXT_MAP %
000018c8 : 01400293;   % 259: 		li t0, 20 # Gets screen width in tiles (20) %
000018c9 : 00530423;   % 260: 		sb t0,8(t1)           # and stores it in X dislocation for the next map  %
000018ca : 01c0006f;   % 261: 		j ENTER_DOOR_ANIMATION_PREP %
000018cb : 00100293;   % 263: 		li t0 1        # Direction is loaded by t0 %
000018cc : 005f05a3;   % 264: 		sb t0,11(t5)   # and stored (next map is on the left) %
000018cd : 005f0523;   % 265: 		sb t0,10(t5)   # Stores 1 in the X dislocation for current map %
000018ce : fffe8e93;   % 266: 		addi t4,t4,-1  # Subtracts 1 from map's width %
000018cf : 01d30323;   % 267: 		sb t4,6(t1)    # and stores the result as the X on NEXT_MAP %
000018d0 : 00030423;   % 268: 		sb zero,8(t1)  # Stores 0 in the X dislocation for next map  %
000018d1 : 0fc0c297;   % 285: 	la t0, PLYR_INPUT %
000018d2 : deb28293;   % 285:  %
000018d3 : 00000393;   % 286: 	li t2, 0   # There isn't input %
000018d4 : 00728023;   % 287: 	sb t2, 0(t0)  %
000018d5 : 0fc0c297;   % 289: 	la t0, PLYR_STATUS      # Loads Player Status %
000018d6 : dd228293;   % 289:  %
000018d7 : 00000313;   % 290: 	li t1, 0        # Loads vertical direction (0 = normal) %
000018d8 : 00628123;   % 291: 	sb t1, 2(t0)    # Stores new direction on PLYR_STATUS %
000018d9 : 006282a3;   % 293: 	sb t1, 5(t0)                   %
000018da : 00028323;   % 294: 	sb zero, 6(t0)  # Stores new direction on MOVE_X %
000018db : 00144413;   % 296: 	xori s0,s0,1   # Switches frame value (register)										 %
000018dc : 00100513;   % 297: 	li a0, 1       # Rendering player's trail operation %
000018dd : 00000593;   % 298: 	li a1, 0       # Rendering full player (a1 doesn't really matter when a0 = 1) %
000018de : ffffb317;   % 299: 	call RENDER_PLAYER %
000018df : 6e0300e7;   % 299:  %
000018e0 : 00003317;   % 302: 	call PLAY_SOUND %
000018e1 : d00300e7;   % 302:  %
000018e2 : c01022f3;   % 304: 	csrr t0,3073                       # Gets current time %
000018e3 : 409282b3;   % 305:     sub t0, t0, s1                     # t0 = current time - last frame's time %
000018e4 : 03200313;   % 306:     li t1, 50                  # Loads frame rate (time (in ms) per frame) %
000018e5 : fe62e6e3;   % 307:     bltu t0,t1, ENTER_DOOR_ANIMATION  # While t0 < minimum time for a frame, keep looping  %
000018e6 : 00144413;   % 309: 	xori s0,s0,1		    # Switches frame value (register) %
000018e7 : 0fc0c297;   % 311: 	la t0, MOVE_Y  # Loads MOVE_Y %
000018e8 : d9128293;   % 311:  %
000018e9 : 00028283;   % 312: 	lb t0,0(t0)    # and gets its value  %
000018ea : 02028463;   % 313: 	beqz t0,ENTER_DOOR_ANIMATION_MOVE_PLAYER # If player is on the ground, go to ENTER_DOOR_ANIMATION_MOVE_PLAYER %
000018eb : ffffb317;   % 315: 		call PHYSICS            # Physics operations %
000018ec : f58300e7;   % 315:  %
000018ed : 00000317;   % 316: 		call UPDATE_STATUS      # Updates player's sprite status %
000018ee : 5b0300e7;   % 316:  %
000018ef : 00000513;   % 318: 		li a0, 0     # Rendering player operation %
000018f0 : 00000593;   % 319: 		li a1, 0     # Rendering full player %
000018f1 : ffffb317;   % 320: 		call RENDER_PLAYER %
000018f2 : 694300e7;   % 320:  %
000018f3 : 0900006f;   % 321: 		j CONTINUE_ENTER_DOOR_ANIMATION %
000018f4 : 0fc0c297;   % 323: 		la t0, CURRENT_MAP   # Loads CURRENT_MAP's address %
000018f5 : d3028293;   % 323:  %
000018f6 : 0fc0c317;   % 324: 		la t1, PLYR_POS   # Loads PLYR_POS's address %
000018f7 : d4230313;   % 324:  %
000018f8 : 00b2c383;   % 325: 		lbu t2,11(t0)        # Loads switch direction %
000018f9 : 04038063;   % 326: 		beqz t2, ENTER_DOOR_ANIMATION_NEXT_ON_RIGHT # If next map is on the right, go to ENTER_DOOR_ANIMATION_NEXT_ON_RIGHT %
000018fa : 00031283;   % 328: 			lh t0,0(t1)   # Gets player's current X related to screen %
000018fb : 00531123;   % 329: 			sh t0,2(t1)   # Stores it on old X %
000018fc : ffc28293;   % 331: 			addi t0,t0,-4  # Adds 4 to player's X %
000018fd : 00531023;   % 332: 			sh t0,0(t1)   # Stores new X %
000018fe : 0fc0c297;   % 334: 			la t0, MOVE_X  # Loads MOVE_X %
000018ff : d3428293;   % 334:  %
00001900 : fff00313;   % 335: 			li t1,-1       # Loads direction (left) %
00001901 : 00628023;   % 336: 			sb t1,0(t0)    # Stores on MOVE_X %
00001902 : 00000317;   % 337: 			call UPDATE_STATUS      # Updates player's sprite status %
00001903 : 55c300e7;   % 337:  %
00001904 : 00000513;   % 339: 			li a0, 0     # Rendering player operation %
00001905 : 00200593;   % 340: 			li a1, 2     # Rendering player's 16 rightmost pixels %
00001906 : ffffb317;   % 341: 			call RENDER_PLAYER %
00001907 : 640300e7;   % 341:  %
00001908 : 03c0006f;   % 342: 			j CONTINUE_ENTER_DOOR_ANIMATION %
00001909 : 00031283;   % 345: 			lh t0,0(t1)   # Gets player's current X related to screen %
0000190a : 00531123;   % 346: 			sh t0,2(t1)   # Stores it on old X %
0000190b : 00428293;   % 348: 			addi t0,t0,4  # Adds 4 to player's X %
0000190c : 00531023;   % 349: 			sh t0,0(t1)   # Stores new X %
0000190d : 0fc0c297;   % 351: 			la t0, MOVE_X  # Loads MOVE_X %
0000190e : cf828293;   % 351:  %
0000190f : 00100313;   % 352: 			li t1,1        # Loads direction (right) %
00001910 : 00628023;   % 353: 			sb t1,0(t0)    # Stores on MOVE_X %
00001911 : 00000317;   % 354: 			call UPDATE_STATUS      # Updates player's sprite status %
00001912 : 520300e7;   % 354:  %
00001913 : 00000513;   % 356: 			li a0, 0     # Rendering player operation %
00001914 : 00100593;   % 357: 			li a1, 1     # Rendering player's 16 leftmost pixels %
00001915 : ffffb317;   % 358: 			call RENDER_PLAYER %
00001916 : 604300e7;   % 358:  %
00001917 : ffffc317;   % 361: 	call RENDER_DOOR_FRAMES	 %
00001918 : ca0300e7;   % 361:  %
00001919 : ff2002b7;   % 364: 	li t0,0xFF200604	# Loads Bitmap Display address %
0000191a : 60428293;   % 364:  %
0000191b : 0082a023;   % 365: 	sw s0,0(t0)         # Stores new frame value (from s0) on Bitmap Display %
0000191c : 00100513;   % 367: 	li a0, 1     # Rendering player's trail operation %
0000191d : 00000593;   % 368: 	li a1, 0     # Rendering full player (a1 doesn't really matter when a0 = 1) %
0000191e : ffffb317;   % 369: 	call RENDER_PLAYER %
0000191f : 5e0300e7;   % 369:  %
00001920 : ffffc317;   % 371: 	call RENDER_UI %
00001921 : 978300e7;   % 371:  %
00001922 : 0fc0c297;   % 375: 	la t0, MOVE_Y  # Loads MOVE_Y %
00001923 : ca528293;   % 375:  %
00001924 : 00028283;   % 376: 	lb t0,0(t0)    # and gets its value  %
00001925 : 04029c63;   % 377: 	bnez t0,CONTINUE_ENTER_DOOR_ANIMATION_2 # If player is on the ground, go to CONTINUE_ENTER_DOOR_ANIMATION_2 %
00001926 : 0fc0c297;   % 378: 		la t0, CURRENT_MAP   # Loads CURRENT_MAP's address %
00001927 : c6828293;   % 378:  %
00001928 : 0fc0c317;   % 379: 		la t1, PLYR_POS      # Loads PLYR_POS's address		 %
00001929 : c7a30313;   % 379:  %
0000192a : 00a30383;   % 380: 		lb t2,10(t1)         # Gets player's current Y related to matrix %
0000192b : 007305a3;   % 381: 		sb t2,11(t1)         # Stores it on old Y related to matrix %
0000192c : 00b2c383;   % 382: 		lbu t2,11(t0)        # Loads switch direction %
0000192d : 00038c63;   % 383: 		beqz t2, ENTER_DOOR_ANIMATION_NEXT_ON_RIGHT_2 # If next map is on the right, go to ENTER_DOOR_ANIMATION_NEXT_ON_RIGHT_2 %
0000192e : 00031383;   % 385: 			lh t2,0(t1)           # Gets player's current X related to screen %
0000192f : 02039863;   % 386: 			bnez,t2,CONTINUE_ENTER_DOOR_ANIMATION_2  # If player's current X = !0, continue loop %
00001930 : 00400313;   % 388: 				li t1,4           # X Offset for map %
00001931 : 00628423;   % 389: 				sb t1,8(t0)       # storing X offset for map %
00001932 : 02c0006f;   % 390: 				j SWITCH_MAP_PREP  %
00001933 : 00031e03;   % 393: 			lh t3,0(t1)           # Gets player's current X related to screen %
00001934 : 14000313;   % 394: 			li t1,320    # Loads 320 %
00001935 : 01000393;   % 395: 			li t2,16       # Loads 16 %
00001936 : 40730333;   % 396: 			sub t1,t1,t2          # t1 = 304	 %
00001937 : 01c31863;   % 397: 			bne t1,t3,CONTINUE_ENTER_DOOR_ANIMATION_2  # If player's current X != 304, continue loop %
00001938 : 00c00313;   % 399: 				li t1,12          # X Offset for map %
00001939 : 00628423;   % 400: 				sb t1,8(t0)       # storing X offset for map %
0000193a : 00c0006f;   % 401: 				j SWITCH_MAP_PREP   %
0000193b : c01024f3;   % 403: 		csrr s1,3073    # new time is stored in s1, in order to be compared later		 %
0000193c : e91ff06f;   % 405: 		j ENTER_DOOR_ANIMATION	# Returns to beginning of loop %
0000193d : 00100513;   % 421: 	li a0,1   # Close doors %
0000193e : 00100593;   % 422: 	li a1,1   # Close them fast    :) %
0000193f : ffffb317;   % 423: 	call CHANGE_DOORS_STATE %
00001940 : d68300e7;   % 423:  %
00001941 : 0fc0c317;   % 425: 	la t1,NEXT_MAP %
00001942 : c0830313;   % 425:  %
00001943 : 00100393;   % 426: 	li t2,1 %
00001944 : 00730523;   % 427: 	sb t2,10(t1)      # Loads render Next Map's %
00001945 : ffffd317;   % 429: 	call RESET_ENEMIES %
00001946 : 590300e7;   % 429:  %
00001947 : 0fc0c317;   % 431: 	la t1,NEXT_MAP %
00001948 : bf030313;   % 431:  %
00001949 : 00030523;   % 432: 	sb zero,10(t1)      # Loads render Next Map's %
0000194a : 0fc0c297;   % 435: 	la t0,CURRENT_MAP %
0000194b : bd828293;   % 435:  %
0000194c : 00300393;   % 436: 	li t2,3 %
0000194d : 007282a3;   % 437: 	sb t2,5(t0) %
0000194e : 00003317;   % 440: 	call PLAY_SOUND %
0000194f : b48300e7;   % 440:  %
00001950 : c01022f3;   % 442: 	csrr t0,3073 %
00001951 : 409282b3;   % 443:     sub t0, t0, s1 #  # a0 = current time - last frame's time %
00001952 : 03200313;   % 444:     li t1, 50       # Loads frame rate (time (in ms) per frame) %
00001953 : fe62e6e3;   % 445:     bltu t0,t1, SWITCH_MAP  # While a0 < minimum time for a frame, keep looping  %
00001954 : 00144413;   % 448: 	xori s0,s0,1			# inverts frame value %
00001955 : 0fc0c317;   % 451: 	la t1, NEXT_MAP         # Gets NEXT_MAP address %
00001956 : bb830313;   % 451:  %
00001957 : 00030523;   % 452: 	sb zero,10(t1)          # Stores 0 on Render Next Map Door (in order to render doors properly) %
00001958 : 00534303;   % 453: 	lbu t1,5(t1)            # Gets number of iterations so far %
00001959 : 01400813;   % 454: 	li a6, 20 	# Screen Width = 20     # width (Related to Matrix) of rendering area %
0000195a : 15035c63;   % 455: 	bge t1,a6,END_OF_SWITCH_MAP %
0000195b : 0fc0c297;   % 459: 		la t0, CURRENT_MAP      # Gets CURRENT_MAP address %
0000195c : b9428293;   % 459:  %
0000195d : 0002a503;   % 460: 		lw a0,0(t0)	            # Loads Current Map's address %
0000195e : 0072c603;   % 461: 		lbu a2, 7(t0)           # Loads current Y on Map (starting Y on Matrix (top left))	 %
0000195f : 0082c683;   % 462: 		lbu a3, 8(t0)           # Loads current X offset on Map %
00001960 : 00000713;   % 463: 		li a4,0                 # Y offset will always be 0 during transition %
00001961 : 008007b3;   % 464: 		mv a5,s0	            # Current frame %
00001962 : 00f00893;   % 465: 		li a7, 15	# Screen Height = 15    # height (Related to Matrix) of rendering area %
00001963 : 00000e13;   % 466: 		li t3, 0	            # Starting X for rendering (top left, related to Matrix) %
00001964 : 00000393;   % 467: 		li t2, 0	            # Starting Y for rendering (top left, related to Matrix) %
00001965 : 0062c583;   % 469: 		lbu a1, 6(t0)           # Loads current X on Map (starting X on Matrix (top left)) %
00001966 : 00a2c203;   % 470: 		lbu tp,10(t0)           # X dislocation related to CURRENT_MAP %
00001967 : 00b2ce83;   % 471: 		lbu t4,11(t0)           # Loads switch direction %
00001968 : 020e8063;   % 472: 		beqz t4, SWITCH_MAP_CURRENT_ON_LEFT  # If next map is on the right, current map is on the left %
00001969 : 00300e93;   % 474: 			li t4,3             # Loads 3 for holding comparision %
0000196a : 00deaeb3;   % 475: 			slt t4,t4,a3        # Sets t4 to 1 if X offset isn't 0 (in this case, if X offset < 4, X offset = 0) %
0000196b : 40680833;   % 476: 			sub a6,a6,t1       # Screen Width = Number of iterations (X offset = 0) or Number of iterations + 1 (X offset != 0) %
0000196c : 00620233;   % 477: 			add tp,tp,t1        # Gets dislocation by adding the number of iterations from it %
0000196d : ffffc317;   % 478: 			call RENDER_MAP %
0000196e : c5c300e7;   % 478:  %
0000196f : 0100006f;   % 479: 			j SWITCH_MAP_NEXT %
00001970 : 006585b3;   % 481: 			add a1,a1,t1            # Changes X %
00001971 : ffffc317;   % 483: 			call RENDER_MAP %
00001972 : c4c300e7;   % 483:  %
00001973 : 0fc0c297;   % 487: 		la t0, CURRENT_MAP      # Gets CURRENT_MAP address %
00001974 : b3428293;   % 487:  %
00001975 : 0fc0c317;   % 488: 		la t1, NEXT_MAP         # Gets NEXT_MAP address %
00001976 : b3830313;   % 488:  %
00001977 : 00100393;   % 489: 		li t2,1                 # Loads 1 in order to render Next Map's Door %
00001978 : 00730523;   % 490: 		sb t2,10(t1)            # Stores 1 on Render Next Map Door %
00001979 : 00032503;   % 492: 		lw a0,0(t1)	            # Loads Next Map's address %
0000197a : 00734603;   % 493: 		lbu a2, 7(t1)           # Loads current Y on Map (starting Y on Matrix (top left))	 %
0000197b : 0082c683;   % 494: 		lbu a3, 8(t0)           # Loads current X offset on Map %
0000197c : 00000713;   % 495: 		li a4,0                 # Y offset will always be 0 during transition %
0000197d : 008007b3;   % 496: 		mv a5,s0	            # Current frame %
0000197e : 00f00893;   % 497: 		li a7, 15	# Screen Height = 15    # height (Related to Matrix) of rendering area %
0000197f : 00000e13;   % 498: 		li t3, 0	            # Starting X for rendering (top left, related to Matrix) %
00001980 : 00000393;   % 499: 		li t2, 0	            # Starting Y for rendering (top left, related to Matrix) %
00001981 : 00634583;   % 502: 		lbu a1, 6(t1)           # Loads current X on Map (starting X on Matrix (top left)) %
00001982 : 00834203;   % 503: 		lbu tp,8(t1)            # X dislocation related to CURRENT_MAP %
00001983 : 00b2ce83;   % 504: 		lbu t4,11(t0)           # Loads switch direction %
00001984 : 00534f03;   % 505: 		lbu t5,5(t1)            # Gets number of iterations so far		 %
00001985 : 020e8063;   % 506: 		beqz t4, SWITCH_MAP_NEXT_ON_RIGHT  # If next map is on the right %
00001986 : 41e585b3;   % 508: 			sub a1,a1,t5        # Changes X %
00001987 : 01400e93;   % 509: 			li t4,20            # Loads 3 for holding comparision %
00001988 : 01df2eb3;   % 510: 			slt t4,t5,t4        # Sets t4 to 1 if number of iterations is less than 19 %
00001989 : 01df0833;   % 511: 			add a6,t5,t4        # Screen Width = Number of iterations (if it's equal to 19) or Number of iterations + 1 (if it's < 19) %
0000198a : ffffc317;   % 513: 			call RENDER_MAP %
0000198b : be8300e7;   % 513:  %
0000198c : 0200006f;   % 514: 			j SWITCH_MAP_CONTINUE %
0000198d : 00300e93;   % 516: 			li t4,3             # Loads 3 for holding comparision %
0000198e : 00deaeb3;   % 517: 			slt t4,t4,a3        # Sets t4 to 1 if X offset isn't 0 (in this case, if X offset < 4, X offset = 0) %
0000198f : 01df0833;   % 518: 			add a6,t5,t4        # Screen Width = Number of iterations (X offset = 0) or Number of iterations + 1 (X offset != 0) %
00001990 : 00834203;   % 519: 			lbu tp,8(t1)        # X dislocation related to CURRENT_MAP %
00001991 : 41e20233;   % 520: 			sub tp,tp,t5        # Gets dislocation by subtracting the number of iterations from it %
00001992 : ffffc317;   % 521: 			call RENDER_MAP %
00001993 : bc8300e7;   % 521:  %
00001994 : ffffb317;   % 525: 	call UPDATE_DOORS       # Updates doors %
00001995 : b54300e7;   % 525:  %
00001996 : ff2002b7;   % 528: 	li t0,0xFF200604		# carrega em t0 o endereco de troca de frame %
00001997 : 60428293;   % 528:  %
00001998 : 0082a023;   % 529: 	sw s0,0(t0) %
00001999 : ffffb317;   % 531: 	call RENDER_UI %
0000199a : 794300e7;   % 531:  %
0000199b : 0fc0c297;   % 535: 	la t0, CURRENT_MAP      # Gets CURRENT_MAP address	 %
0000199c : a9428293;   % 535:  %
0000199d : 0fc0c317;   % 536: 	la t1, NEXT_MAP         # Gets NEXT_MAP address %
0000199e : a9830313;   % 536:  %
0000199f : 00b2ce03;   % 537: 	lbu t3,11(t0)           # Loads switch direction %
000019a0 : 0082c383;   % 538: 	lbu t2, 8(t0)           # Loads current X offset  %
000019a1 : 000e0a63;   % 540: 	beqz t3, SWITCH_MAP_OFFSET_RIGHT # If next map is on the right %
000019a2 : ffc38393;   % 542: 		addi t2,t2,-4   # decrease offset by 4  %
000019a3 : 0203d463;   % 544: 		bge t2, zero, SWITCH_MAP_AFTER_OFFSET_OPERATION %
000019a4 : 01038393;   % 546: 			addi t2,t2,16 # Corrects negative offset by adding 16 %
000019a5 : 0140006f;   % 547: 			j SWITCH_MAP_ITERATE # iterates procedure  %
000019a6 : 00438393;   % 549: 		addi t2,t2,4      # increase offset by 4  %
000019a7 : 01000e13;   % 550: 		li t3,16   # loads 16 for operations %
000019a8 : 01c3ca63;   % 552: 		blt t2, t3, SWITCH_MAP_AFTER_OFFSET_OPERATION  %
000019a9 : 41c383b3;   % 554: 			sub t2,t2,t3           # Corrects offset by subtracting 16 %
000019aa : 00534e03;   % 557: 		lbu t3,5(t1)    # Gets number of iterations so far %
000019ab : 001e0e13;   % 558: 		addi t3,t3,1    # t2++ %
000019ac : 01c302a3;   % 559: 		sb t3,5(t1)     # Stores new iteration %
000019ad : 00728423;   % 561: 		sb t2, 8(t0)    # Stores new X offset %
000019ae : c01024f3;   % 562: 		csrr s1,3073    # new time is stored in s1, in order to be compared later %
000019af : e7dff06f;   % 563: 		j SWITCH_MAP %
000019b0 : 0fc0c297;   % 566: 	la t0,CURRENT_MAP %
000019b1 : a4028293;   % 566:  %
000019b2 : 0fc0c317;   % 567: 	la t1,NEXT_MAP %
000019b3 : a4430313;   % 567:  %
000019b4 : 00032383;   % 568: 	lw t2,0(t1)        # Loads next map's address %
000019b5 : 0072a023;   % 569: 	sw t2,0(t0)        # and stores it on CURRENT_MAP %
000019b6 : 00434383;   % 570: 	lbu t2,4(t1)       # Loads next map's number %
000019b7 : 00728223;   % 571: 	sb t2,4(t0)        # and stores it on CURRENT_MAP %
000019b8 : 00634383;   % 572: 	lbu t2,6(t1)       # Loads next map's X %
000019b9 : 00728323;   % 573: 	sb t2,6(t0)        # and stores it on CURRENT_MAP %
000019ba : 00734383;   % 574: 	lbu t2,7(t1)       # Loads next map's Y %
000019bb : 007283a3;   % 575: 	sb t2,7(t0)        # and stores it on CURRENT_MAP %
000019bc : 00028423;   % 576: 	sb zero,8(t0)      # Sets CURRENT_MAP's X offset to 0 %
000019bd : 000284a3;   % 577: 	sb zero,9(t0)      # Sets CURRENT_MAP's Y offset to 0 %
000019be : 00b2ce03;   % 579: 	lbu t3,11(t0)  # Loads switch direction %
000019bf : 000e0c63;   % 580: 	beqz t3,END_OF_SWITCH_MAP_SKIP_CHANGE_MAP_POSITION # If next map was on the right, player will be on the left door %
000019c0 : 0002ae03;   % 582: 		lw t3,0(t0)    # Gets current map's address %
000019c1 : 001e4e03;   % 583: 		lbu t3,1(t3)   # and takes its width %
000019c2 : 01400e93;   % 584: 		li t4,20  # t4 = 20 %
000019c3 : 41de0eb3;   % 585: 		sub t4,t3,t4          # t4 = Current Map's X position %
000019c4 : 01d28323;   % 586: 		sb t4,6(t0)           # Stores map's X %
000019c5 : 8dcfa06f;   % 588: 		j SETUP %
000019c6 : 0fc0c297;   % 602: 	la t0,CURRENT_MAP %
000019c7 : 9e828293;   % 602:  %
000019c8 : 00200393;   % 603: 	li t2,2            # Loads 3 (switch map through door) %
000019c9 : 007282a3;   % 604: 	sb t2,5(t0) %
000019ca : 0fc0c317;   % 607: 	la t1,NEXT_MAP %
000019cb : 9e430313;   % 607:  %
000019cc : 00934303;   % 608: 	lbu t1,9(t1)     # loads "next door"'s number %
000019cd : 00231313;   % 609: 	slli t1,t1,2     # multiplies it by 4 %
000019ce : 0fc0c517;   % 610: 	la a0, Doors     # Gets Doors address %
000019cf : d5450513;   % 610:  %
000019d0 : 00052503;   % 611: 	lw a0,0(a0)      # gets current map's doors address %
000019d1 : 00150513;   % 612: 	addi a0,a0,1     # skips number of doors %
000019d2 : 00650533;   % 613: 	add a0,a0,t1     # and adds t1 to get the correct door's address %
000019d3 : 00100393;   % 614: 	li t2,1             # Loads 1 (opening/closing) %
000019d4 : 00750123;   % 615:     sb t2,2(a0)         # and stores it on door's state byte     %
000019d5 : ffe00393;   % 616:     li t2,-2  # Gets new counter (related to opening door -- negative, in order to open) %
000019d6 : 007501a3;   % 617:     sb t2,3(a0)         # and stores it on door's counter byte %
000019d7 : 0fc0c397;   % 620: 	la t2, PLYR_POS %
000019d8 : 9be38393;   % 620:  %
000019d9 : 0072ce83;   % 622: 	lbu t4,7(t0)                # Loads map's Y %
000019da : 006e8e13;   % 623: 	addi t3,t4,6  # adds 6 to it to get Player's new Y related to matrix %
000019db : 01c38523;   % 624: 	sb t3, 10(t2)               # and stores it  %
000019dc : 01c385a3;   % 625: 	sb t3, 11(t2)               # as well as on old Y %
000019dd : 41de0e33;   % 627: 	sub t3,t3,t4                # Gets player's matrix Y related to map's matrix Y  %
000019de : 004e1e13;   % 628: 	slli t3,t3,4  # Multiplies t3 by 16 to get Player's new Y related to screen %
000019df : 01c38223;   % 629: 	sb t3, 4(t2)                # and stores it %
000019e0 : 00b2ce03;   % 632: 	lbu t3,11(t0)  # Loads switch direction %
000019e1 : 000e0a63;   % 633: 	beqz t3,LEAVE_DOOR_ANIMATION_PREP_PLAYER_LEFT_DOOR # If next map was on the right, player will be on the left door %
000019e2 : 0002ae03;   % 635: 		lw t3,0(t0)    # Gets current map's address %
000019e3 : 001e4e03;   % 636: 		lbu t3,1(t3)   # and takes its width %
000019e4 : fffe0e13;   % 637: 		addi t3,t3,-1         # Subtracts 1 from width to get Player's new X related to matrix (because coordinate starts on 0) %
000019e5 : 0080006f;   % 638: 		j LEAVE_DOOR_ANIMATION_PREP_PLAYER_POS %
000019e6 : 00000e13;   % 640: 		li t3,0               # Player's new X related to matrix %
000019e7 : 01c38423;   % 642: 		sb t3, 8(t2)      # Stores new player's X related to the matrix %
000019e8 : 01c384a3;   % 643: 		sb t3, 9(t2)      # as well as on player's old X related to the matrix %
000019e9 : 0062ce83;   % 645: 		lbu t4,6(t0)                # Loads map's X %
000019ea : 41de0e33;   % 646: 		sub t3,t3,t4                # Gets player's matrix X related to map's matrix X  %
000019eb : 004e1e13;   % 647: 		slli t3,t3,4  # Multiplies t3 by 16 to get Player's new X related to screen %
000019ec : 01c39023;   % 648: 		sh t3, 0(t2)   # Stores new player's X related to the screen %
000019ed : 00000e13;   % 650: 		li t3, 0       # For player's offset %
000019ee : 01c38323;   % 651: 		sb t3, 6(t2)   # Stores new player's X offset %
000019ef : 01c383a3;   % 652: 		sb t3, 7(t2)   # Stores new player's Y offset %
000019f0 : 00003317;   % 656: 	call PLAY_SOUND %
000019f1 : 8c0300e7;   % 656:  %
000019f2 : c01022f3;   % 658: 	csrr t0,3073                       # Gets current time %
000019f3 : 409282b3;   % 659:     sub t0, t0, s1                     # t0 = current time - last frame's time %
000019f4 : 03200313;   % 660:     li t1, 50                  # Loads frame rate (time (in ms) per frame) %
000019f5 : fe62e6e3;   % 661:     bltu t0,t1, LEAVE_DOOR_ANIMATION   # While t0 < minimum time for a frame, keep looping  %
000019f6 : 00144413;   % 663: 	xori s0,s0,1		    # Switches frame value (register) %
000019f7 : ffffb317;   % 665: 	call UPDATE_DOORS       # Updates doors %
000019f8 : 9c8300e7;   % 665:  %
000019f9 : 00000317;   % 666: 	call MAP_MOVE_RENDER    # Renders map when necessary %
000019fa : 828300e7;   % 666:  %
000019fb : 0fc0c297;   % 669: 	la t0, CURRENT_MAP   # Loads CURRENT_MAP's address %
000019fc : 91428293;   % 669:  %
000019fd : 0fc0c317;   % 670: 	la t1, PLYR_POS      # Loads PLYR_POS's address %
000019fe : 92630313;   % 670:  %
000019ff : 00b2c383;   % 671: 	lbu t2,11(t0)        # Loads switch direction %
00001a00 : 04038063;   % 672: 	beqz t2, LEAVE_DOOR_ANIMATION_NEXT_ON_RIGHT # If next map is on the right, go to LEAVE_DOOR_ANIMATION_NEXT_ON_RIGHT %
00001a01 : 00031283;   % 674: 		lh t0,0(t1)   # Gets player's current X related to screen %
00001a02 : 00531123;   % 675: 		sh t0,2(t1)   # Stores it on old X %
00001a03 : ffc28293;   % 677: 		addi t0,t0,-4  # Adds 4 to player's X %
00001a04 : 00531023;   % 678: 		sh t0,0(t1)    # Stores new X %
00001a05 : 0fc0c297;   % 680: 		la t0, MOVE_X  # Loads MOVE_X %
00001a06 : 91828293;   % 680:  %
00001a07 : fff00313;   % 681: 		li t1,-1       # Loads direction (left) %
00001a08 : 00628023;   % 682: 		sb t1,0(t0)    # Stores on MOVE_X %
00001a09 : 00000317;   % 683: 		call UPDATE_STATUS      # Updates player's sprite status %
00001a0a : 140300e7;   % 683:  %
00001a0b : 00000513;   % 685: 		li a0, 0     # Rendering player operation %
00001a0c : 00000593;   % 686: 		li a1,0     # Rendering full player %
00001a0d : ffffb317;   % 687: 		call RENDER_PLAYER %
00001a0e : 224300e7;   % 687:  %
00001a0f : 03c0006f;   % 688: 		j CONTINUE_LEAVE_DOOR_ANIMATION %
00001a10 : 00031283;   % 691: 		lh t0,0(t1)   # Gets player's current X related to screen %
00001a11 : 00531123;   % 692: 		sh t0,2(t1)   # Stores it on old X %
00001a12 : 00428293;   % 694: 		addi t0,t0,4  # Adds 4 to player's X %
00001a13 : 00531023;   % 695: 		sh t0,0(t1)   # Stores new X %
00001a14 : 0fc0c297;   % 697: 		la t0, MOVE_X  # Loads MOVE_X %
00001a15 : 8dc28293;   % 697:  %
00001a16 : 00100313;   % 698: 		li t1,1        # Loads direction (right) %
00001a17 : 00628023;   % 699: 		sb t1,0(t0)    # Stores on MOVE_X %
00001a18 : 00000317;   % 700: 		call UPDATE_STATUS      # Updates player's sprite status %
00001a19 : 104300e7;   % 700:  %
00001a1a : 00000513;   % 702: 		li a0, 0     # Rendering player operation %
00001a1b : 00000593;   % 703: 		li a1, 0     # Rendering full player %
00001a1c : ffffb317;   % 704: 		call RENDER_PLAYER %
00001a1d : 1e8300e7;   % 704:  %
00001a1e : ffffc317;   % 707: 	call RENDER_DOOR_FRAMES %
00001a1f : 884300e7;   % 707:  %
00001a20 : ff2002b7;   % 710: 	li t0,0xFF200604	# Loads Bitmap Display address %
00001a21 : 60428293;   % 710:  %
00001a22 : 0082a023;   % 711: 	sw s0,0(t0)         # Stores new frame value (from s0) on Bitmap Display %
00001a23 : 00100513;   % 713: 	li a0, 1     # Rendering player's trail operation %
00001a24 : 00000593;   % 714: 	li a1, 0     # Rendering full player (a1 doesn't really matter when a0 = 1) %
00001a25 : ffffb317;   % 715: 	call RENDER_PLAYER %
00001a26 : 1c4300e7;   % 715:  %
00001a27 : ffffb317;   % 717: 	call RENDER_UI %
00001a28 : 55c300e7;   % 717:  %
00001a29 : 0fc0c297;   % 722: 	la t0, CURRENT_MAP   # Loads CURRENT_MAP's address %
00001a2a : 85c28293;   % 722:  %
00001a2b : 0fc0c317;   % 723: 	la t1, PLYR_POS   # Loads PLYR_POS's address	 %
00001a2c : 86e30313;   % 723:  %
00001a2d : 00b2c383;   % 724: 	lbu t2,11(t0)        # Loads switch direction %
00001a2e : 02038e63;   % 725: 	beqz t2, LEAVE_DOOR_ANIMATION_NEXT_ON_RIGHT_2 # If next map is on the right, go to LEAVE_DOOR_ANIMATION_NEXT_ON_RIGHT_2 %
00001a2f : 00031e03;   % 727: 		lh t3,0(t1)           # Gets player's current X related to screen %
00001a30 : 14000293;   % 728: 		li t0,320    # Loads 320 (screen width in pixels) %
00001a31 : 01000393;   % 729: 		li t2,16       # Loads 16 (tile size) %
00001a32 : 407282b3;   % 730: 		sub t0,t0,t2          # t0 = 304 %
00001a33 : 407282b3;   % 731: 		sub t0,t0,t2          # t0 = 288 %
00001a34 : ff828293;   % 732: 		addi t0,t0,-8	      # Player should have an offset of 8 %
00001a35 : 05c29663;   % 733: 		bne t0,t3,CONTINUE_LEAVE_DOOR_ANIMATION_2  # If player's current X != 280, continue loop %
00001a36 : 00800393;   % 735: 			li t2,8           # Loads 8 for player's X offset %
00001a37 : 00730323;   % 736: 			sb t2,6(t1)       # and stores it %
00001a38 : 00834383;   % 737: 			lbu t2,8(t1)      # Gets player's current X related to matrix %
00001a39 : ffe38393;   % 738: 			addi t2,t2,-2     # subtracts 1 from it %
00001a3a : 00730423;   % 739: 			sb t2,8(t1)       # and stores it back %
00001a3b : 007304a3;   % 740: 			sb t2,9(t1)       # as well as storing on old X %
00001a3c : 0380006f;   % 741: 			j END_LEAVE_DOOR_ANIMATION  # Finish procedure  %
00001a3d : 00031383;   % 745: 		lh t2,0(t1)           # Gets player's current X related to screen %
00001a3e : 01000e13;   % 746: 		li t3,16       # Loads 16 (tile size) %
00001a3f : 008e0e13;   % 747: 		addi t3,t3,8          # Player should have an offset of 8 %
00001a40 : 027e1063;   % 748: 		bne t3,t2,CONTINUE_LEAVE_DOOR_ANIMATION_2  # If player's current X != 16, continue loop %
00001a41 : 00800293;   % 750: 			li t0,8           # Loads 8 for player's X offset %
00001a42 : 00530323;   % 751: 			sb t0,6(t1)       # and stores it %
00001a43 : 00834383;   % 752: 			lbu t2,8(t1)      # Gets player's current X related to matrix %
00001a44 : 00138393;   % 753: 			addi t2,t2,1      # adds 1 to it %
00001a45 : 00730423;   % 754: 			sb t2,8(t1)       # and stores it back %
00001a46 : 007304a3;   % 755: 			sb t2,9(t1)       # as well as storing on old X %
00001a47 : 00c0006f;   % 756: 			j END_LEAVE_DOOR_ANIMATION  # Finish procedure  %
00001a48 : c01024f3;   % 759: 		csrr s1,3073    # new time is stored in s1, in order to be compared later		 %
00001a49 : e9dff06f;   % 760: 		j LEAVE_DOOR_ANIMATION	# Returns to beginning of loop %
00001a4a : 0fc0b317;   % 764: 		la t1,NEXT_MAP %
00001a4b : 7e430313;   % 764:  %
00001a4c : 00934303;   % 765: 		lbu t1,9(t1)     # loads "next door"'s number %
00001a4d : 00231313;   % 766: 		slli t1,t1,2     # multiplies it by 4 %
00001a4e : 0fc0c517;   % 767: 		la a0, Doors     # Gets Doors address %
00001a4f : b5450513;   % 767:  %
00001a50 : 00052503;   % 768: 		lw a0,0(a0)      # gets current map's doors address %
00001a51 : 00150513;   % 769: 		addi a0,a0,1     # skips number of doors %
00001a52 : 00650533;   % 770: 		add a0,a0,t1     # and adds t1 to get the correct door's address %
00001a53 : 00100393;   % 771: 		li t2,1             # Loads 1 (opening/closing) %
00001a54 : 00750123;   % 772: 		sb t2,2(a0)         # and stores it on door's state byte     %
00001a55 : 00400393;   % 773: 		li t2,4  # Gets new counter (related to closing door -- positive, in order to close) %
00001a56 : 007501a3;   % 774: 		sb t2,3(a0)         # and stores it on door's counter byte %
00001a57 : c01024f3;   % 776: 		csrr s1,3073      # new time is stored in s1, in order to be compared later		 %
00001a58 : ee8f906f;   % 777: 		j GAME_LOOP       # go to GAME_LOOP   %
00001a59 : 0fc0b297;   % 11:     la t0,PLYR_INFO %
00001a5a : 7b428293;   % 11:  %
00001a5b : 00028283;   % 12:     lb t0,0(t0) %
00001a5c : 00504a63;   % 13:     blt zero,t0,END_CHECK_LIFE   # If player is alive %
00001a5d : 2440006f;   % 15:     j DEATH_LOOP_PREP %
00001a5e : 00300913;   % 16:         li s2,3 %
00001a5f : c01024f3;   % 17:         csrr s1,3073 %
00001a60 : e71f906f;   % 18:         j SETUP %
00001a61 : 0fc0b297;   % 25:     la t0,PLYR_STATUS  # Loads Player Status %
00001a62 : 7a228293;   % 25:  %
00001a63 : 00428303;   % 26:     lb t1, 4(t0)       # Loads Ball Byte  %
00001a64 : 00031463;   % 27:     bnez t1, UPDATE_PLAYER_SPRITE_BALL # If player is on morph ball (t1 != 0), go to UPDATE_BALL_SPRITE %
00001a65 : 0500006f;   % 28:     j UPDATE_PLAYER_SPRITE_STANDING    # Otherwise, go to CHECK_VERTICAL_MOV %
00001a66 : 0012c303;   % 32:         lbu t1, 1(t0)                    # Loads player's facing direction into t1 %
00001a67 : 00031463;   % 33:         bnez t1, UPDATE_PLAYER_SPRITE_BALL_LEFT # If player is looking left, go to UPDATE_PLAYER_SPRITE_BALL_LEFT %
00001a68 : 0240006f;   % 34:         j UPDATE_PLAYER_SPRITE_BALL_RIGHT       # otherwise, go to UPDATE_PLAYER_SPRITE_BALL_RIGHT %
00001a69 : 0002c303;   % 38:             lbu t1, 0(t0)  # Loads sprite number %
00001a6a : 00030863;   % 39:             beqz t1, UPDATE_PLAYER_SPRITE_BALL_LEFT_RESET   # If sprite arrived at 0 %
00001a6b : fff30313;   % 41:                 addi t1,t1,-1  # Decrements sprite number %
00001a6c : 00628023;   % 42:                 sb t1, 0(t0)   # and stores it %
00001a6d : 0700006f;   % 43:                 j END_UPDATE_PLAYER_SPRITE %
00001a6e : 00300313;   % 46:                 li t1,3        # Loads new sprite status %
00001a6f : 00628023;   % 47:                 sb t1, 0(t0)  # and stores it %
00001a70 : 0640006f;   % 48:                 j END_UPDATE_PLAYER_SPRITE %
00001a71 : 0002c303;   % 52:             lbu t1, 0(t0)  # Loads sprite number %
00001a72 : 00300393;   % 53:             li t2,3        # loads upper threshold %
00001a73 : 00730863;   % 54:             beq t1,t2, UPDATE_PLAYER_SPRITE_BALL_RIGHT_RESET   # If sprite arrived at 3 %
00001a74 : 00130313;   % 56:                 addi t1,t1,1   # Increments sprite number %
00001a75 : 00628023;   % 57:                 sb t1, 0(t0)   # and stores it %
00001a76 : 04c0006f;   % 58:                 j END_UPDATE_PLAYER_SPRITE %
00001a77 : 00028023;   % 61:                 sb zero, 0(t0)  # Stores 0 on sprite status %
00001a78 : 0440006f;   % 62:                 j END_UPDATE_PLAYER_SPRITE %
00001a79 : 0072c303;   % 65:         lbu t1, 7(t0) # Loads MOVE_Y to t1 %
00001a7a : 00030663;   % 66:         beqz t1, UPDATE_PLAYER_SPRITE_STANDING_CHECK_HORIZONTAL_MOV  %
00001a7b : 00028023;   % 68:             sb zero, 0(t0)  # Stores 0 on sprite status %
00001a7c : 0340006f;   % 69:             j END_UPDATE_PLAYER_SPRITE %
00001a7d : 0062c303;   % 72:             lbu t1,6(t0)  # Loads Move X to t1 %
00001a7e : 00031663;   % 73:             bnez t1, UPDATE_PLAYER_SPRITE_STANDING_HORIZONTAL_MOV %
00001a7f : 00028023;   % 75:                 sb zero, 0(t0)  # Stores 0 on sprite status %
00001a80 : 0240006f;   % 76:                 j END_UPDATE_PLAYER_SPRITE %
00001a81 : 0002c303;   % 80:             lbu t1, 0(t0)  # Loads sprite number %
00001a82 : 00200393;   % 81:             li t2,2        # loads upper threshold %
00001a83 : 00730863;   % 82:             beq t1,t2, UPDATE_PLAYER_SPRITE_STANDING_HORIZONTAL_MOV_RESET   # If sprite arrived at 2 %
00001a84 : 00130313;   % 84:                 addi t1,t1,1   # Increments sprite number %
00001a85 : 00628023;   % 85:                 sb t1, 0(t0)   # and stores it %
00001a86 : 00c0006f;   % 86:                 j END_UPDATE_PLAYER_SPRITE %
00001a87 : 00028023;   % 89:                 sb zero, 0(t0)  # Stores 0 on sprite status %
00001a88 : 0040006f;   % 90:                 j END_UPDATE_PLAYER_SPRITE %
00001a89 : 0fc0b317;   % 98:         la t1, PLYR_INFO_2	 # Loads address of the second part of PLYR_INFO %
00001a8a : 70c30313;   % 98:  %
00001a8b : 00534283;   % 99:         lbu t0,5(t1)         # and damage cooldown %
00001a8c : 00028a63;   % 100:         beqz t0,UPDATE_PLAYER_STATUS_DAMAGE_MOVE_X  # If it's on 0, don't update it %
00001a8d : fff28293;   % 102:             addi t0,t0,-1    # decrements it %
00001a8e : 005302a3;   % 103:             sb t0,5(t1)      # and stores it back %
00001a8f : 00029463;   % 104:             bnez t0,UPDATE_PLAYER_STATUS_DAMAGE_MOVE_X # If it didn't reach 0,  %
00001a90 : 000301a3;   % 106:                 sb zero,3(t1) %
00001a91 : 00634283;   % 110:         lbu t0,6(t1)   # Loads knockback cooldown %
00001a92 : 00028a63;   % 111:         beqz t0,UPDATE_PLAYER_STATUS_ATTACK_COOLDOWN  # If it's on 0, don't update it %
00001a93 : fff28293;   % 113:             addi t0,t0,-1    # decrements it %
00001a94 : 00530323;   % 114:             sb t0,6(t1)      # and stores it back %
00001a95 : 00504463;   % 115:             bgt t0,zero,UPDATE_PLAYER_STATUS_ATTACK_COOLDOWN # If it didn't reach 0,  %
00001a96 : 00030223;   % 117:                 sb zero,4(t1)    %
00001a97 : 0fc0b317;   % 120:         la t1, BEAMS_ARRAY     # Loads BEAMS array %
00001a98 : 70230313;   % 120:  %
00001a99 : 00034283;   % 121:         lbu t0,0(t1)           # And the attack cooldown byte %
00001a9a : 00028663;   % 122:         beqz t0,UPDATE_PLAYER_STATUS_BOMB_COOLDOWN  # If it's on 0, don't update it %
00001a9b : fff28293;   % 124:             addi t0,t0,-1    # decrements it %
00001a9c : 00530023;   % 125:             sb t0,0(t1)      # and stores it back %
00001a9d : 0fc0b317;   % 128:         la t1, BOMBS_ARRAY     # Loads BOMBS array %
00001a9e : 70630313;   % 128:  %
00001a9f : 00034283;   % 129:         lbu t0,0(t1)           # And the attack cooldown byte %
00001aa0 : 00028663;   % 130:         beqz t0,END_UPDATE_PLAYER_STATUS  # If it's on 0, don't update it %
00001aa1 : fff28293;   % 132:             addi t0,t0,-1    # decrements it %
00001aa2 : 00530023;   % 133:             sb t0,0(t1)      # and stores it back %
00001aa3 : 00008067;   % 142:     ret     %
00001aa4 : 00100313;   % 148:         li t1, 1      # Loads morph ball mode (1 = enabled) %
00001aa5 : 00650223;   % 149:         sb t1, 4(a0)  # Stores new direction on PLYR_STATUS %
00001aa6 : 00008067;   % 150:         ret %
00001aa7 : fff00313;   % 153:     li t1, -1     # Loads direction for MOVE_Y (-1 = up) %
00001aa8 : 006503a3;   % 154:     sb t1, 7(a0)  # Stores new direction on MOVE_Y %
00001aa9 : 0fc0b517;   % 157:     la a0, MOVE_Y %
00001aaa : 68950513;   % 157:  %
00001aab : 0fc0b597;   % 158:     la a1, CURRENT_MAP %
00001aac : 65458593;   % 158:  %
00001aad : 0005a583;   % 159:     lw a1, 0(a1) %
00001aae : 0fc0b617;   % 160:     la a2, PLYR_POS %
00001aaf : 66260613;   % 160:  %
00001ab0 : 00000693;   % 161:     li a3, 0 %
00001ab1 : 00100db3;   % 164:     mv s11, ra # storing return address in s11 %
00001ab2 : 00000317;   % 165:     call CHECK_VERTICAL_COLLISION %
00001ab3 : 594300e7;   % 165:  %
00001ab4 : 01b000b3;   % 166:     mv ra, s11 # loading return address from s11 %
00001ab5 : 0fc0b297;   % 168:     la t0, PLYR_STATUS      # Loads Player Status %
00001ab6 : 65228293;   % 168:  %
00001ab7 : 00050463;   % 169:     beqz a0, END_OUT_OF_MORPH_BALL %
00001ab8 : 00028223;   % 170:         sb zero, 4(t0) # key = up ? ball = 0  %
00001ab9 : 00100313;   % 172:         li t1,1       # Sets MOVE_Y to 1 (falling) so that player is placed on the ground correctly %
00001aba : 005283a3;   % 173:         sb t0, 7(t0)  # Stores new direction on MOVE_Y %
00001abb : 00008067;   % 174:         ret %
00001abc : 00a00233;   % 196:     mv tp, a0 # Moves whether it was damage from input (1 - Cheat) or from enemy (0) %
00001abd : 00b00f33;   % 197:     mv t5, a1 %
00001abe : 0fc0b517;   % 199:     la a0, PLYR_INFO_2	 # Loads address of the second part of PLYR_INFO %
00001abf : 63850513;   % 199:  %
00001ac0 : 00354283;   % 200:     lbu t0,3(a0)         # Loads taking damage byte %
00001ac1 : 00028463;   % 201:     beqz t0,DAMAGE_PLAYER_START   # If not taking damage, do it %
00001ac2 : 0ac0006f;   % 202:         j END_DAMAGE_PLAYER       # Otherwise, player is invincible, end procedure %
00001ac3 : 00100293;   % 205:         li t0,1        # Taking damage == True %
00001ac4 : 005501a3;   % 206:         sb t0,3(a0)    # stores taking damage byte %
00001ac5 : 01400293;   % 208:         li t0,20  # Loads number of invincibility frames %
00001ac6 : 005502a3;   % 209:         sb t0,5(a0)           # and stores it %
00001ac7 : 01400293;   % 211:         li t0,20  # Loads number of invincibility frames %
00001ac8 : 00550323;   % 212:         sb t0,6(a0)           # and stores it %
00001ac9 : 0fc0b317;   % 214:         la t1, MOVE_Y	# Loads address of the second part of PLYR_INFO %
00001aca : 60930313;   % 214:  %
00001acb : fff00293;   % 215:         li t0, -1       # Loads direction for MOVE_Y (-1 = up) %
00001acc : 00530023;   % 216:         sb t0, 0(t1)    # Stores new direction on MOVE_Y %
00001acd : 000300a3;   % 217:         sb zero,1(t1)   # Resets jump counter %
00001ace : ffd00293;   % 220:         li t0,-3 # Jumping value for damage %
00001acf : d002f953;   % 221:         fcvt.s.w fs2,t0   # Sets fs2 (player's Y speed) to -3 %
00001ad0 : 00300293;   % 223:         li t0,3 %
00001ad1 : 00560663;   % 224:         beq a2,t0,DAMAGE_PLAYER_RANDOMIZE %
00001ad2 : 00200293;   % 225:         li t0,2 %
00001ad3 : 00429a63;   % 226:         bne t0,tp,DAMAGE_PLAYER_CHECK_DIRECTION %
00001ad4 : 00200593;   % 229:             li a1,2                  # Range %
00001ad5 : 08e00893;   % 230:             li a7,142  # random integer within range ecall %
00001ad6 : 00000073;   % 231:             ecall %
00001ad7 : 00a00633;   % 232:             mv a2,a0   # Moves result to a2 and starts checking direction %
00001ad8 : 00061663;   % 234:             bnez a2,DAMAGE_PLAYER_CHECK_LEFT %
00001ad9 : ffc00293;   % 236:                 li t0,-4 %
00001ada : 01c0006f;   % 237:                 j DAMAGE_PLAYER_DIRECTION %
00001adb : 00100293;   % 239:             DAMAGE_PLAYER_CHECK_LEFT: li t0,1 %
00001adc : 00c29663;   % 240:             bne t0,a2,DAMAGE_PLAYER_SAME_X %
00001add : 00400293;   % 242:                 li t0,4 %
00001ade : 00c0006f;   % 243:                 j DAMAGE_PLAYER_DIRECTION %
00001adf : 00000293;   % 247:                 li t0,0 %
00001ae0 : 0040006f;   % 248:                 j DAMAGE_PLAYER_DIRECTION %
00001ae1 : 0fc0b517;   % 251:                 la a0, PLYR_INFO_2	 # Loads address of the second part of PLYR_INFO  %
00001ae2 : 5ac50513;   % 251:  %
00001ae3 : 00550223;   % 252:                 sb t0, 4(a0)    # Stores new direction on DAMAGE_MOVE_X %
00001ae4 : 0fc0b297;   % 257:         la t0,PLYR_INFO_2 %
00001ae5 : 5a028293;   % 257:  %
00001ae6 : 0002c283;   % 258:         lbu t0,0(t0) %
00001ae7 : 00029c63;   % 259:         bnez t0,END_DAMAGE_PLAYER %
00001ae8 : 0fc0b297;   % 260:             la t0,PLYR_INFO  # Loads PLYR_INFO %
00001ae9 : 57828293;   % 260:  %
00001aea : 0002c303;   % 261:             lbu t1,0(t0)     # and player's health %
00001aeb : 41e30333;   % 262:             sub t1,t1,t5     # takes away hp %
00001aec : 00628023;   % 263:             sb t1,0(t0)      # and stores it back %
00001aed : 00008067;   % 266:     ret %
00001aee : 0fc0b297;   % 281: 	la t0, PLYR_POS %
00001aef : 56228293;   % 281:  %
00001af0 : 0002d383;   % 282: 	lhu t2,0(t0)           # Loads Player's X %
00001af1 : 0042ce03;   % 283: 	lbu t3,4(t0)           # Loads Player's Y %
00001af2 : 0fc0b317;   % 285: 	la t1, DEATH_1E_POS    # Loads  %
00001af3 : 57830313;   % 285:  %
00001af4 : 00731023;   % 286: 	sh t2,0(t1) %
00001af5 : 01c31123;   % 287: 	sh t3,2(t1) %
00001af6 : ff800e93;   % 288: 	li t4,-8 %
00001af7 : d00ef053;   % 289: 	fcvt.s.w ft0 ,t4 %
00001af8 : 0fc0b317;   % 291: 	la t1, DEATH_2E_POS    # Loads  %
00001af9 : 56430313;   % 291:  %
00001afa : 00731023;   % 292: 	sh t2,0(t1) %
00001afb : 008e0e93;   % 293: 	addi t4,t3,8 %
00001afc : 01d31123;   % 294: 	sh t4,2(t1) %
00001afd : ffb00e93;   % 295: 	li t4,-5 %
00001afe : d00ef053;   % 296: 	fcvt.s.w ft0 ,t4 %
00001aff : 0fc0b317;   % 298: 	la t1, DEATH_3E_POS    # Loads  %
00001b00 : 54c30313;   % 298:  %
00001b01 : 00731023;   % 299: 	sh t2,0(t1) %
00001b02 : 010e0e93;   % 300: 	addi t4,t3,16 %
00001b03 : 01d31123;   % 301: 	sh t4,2(t1) %
00001b04 : ffd00e93;   % 302: 	li t4,-3 %
00001b05 : d00ef053;   % 303: 	fcvt.s.w ft0 ,t4 %
00001b06 : 0fc0b317;   % 305: 	la t1, DEATH_1D_POS    # Loads  %
00001b07 : 53430313;   % 305:  %
00001b08 : 00838e93;   % 306: 	addi t4,t2,8 %
00001b09 : 01d31023;   % 307: 	sh t4,0(t1) %
00001b0a : 01c31123;   % 308: 	sh t3,2(t1) %
00001b0b : ff800e93;   % 309: 	li t4,-8 %
00001b0c : d00ef053;   % 310: 	fcvt.s.w ft0 ,t4 %
00001b0d : 0fc0b317;   % 312: 	la t1, DEATH_2D_POS    # Loads  %
00001b0e : 51c30313;   % 312:  %
00001b0f : 00838e93;   % 313: 	addi t4,t2,8 %
00001b10 : 01d31023;   % 314: 	sh t4,0(t1) %
00001b11 : 008e0e93;   % 315: 	addi t4,t3,8 %
00001b12 : 01d31123;   % 316: 	sh t4,2(t1) %
00001b13 : ffb00e93;   % 317: 	li t4,-5 %
00001b14 : d00ef053;   % 318: 	fcvt.s.w ft0 ,t4 %
00001b15 : 0fc0b317;   % 320: 	la t1, DEATH_3D_POS    # Loads  %
00001b16 : 50030313;   % 320:  %
00001b17 : 00838e93;   % 321: 	addi t4,t2,8 %
00001b18 : 01d31023;   % 322: 	sh t4,0(t1) %
00001b19 : 010e0e93;   % 323: 	addi t4,t3,16 %
00001b1a : 01d31123;   % 324: 	sh t4,2(t1) %
00001b1b : ffd00e93;   % 325: 	li t4,-3 %
00001b1c : d00ef053;   % 326: 	fcvt.s.w ft0 ,t4 %
00001b1d : 00000a13;   % 328: 	li s4,0         #   Counter %
00001b1e : 00000a93;   % 329: 	li s5,0 %
00001b1f : c0102573;   % 333:     csrr a0,3073 %
00001b20 : 40950533;   % 334:     sub a0, a0, s1          # a0 = current time - last frame's time %
00001b21 : 03200293;   % 335:     li t0, 50	    # Loads frame rate (time (in ms) per frame) %
00001b22 : fe556ae3;   % 336:     bltu a0,t0, DEATH_LOOP  # While a0 < minimum time for a frame, keep looping  %
00001b23 : 00144413;   % 339:     xori s0,s0,1		    # Switches frame value (register) %
00001b24 : ffffa317;   % 341: 	call UPDATE_DOORS       # Updates doors %
00001b25 : 514300e7;   % 341:  %
00001b26 : fffff317;   % 342: 	call MAP_MOVE_RENDER    # Renders map when necessary %
00001b27 : 374300e7;   % 342:  %
00001b28 : ffffc317;   % 344: 	call MARU_MARI_OPERATIONS %
00001b29 : edc300e7;   % 344:  %
00001b2a : ffffc317;   % 346: 	call BOMB_POWER_OPERATIONS %
00001b2b : fb8300e7;   % 346:  %
00001b2c : ffffc317;   % 348: 	call ITEM_CAPSULE_OPERATIONS %
00001b2d : 08c300e7;   % 348:  %
00001b2e : 00000513;   % 350: 	li a0,0 %
00001b2f : ffffc317;   % 351: 	call ENEMY_OPERATIONS %
00001b30 : 5dc300e7;   % 351:  %
00001b31 : ffffc317;   % 353: 	call BEAMS_OPERATIONS %
00001b32 : b4c300e7;   % 353:  %
00001b33 : 0fc0b317;   % 356: 	la t1, DEATH_1E_POS    # Loads  %
00001b34 : 47430313;   % 356:  %
00001b35 : 0fc19517;   % 357: 	la a0, Death_E1 %
00001b36 : ea850513;   % 357:  %
00001b37 : 00035583;   % 358: 	lhu a1,0(t1) %
00001b38 : 00235603;   % 359: 	lhu a2,2(t1) %
00001b39 : ff658393;   % 361: 	addi t2,a1,-10 %
00001b3a : 00807053;   % 362: 	fadd.s ft0,ft0,fs0    # ft0 = Death Sprite's current Y speed + gravity factor        %
00001b3b : c0007e53;   % 363:     fcvt.w.s t3,ft0       # Sets t3 = floor(ft0) %
00001b3c : 01c60e33;   % 364: 	add t3,a2,t3  %
00001b3d : 00731023;   % 365: 	sh t2,0(t1) %
00001b3e : 01c31123;   % 366: 	sh t3,2(t1) %
00001b3f : 00800693;   % 368: 	li a3,8 %
00001b40 : 00800713;   % 369: 	li a4,8 %
00001b41 : 008007b3;   % 370: 	mv a5,s0 %
00001b42 : 01500833;   % 371: 	mv a6,s5 %
00001b43 : 001a8a93;   % 372: 	addi s5,s5,1 %
00001b44 : 00300293;   % 373: 	li t0,3 %
00001b45 : 005ac463;   % 374: 	blt s5,t0,SKIP_STATUS_CORRECTION_1E %
00001b46 : 00000a93;   % 375: 		li s5,0 %
00001b47 : 00000893;   % 377: 	li a7,0 %
00001b48 : ffffb317;   % 379: 	call RENDER %
00001b49 : b74300e7;   % 379:  %
00001b4a : 0fc0b317;   % 381: 	la t1, DEATH_2E_POS    # Loads  %
00001b4b : 41c30313;   % 381:  %
00001b4c : 0fc19517;   % 382: 	la a0, Death_E2 %
00001b4d : f4c50513;   % 382:  %
00001b4e : 00035583;   % 383: 	lhu a1,0(t1) %
00001b4f : 00235603;   % 384: 	lhu a2,2(t1) %
00001b50 : ff658393;   % 386: 	addi t2,a1,-10 %
00001b51 : 0080f0d3;   % 387: 	fadd.s ft1,ft1,fs0    # ft1 = Death Sprite's current Y speed + gravity factor        %
00001b52 : c000fe53;   % 388:     fcvt.w.s t3,ft1       # Sets t3 = floor(ft0) %
00001b53 : 01c60e33;   % 389: 	add t3,a2,t3  %
00001b54 : 00731023;   % 390: 	sh t2,0(t1) %
00001b55 : 01c31123;   % 391: 	sh t3,2(t1) %
00001b56 : 00800693;   % 393: 	li a3,8 %
00001b57 : 00800713;   % 394: 	li a4,8 %
00001b58 : 008007b3;   % 395: 	mv a5,s0 %
00001b59 : 00400293;   % 396: 	li t0,4 %
00001b5a : 01400833;   % 397: 	mv a6,s4 %
00001b5b : 005a4463;   % 398: 	blt s4,t0,SKIP_STATUS_CORRECTION_2E %
00001b5c : ffc80813;   % 399: 		addi a6,a6,-4 %
00001b5d : 00000893;   % 401: 	li a7,0 %
00001b5e : ffffb317;   % 403: 	call RENDER %
00001b5f : b1c300e7;   % 403:  %
00001b60 : 0fc0b317;   % 405: 	la t1, DEATH_3E_POS    # Loads %
00001b61 : 3c830313;   % 405:  %
00001b62 : 0fc19517;   % 406: 	la a0, Death_E3  %
00001b63 : ff450513;   % 406:  %
00001b64 : 00035583;   % 407: 	lhu a1,0(t1) %
00001b65 : 00235603;   % 408: 	lhu a2,2(t1) %
00001b66 : ff658393;   % 410: 	addi t2,a1,-10 %
00001b67 : 00817153;   % 411: 	fadd.s ft2,ft2,fs0    # ft0 = Death Sprite's current Y speed + gravity factor        %
00001b68 : c0017e53;   % 412:     fcvt.w.s t3,ft2       # Sets t3 = floor(ft0) %
00001b69 : 01c60e33;   % 413: 	add t3,a2,t3  %
00001b6a : 00731023;   % 414: 	sh t2,0(t1) %
00001b6b : 01c31123;   % 415: 	sh t3,2(t1) %
00001b6c : 00800693;   % 417: 	li a3,8 %
00001b6d : 00800713;   % 418: 	li a4,8 %
00001b6e : 008007b3;   % 419: 	mv a5,s0 %
00001b6f : 00400293;   % 420: 	li t0,4 %
00001b70 : 01400833;   % 421: 	mv a6,s4 %
00001b71 : 005a4463;   % 422: 	blt s4,t0,SKIP_STATUS_CORRECTION_3E %
00001b72 : ffc80813;   % 423: 		addi a6,a6,-4 %
00001b73 : 00000893;   % 425: 	li a7,0 %
00001b74 : ffffb317;   % 427: 	call RENDER %
00001b75 : ac4300e7;   % 427:  %
00001b76 : 0fc0b317;   % 429: 	la t1, DEATH_1D_POS    # Loads  %
00001b77 : 37430313;   % 429:  %
00001b78 : 0fc19517;   % 430: 	la a0, Death_D1 %
00001b79 : 09c50513;   % 430:  %
00001b7a : 00035583;   % 431: 	lhu a1,0(t1) %
00001b7b : 00235603;   % 432: 	lhu a2,2(t1) %
00001b7c : 00a58393;   % 434: 	addi t2,a1,10 %
00001b7d : 0081f1d3;   % 435: 	fadd.s ft3,ft3,fs0    # ft3 = Death Sprite's current Y speed + gravity factor        %
00001b7e : c001fe53;   % 436:     fcvt.w.s t3,ft3       # Sets t3 = floor(ft3) %
00001b7f : 01c60e33;   % 437: 	add t3,a2,t3  %
00001b80 : 00731023;   % 438: 	sh t2,0(t1) %
00001b81 : 01c31123;   % 439: 	sh t3,2(t1) %
00001b82 : 00800693;   % 441: 	li a3,8 %
00001b83 : 00800713;   % 442: 	li a4,8 %
00001b84 : 008007b3;   % 443: 	mv a5,s0 %
00001b85 : 00400293;   % 444: 	li t0,4 %
00001b86 : 01400833;   % 445: 	mv a6,s4 %
00001b87 : 005a4463;   % 446: 	blt s4,t0,SKIP_STATUS_CORRECTION_1D %
00001b88 : ffc80813;   % 447: 		addi a6,a6,-4 %
00001b89 : 00000893;   % 449: 	li a7,0 %
00001b8a : ffffb317;   % 451: 	call RENDER %
00001b8b : a6c300e7;   % 451:  %
00001b8c : 0fc0b317;   % 453: 	la t1, DEATH_2D_POS    # Loads  %
00001b8d : 32030313;   % 453:  %
00001b8e : 0fc19517;   % 454: 	la a0, Death_D2 %
00001b8f : 14450513;   % 454:  %
00001b90 : 00035583;   % 455: 	lhu a1,0(t1) %
00001b91 : 00235603;   % 456: 	lhu a2,2(t1) %
00001b92 : 00a58393;   % 458: 	addi t2,a1,10 %
00001b93 : 00827253;   % 459: 	fadd.s ft4,ft4,fs0    # ft4 = Death Sprite's current Y speed + gravity factor        %
00001b94 : c0027e53;   % 460:     fcvt.w.s t3,ft4       # Sets t3 = floor(ft4) %
00001b95 : 01c60e33;   % 461: 	add t3,a2,t3  %
00001b96 : 00731023;   % 462: 	sh t2,0(t1) %
00001b97 : 01c31123;   % 463: 	sh t3,2(t1) %
00001b98 : 00800693;   % 465: 	li a3,8 %
00001b99 : 00800713;   % 466: 	li a4,8 %
00001b9a : 008007b3;   % 467: 	mv a5,s0 %
00001b9b : 00400293;   % 468: 	li t0,4 %
00001b9c : 01400833;   % 469: 	mv a6,s4 %
00001b9d : 005a4463;   % 470: 	blt s4,t0,SKIP_STATUS_CORRECTION_2D %
00001b9e : ffc80813;   % 471: 		addi a6,a6,-4 %
00001b9f : 00000893;   % 473: 	li a7,0 %
00001ba0 : ffffb317;   % 475: 	call RENDER %
00001ba1 : a14300e7;   % 475:  %
00001ba2 : 0fc0b317;   % 477: 	la t1, DEATH_3D_POS    # Loads  %
00001ba3 : 2cc30313;   % 477:  %
00001ba4 : 0fc19517;   % 478: 	la a0, Death_D3 %
00001ba5 : 1ec50513;   % 478:  %
00001ba6 : 00035583;   % 479: 	lhu a1,0(t1) %
00001ba7 : 00235603;   % 480: 	lhu a2,2(t1) %
00001ba8 : 00a58393;   % 482: 	addi t2,a1,10 %
00001ba9 : 0082f2d3;   % 483: 	fadd.s ft5,ft5,fs0    # ft5 = Death Sprite's current Y speed + gravity factor        %
00001baa : c002fe53;   % 484:     fcvt.w.s t3,ft5       # Sets t3 = floor(ft5) %
00001bab : 01c60e33;   % 485: 	add t3,a2,t3  %
00001bac : 00731023;   % 486: 	sh t2,0(t1) %
00001bad : 01c31123;   % 487: 	sh t3,2(t1) %
00001bae : 00800693;   % 489: 	li a3,8 %
00001baf : 00800713;   % 490: 	li a4,8 %
00001bb0 : 008007b3;   % 491: 	mv a5,s0 %
00001bb1 : 00400293;   % 492: 	li t0,4 %
00001bb2 : 01400833;   % 493: 	mv a6,s4 %
00001bb3 : 005a4463;   % 494: 	blt s4,t0,SKIP_STATUS_CORRECTION_3D %
00001bb4 : ffc80813;   % 495: 		addi a6,a6,-4 %
00001bb5 : 00000893;   % 497: 	li a7,0 %
00001bb6 : ffffb317;   % 499: 	call RENDER %
00001bb7 : 9bc300e7;   % 499:  %
00001bb8 : ffffc317;   % 501: 	call LOOT_OPERATIONS %
00001bb9 : fe0300e7;   % 501:  %
00001bba : ffffc317;   % 503: 	call BOMBS_OPERATIONS %
00001bbb : a9c300e7;   % 503:  %
00001bbc : ffffc317;   % 504: 	call EXPLOSIONS_OPERATIONS %
00001bbd : 170300e7;   % 504:  %
00001bbe : 00001317;   % 506: 	call BEAM_COLLISION  # Will see if beam hit an enemy %
00001bbf : 92c300e7;   % 506:  %
00001bc0 : 00000513;   % 508: 	li a0, 0     # Rendering UI operation %
00001bc1 : ffffb317;   % 509: 	call RENDER_UI	 %
00001bc2 : ef4300e7;   % 509:  %
00001bc3 : ff2002b7;   % 512: 	li t0,0xFF200604	# Loads Bitmap Display address %
00001bc4 : 60428293;   % 512:  %
00001bc5 : 0082a023;   % 513: 	sw s0,0(t0)         # Stores new frame value (from s0) on Bitmap Display %
00001bc6 : c01024f3;   % 515: 	csrr s1,3073        # New time is stored in s1, in order to be compared later		 %
00001bc7 : 001a0a13;   % 517: 	addi s4,s4,1 %
00001bc8 : 00600293;   % 518: 	li t0,6 %
00001bc9 : d45a4ce3;   % 519: 	blt s4,t0,DEATH_LOOP %
00001bca : 00300913;   % 520:         li s2,3 %
00001bcb : c01024f3;   % 521:         csrr s1,3073 %
00001bcc : 8c1f906f;   % 522:         j SETUP %
00001bcd : 00000213;   % 48:     li tp, 0  # Player check %
00001bce : 00c003b3;   % 49:     mv t2,a2  # Moves a2 to t2 %
00001bcf : 00200613;   % 50:     li a2, 2  # Base case: check 2 tiles horizontally (or 1 if on morph ball) %
00001bd0 : 00000693;   % 51:     li a3,0   # Sets for horizontal check  %
00001bd1 : 00000713;   % 52:     li a4,0   # Base case: ignore door %
00001bd2 : 0015c783;   % 53:     lbu a5,1(a1)   # Loads Map Matrix's width %
00001bd3 : 0083c803;   % 54:     lbu a6, 8(t2)  # a6 = Player's X related to matrix %
00001bd4 : 00a3c883;   % 55:     lbu a7, 10(t2) # a7 = Player's Y related to matrix %
00001bd5 : 00358593;   % 57:     addi a1,a1,3   # Adds 3 to the Matrix's address so that it goes to the beginning of matrix %
00001bd6 : 02f882b3;   % 58:     mul t0,a7,a5   # Player's Y related to matrix * Map Matrix's width %
00001bd7 : 005802b3;   % 59:     add t0,a6,t0   # t0 = Player's X related to matrix +  Player's Y related to matrix * Map Matrix's width   %
00001bd8 : 005585b3;   % 60:     add a1,a1,t0   # a1 = Map Matrix's address adjusted for Player's X and Y related to matrix %
00001bd9 : 0063ce03;   % 62:     lbu t3, 6(t2)  # t3 = Player's X offset %
00001bda : 00050283;   % 63:     lb t0, 0(a0)   # Loads MOVE_X information to t0 %
00001bdb : 00200513;   % 65:     li a0,2        # Sets a0 to 2 (check any type of door) %
00001bdc : 00029c63;   % 66:     bnez t0, CHECK_X_DIRECTION  # If player's not moving, end procedure  %
00001bdd : 0fc0b317;   % 67:     la t1, PLYR_INFO_2	   # Loads address of the second part of PLYR_INFO %
00001bde : 1bc30313;   % 67:  %
00001bdf : 00430303;   % 68:     lb t1,4(t1)            # Gets the DAMAGE_MOVE_X value %
00001be0 : 00031463;   % 69:     bnez t1, CHECK_X_DIRECTION  # If player's not moving, end procedure  %
00001be1 : 0d00006f;   % 70:     j END_HORIZONTAL_COLLISION  %
00001be2 : 0fc0b317;   % 74:         la t1, MOVE_Y # Loads MOVE_Y address %
00001be3 : 1a530313;   % 74:  %
00001be4 : 00030303;   % 75:         lb t1,0(t1)   # Loads MOVE_Y content %
00001be5 : 04030663;   % 76:         beqz t1, CONTINUE_CHECK_X_DIRECTION  # If MOVE_Y = 0, skip %
00001be6 : 02605863;   % 77:             bge zero,t1, UPWARDS_THIRD_CHECK # If MOVE_Y = 1 (down) continue %
00001be7 : 0fc0b317;   % 78:                 la t1, PLYR_POS    # Loads PLYR_POS address %
00001be8 : 17e30313;   % 78:  %
00001be9 : 00730303;   % 79:                 lb t1, 7(t1)       # Loads Y offset %
00001bea : 02030c63;   % 80:                 beqz t1 CONTINUE_CHECK_X_DIRECTION # If Y offset is zero, there's no need to check 3 tiles %
00001beb : 00e00e93;   % 81:                 li t4,14 %
00001bec : 01d35663;   % 82:                 bge t1,t4,DONWARDS_CHECK_2_BELLOW  # Instead of checking the two in front of samus, check two, but 1 tile bellow %
00001bed : 00160613;   % 83:                     addi a2,a2, 1  # Checks 3 tiles horizontally (or 2 if on morph ball) %
00001bee : 0280006f;   % 84:                     j CONTINUE_CHECK_X_DIRECTION %
00001bef : 00188893;   % 86:                     addi a7,a7,1 %
00001bf0 : 00b785b3;   % 87:                     add a1,a5, a1 %
00001bf1 : 01c0006f;   % 88:                     j CONTINUE_CHECK_X_DIRECTION %
00001bf2 : 0fc0b317;   % 90:                 la t1, PLYR_POS # Loads PLYR_POS address %
00001bf3 : 15230313;   % 90:  %
00001bf4 : 00730303;   % 91:                 lb t1, 7(t1)    # Loads Y offset %
00001bf5 : 00200f13;   % 92:                 li t5, 2        # Represents the desired offset %
00001bf6 : 006f5463;   % 93:                 bge t5, t1 CONTINUE_CHECK_X_DIRECTION # If Y offset is zero, there's no need to check 3 tiles %
00001bf7 : 00160613;   % 94:                     addi a2,a2, 1  # Checks 3 tiles horizontally (or 2 if on morph ball) %
00001bf8 : 0103c303;   % 97:         lbu t1,16(t2) # Loads Player's morph ball byte %
00001bf9 : 00030863;   % 98:         beqz t1,CONTINUE_CHECK_X_DIRECTION_2 # If player's not on morph ball %
00001bfa : fff60613;   % 99:         addi a2,a2,-1 # Morph ball requires one less iteration on horizontal check %
00001bfb : 00b785b3;   % 100:         add a1,a5,a1  # Increments width to player's y on matrix (checks only one tile in front of them) %
00001bfc : 00188893;   % 101:         addi a7,a7,1  # Increments current Y on matrix(+1 Y) %
00001bfd : 0002cc63;   % 104:         blt t0, zero, CHECK_X_LEFT # If player is moving left (t0 < 0), go to CHECK_X_LEFT %
00001bfe : 0fc0b297;   % 105:         la t0, PLYR_INFO_2	   # Loads address of the second part of PLYR_INFO %
00001bff : 13828293;   % 105:  %
00001c00 : 00428283;   % 106:         lb t0,4(t0)            # Gets the DAMAGE_MOVE_X value %
00001c01 : 0002c463;   % 107:         blt t0, zero, CHECK_X_LEFT # If player is moving left (t0 < 0), go to CHECK_X_LEFT %
00001c02 : 0240006f;   % 108:         j CHECK_X_RIGHT            # otherwise, go to CHECK_X_RIGHT %
00001c03 : 00c00293;   % 111:             li t0, 12    # Loads number 12 for comparing with X offset  %
00001c04 : 005e0a63;   % 112:             beq t3, t0, CONTINUE_CHECK_X_LEFT # If X offset is 12, continue checking %
00001c05 : ff828293;   % 113:             addi t0,t0, -8                    # Otherwise, compare with offset 4 %
00001c06 : 00200713;   % 114:             li a4,2      # Sets to check for only doors (if the next condition isn't met, it doesn' matter the value of a4) %
00001c07 : 005e0663;   % 115:             beq t3, t0, CONTINUE_CHECK_X_LEFT_DOOR # If X offset is 4, check for doors %
00001c08 : 0340006f;   % 116:             j END_HORIZONTAL_COLLISION             # Otherwise, stop %
00001c09 : 00000713;   % 119:                 li a4,0 # Sets to ignore doors %
00001c0a : 52d0106f;   % 121:                 j CHECK_MAP_COLLISION %
00001c0b : 00158593;   % 124:             addi a1,a1, 1 # Looks to the tile on the right of player's current tile %
00001c0c : 00180813;   % 125:             addi a6,a6,1  # Increments current X on matrix(+1 X) %
00001c0d : 00400293;   % 126:             li t0, 4      # Loads number 4 for comparing with X offset  %
00001c0e : 005e0a63;   % 127:             beq t3, t0, CONTINUE_CHECK_X_RIGHT # If X offset is 4, continue checking %
00001c0f : 00828293;   % 128:             addi t0,t0, 8                      # Otherwise, compare with offset 12 %
00001c10 : 00200713;   % 129:             li a4,2       # Sets to check for only doors (if the next condition isn't met, it doesn' matter the value of a4) %
00001c11 : 005e0663;   % 130:             beq t3, t0, CONTINUE_CHECK_X_RIGHT_DOOR # If X offset is 12, check for doors %
00001c12 : 00c0006f;   % 131:                 j END_HORIZONTAL_COLLISION  %
00001c13 : 00000713;   % 134:                 li a4,0 # Sets to ignore doors %
00001c14 : 5050106f;   % 136:                 j CHECK_MAP_COLLISION %
00001c15 : 00100513;   % 140:         li a0,1   %
00001c16 : 00008067;   % 141:         ret  %
00001c17 : 00c003b3;   % 173:     mv t2,a2  # Moves a2 to t2 %
00001c18 : 00d00233;   % 174:     mv tp,a3  # Moves a3 to tp %
00001c19 : 00100613;   % 175:     li a2,1   # Base case: check 1 tiles vertically %
00001c1a : 00100693;   % 176:     li a3,1   # Sets for horizontal check  %
00001c1b : 00000713;   % 177:     li a4,0   # Base case: ignore door %
00001c1c : 0015c783;   % 178:     lbu a5,1(a1)   # Loads Map Matrix's width %
00001c1d : 0083c803;   % 179:     lbu a6, 8(t2)  # a6 = Player's X related to matrix %
00001c1e : 00a3c883;   % 180:     lbu a7, 10(t2) # a7 = Player's Y related to matrix %
00001c1f : 00358593;   % 182:     addi a1,a1,3   # Adds 3 to the Matrix's address so that it goes to the beginning of matrix %
00001c20 : 02f882b3;   % 183:     mul t0,a7,a5   # Player's Y related to matrix * Map Matrix's width %
00001c21 : 005802b3;   % 184:     add t0,a6,t0   # t0 = Player's X related to matrix +  Player's Y related to matrix * Map Matrix's width   %
00001c22 : 005585b3;   % 185:     add a1,a1,t0   # a1 = Map Matrix's address adjusted for Player's X and Y related to matrix %
00001c23 : 0073ce03;   % 187:     lbu t3, 7(t2)  # t3 = Player's Y offset %
00001c24 : 00050283;   % 188:     lb t0, 0(a0) # Loads MOVE_Y to t0  %
00001c25 : 0002c463;   % 189:     blt t0,zero, CHECK_Y_UP # If t0 < 0, check up,  %
00001c26 : 0500006f;   % 190:     j CHECK_Y_DOWN          # otherwise check down %
00001c27 : 004e0e33;   % 194:         add t3,t3,tp     # current offset + offset modifier %
00001c28 : 01c05463;   % 195:         bge zero,t3 CONTINUE_CHECK_Y_UP # If current offset + offset modifier <= 0, continue checking %
00001c29 : 0d00006f;   % 196:         j END_VERTICAL_COLLISION    # otherwise, end procedure %
00001c2a : 0103c303;   % 200:             lbu t1,16(t2)  # Loads Player's morph ball byte %
00001c2b : 00031663;   % 201:             bnez t1, CONTINUE_CHECK_Y_UP2 # If player is on morph ball, don't update Y to be checked %
00001c2c : 40f585b3;   % 202:             sub a1,a1,a5   # If player isn't on morph ball, update Y one tile up (-1 matrix Y)  %
00001c2d : fff88893;   % 203:             addi a7,a7,-1  # Increments current Y on matrix(-1 Y) %
00001c2e : 0063ce03;   % 207:             lbu t3, 6(t2)  # t3 = Player's X offset %
00001c2f : 00800293;   % 208:             li t0, 8   # Loads number 8 for comparing with X offset  %
00001c30 : 005e4863;   % 209:             blt t3,t0, CHECK_Y_UP_ABOVE # If X offset < 8, just check one tile above %
00001c31 : 00c00293;   % 210:             li t0,12   # Loads number 12 for comparing with X offset  %
00001c32 : 005e5863;   % 211:             bge t3,t0, CHECK_Y_UP_TO_THE_RIGHT # If X offset >= 12, check one tile above to the right  %
00001c33 : 00200613;   % 212:             li a2,2    # If player's X offset = 8, check 2 tiles above the player (one above, the other above to the right) %
00001c34 : 00000213;   % 215:                 li tp, 0  # Player check %
00001c35 : 4810106f;   % 216:                 j CHECK_MAP_COLLISION %
00001c36 : 00158593;   % 219:                 addi a1,a1, 1 # Looks to the tile on the right of player's current tile %
00001c37 : 00180813;   % 220:                 addi a6,a6,1  # Increments current X on matrix (+1 X) %
00001c38 : 00000213;   % 221:                 li tp, 0  # Player check %
00001c39 : 4710106f;   % 222:                 j CHECK_MAP_COLLISION            %
00001c3a : 00000e93;   % 225:         li t4,0   # If Y offset = 0 %
00001c3b : 00000f13;   % 226:         li t5,0   # If Y offset = 0 %
00001c3c : 000e0e63;   % 227:         beqz t3 CONTINUE_CHECK_Y_DOWN    # If player's Y offset = 0, continue checking %
00001c3d : 00f00eb3;   % 230:         mv t4,a5   %
00001c3e : 00100f13;   % 231:         li t5,1    %
00001c3f : 01000313;   % 233:         li t1,16  # Loads 16 %
00001c40 : 004e0e33;   % 234:         add t3,t3,tp     # current offset + offset modifier %
00001c41 : 006e5463;   % 235:         bge t3,t1 CONTINUE_CHECK_Y_DOWN  # If current offset + offset modifier >= 16, continue checking (but check one tile bellow) %
00001c42 : 06c0006f;   % 237:         j END_VERTICAL_COLLISION         # otherwise, end procedure %
00001c43 : 00100713;   % 240:             li a4, 1  # Base case: Consider doors %
00001c44 : 00179293;   % 242:             slli t0,a5,1     # t0 = 2 x Matrix width %
00001c45 : 005585b3;   % 243:             add a1,a1,t0     # Updates Y 2 tiles down (+2 matrix Y)  %
00001c46 : 00288893;   % 244:             addi a7,a7,2     # Increments current Y on matrix (+2 Y) %
00001c47 : 01d585b3;   % 246:             add a1,a1,t4     # If current offset + offset modifier >= 16, update Y another tile down (+1 matrix Y) %
00001c48 : 01e888b3;   % 247:             add a7,a7,t5    # If Y current offset + offset modifier >= 16, increment current Y on matrix once more (+1 Y) %
00001c49 : 0063ce03;   % 249:             lbu t3, 6(t2)    # t3 = Player's X offset %
00001c4a : 020e0063;   % 250:             beqz t3 CHECK_Y_DOWN_BOTH_DOORS # If X offset = 0, just check one tile bellow, and consider both doors %
00001c4b : 00800293;   % 251:             li t0, 8   # Loads number 8 for comparing with X offset  %
00001c4c : 025e4263;   % 252:             blt t3,t0, CHECK_Y_DOWN_RIGHT_DOOR # If X offset < 8, just check one tile bellow, and consider right doors %
00001c4d : 03c2c663;   % 253:             blt t0,t3, CHECK_Y_DOWN_LEFT_DOOR # If X offset > 8, check one tile bellow to the right , and consider left doors %
00001c4e : 00200613;   % 255:                 li a2,2  # Check 2 tiles above the player (one bellow, the other bellow to the right)   %
00001c4f : 00000713;   % 256:                 li a4,0  # Ignore doors %
00001c50 : 00000213;   % 257:                 li tp, 0  # Player check %
00001c51 : 4110106f;   % 258:                 j CHECK_MAP_COLLISION %
00001c52 : 00200513;   % 261:                 li a0, 2 # Consider both doors on the left and on the right sides of the map %
00001c53 : 00000213;   % 262:                 li tp, 0  # Player check %
00001c54 : 4050106f;   % 263:                 j CHECK_MAP_COLLISION %
00001c55 : 00000513;   % 266:                 li a0, 0 # Only consider doors on the right side of the map %
00001c56 : 00000213;   % 267:                 li tp, 0  # Player check %
00001c57 : 3f90106f;   % 268:                 j CHECK_MAP_COLLISION %
00001c58 : 00100513;   % 271:                 li a0, 1 # Only consider doors on the left side of the map %
00001c59 : 00158593;   % 272:                 addi a1,a1, 1 # Looks to the tile on the right of player's current tile %
00001c5a : 00180813;   % 273:                 addi a6,a6,1  # Increments current X on matrix (+1 X) %
00001c5b : 00000213;   % 274:                 li tp, 0  # Player check %
00001c5c : 3e50106f;   % 275:                 j CHECK_MAP_COLLISION  %
00001c5d : 00100513;   % 279:         li a0,1   %
00001c5e : 00008067;   % 280:         ret  %
00001c5f : ffc10113;   % 304:     addi sp,sp,-4 %
00001c60 : 00112023;   % 305:     sw ra,0(sp) %
00001c61 : 0fc0b297;   % 307:     la t0, PLYR_POS  # Loads PLAYER_POS address %
00001c62 : f9628293;   % 307:  %
00001c63 : 0082c503;   % 308:     lbu a0, 8(t0)      # Loads Player's current X (matrix) %
00001c64 : 00a2c583;   % 309:     lbu a1, 10(t0)     # Loads Player's current Y (matrix)   %
00001c65 : 0062c603;   % 310:     lbu a2, 6(t0)      # Loads Player's current X offset %
00001c66 : 0072c683;   % 311:     lbu a3, 7(t0)      # Loads Player's current Y offset %
00001c67 : 0102c703;   % 312:     lbu a4, 16(t0)     # Loads Player's ball mode (0 - Disabled, 1 - Enabled) %
00001c68 : 0fc0b297;   % 316:     la t0,CURRENT_MAP             # Loads map address %
00001c69 : f6028293;   % 316:  %
00001c6a : 0042c283;   % 317:     lbu t0,4(t0)                  # and from it, loads map's number %
00001c6b : 00600313;   % 318:     li t1,6                       # Loads 6 to compare with map's number %
00001c6c : 00628463;   % 319:     beq t0,t1,PLAYER_COLLISION_BOMB_POWER      # If on map 6, continue checking for Bomb Power %
00001c6d : 0a40006f;   % 320:         j PLAYER_COLLISION_MARU_MARI   # Otherwise, skip this check %
00001c6e : 0fc0be17;   % 323:         la t3,PLYR_INFO  # Loads Bomb Power's info address %
00001c6f : f60e0e13;   % 323:  %
00001c70 : 001e4e83;   % 324:         lbu t4,1(t3)     # Loads player's abilities %
00001c71 : 00300e13;   % 325:         li t3,3 %
00001c72 : 01de1463;   % 326:         bne t3,t4, CONTINUE_PLAYER_COLLISION_BOMB_POWER %
00001c73 : 08c0006f;   % 327:             j PLAYER_COLLISION_MARU_MARI   # Otherwise, skip this check %
00001c74 : 00b00e13;   % 330:         li t3,11   # Loads Bomb Power's current X %
00001c75 : 00ae0863;   % 331:         beq t3,a0,PLAYER_COLLISION_BOMB_POWER_SAME_X   # If Bomb Power's X is the same as the player's %
00001c76 : 00150e93;   % 332:         addi t4,a0,1   # Checks player's tile to the right %
00001c77 : 01de0a63;   % 333:         beq t3,t4,PLAYER_COLLISION_BOMB_POWER_RIGHT_X  # If Bomb Power's X is to the right of player %
00001c78 : 0780006f;   % 334:             j PLAYER_COLLISION_MARU_MARI   # Otherwise, Bomb Power isn't near player enough to be collected, check next %
00001c79 : 00c00e93;   % 337:             li t4,12 %
00001c7a : 01d64a63;   % 338:             blt a2,t4,PLAYER_COLLISION_BOMB_POWER_CHECK_Y # If player's X offset < 12, continue %
00001c7b : 06c0006f;   % 339:                 j PLAYER_COLLISION_MARU_MARI # Otherwise, Bomb Power isn't near player enough to be collected, check next %
00001c7c : 00400e13;   % 342:             li t3,4  %
00001c7d : 00ce4463;   % 343:             blt t3,a2,PLAYER_COLLISION_BOMB_POWER_CHECK_Y # If t3 < player offset, continue %
00001c7e : 0600006f;   % 344:                 j PLAYER_COLLISION_MARU_MARI     # Otherwise, Bomb Power isn't near player enough to be collected, check next %
00001c7f : 00300e13;   % 347:             li t3,3   # Loads Bomb Power's current Y %
00001c80 : 00158e93;   % 348:             addi t4,a1,1        # Checks player's base tile (Y + 1) %
00001c81 : 01de0a63;   % 349:             beq t3,t4,PLAYER_COLLISION_BOMB_POWER_HIT  # If Bomb Power's Y on player's base, it's collected %
00001c82 : 0500006f;   % 351:                 j PLAYER_COLLISION_MARU_MARI     # Otherwise, Bomb Power isn't near player enough to be collected, check next %
00001c83 : 00200e13;   % 354:                 li t3,2 %
00001c84 : 00de4463;   % 355:                 blt t3,a3,PLAYER_COLLISION_BOMB_POWER_HIT # If Bomb Power's "Y offset" is less than the player's Y offset deal damage %
00001c85 : 0440006f;   % 356:                     j PLAYER_COLLISION_MARU_MARI     # Otherwise, Bomb Power isn't near player enough to be collected, check next %
00001c86 : 0fc0be17;   % 360:                 la t3,PLYR_INFO  # Loads Maru Bomb Power's info address %
00001c87 : f00e0e13;   % 360:  %
00001c88 : 00300e93;   % 361:                 li t4,3          # Loads 1 (1 - ball) %
00001c89 : 01de00a3;   % 362:                 sb t4,1(t3)      # Loads player's abilities %
00001c8a : ff010113;   % 365:                     addi sp,sp,-16 %
00001c8b : 00a12023;   % 366:                     sw a0,0(sp) %
00001c8c : 00b12223;   % 367:                     sw a1,4(sp) %
00001c8d : 00c12423;   % 368:                     sw a2,8(sp) %
00001c8e : 00d12623;   % 369:                     sw a3,12(sp) %
00001c8f : 00002317;   % 372:                 call PLAY_ITEM_GET       %
00001c90 : f3c300e7;   % 372:  %
00001c91 : 00012503;   % 375:                     lw a0,0(sp) %
00001c92 : 00412583;   % 376:                     lw a1,4(sp) %
00001c93 : 00812603;   % 377:                     lw a2,8(sp) %
00001c94 : 00c12683;   % 378:                     lw a3,12(sp) %
00001c95 : 01010113;   % 379:                     addi sp,sp,16 %
00001c96 : 0fc0b297;   % 392:     la t0,CURRENT_MAP             # Loads map address %
00001c97 : ea828293;   % 392:  %
00001c98 : 0042c283;   % 393:     lbu t0,4(t0)                  # and from it, loads map's number %
00001c99 : 00100313;   % 394:     li t1,1                       # Loads 1 to compare with map's number %
00001c9a : 00628463;   % 395:     beq t0,t1,CONTINUE_PLAYER_COLLISION_MARU_MARI1      # If on map 1, continue checking for MARU MARI %
00001c9b : 0a00006f;   % 396:         j PLAYER_COLLISION_LOOT   # Otherwise, skip this check %
00001c9c : 0fc0be17;   % 399:         la t3,PLYR_INFO  # Loads Maru Mari's info address %
00001c9d : ea8e0e13;   % 399:  %
00001c9e : 001e4e83;   % 400:         lbu t4,1(t3)     # Loads player's abilities %
00001c9f : 000e8463;   % 401:         beqz t4, CONTINUE_PLAYER_COLLISION_MARU_MARI2 %
00001ca0 : 08c0006f;   % 402:             j PLAYER_COLLISION_LOOT   # Otherwise, skip this check %
00001ca1 : 00f00e13;   % 405:         li t3,15   # Loads MaruMari's current X %
00001ca2 : 00ae0863;   % 406:         beq t3,a0,PLAYER_COLLISION_MARU_MARI_SAME_X   # If MaruMari's X is the same as the player's %
00001ca3 : 00150e93;   % 407:         addi t4,a0,1   # Checks player's tile to the right %
00001ca4 : 01de0a63;   % 408:         beq t3,t4,PLAYER_COLLISION_MARU_MARI_RIGHT_X  # If MaruMari's X is to the right of player %
00001ca5 : 0780006f;   % 409:             j PLAYER_COLLISION_LOOT   # Otherwise, MaruMari isn't near player enough to be collected, check next %
00001ca6 : 00c00e93;   % 412:             li t4,12 %
00001ca7 : 01d64a63;   % 413:             blt a2,t4,PLAYER_COLLISION_MARU_MARI_CHECK_Y # If player's X offset < 12, continue %
00001ca8 : 06c0006f;   % 414:                 j PLAYER_COLLISION_LOOT # Otherwise, MaruMari isn't near player enough to be collected, check next %
00001ca9 : 00400e13;   % 417:             li t3,4  %
00001caa : 00ce4463;   % 418:             blt t3,a2,PLAYER_COLLISION_MARU_MARI_CHECK_Y # If t3 < player offset, continue %
00001cab : 0600006f;   % 419:                 j PLAYER_COLLISION_LOOT     # Otherwise, MaruMari isn't near player enough to be collected, check next %
00001cac : 00900e13;   % 422:             li t3,9   # Loads MaruMari's current Y %
00001cad : 00158e93;   % 423:             addi t4,a1,1        # Checks player's base tile (Y + 1) %
00001cae : 01de0a63;   % 424:             beq t3,t4,PLAYER_COLLISION_MARU_MARI_HIT  # If MaruMari's Y on player's base, it's collected %
00001caf : 0500006f;   % 426:                 j PLAYER_COLLISION_LOOT     # Otherwise, MaruMari isn't near player enough to be collected, check next %
00001cb0 : 00200e13;   % 429:                 li t3,2 %
00001cb1 : 00de4463;   % 430:                 blt t3,a3,PLAYER_COLLISION_MARU_MARI_HIT # If MaruMari's "Y offset" is less than the player's Y offset deal damage %
00001cb2 : 0440006f;   % 431:                     j PLAYER_COLLISION_LOOT     # Otherwise, MaruMari isn't near player enough to be collected, check next %
00001cb3 : 0fc0be17;   % 435:                 la t3,PLYR_INFO  # Loads Maru Mari's info address %
00001cb4 : e4ce0e13;   % 435:  %
00001cb5 : 00100e93;   % 436:                 li t4,1          # Loads 1 (1 - ball) %
00001cb6 : 01de00a3;   % 437:                 sb t4,1(t3)      # Loads player's abilities %
00001cb7 : ff010113;   % 440:                     addi sp,sp,-16 %
00001cb8 : 00a12023;   % 441:                     sw a0,0(sp) %
00001cb9 : 00b12223;   % 442:                     sw a1,4(sp) %
00001cba : 00c12423;   % 443:                     sw a2,8(sp) %
00001cbb : 00d12623;   % 444:                     sw a3,12(sp) %
00001cbc : 00002317;   % 447:                 call PLAY_ITEM_GET       %
00001cbd : e88300e7;   % 447:  %
00001cbe : 00012503;   % 450:                     lw a0,0(sp) %
00001cbf : 00412583;   % 451:                     lw a1,4(sp) %
00001cc0 : 00812603;   % 452:                     lw a2,8(sp) %
00001cc1 : 00c12683;   % 453:                     lw a3,12(sp) %
00001cc2 : 01010113;   % 454:                     addi sp,sp,16 %
00001cc3 : 0fc0b297;   % 467:     la t0,LOOT_ARRAY   # Loads loot array %
00001cc4 : ed228293;   % 467:  %
00001cc5 : 00000393;   % 469:     li t2,0                 # resets counter %
00001cc6 : 00400313;   % 470:     li t1,4       # gets number of loot in game %
00001cc7 : 0022ce03;   % 472:         lbu t3,2(t0) # Loads enable byte %
00001cc8 : 000e1463;   % 473:         bnez t3,PLAYER_COLLISION_LOOT_LOOP_CONTINUE    # If enabled, %
00001cc9 : 0e80006f;   % 474:             j NEXT_IN_PLAYER_COLLISION_LOOT_LOOP       # Otherwise, check other loot %
00001cca : 0062ce03;   % 477:         lbu t3,6(t0)   # Loads loot's current X %
00001ccb : 00ae0c63;   % 478:         beq t3,a0,PLAYER_COLLISION_LOOT_LOOP_SAME_X   # If loot's X is the same as the player's %
00001ccc : 00150e93;   % 479:         addi t4,a0,1   # Checks player's tile to the right %
00001ccd : 03de0863;   % 480:         beq t3,t4,PLAYER_COLLISION_LOOT_LOOP_RIGHT_X  # If loot's X is to the right of player %
00001cce : fff50e93;   % 481:         addi t4,a0,-1  # Checks player's tile to the left %
00001ccf : 01de0c63;   % 482:         beq t3,t4,PLAYER_COLLISION_LOOT_LOOP_LEFT_X   # If loot's X is to the left of player %
00001cd0 : 0cc0006f;   % 483:         j NEXT_IN_PLAYER_COLLISION_LOOT_LOOP # Otherwise, loot isn't near player enough to be collected, check next %
00001cd1 : 0042ce03;   % 486:             lbu t3,4(t0)   # Loads loot's X offset %
00001cd2 : 00c00e93;   % 487:             li t4,12 %
00001cd3 : 03ced463;   % 488:             ble t3,t4,PLAYER_COLLISION_LOOT_LOOP_CHECK_Y # If t3 <= 12, continue %
00001cd4 : 0bc0006f;   % 489:                 j NEXT_IN_PLAYER_COLLISION_LOOT_LOOP # Otherwise, loot isn't near player enough to be collected, check next %
00001cd5 : 0042ce03;   % 492:             lbu t3,4(t0)   # Loads loot's X offset %
00001cd6 : ffce0e13;   % 493:             addi t3,t3,-4  # subtracts 4 from it %
00001cd7 : 00ce4c63;   % 494:             blt t3,a2,PLAYER_COLLISION_LOOT_LOOP_CHECK_Y # If t3 < player offset, continue %
00001cd8 : 0ac0006f;   % 495:                 j NEXT_IN_PLAYER_COLLISION_LOOT_LOOP     # Otherwise, loot isn't near player enough to be collected, check next %
00001cd9 : 0042ce03;   % 498:             lbu t3,4(t0)   # Loads loot's X offset %
00001cda : 004e0e13;   % 499:             addi t3,t3,4   # adds 4 to it %
00001cdb : 00ce4463;   % 500:             blt t3,a2,PLAYER_COLLISION_LOOT_LOOP_CHECK_Y # If t3 < player offset, continue %
00001cdc : 09c0006f;   % 501:                 j NEXT_IN_PLAYER_COLLISION_LOOT_LOOP     # Otherwise, loot isn't near player enough to be collected, check next %
00001cdd : 0082ce03;   % 504:             lbu t3,8(t0)   # Loads loot's current Y %
00001cde : 02be0463;   % 505:             beq t3,a1,PLAYER_COLLISION_LOOT_LOOP_SAME_Y    # If loot's Y is the same as the player's %
00001cdf : 00158e93;   % 506:             addi t4,a1,1   # Checks player's base tile (Y + 1) %
00001ce0 : 03de0c63;   % 507:             beq t3,t4,PLAYER_COLLISION_LOOT_LOOP_HIT  # If loot's Y on player's base %
00001ce1 : 00258e93;   % 508:             addi t4,a1,2   # Checks bellow player's base tile (Y + 2) %
00001ce2 : 01de0463;   % 509:             beq t3,t4,PLAYER_COLLISION_LOOT_LOOP_BELLOW  # If loot's X is bellow player %
00001ce3 : 0800006f;   % 511:             j NEXT_IN_PLAYER_COLLISION_LOOT_LOOP     # Otherwise, loot isn't near player enough to be collected, check next %
00001ce4 : 0042ce03;   % 514:                 lbu t3,4(t0)  # Loads loot's Y offset %
00001ce5 : 007e0e93;   % 515:                 addi t4,t3,7  %
00001ce6 : 02de4063;   % 516:                 blt t3,a3,PLAYER_COLLISION_LOOT_LOOP_HIT # If loot's "Y offset" is less than the player's Y offset deal damage %
00001ce7 : 0700006f;   % 517:                     j NEXT_IN_PLAYER_COLLISION_LOOT_LOOP     # Otherwise, loot isn't near player enough to be collected, check next %
00001ce8 : 00070463;   % 520:                 beqz a4,CONTINUE_PLAYER_COLLISION_LOOT_LOOP_SAME_Y  # If not on morph ball, check it was a hit %
00001ce9 : 0680006f;   % 522:                     j NEXT_IN_PLAYER_COLLISION_LOOT_LOOP     # Otherwise, loot isn't near player enough to be collected, check next %
00001cea : 0042ce03;   % 525:                     lbu t3,4(t0)      # Loads loot's Y offset %
00001ceb : 00ce0e13;   % 526:                     addi t3,t3, 12  %
00001cec : 01c6c463;   % 527:                     bgt t3,a3,PLAYER_COLLISION_LOOT_LOOP_HIT # If loot's "Y offset" is greater than the player's Y offset deal damage %
00001ced : 0580006f;   % 528:                         j NEXT_IN_PLAYER_COLLISION_LOOT_LOOP # Otherwise, loot isn't near player enough to be collected, check next %
00001cee : 00028123;   % 532:                 sb zero,2(t0)     # Disables loot %
00001cef : 0032ce03;   % 533:                 lbu t3,3(t0)      # Loads loot's type %
00001cf0 : 020e0463;   % 534:                 beqz t3, PLAYER_COLLISION_LOOT_LOOP_HIT_ENERGY  # If it's energy %
00001cf1 : 0fc0be17;   % 536:                     la t3,PLYR_INFO_2 %
00001cf2 : d6ce0e13;   % 536:  %
00001cf3 : 002e4e83;   % 537:                     lbu t4,2(t3)       # Loads number of missiles %
00001cf4 : 005e8e93;   % 538:                     addi t4,t4,5 %
00001cf5 : 06400f13;   % 539:                     li t5,100 %
00001cf6 : 01eec463;   % 540:                     blt t4,t5,STORE_NEW_MISSILE %
00001cf7 : 06400e93;   % 541:                         li t4,100      # Sets missile number to maximum %
00001cf8 : 01de0123;   % 543:                         sb t4,2(t3)    # Stores updated number of missiles %
00001cf9 : 0280006f;   % 544:                         j NEXT_IN_PLAYER_COLLISION_LOOT_LOOP # Go to next loot        %
00001cfa : 0fc0be17;   % 548:                     la t3,PLYR_INFO %
00001cfb : d30e0e13;   % 548:  %
00001cfc : 000e4e83;   % 549:                     lbu t4,0(t3)       # Loads health %
00001cfd : 005e8e93;   % 550:                     addi t4,t4,5 %
00001cfe : 06300f13;   % 551:                     li t5,99 %
00001cff : 01eec463;   % 552:                     blt t4,t5,STORE_NEW_ENERGY %
00001d00 : 06300e93;   % 553:                         li t4,99       # Sets missile number to maximum %
00001d01 : 01de0023;   % 555:                         sb t4,0(t3)    # Stores updated number of missiles %
00001d02 : 0040006f;   % 556:                         j NEXT_IN_PLAYER_COLLISION_LOOT_LOOP # Go to next loot            %
00001d03 : 00728293;   % 559:             addi t0,t0,7   # Going to the next ripper's address                                   %
00001d04 : 00138393;   % 560:             addi t2,t2,1             # Iterating counter by 1                                    %
00001d05 : 0063d463;   % 561:             bge t2,t1, PLAYER_COLLISION_ENEMIES # If all of the rippers were checked, end loop                                   %
00001d06 : f05ff06f;   % 562:             j PLAYER_COLLISION_LOOT_LOOP # otherwise, go back to the loop's beginning          %
00001d07 : 0fc0b297;   % 565:     la t0,CURRENT_MAP             # Loads map address %
00001d08 : ce428293;   % 565:  %
00001d09 : 0042c283;   % 566:     lbu t0,4(t0)                  # and from it, loads map's number %
00001d0a : 00700313;   % 567:     li t1,7                       # Loads 7 to compare with map's number %
00001d0b : 00629463;   % 568:     bne t0,t1,PLAYER_COLLISION_SKIP_RIDLEY         # If not on map 7, skip Ridley and Plasma Breath >:D %
00001d0c : 20c0006f;   % 569:         j PLAYER_COLLISION_RIDLEY # Otherwise, skip the rest of the checks %
00001d0d : 0fc0b297;   % 574:     la t0,Zoomers  # Loads Zoomers address %
00001d0e : e0428293;   % 574:  %
00001d0f : 0002a283;   % 576:     lw t0,0(t0)    # Loads the ZoomersA address over the Zoomers address %
00001d10 : 00029463;   % 577:     bnez t0,CONTINUE_PLAYER_COLLISION_ZOOMER  # If there are zoomers in this map %
00001d11 : 1040006f;   % 578:         j PLAYER_COLLISION_RIPPER             # If t0 = 0, there are no zoomers in this map %
00001d12 : 0002c303;   % 582:     lbu t1,0(t0)   # Loads number of Zoomers in current map %
00001d13 : 00000393;   % 583:     li t2,0        # Counter for zoomers %
00001d14 : 00128293;   % 584:     addi t0,t0,1   # Goes to next byte (where zoomers from current map start) %
00001d15 : 00028e03;   % 587:         lb t3,0(t0) # Loads zoomer's health %
00001d16 : 01c04463;   % 588:         blt zero,t3,CONTINUE_PLAYER_COLLISION_ZOOMER_LOOP # If zoomer is alive %
00001d17 : 0dc0006f;   % 590:             j NEXT_IN_PLAYER_COLLISION_ZOOMER_LOOP   # Zoomer is dead %
00001d18 : 00300213;   % 593:         li tp, 3 # tp will start as 3 (random direction)  %
00001d19 : 0042ce03;   % 594:         lbu t3,4(t0)   # Loads zoomer's current X %
00001d1a : 00ae0c63;   % 595:         beq t3,a0,PLAYER_COLLISION_ZOOMER_LOOP_SAME_X   # If zoomer's X is the same as the player's %
00001d1b : 00150e93;   % 596:         addi t4,a0,1   # Checks player's tile to the right %
00001d1c : 05de0263;   % 597:         beq t3,t4,PLAYER_COLLISION_ZOOMER_LOOP_RIGHT_X  # If zoomer's X is to the right of player %
00001d1d : fff50e93;   % 598:         addi t4,a0,-1  # Checks player's tile to the left %
00001d1e : 03de0263;   % 599:         beq t3,t4,PLAYER_COLLISION_ZOOMER_LOOP_LEFT_X   # If zoomer's X is to the left of player %
00001d1f : 0bc0006f;   % 600:         j NEXT_IN_PLAYER_COLLISION_ZOOMER_LOOP # Otherwise, zoomer isn't near player enough to deal damage, check next %
00001d20 : 0022ce03;   % 603:             lbu t3,2(t0)   # Loads zoomer's X offset %
00001d21 : 00ce0463;   % 604:             beq t3,a2,PLAYER_COLLISION_ZOOMER_LOOP_SAME_X_RANDOM # If offsets are the same, randomize direction %
00001d22 : 00ce2233;   % 606:                 slt tp,t3,a2   # If t3 < a2, damage is from the left, otherwise, it is from the right  %
00001d23 : 00c00e93;   % 608:                 li t4,12       # to be compared with  %
00001d24 : 41c60e33;   % 609:                 sub t3,a2,t3   # t3 = zoomer's x offset - player's x offset %
00001d25 : 03de4c63;   % 610:                 blt t3,t4,PLAYER_COLLISION_ZOOMER_LOOP_CHECK_Y # If t3 < 12, continue %
00001d26 : 0a00006f;   % 611:                     j NEXT_IN_PLAYER_COLLISION_ZOOMER_LOOP # Otherwise, zoomer isn't near player enough to deal damage, check next %
00001d27 : 0022ce03;   % 614:             lbu t3,2(t0)   # Loads zoomer's X offset %
00001d28 : ffce0e13;   % 615:             addi t3,t3,-4  # subtracts 4 from it %
00001d29 : 01c65663;   % 616:             bge a2,t3,STOP_PLAYER_COLLISION_ZOOMER_LOOP_LEFT_X # If t3 <= player offset, there wasn't a hit %
00001d2a : 00100213;   % 617:                 li tp,1    # Damage from the left %
00001d2b : 0200006f;   % 618:                 j PLAYER_COLLISION_ZOOMER_LOOP_CHECK_Y %
00001d2c : 0880006f;   % 620:                 j NEXT_IN_PLAYER_COLLISION_ZOOMER_LOOP # Zoomer isn't near player enough to deal damage, check next %
00001d2d : 0022ce03;   % 623:             lbu t3,2(t0)   # Loads zoomer's X offset %
00001d2e : 004e0e13;   % 624:             addi t3,t3,4   # adds 4 to it %
00001d2f : 00ce5663;   % 625:             bge t3,a2,STOP_PLAYER_COLLISION_ZOOMER_LOOP_RIGHT_X # If t3 >= player offset, there wasn't a hit %
00001d30 : 00000213;   % 626:                 li tp,0    # Damage from the right %
00001d31 : 0080006f;   % 627:                 j PLAYER_COLLISION_ZOOMER_LOOP_CHECK_Y %
00001d32 : 0700006f;   % 629:                 j NEXT_IN_PLAYER_COLLISION_ZOOMER_LOOP # Zoomer isn't near player enough to deal damage, check next %
00001d33 : 0062ce03;   % 632:             lbu t3,6(t0)   # Loads zoomer's current Y %
00001d34 : 04be0063;   % 633:             beq t3,a1,PLAYER_COLLISION_ZOOMER_LOOP_SAME_Y    # If zoomer's Y is the same as the player's %
00001d35 : 00158e93;   % 634:             addi t4,a1,1   # Checks player's base tile (Y + 1) %
00001d36 : 05de0463;   % 635:             beq t3,t4,PLAYER_COLLISION_ZOOMER_LOOP_HIT  # If zoomer's Y on player's base %
00001d37 : 00258e93;   % 636:             addi t4,a1,2   # Checks bellow player's base tile (Y + 2) %
00001d38 : 01de0863;   % 637:             beq t3,t4,PLAYER_COLLISION_ZOOMER_LOOP_BELLOW  # If zoomer's X is bellow player %
00001d39 : fff58e93;   % 638:             addi t4,a1,-1  # Checks 1 tile above player's Y %
00001d3a : 01de0a63;   % 639:             beq t3,t4,PLAYER_COLLISION_ZOOMER_LOOP_ABOVE     # If zoomer's X is above the player %
00001d3b : 04c0006f;   % 640:             j NEXT_IN_PLAYER_COLLISION_ZOOMER_LOOP # Otherwise, zoomer isn't near player enough to deal damage, check next %
00001d3c : 0032ce03;   % 643:                 lbu t3,3(t0)   # Loads zoomer's Y offset %
00001d3d : 02de4663;   % 644:                 blt t3,a3,PLAYER_COLLISION_ZOOMER_LOOP_HIT # If zoomer's Y offset is less than the player's Y offset deal damage %
00001d3e : 0400006f;   % 645:                     j NEXT_IN_PLAYER_COLLISION_ZOOMER_LOOP # Otherwise, zoomer isn't near player enough to deal damage, check next %
00001d3f : 00070463;   % 648:                 beqz a4,CONTINUE_PLAYER_COLLISION_ZOOMER_LOOP_ABOVE  # If not on morph ball, check if it was a hit %
00001d40 : 0380006f;   % 649:                     j NEXT_IN_PLAYER_COLLISION_ZOOMER_LOOP # Otherwise, zoomer isn't near player enough to deal damage, check next %
00001d41 : 0032ce03;   % 652:                 lbu t3,3(t0)   # Loads zoomer's Y offset %
00001d42 : 01c6cc63;   % 653:                 bgt t3,a3,PLAYER_COLLISION_ZOOMER_LOOP_HIT # If zoomer's Y offset is greater than the player's Y offset deal damage %
00001d43 : 02c0006f;   % 654:                     j NEXT_IN_PLAYER_COLLISION_ZOOMER_LOOP # Otherwise, zoomer isn't near player enough to deal damage, check next %
00001d44 : 00070863;   % 657:                 beqz a4,PLAYER_COLLISION_ZOOMER_LOOP_HIT  # If not on morph ball, it was a hit %
00001d45 : 0032ce03;   % 659:                 lbu t3,3(t0)   # Loads zoomer's Y offset %
00001d46 : 01c6c463;   % 660:                 bgt t3,a3,PLAYER_COLLISION_ZOOMER_LOOP_HIT # If zoomer's Y offset is greater than the player's Y offset deal damage %
00001d47 : 01c0006f;   % 661:                     j NEXT_IN_PLAYER_COLLISION_ZOOMER_LOOP # Otherwise, zoomer isn't near player enough to deal damage, check next %
00001d48 : 00000513;   % 665:                 li a0,0  # Hit was from same X %
00001d49 : 00800593;   % 666:                 li a1,8  # Damage dealt %
00001d4a : 00400633;   % 667:                 mv a2,tp # Gets direction %
00001d4b : fffff317;   % 668:                 call DAMAGE_PLAYER %
00001d4c : 5c4300e7;   % 668:  %
00001d4d : 2e40006f;   % 669:                 j END_PLAYER_COLLISION  # Player already took damage, end procedure here                %
00001d4e : 00c28293;   % 672:             addi t0,t0,12   # Going to the next zoomer's address                                   %
00001d4f : 00138393;   % 673:             addi t2,t2,1             # Iterating counter by 1                                    %
00001d50 : 0063d463;   % 674:             bge t2,t1, PLAYER_COLLISION_RIPPER # If all of the zoomers were checked, end loop                                   %
00001d51 : f11ff06f;   % 675:             j PLAYER_COLLISION_ZOOMER_LOOP # otherwise, go back to the loop's beginning                      %
00001d52 : 0fc0b297;   % 678:     la t0,Rippers  # Loads Rippers address %
00001d53 : eb028293;   % 678:  %
00001d54 : 0002a283;   % 680:     lw t0,0(t0)    # Loads the RippersA address over the Rippers address %
00001d55 : 00029463;   % 681:     bnez t0,CONTINUE_PLAYER_COLLISION_RIPPER  # If there are rippers in this map %
00001d56 : 2c00006f;   % 682:         j END_PLAYER_COLLISION             # If t0 = 0, there are no rippers in this map %
00001d57 : 0002c303;   % 686:     lbu t1,0(t0)   # Loads number of Rippers in current map %
00001d58 : 00000393;   % 687:     li t2,0        # Counter for rippers %
00001d59 : 00128293;   % 688:     addi t0,t0,1   # Goes to next byte (where rippers from current map start) %
00001d5a : 00300213;   % 691:         li tp, 3 # tp will start as 3 (random direction)  %
00001d5b : 0032ce03;   % 692:         lbu t3,3(t0)   # Loads ripper's current X %
00001d5c : 00ae0c63;   % 693:         beq t3,a0,PLAYER_COLLISION_RIPPER_LOOP_SAME_X   # If ripper's X is the same as the player's %
00001d5d : 00150e93;   % 694:         addi t4,a0,1   # Checks player's tile to the right %
00001d5e : 05de0263;   % 695:         beq t3,t4,PLAYER_COLLISION_RIPPER_LOOP_RIGHT_X  # If ripper's X is to the right of player %
00001d5f : fff50e93;   % 696:         addi t4,a0,-1  # Checks player's tile to the left %
00001d60 : 03de0263;   % 697:         beq t3,t4,PLAYER_COLLISION_RIPPER_LOOP_LEFT_X   # If ripper's X is to the left of player %
00001d61 : 0a40006f;   % 698:         j NEXT_IN_PLAYER_COLLISION_RIPPER_LOOP # Otherwise, ripper isn't near player enough to deal damage, check next %
00001d62 : 0022ce03;   % 701:             lbu t3,2(t0)   # Loads ripper's X offset %
00001d63 : 00ce0463;   % 702:             beq t3,a2,PLAYER_COLLISION_RIPPER_LOOP_SAME_X_RANDOM # If offsets are the same, randomize direction %
00001d64 : 00ce2233;   % 704:                 slt tp,t3,a2   # If t3 < a2, damage is from the left, otherwise, it is from the right  %
00001d65 : 00c00e93;   % 706:                 li t4,12       # to be compared with  %
00001d66 : 41c60e33;   % 707:                 sub t3,a2,t3   # t3 = ripper's x offset - player's x offset %
00001d67 : 03de4c63;   % 708:                 blt t3,t4,PLAYER_COLLISION_RIPPER_LOOP_CHECK_Y # If t3 < 12, continue %
00001d68 : 0880006f;   % 709:                     j NEXT_IN_PLAYER_COLLISION_RIPPER_LOOP # Otherwise, ripper isn't near player enough to deal damage, check next %
00001d69 : 0022ce03;   % 712:             lbu t3,2(t0)   # Loads ripper's X offset %
00001d6a : ffce0e13;   % 713:             addi t3,t3,-4  # subtracts 4 from it %
00001d6b : 01c65663;   % 714:             bge a2,t3,STOP_PLAYER_COLLISION_RIPPER_LOOP_LEFT_X # If t3 <= player offset, there wasn't a hit %
00001d6c : 00100213;   % 715:                 li tp,1    # Damage from the left %
00001d6d : 0200006f;   % 716:                 j PLAYER_COLLISION_RIPPER_LOOP_CHECK_Y %
00001d6e : 0700006f;   % 718:                 j NEXT_IN_PLAYER_COLLISION_RIPPER_LOOP # Ripper isn't near player enough to deal damage, check next %
00001d6f : 0022ce03;   % 721:             lbu t3,2(t0)   # Loads ripper's X offset %
00001d70 : 004e0e13;   % 722:             addi t3,t3,4   # adds 4 to it %
00001d71 : 00ce5663;   % 723:             bge t3,a2,STOP_PLAYER_COLLISION_RIPPER_LOOP_RIGHT_X # If t3 >= player offset, there wasn't a hit %
00001d72 : 00000213;   % 724:                 li tp,0    # Damage from the right %
00001d73 : 0080006f;   % 725:                 j PLAYER_COLLISION_RIPPER_LOOP_CHECK_Y %
00001d74 : 0580006f;   % 727:                 j NEXT_IN_PLAYER_COLLISION_RIPPER_LOOP # Ripper isn't near player enough to deal damage, check next %
00001d75 : 0052ce03;   % 730:             lbu t3,5(t0)   # Loads ripper's current Y %
00001d76 : 02be0263;   % 731:             beq t3,a1,PLAYER_COLLISION_RIPPER_LOOP_SAME_Y    # If ripper's Y is the same as the player's %
00001d77 : 00158e93;   % 732:             addi t4,a1,1   # Checks player's base tile (Y + 1) %
00001d78 : 03de0863;   % 733:             beq t3,t4,PLAYER_COLLISION_RIPPER_LOOP_HIT  # If ripper's Y on player's base %
00001d79 : 00258e93;   % 734:             addi t4,a1,2   # Checks bellow player's base tile (Y + 2) %
00001d7a : 01de0463;   % 735:             beq t3,t4,PLAYER_COLLISION_RIPPER_LOOP_BELLOW  # If ripper's X is bellow player %
00001d7b : 03c0006f;   % 737:             j NEXT_IN_PLAYER_COLLISION_RIPPER_LOOP # Ripper isn't near player enough to deal damage, check next %
00001d7c : 00700e13;   % 740:                 li t3, 7 # Ripper's Y offset is always 0, but we add 4 to it (sprite is 4 pixels bellow initial Y) %
00001d7d : 00de4e63;   % 741:                 blt t3,a3,PLAYER_COLLISION_RIPPER_LOOP_HIT # If ripper's "Y offset" is less than the player's Y offset deal damage %
00001d7e : 0300006f;   % 742:                     j NEXT_IN_PLAYER_COLLISION_RIPPER_LOOP # Otherwise, ripper isn't near player enough to deal damage, check next %
00001d7f : 00070463;   % 745:                 beqz a4,CONTINUE_PLAYER_COLLISION_RIPPER_LOOP_SAME_Y  # If not on morph ball, check it was a hit %
00001d80 : 0280006f;   % 747:                     j NEXT_IN_PLAYER_COLLISION_RIPPER_LOOP # Otherwise, ripper isn't near player enough to deal damage, check next %
00001d81 : 00c00e13;   % 750:                     li t3, 12 # Ripper's Y offset is always 0, but we add 12 to it (sprite end 4 lines befor its real end) %
00001d82 : 01c6c463;   % 751:                     bgt t3,a3,PLAYER_COLLISION_RIPPER_LOOP_HIT # If ripper's "Y offset" is greater than the player's Y offset deal damage %
00001d83 : 01c0006f;   % 752:                     j NEXT_IN_PLAYER_COLLISION_RIPPER_LOOP # Otherwise, ripper isn't near player enough to deal damage, check next %
00001d84 : 00000513;   % 756:                 li a0,0  # Hit was from same X %
00001d85 : 00800593;   % 757:                 li a1,8  # Damage dealt %
00001d86 : 00400633;   % 758:                 mv a2,tp # Gets direction %
00001d87 : fffff317;   % 759:                 call DAMAGE_PLAYER %
00001d88 : 4d4300e7;   % 759:  %
00001d89 : 1f40006f;   % 760:                 j END_PLAYER_COLLISION  # Player already took damage, end procedure here                %
00001d8a : 00728293;   % 763:             addi t0,t0,7   # Going to the next ripper's address                                   %
00001d8b : 00138393;   % 764:             addi t2,t2,1             # Iterating counter by 1                                    %
00001d8c : 0063d463;   % 765:             bge t2,t1, PLAYER_COLLISION_RIDLEY_SKIP # If all of the rippers were checked, end loop                                   %
00001d8d : f35ff06f;   % 766:             j PLAYER_COLLISION_RIPPER_LOOP # otherwise, go back to the loop's beginning   %
00001d8e : 1e00006f;   % 769:         j END_PLAYER_COLLISION %
00001d8f : 0fc0b297;   % 772:         la t0,RIDLEY_INFO %
00001d90 : e0c28293;   % 772:  %
00001d91 : 00028303;   % 773:         lb t1,0(t0) # Loads Ridley's health %
00001d92 : 00604463;   % 774:         blt zero,t1,CONTINUE_PLAYER_COLLISION_RIDLEY # If Ridley is alive %
00001d93 : 1cc0006f;   % 775:             j END_PLAYER_COLLISION %
00001d94 : 00100213;   % 778:         li tp, 1 # tp will start as left %
00001d95 : 00900e13;   % 779:         li t3,9   # Loads Ridley's current X %
00001d96 : 02ae0863;   % 780:         beq t3,a0,PLAYER_COLLISION_RIDLEY_CHECK_Y   # If Ridley's X is the same as the player's %
00001d97 : 00150e93;   % 781:         addi t4,a0,1   # Checks player's tile to the right %
00001d98 : 01de0e63;   % 782:         beq t3,t4,PLAYER_COLLISION_RIDLEY_RIGHT_X  # If Ridley's X is to the right of player %
00001d99 : fff50e93;   % 783:         addi t4,a0,-1  # Checks player's tile to the left %
00001d9a : 01de0463;   % 784:         beq t3,t4,PLAYER_COLLISION_RIDLEY_LEFT_X   # If Ridley's X is to the left of player %
00001d9b : 0900006f;   % 785:         j PLAYER_COLLISION_PLASMA_BREATH # Otherwise, Ridley isn't near player enough to deal damage, check Plasma Breath %
00001d9c : 00600e13;   % 788:             li t3,6   # Loads Ridley's X offset %
00001d9d : 01c64a63;   % 789:             blt a2,t3,PLAYER_COLLISION_RIDLEY_CHECK_Y # If t3 < player offset, check Y %
00001d9e : 0840006f;   % 790:             j PLAYER_COLLISION_PLASMA_BREATH # Otherwise, Ridley isn't near player enough to deal damage, check Plasma Breath %
00001d9f : 00600e13;   % 793:             li t3,6   # Loads Ridley's X offset %
00001da0 : 00ce4463;   % 794:             blt t3,a2,PLAYER_COLLISION_RIDLEY_CHECK_Y # If t3 < player offset, there wasn't a hit %
00001da1 : 0780006f;   % 795:             j PLAYER_COLLISION_PLASMA_BREATH # Otherwise, Ridley isn't near player enough to deal damage, check Plasma Breath        %
00001da2 : 0032ce03;   % 798:             lbu t3,3(t0)   # Loads Ridley's current Y %
00001da3 : 04be0c63;   % 799:             beq t3,a1,PLAYER_COLLISION_RIDLEY_HIT    # If Ridley's Y is the same as the player's (player would basically be inside him) %
00001da4 : 00158e93;   % 800:             addi t4,a1,1   # Checks player's base tile (Y + 1) %
00001da5 : 05de0863;   % 801:             beq t3,t4,PLAYER_COLLISION_RIDLEY_HIT    # If Ridley's Y on player's base, it's a hit (player would basically be inside him) %
00001da6 : 00258e93;   % 802:             addi t4,a1,2   # Checks bellow player's base tile (Y + 2) %
00001da7 : 03de0063;   % 803:             beq t3,t4,PLAYER_COLLISION_RIDLEY_BELLOW  # If Ridley's Y is bellow player %
00001da8 : 001e0e13;   % 805:             addi t3,t3,1   # Gets ridley's Y + 1 %
00001da9 : 04be0063;   % 806:             beq t3,a1,PLAYER_COLLISION_RIDLEY_HIT    # If Ridley's Y + 1 is the same as the player's, it's a hit (player would basically be inside him) %
00001daa : 001e0e13;   % 808:             addi t3,t3,1   # Gets ridley's Y + 2 %
00001dab : 02be0863;   % 809:             beq t3,a1,PLAYER_COLLISION_RIDLEY_SAME_Y    # If Ridley's Y is the same as the player's %
00001dac : fff58e93;   % 810:             addi t4,a1,-1  # Checks 1 tile above player's Y %
00001dad : 01de0a63;   % 811:             beq t3,t4,PLAYER_COLLISION_RIDLEY_ABOVE     # If Ridley's X is above the player %
00001dae : 0440006f;   % 813:             j PLAYER_COLLISION_PLASMA_BREATH # Otherwise, Ridley isn't near player enough to deal damage, check Plasma Breath  %
00001daf : 0022ce03;   % 816:                 lbu t3,2(t0)   # Loads Ridley's current Y offset %
00001db0 : 02de4263;   % 817:                 blt t3,a3,PLAYER_COLLISION_RIDLEY_HIT # If Ridley's "Y offset" is less than the player's Y offset deal damage %
00001db1 : 0380006f;   % 818:                     j PLAYER_COLLISION_PLASMA_BREATH # Otherwise, Ridley isn't near player enough to deal damage, check Plasma Breath  %
00001db2 : 00070463;   % 821:                 beqz a4,CONTINUE_PLAYER_COLLISION_RIDLEY_ABOVE  # If not on morph ball, check if it was a hit %
00001db3 : 0300006f;   % 822:                     j PLAYER_COLLISION_PLASMA_BREATH # Otherwise, Ridley isn't near player enough to deal damage, check Plasma Breath  %
00001db4 : 0032ce03;   % 825:                 lbu t3,3(t0)   # Loads Ridley's Y offset %
00001db5 : e5c6c6e3;   % 826:                 bgt t3,a3,PLAYER_COLLISION_ZOOMER_LOOP_HIT # If Ridley's adjusted Y offset is greater than the player's Y offset deal damage %
00001db6 : 0240006f;   % 827:                     j PLAYER_COLLISION_PLASMA_BREATH # Otherwise, Ridley isn't near player enough to deal damage, check Plasma Breath  %
00001db7 : 00070463;   % 830:                 beqz a4,PLAYER_COLLISION_RIDLEY_HIT  # If not on morph ball, check it was a hit %
00001db8 : 01c0006f;   % 832:                     j PLAYER_COLLISION_PLASMA_BREATH # Otherwise, Ridley isn't near player enough to deal damage, check Plasma Breath  %
00001db9 : 00000513;   % 836:                 li a0,0  # Hit was from same X %
00001dba : 00800593;   % 837:                 li a1,8  # Damage dealt %
00001dbb : 00400633;   % 838:                 mv a2,tp # Gets direction %
00001dbc : fffff317;   % 839:                 call DAMAGE_PLAYER %
00001dbd : 400300e7;   % 839:  %
00001dbe : 1200006f;   % 840:                 j END_PLAYER_COLLISION  # Player already took damage, end procedure here      %
00001dbf : 0fc0b297;   % 843:         la t0,PLASMA_BREATH_ARRAY  # Loads Plasma breath array %
00001dc0 : d5c28293;   % 843:  %
00001dc1 : 00000393;   % 845:         li t2,0 # resets counter %
00001dc2 : 00500313;   % 846:         li t1,5 # gets number of plasma breaths in game %
00001dc3 : 0002ce03;   % 848:             lbu t3,0(t0) # Loads enable byte %
00001dc4 : 000e1463;   % 849:             bnez t3,PLAYER_COLLISION_PLASMA_BREATH_LOOP_CONTINUE    # If enabled, %
00001dc5 : 0f40006f;   % 850:                 j NEXT_IN_PLAYER_COLLISION_PLASMA_BREATH_LOOP       # Otherwise, check other plasma breaths %
00001dc6 : 00300213;   % 853:             li tp, 3 # tp will start as 3 (random direction)  %
00001dc7 : 0062ce03;   % 854:             lbu t3,6(t0)   # Loads plasma breath's current X %
00001dc8 : 00ae0c63;   % 855:             beq t3,a0,PLAYER_COLLISION_PLASMA_BREATH_LOOP_SAME_X   # If plasma breath's X is the same as the player's %
00001dc9 : 00150e93;   % 856:             addi t4,a0,1   # Checks player's tile to the right %
00001dca : 05de0263;   % 857:             beq t3,t4,PLAYER_COLLISION_PLASMA_BREATH_LOOP_RIGHT_X  # If plasma breath's X is to the right of player %
00001dcb : fff50e93;   % 858:             addi t4,a0,-1  # Checks player's tile to the left %
00001dcc : 03de0263;   % 859:             beq t3,t4,PLAYER_COLLISION_PLASMA_BREATH_LOOP_LEFT_X   # If plasma breath's X is to the left of player %
00001dcd : 0d40006f;   % 860:             j NEXT_IN_PLAYER_COLLISION_PLASMA_BREATH_LOOP # Otherwise, plasma breath isn't near player enough to deal damage, check next %
00001dce : 0032ce03;   % 863:                 lbu t3,3(t0)   # Loads plasma breath's X offset %
00001dcf : 00ce0463;   % 864:                 beq t3,a2,PLAYER_COLLISION_PLASMA_BREATH_LOOP_SAME_X_RANDOM # If offsets are the same, randomize direction %
00001dd0 : 00ce2233;   % 866:                     slt tp,t3,a2   # If t3 < a2, damage is from the left, otherwise, it is from the right  %
00001dd1 : 00c00e93;   % 868:                     li t4,12       # to be compared with  %
00001dd2 : 41c60e33;   % 869:                     sub t3,a2,t3   # t3 = plasma breath's x offset - player's x offset %
00001dd3 : 03de4c63;   % 870:                     blt t3,t4,PLAYER_COLLISION_PLASMA_BREATH_LOOP_CHECK_Y # If t3 < 12, continue %
00001dd4 : 0b80006f;   % 871:                         j NEXT_IN_PLAYER_COLLISION_PLASMA_BREATH_LOOP # Otherwise, plasma breath isn't near player enough to deal damage, check next %
00001dd5 : 0032ce03;   % 874:                 lbu t3,3(t0)   # Loads plasma breath's X offset %
00001dd6 : ffce0e13;   % 875:                 addi t3,t3,-4  # subtracts 4 from it %
00001dd7 : 01c65663;   % 876:                 bge a2,t3,STOP_PLAYER_COLLISION_PLASMA_BREATH_LOOP_LEFT_X # If t3 <= player offset, there wasn't a hit %
00001dd8 : 00100213;   % 877:                     li tp,1    # Damage from the left %
00001dd9 : 0200006f;   % 878:                     j PLAYER_COLLISION_PLASMA_BREATH_LOOP_CHECK_Y %
00001dda : 0a00006f;   % 880:                     j NEXT_IN_PLAYER_COLLISION_PLASMA_BREATH_LOOP # Zoomer isn't near player enough to deal damage, check next %
00001ddb : 0032ce03;   % 883:                 lbu t3,3(t0)   # Loads plasma breath's X offset %
00001ddc : 004e0e13;   % 884:                 addi t3,t3,4   # adds 4 to it %
00001ddd : 00ce5663;   % 885:                 bge t3,a2,STOP_PLAYER_COLLISION_PLASMA_BREATH_LOOP_RIGHT_X # If t3 >= player offset, there wasn't a hit %
00001dde : 00000213;   % 886:                     li tp,0    # Damage from the right %
00001ddf : 0080006f;   % 887:                     j PLAYER_COLLISION_PLASMA_BREATH_LOOP_CHECK_Y %
00001de0 : 0880006f;   % 889:                     j NEXT_IN_PLAYER_COLLISION_PLASMA_BREATH_LOOP # Zoomer isn't near player enough to deal damage, check next %
00001de1 : 0082ce03;   % 892:                 lbu t3,8(t0)   # Loads plasma breath's current Y %
00001de2 : 04be0a63;   % 893:                 beq t3,a1,PLAYER_COLLISION_PLASMA_BREATH_LOOP_SAME_Y    # If plasma breath's Y is the same as the player's %
00001de3 : 00158e93;   % 894:                 addi t4,a1,1   # Checks player's base tile (Y + 1) %
00001de4 : 03de0463;   % 895:                 beq t3,t4,PLAYER_COLLISION_PLASMA_BREATH_LOOP_BASE  # If plasma breath's Y on player's base %
00001de5 : 00258e93;   % 896:                 addi t4,a1,2   # Checks bellow player's base tile (Y + 2) %
00001de6 : 01de0863;   % 897:                 beq t3,t4,PLAYER_COLLISION_PLASMA_BREATH_LOOP_BELLOW  # If plasma breath's X is bellow player %
00001de7 : fff58e93;   % 898:                 addi t4,a1,-1  # Checks 1 tile above player's Y %
00001de8 : 03de0463;   % 899:                 beq t3,t4,PLAYER_COLLISION_PLASMA_BREATH_LOOP_ABOVE     # If plasma breath's X is above the player %
00001de9 : 0640006f;   % 900:                 j NEXT_IN_PLAYER_COLLISION_PLASMA_BREATH_LOOP # Otherwise, plasma breath isn't near player enough to deal damage, check next %
00001dea : 0042ce03;   % 903:                     lbu t3,4(t0)   # Loads plasma breath's Y offset %
00001deb : 008e0e13;   % 904:                     addi t3,t3,8 %
00001dec : 02de4e63;   % 905:                     blt t3,a3,PLAYER_COLLISION_PLASMA_BREATH_LOOP_HIT # If plasma breath's Y offset is less than the player's Y offset deal damage %
00001ded : 0540006f;   % 906:                         j NEXT_IN_PLAYER_COLLISION_PLASMA_BREATH_LOOP # Otherwise, plasma breath isn't near player enough to deal damage, check next %
00001dee : 0042ce03;   % 909:                     lbu t3,4(t0)   # Loads plasma breath's Y offset %
00001def : 008e0e13;   % 910:                     addi t3,t3,8 %
00001df0 : 02de4663;   % 911:                     blt t3,a3,PLAYER_COLLISION_PLASMA_BREATH_LOOP_HIT # If plasma breath's Y offset is less than the player's Y offset deal damage %
00001df1 : 0440006f;   % 912:                         j NEXT_IN_PLAYER_COLLISION_PLASMA_BREATH_LOOP # Otherwise, plasma breath isn't near player enough to deal damage, check next %
00001df2 : 00070463;   % 915:                     beqz a4,CONTINUE_PLAYER_COLLISION_PLASMA_BREATH_LOOP_ABOVE  # If not on morph ball, check if it was a hit %
00001df3 : 03c0006f;   % 916:                         j NEXT_IN_PLAYER_COLLISION_PLASMA_BREATH_LOOP # Otherwise, plasma breath isn't near player enough to deal damage, check next %
00001df4 : 0042ce03;   % 919:                     lbu t3,4(t0)   # Loads plasma breath's Y offset %
00001df5 : 01c6cc63;   % 920:                     bgt t3,a3,PLAYER_COLLISION_PLASMA_BREATH_LOOP_HIT # If plasma breath's Y offset is greater than the player's Y offset deal damage %
00001df6 : 0300006f;   % 921:                         j NEXT_IN_PLAYER_COLLISION_PLASMA_BREATH_LOOP # Otherwise, plasma breath isn't near player enough to deal damage, check next %
00001df7 : 00070863;   % 924:                     beqz a4,PLAYER_COLLISION_PLASMA_BREATH_LOOP_HIT  # If not on morph ball, it was a hit %
00001df8 : 0042ce03;   % 926:                     lbu t3,4(t0)   # Loads plasma breath's Y offset %
00001df9 : 01c6c463;   % 927:                     bgt t3,a3,PLAYER_COLLISION_PLASMA_BREATH_LOOP_HIT # If plasma breath's Y offset is greater than the player's Y offset deal damage %
00001dfa : 0200006f;   % 928:                         j NEXT_IN_PLAYER_COLLISION_PLASMA_BREATH_LOOP # Otherwise, plasma breath isn't near player enough to deal damage, check next %
00001dfb : 00028023;   % 932:                     sb zero,0(t0)     # Disables plasma breath %
00001dfc : 00000513;   % 933:                     li a0,0  # Hit was from same X %
00001dfd : 00800593;   % 934:                     li a1,8  # Damage dealt %
00001dfe : 00400633;   % 935:                     mv a2,tp # Gets direction %
00001dff : fffff317;   % 936:                     call DAMAGE_PLAYER %
00001e00 : 2f4300e7;   % 936:  %
00001e01 : 0140006f;   % 937:                     j END_PLAYER_COLLISION  # Player already took damage, end procedure here                 %
00001e02 : 00a28293;   % 940:             addi t0,t0,10  # Going to the next plasma breath's address                                   %
00001e03 : 00138393;   % 941:             addi t2,t2,1            # Iterating counter by 1                                    %
00001e04 : 0063d463;   % 942:             bge t2,t1, END_PLAYER_COLLISION       # If all of the plasma breaths were checked, end loop                               %
00001e05 : ef9ff06f;   % 943:             j PLAYER_COLLISION_PLASMA_BREATH_LOOP # otherwise, go back to the loop's beginning  %
00001e06 : 00012083;   % 947:         lw ra,0(sp) %
00001e07 : 00410113;   % 948:         addi sp,sp,4 %
00001e08 : 00008067;   % 950:         ret  %
00001e09 : ffc10113;   % 977:     addi sp,sp,-4 %
00001e0a : 00112023;   % 978:     sw ra,0(sp) %
00001e0b : 0fc0b517;   % 980:     la a0,BEAMS_ARRAY   # Loads Beams array %
00001e0c : 93250513;   % 980:  %
00001e0d : 00150513;   % 981:     addi a0,a0,1        # skips cooldown byte %
00001e0e : 00000613;   % 983:     li a2,0             # resets counter %
00001e0f : 00300593;   % 984:     li a1,3  # gets number of beams in game %
00001e10 : 00054283;   % 986:         lbu t0,0(a0) # Loads enable byte %
00001e11 : 00029463;   % 987:         bnez t0,BEAM_COLLISION_LOOP_CONTINUE    # If enabled, %
00001e12 : 49c0006f;   % 988:             j NEXT_IN_BEAM_COLLISION_LOOP       # Otherwise, check other beams %
00001e13 : 00554683;   % 991:         lbu a3, 5(a0)      # Loads Player's current X (matrix) %
00001e14 : 00754703;   % 992:         lbu a4, 7(a0)     # Loads Player's current Y (matrix)   %
00001e15 : 00354783;   % 993:         lbu a5, 3(a0)      # Loads Player's current X offset %
00001e16 : 00454803;   % 994:         lbu a6, 4(a0)      # Loads Player's current Y offset %
00001e17 : 0fc0b297;   % 996:         la t0,CURRENT_MAP             # Loads map address %
00001e18 : 8a428293;   % 996:  %
00001e19 : 0042c283;   % 997:         lbu t0,4(t0)                  # and from it, loads map's number %
00001e1a : 00700313;   % 998:         li t1,7                       # Loads 7 to compare with map's number %
00001e1b : 00629463;   % 999:         bne t0,t1,BEAM_COLLISION_SKIP_RIDLEY         # If not on map 7, skip Ridley and Plasma Breath >:D %
00001e1c : 2180006f;   % 1000:             j BEAM_COLLISION_RIDLEY # Otherwise, skip the rest of the checks %
00001e1d : 0fc0b297;   % 1005:         la t0,Zoomers  # Loads Zoomers address %
00001e1e : 9c428293;   % 1005:  %
00001e1f : 0002a283;   % 1007:         lw t0,0(t0)    # Loads the ZoomersA address over the Zoomers address %
00001e20 : 00029463;   % 1008:         bnez t0,CONTINUE_BEAM_COLLISION_ZOOMER  # If there are zoomers in this map %
00001e21 : 13c0006f;   % 1009:             j BEAM_COLLISION_RIPPER             # If t0 = 0, there are no zoomers in this map %
00001e22 : 0002c303;   % 1013:         lbu t1,0(t0)   # Loads number of Zoomers in current map %
00001e23 : 00000393;   % 1014:         li t2,0        # Counter for zoomers %
00001e24 : 00128293;   % 1015:         addi t0,t0,1   # Goes to next byte (where zoomers from current map start) %
00001e25 : 00028e03;   % 1018:             lb t3,0(t0) # Loads zoomer's health %
00001e26 : 01c04463;   % 1019:             blt zero,t3,CONTINUE_BEAM_COLLISION_ZOOMER_LOOP # If zoomer is alive %
00001e27 : 1140006f;   % 1021:                 j NEXT_IN_BEAM_COLLISION_ZOOMER_LOOP %
00001e28 : 0042ce03;   % 1024:             lbu t3,4(t0)   # Loads zoomer's current X %
00001e29 : 00de0c63;   % 1025:             beq t3,a3,BEAM_COLLISION_ZOOMER_LOOP_SAME_X   # If zoomer's X is the same as the beam %
00001e2a : 00168e93;   % 1026:             addi t4,a3,1   # Checks beam's tile to the right %
00001e2b : 03de0c63;   % 1027:             beq t3,t4,BEAM_COLLISION_ZOOMER_LOOP_RIGHT_X  # If zoomer's X is to the right of beam %
00001e2c : fff68e93;   % 1028:             addi t4,a3,-1  # Checks beam's tile to the left %
00001e2d : 03de0063;   % 1029:             beq t3,t4,BEAM_COLLISION_ZOOMER_LOOP_LEFT_X   # If zoomer's X is to the left of beam %
00001e2e : 0f80006f;   % 1030:             j NEXT_IN_BEAM_COLLISION_ZOOMER_LOOP # Otherwise, zoomer isn't near beam enough be hit, check next %
00001e2f : 0022ce03;   % 1033:                     lbu t3,2(t0)   # Loads zoomer's X offset %
00001e30 : 02fe0a63;   % 1034:                     beq t3,a5,BEAM_COLLISION_ZOOMER_LOOP_CHECK_Y # If offsets are the same, continue to check Y %
00001e31 : 00c00e93;   % 1035:                     li t4,12       # to be compared with  %
00001e32 : 41c78e33;   % 1036:                     sub t3,a5,t3   # t3 = zoomer's x offset - beam's x offset %
00001e33 : 03de4463;   % 1037:                     blt t3,t4,BEAM_COLLISION_ZOOMER_LOOP_CHECK_Y # If t3 < 12, continue %
00001e34 : 0e00006f;   % 1038:                         j NEXT_IN_BEAM_COLLISION_ZOOMER_LOOP # Otherwise, zoomer isn't near beam enough be hit, check next %
00001e35 : 0022ce03;   % 1041:                     lbu t3,2(t0)   # Loads zoomer's X offset %
00001e36 : ff8e0e13;   % 1042:                     addi t3,t3,-8  # subtracts 4 from it %
00001e37 : 00fe5c63;   % 1043:                     bge t3,a5,BEAM_COLLISION_ZOOMER_LOOP_CHECK_Y # If t3 - 8 >= beam's offset, continue to check Y %
00001e38 : 0d00006f;   % 1044:                         j NEXT_IN_BEAM_COLLISION_ZOOMER_LOOP # Otherwise, zoomer isn't near beam enough be hit, check next %
00001e39 : 0022ce03;   % 1047:                     lbu t3,2(t0)   # Loads zoomer's X offset %
00001e3a : ff878e93;   % 1048:                     addi t4,a5,-8  # Subtracts 8 from beam offset %
00001e3b : 01c7d463;   % 1049:                     bge a5,t3,BEAM_COLLISION_ZOOMER_LOOP_CHECK_Y # If t3 <= beam's offset - 8, continue to check Y %
00001e3c : 0c00006f;   % 1050:                         j NEXT_IN_BEAM_COLLISION_ZOOMER_LOOP # Otherwise, zoomer isn't near beam enough be hit, check next %
00001e3d : 0062ce03;   % 1053:                 lbu t3,6(t0)   # Loads zoomer's current Y %
00001e3e : 00ee0e63;   % 1054:                 beq t3,a4,BEAM_COLLISION_ZOOMER_LOOP_SAME_Y    # If zoomer's Y is the same as the beam's %
00001e3f : 00170e93;   % 1055:                 addi t4,a4,1   # Checks beam's base tile (Y + 1) %
00001e40 : 01de0463;   % 1056:                 beq t3,t4,BEAM_COLLISION_ZOOMER_LOOP_BELLOW  # If zoomer's Y on beam's base %
00001e41 : 0ac0006f;   % 1057:                 j NEXT_IN_BEAM_COLLISION_ZOOMER_LOOP # Otherwise, zoomer isn't near beam enough be hit, check next %
00001e42 : 0032ce03;   % 1060:                     lbu t3,3(t0)   # Loads zoomer's Y offset %
00001e43 : 010e4c63;   % 1061:                     blt t3,a6,BEAM_COLLISION_ZOOMER_LOOP_HIT # If zoomer's Y offset is less than the beam's Y offset deal damage %
00001e44 : 0a00006f;   % 1062:                         j NEXT_IN_BEAM_COLLISION_ZOOMER_LOOP # Otherwise, zoomer isn't near beam enough be hit, check next %
00001e45 : 0032ce03;   % 1065:                     lbu t3,3(t0)   # Loads zoomer's Y  %
00001e46 : 008e0e13;   % 1066:                     addi t3,t3,8   #  %
00001e47 : 010e5463;   % 1067:                     bge t3,a6,BEAM_COLLISION_ZOOMER_LOOP_HIT # If zoomer's Y offset + 8 is greater than the beam's Y offset deal damage %
00001e48 : 0900006f;   % 1068:                         j NEXT_IN_BEAM_COLLISION_ZOOMER_LOOP # Otherwise, zoomer isn't near beam enough be hit, check next %
00001e49 : 0002ce03;   % 1072:                     lbu t3,0(t0)   # Loads zoomer's health %
00001e4a : 060e0c63;   % 1073:                     beqz t3,BEAM_COLLISION_ZOOMER_LOOP_HIT_DISABLE_BEAM    # Zoomer is already dead %
00001e4b : fffe0e13;   % 1074:                     addi t3,t3,-1  # Takes 1 away from it %
00001e4c : 000e0c63;   % 1075:                     beqz t3,BEAM_COLLISION_ZOOMER_LOOP_HIT_DESTROY_ZOOMER  # If zoomer is killed %
00001e4d : 01c28023;   % 1076:                         sb t3,0(t0)    # and stores it back %
00001e4e : 0012ce03;   % 1077:                         lbu t3,1(t0)   # Loads zoomer's type %
00001e4f : 002e0e13;   % 1078:                         addi t3,t3,2   # Adds 2 to it ( will go to damage state) %
00001e50 : 01c280a3;   % 1079:                         sb t3,1(t0)    # and stores it back %
00001e51 : 05c0006f;   % 1080:                         j BEAM_COLLISION_ZOOMER_LOOP_HIT_DISABLE_BEAM %
00001e52 : 00028023;   % 1083:                         sb zero,0(t0)  # Stores 0 to zoomer's health %
00001e53 : 0022c583;   % 1084:                         lbu a1,2(t0)   # Loads zoomer's X offset %
00001e54 : 0032c603;   % 1085:                         lbu a2,3(t0)   # Loads zoomer's Y offset %
00001e55 : 0042c683;   % 1086:                         lbu a3,4(t0)   # Loads zoomer's X  %
00001e56 : 0062c703;   % 1087:                         lbu a4,6(t0)   # Loads zoomer's Y %
00001e57 : 00000793;   % 1088:                         li a5,0        # No Delay %
00001e58 : ff810113;   % 1090:                             addi sp,sp,-8 %
00001e59 : 00a12023;   % 1091:                             sw a0,0(sp) %
00001e5a : 00512223;   % 1092:                             sw t0,4(sp) %
00001e5b : 00000513;   % 1095:                             li a0, 0       # Small explosion %
00001e5c : ffffb317;   % 1096:                             call EXPLOSION_SPAWN   # Summons explosion %
00001e5d : 684300e7;   % 1096:  %
00001e5e : 00412283;   % 1098:                             lw t0,4(sp)    # Restores zoomer's address %
00001e5f : 00b2c503;   % 1099:                             lbu a0,11(t0)  # Loads zoomer's loot value %
00001e60 : 0022c583;   % 1100:                             lbu a1,2(t0)   # Loads zoomer's X offset %
00001e61 : 0032c603;   % 1101:                             lbu a2,3(t0)   # Loads zoomer's Y offset %
00001e62 : 0042c683;   % 1102:                             lbu a3,4(t0)   # Loads zoomer's X  %
00001e63 : 0062c703;   % 1103:                             lbu a4,6(t0)   # Loads zoomer's Y %
00001e64 : ffffb317;   % 1104:                             call LOOT_SPAWN   # Summons explosion %
00001e65 : 48c300e7;   % 1104:  %
00001e66 : 00012503;   % 1107:                             lw a0,0(sp) %
00001e67 : 00810113;   % 1109:                             addi sp,sp,8 %
00001e68 : 00300313;   % 1114:                         li t1,3           # Loads "Hit to be Disabled"  %
00001e69 : 00650023;   % 1115:                         sb t1,0(a0)       # and stores it on enable byte %
00001e6a : 00050123;   % 1116:                         sb zero,2(a0)     # Resets render counter %
00001e6b : 3380006f;   % 1117:                         j NEXT_IN_BEAM_COLLISION_LOOP  # Beam was deactivated, end procedure here                %
00001e6c : 00c28293;   % 1120:                 addi t0,t0,12   # Going to the next zoomer's address                                   %
00001e6d : 00138393;   % 1121:                 addi t2,t2,1             # Iterating counter by 1                                    %
00001e6e : 0063d463;   % 1122:                 bge t2,t1, BEAM_COLLISION_RIPPER # If all of the zoomers were checked, end loop                                   %
00001e6f : ed9ff06f;   % 1123:                 j BEAM_COLLISION_ZOOMER_LOOP # otherwise, go back to the loop's beginning                      %
00001e70 : 0fc0b297;   % 1126:         la t0,Rippers  # Loads Rippers address %
00001e71 : a3828293;   % 1126:  %
00001e72 : 0002a283;   % 1128:         lw t0,0(t0)    # Loads the RippersA address over the Rippers address %
00001e73 : 00029463;   % 1129:         bnez t0,CONTINUE_BEAM_COLLISION_RIPPER  # If there are rippers in this map %
00001e74 : 3140006f;   % 1130:             j NEXT_IN_BEAM_COLLISION_LOOP             # If t0 = 0, there are no rippers in this map %
00001e75 : 0002c303;   % 1134:         lbu t1,0(t0)   # Loads number of Rippers in current map %
00001e76 : 00000393;   % 1135:         li t2,0        # Counter for rippers %
00001e77 : 00128293;   % 1136:         addi t0,t0,1   # Goes to next byte (where rippers from current map start) %
00001e78 : 00300213;   % 1139:             li tp, 3 # tp will start as 3 (random direction)  %
00001e79 : 0032ce03;   % 1140:             lbu t3,3(t0)   # Loads ripper's current X %
00001e7a : 00de0c63;   % 1141:             beq t3,a3,BEAM_COLLISION_RIPPER_LOOP_SAME_X   # If ripper's X is the same as the player's %
00001e7b : 00168e93;   % 1142:             addi t4,a3,1   # Checks player's tile to the right %
00001e7c : 03de0c63;   % 1143:             beq t3,t4,BEAM_COLLISION_RIPPER_LOOP_RIGHT_X  # If ripper's X is to the right of player %
00001e7d : fff68e93;   % 1144:             addi t4,a3,-1  # Checks player's tile to the left %
00001e7e : 03de0063;   % 1145:             beq t3,t4,BEAM_COLLISION_RIPPER_LOOP_LEFT_X   # If ripper's X is to the left of player %
00001e7f : 0780006f;   % 1146:             j NEXT_IN_BEAM_COLLISION_RIPPER_LOOP # Otherwise, ripper isn't near player enough to deal damage, check next %
00001e80 : 0022ce03;   % 1149:                 lbu t3,2(t0)   # Loads ripper's X offset %
00001e81 : 02fe0a63;   % 1150:                 beq t3,a5,BEAM_COLLISION_RIPPER_LOOP_CHECK_Y # If offsets are the same, continue to check Y %
00001e82 : 00c00e93;   % 1151:                 li t4,12       # to be compared with  %
00001e83 : 41c78e33;   % 1152:                 sub t3,a5,t3   # t3 = ripper's x offset - beam's x offset %
00001e84 : 03de4463;   % 1153:                 blt t3,t4,BEAM_COLLISION_RIPPER_LOOP_CHECK_Y # If t3 < 12, continue %
00001e85 : 0600006f;   % 1154:                     j NEXT_IN_BEAM_COLLISION_RIPPER_LOOP # Otherwise, ripper isn't near beam enough be hit, check next %
00001e86 : 0022ce03;   % 1157:                 lbu t3,2(t0)   # Loads ripper's X offset %
00001e87 : ff8e0e13;   % 1158:                 addi t3,t3,-8  # subtracts 4 from it %
00001e88 : 00fe5c63;   % 1159:                 bge t3,a5,BEAM_COLLISION_RIPPER_LOOP_CHECK_Y # If t3 - 8 >= beam's offset, continue to check Y %
00001e89 : 0500006f;   % 1160:                     j NEXT_IN_BEAM_COLLISION_RIPPER_LOOP # Otherwise, ripper isn't near beam enough be hit, check next %
00001e8a : 0022ce03;   % 1163:                 lbu t3,2(t0)   # Loads ripper's X offset %
00001e8b : ff878e93;   % 1164:                 addi t4,a5,-8  # Subtracts 8 from beam offset %
00001e8c : 01c7d463;   % 1165:                 bge a5,t3,BEAM_COLLISION_RIPPER_LOOP_CHECK_Y # If t3 <= beam's offset - 8, continue to check Y %
00001e8d : 0400006f;   % 1166:                     j NEXT_IN_BEAM_COLLISION_RIPPER_LOOP # Otherwise, ripper isn't near beam enough be hit, check next %
00001e8e : 0052ce03;   % 1169:                 lbu t3,5(t0)   # Loads ripper's current Y %
00001e8f : 00ee0e63;   % 1170:                 beq t3,a4,BEAM_COLLISION_RIPPER_LOOP_SAME_Y    # If ripper's Y is the same as the player's %
00001e90 : 00170e93;   % 1171:                 addi t4,a4,1   # Checks bellow beam (Y + 1) %
00001e91 : 01de0463;   % 1172:                 beq t3,t4,BEAM_COLLISION_RIPPER_LOOP_BELLOW  # If ripper's Y is bellow beam %
00001e92 : 02c0006f;   % 1174:                 j NEXT_IN_BEAM_COLLISION_RIPPER_LOOP # Otherwise, ripper isn't near beam enough be hit, check next %
00001e93 : 00700e13;   % 1177:                     li t3, 7 # Ripper's Y offset is always 0, but we add 7 to it (sprite is 4 pixels bellow initial Y) %
00001e94 : 010e4a63;   % 1178:                     blt t3,a6,BEAM_COLLISION_RIPPER_LOOP_HIT # If ripper's "Y offset" is less than the player's Y offset hit ripper %
00001e95 : 0200006f;   % 1179:                         j NEXT_IN_BEAM_COLLISION_RIPPER_LOOP # Otherwise, ripper isn't near beam enough be hit, check next %
00001e96 : 00c00e13;   % 1182:                     li t3, 12 # Ripper's Y offset is always 0, but we add 12 to it (sprite end 4 lines befor its real end) %
00001e97 : 01c84463;   % 1183:                     bgt t3,a6,BEAM_COLLISION_RIPPER_LOOP_HIT # If ripper's "Y offset" is greater than the player's Y offset hit ripper %
00001e98 : 0140006f;   % 1184:                         j NEXT_IN_BEAM_COLLISION_RIPPER_LOOP # Otherwise, ripper isn't near beam enough be hit, check next %
00001e99 : 00300313;   % 1188:                     li t1,3           # Loads "Hit to be Disabled"  %
00001e9a : 00650023;   % 1189:                     sb t1,0(a0)       # and stores it on enable byte %
00001e9b : 00050123;   % 1190:                     sb zero,2(a0)     # Resets render counter %
00001e9c : 2740006f;   % 1191:                     j NEXT_IN_BEAM_COLLISION_LOOP  # Beam was deactivated, end procedure here             %
00001e9d : 00728293;   % 1194:                 addi t0,t0,7   # Going to the next ripper's address                                   %
00001e9e : 00138393;   % 1195:                 addi t2,t2,1             # Iterating counter by 1                                    %
00001e9f : 0063d463;   % 1196:                 bge t2,t1, BEAM_COLLISION_RIDLEY_SKIP # If all of the rippers were checked, end loop                                   %
00001ea0 : f61ff06f;   % 1197:                 j BEAM_COLLISION_RIPPER_LOOP # otherwise, go back to the loop's beginning   %
00001ea1 : 2600006f;   % 1200:             j NEXT_IN_BEAM_COLLISION_LOOP %
00001ea2 : 0fc0b297;   % 1203:             la t0,RIDLEY_INFO %
00001ea3 : 9c028293;   % 1203:  %
00001ea4 : 00028303;   % 1204:             lb t1,0(t0) # Loads Ridley's health %
00001ea5 : 00604463;   % 1205:             blt zero,t1,CONTINUE_BEAM_COLLISION_RIDLEY # If Ridley is alive %
00001ea6 : 24c0006f;   % 1206:                 j NEXT_IN_BEAM_COLLISION_LOOP %
00001ea7 : 00100213;   % 1209:             li tp, 1 # tp will start as left %
00001ea8 : 00900e13;   % 1210:             li t3,9   # Loads Ridley's current X %
00001ea9 : 02de0863;   % 1211:             beq t3,a3,BEAM_COLLISION_RIDLEY_CHECK_Y   # If Ridley's X is the same as the beam's %
00001eaa : 00168e93;   % 1212:             addi t4,a3,1   # Checks beam's tile to the right %
00001eab : 01de0e63;   % 1213:             beq t3,t4,BEAM_COLLISION_RIDLEY_RIGHT_X  # If Ridley's X is to the right of beam %
00001eac : fff68e93;   % 1214:             addi t4,a3,-1  # Checks beam's tile to the left %
00001ead : 01de0463;   % 1215:             beq t3,t4,BEAM_COLLISION_RIDLEY_LEFT_X   # If Ridley's X is to the left of beam %
00001eae : 1600006f;   % 1216:             j BEAM_COLLISION_PLASMA_BREATH # Otherwise, Ridley isn't near beam to be hit, check Plasma Breath %
00001eaf : 00600e13;   % 1219:                 li t3,6   # Loads Ridley's X offset %
00001eb0 : 01c7ca63;   % 1220:                 blt a5,t3,BEAM_COLLISION_RIDLEY_CHECK_Y # If t3 < beam offset, check Y %
00001eb1 : 1540006f;   % 1221:                 j BEAM_COLLISION_PLASMA_BREATH # Otherwise, Ridley isn't near beam to be hit, check Plasma Breath %
00001eb2 : 00600e13;   % 1224:                 li t3,6   # Loads Ridley's X offset %
00001eb3 : 00fe4463;   % 1225:                 blt t3,a5,BEAM_COLLISION_RIDLEY_CHECK_Y # If t3 < beam offset, there wasn't a hit %
00001eb4 : 1480006f;   % 1226:                 j BEAM_COLLISION_PLASMA_BREATH # Otherwise, Ridley isn't near beam to be hit, check Plasma Breath      %
00001eb5 : 0032ce03;   % 1229:                 lbu t3,3(t0)   # Loads Ridley's current Y %
00001eb6 : 02ee0e63;   % 1230:                 beq t3,a4,BEAM_COLLISION_RIDLEY_HIT    # If Ridley's Y is the same as the beam's (beam would basically be inside him) %
00001eb7 : 00170e93;   % 1231:                 addi t4,a4,1   # Checks beam's base tile (Y + 1) %
00001eb8 : 01de0c63;   % 1232:                 beq t3,t4,BEAM_COLLISION_RIDLEY_BELLOW  # If Ridley's Y is bellow beam %
00001eb9 : 001e0e13;   % 1234:                 addi t3,t3,1   # Gets ridley's Y + 1 %
00001eba : 02ee0663;   % 1235:                 beq t3,a4,BEAM_COLLISION_RIDLEY_HIT    # If Ridley's Y + 1 is the same as the beam's, it's a hit (beam would basically be inside him) %
00001ebb : 001e0e13;   % 1237:                 addi t3,t3,1   # Gets ridley's Y + 2 %
00001ebc : 00ee0a63;   % 1238:                 beq t3,a4,BEAM_COLLISION_RIDLEY_SAME_Y    # If Ridley's Y + 2 is the same as the beam's %
00001ebd : 1240006f;   % 1240:                 j BEAM_COLLISION_PLASMA_BREATH # Otherwise, Ridley isn't near beam to be hit, check Plasma Breath    %
00001ebe : 0022ce03;   % 1243:                     lbu t3,2(t0)   # Loads Ridley's current Y offset %
00001ebf : 010e4c63;   % 1244:                     blt t3,a6,BEAM_COLLISION_RIDLEY_HIT # If Ridley's "Y offset" is less than the beam's Y offset deal damage %
00001ec0 : 1180006f;   % 1245:                         j BEAM_COLLISION_PLASMA_BREATH # Otherwise, Ridley isn't near beam to be hit, check Plasma Breath    %
00001ec1 : 0022ce03;   % 1248:                     lbu t3,2(t0)   # Loads Ridley's current Y offset %
00001ec2 : 008e0e13;   % 1249:                     addi t3,t3,8   #  %
00001ec3 : 010e5463;   % 1250:                     bge t3,a6,BEAM_COLLISION_RIDLEY_HIT # If ridley's Y offset + 8 is greater than the beam's Y offset deal damage %
00001ec4 : 1080006f;   % 1251:                         j BEAM_COLLISION_PLASMA_BREATH # Otherwise, Ridley isn't near beam to be hit, check Plasma Breath    %
00001ec5 : 0002ce03;   % 1255:                     lbu t3,0(t0)   # Loads Ridley's health %
00001ec6 : 0e0e0863;   % 1256:                     beqz t3,BEAM_COLLISION_RIDLEY_HIT_DISABLE_BEAM %
00001ec7 : fffe0e13;   % 1257:                     addi t3,t3,-1  # Takes 1 away from it %
00001ec8 : 000e0c63;   % 1258:                     beqz t3,BEAM_COLLISION_RIDLEY_HIT_DESTROY_RIDLEY  # If Ridley is killed %
00001ec9 : 01c28023;   % 1259:                         sb t3,0(t0)    # and stores it back %
00001eca : 0012ce03;   % 1260:                         lbu t3,1(t0)   # Loads Ridley's type %
00001ecb : 001e0e13;   % 1261:                         addi t3,t3,1   # Adds 1 to it ( will go to damage state) %
00001ecc : 01c280a3;   % 1262:                         sb t3,1(t0)    # and stores it back %
00001ecd : 0d40006f;   % 1263:                         j BEAM_COLLISION_RIDLEY_HIT_DISABLE_BEAM %
00001ece : 00028023;   % 1266:                         sb zero,0(t0)  # Stores 0 to Ridley's health %
00001ecf : 00600593;   % 1267:                         li a1,6   # Loads Ridley's X offset %
00001ed0 : 0022c603;   % 1268:                         lbu a2,2(t0)            # Loads Ridley's Y offset %
00001ed1 : 00900693;   % 1269:                         li a3,9          # Loads Ridley's X  %
00001ed2 : 0032c703;   % 1270:                         lbu a4,3(t0)            # Loads Ridley's Y %
00001ed3 : 00000793;   % 1271:                         li a5,0        # No Delay %
00001ed4 : ffc10113;   % 1273:                             addi sp,sp,-4 %
00001ed5 : 00a12023;   % 1274:                             sw a0,0(sp) %
00001ed6 : 00100513;   % 1276:                             li a0, 1               # Big explosion %
00001ed7 : ffffb317;   % 1277:                             call EXPLOSION_SPAWN   # Summons explosion %
00001ed8 : 498300e7;   % 1277:  %
00001ed9 : 0fc0b297;   % 1279:                             la t0,RIDLEY_INFO %
00001eda : 8e428293;   % 1279:  %
00001edb : 00600593;   % 1280:                             li a1,6   # Loads Ridley's X offset %
00001edc : 0022c603;   % 1281:                             lbu a2,2(t0)            # Loads Ridley's Y offset %
00001edd : 00900693;   % 1282:                             li a3,9          # Loads Ridley's X  %
00001ede : 00168693;   % 1283:                             addi a3,a3,1 %
00001edf : 0032c703;   % 1284:                             lbu a4,3(t0)            # Loads Ridley's Y %
00001ee0 : 00170713;   % 1285:                             addi a4,a4,1 %
00001ee1 : 00000793;   % 1286:                             li a5,0        # No Delay %
00001ee2 : 00100513;   % 1287:                             li a0, 1               # Big explosion %
00001ee3 : ffffb317;   % 1288:                             call EXPLOSION_SPAWN   # Summons explosion %
00001ee4 : 468300e7;   % 1288:  %
00001ee5 : 0fc0b297;   % 1290:                             la t0,RIDLEY_INFO %
00001ee6 : 8b428293;   % 1290:  %
00001ee7 : 00600593;   % 1291:                             li a1,6   # Loads Ridley's X offset %
00001ee8 : 0022c603;   % 1292:                             lbu a2,2(t0)            # Loads Ridley's Y offset %
00001ee9 : 00900693;   % 1293:                             li a3,9          # Loads Ridley's X  %
00001eea : fff68693;   % 1294:                             addi a3,a3,-1 %
00001eeb : 0032c703;   % 1295:                             lbu a4,3(t0)            # Loads Ridley's Y %
00001eec : 00270713;   % 1296:                             addi a4,a4,2 %
00001eed : 00000793;   % 1297:                             li a5,0        # No Delay %
00001eee : 00100513;   % 1298:                             li a0, 1               # Big explosion %
00001eef : ffffb317;   % 1299:                             call EXPLOSION_SPAWN   # Summons explosion %
00001ef0 : 438300e7;   % 1299:  %
00001ef1 : 00012503;   % 1302:                             lw a0,0(sp) %
00001ef2 : 00410113;   % 1303:                             addi sp,sp,4 %
00001ef3 : ff010113;   % 1307:                                 addi sp,sp,-16 %
00001ef4 : 00a12023;   % 1308:                                 sw a0,0(sp) %
00001ef5 : 00b12223;   % 1309:                                 sw a1,4(sp) %
00001ef6 : 00c12423;   % 1310:                                 sw a2,8(sp) %
00001ef7 : 00d12623;   % 1311:                                 sw a3,12(sp) %
00001ef8 : 00001317;   % 1314:                             call PLAY_ITEM_GET       %
00001ef9 : 598300e7;   % 1314:  %
00001efa : 00012503;   % 1317:                                 lw a0,0(sp) %
00001efb : 00412583;   % 1318:                                 lw a1,4(sp) %
00001efc : 00812603;   % 1319:                                 lw a2,8(sp) %
00001efd : 00c12683;   % 1320:                                 lw a3,12(sp) %
00001efe : 01010113;   % 1321:                                 addi sp,sp,16 %
00001eff : 00000993;   % 1325:                                 li s3,0 %
00001f00 : 00100913;   % 1326:                                 li s2,1   %
00001f01 : bedf806f;   % 1327:                                 j SETUP          # end procedure by going to setup %
00001f02 : 00300313;   % 1333:                         li t1,3           # Loads "Hit to be Disabled"  %
00001f03 : 00650023;   % 1334:                         sb t1,0(a0)       # and stores it on enable byte %
00001f04 : 00050123;   % 1335:                         sb zero,2(a0)     # Resets render counter %
00001f05 : 0d00006f;   % 1336:                         j NEXT_IN_BEAM_COLLISION_LOOP  # Beam was deactivated, end procedure here          %
00001f06 : 0fc0b297;   % 1339:             la t0,PLASMA_BREATH_ARRAY  # Loads Plasma breath array %
00001f07 : 84028293;   % 1339:  %
00001f08 : 00000393;   % 1341:             li t2,0 # resets counter %
00001f09 : 00500313;   % 1342:             li t1,5 # gets number of plasma breaths in game %
00001f0a : 0002ce03;   % 1344:                 lbu t3,0(t0) # Loads enable byte %
00001f0b : 000e1463;   % 1345:                 bnez t3,BEAM_COLLISION_PLASMA_BREATH_LOOP_CONTINUE    # If enabled, %
00001f0c : 0a40006f;   % 1346:                     j NEXT_IN_BEAM_COLLISION_PLASMA_BREATH_LOOP       # Otherwise, check other plasma breaths %
00001f0d : 00300213;   % 1349:                 li tp, 3 # tp will start as 3 (random direction)  %
00001f0e : 0062ce03;   % 1350:                 lbu t3,6(t0)   # Loads plasma breath's current X %
00001f0f : 00de0c63;   % 1351:                 beq t3,a3,BEAM_COLLISION_PLASMA_BREATH_LOOP_SAME_X   # If plasma breath's X is the same as the beam's %
00001f10 : 00168e93;   % 1352:                 addi t4,a3,1   # Checks beam's tile to the right %
00001f11 : 03de0c63;   % 1353:                 beq t3,t4,BEAM_COLLISION_PLASMA_BREATH_LOOP_RIGHT_X  # If plasma breath's X is to the right of beam %
00001f12 : fff68e93;   % 1354:                 addi t4,a3,-1  # Checks beam's tile to the left %
00001f13 : 03de0063;   % 1355:                 beq t3,t4,BEAM_COLLISION_PLASMA_BREATH_LOOP_LEFT_X   # If plasma breath's X is to the left of beam %
00001f14 : 0840006f;   % 1356:                 j NEXT_IN_BEAM_COLLISION_PLASMA_BREATH_LOOP # Otherwise, plasma breath isn't near beam enough to deal damage, check next %
00001f15 : 0032ce03;   % 1359:                         lbu t3,3(t0)   # Loads plasma breath's X offset %
00001f16 : 02fe0a63;   % 1360:                         beq t3,a5,BEAM_COLLISION_PLASMA_BREATH_LOOP_CHECK_Y # If offsets are the same, continue to check Y %
00001f17 : 00c00e93;   % 1361:                         li t4,12       # to be compared with  %
00001f18 : 41c78e33;   % 1362:                         sub t3,a5,t3   # t3 = plasma breath's x offset - beam's x offset %
00001f19 : 03de4463;   % 1363:                         blt t3,t4,BEAM_COLLISION_PLASMA_BREATH_LOOP_CHECK_Y # If t3 < 12, continue %
00001f1a : 06c0006f;   % 1364:                             j NEXT_IN_BEAM_COLLISION_PLASMA_BREATH_LOOP # Otherwise, plasma breath isn't near beam enough be hit, check next                   %
00001f1b : 0032ce03;   % 1367:                         lbu t3,3(t0)   # Loads plasma breath's X offset %
00001f1c : ff8e0e13;   % 1368:                         addi t3,t3,-8  # subtracts 4 from it %
00001f1d : 00fedc63;   % 1369:                         bge t4,a5,BEAM_COLLISION_PLASMA_BREATH_LOOP_CHECK_Y # If t3 <= player offset, there wasn't a hit %
00001f1e : 05c0006f;   % 1370:                             j NEXT_IN_BEAM_COLLISION_PLASMA_BREATH_LOOP # Otherwise, plasma breath isn't near beam enough be hit, check next %
00001f1f : 0032ce03;   % 1373:                         lbu t3,3(t0)   # Loads plasma breath's X offset %
00001f20 : ff8e0e13;   % 1374:                         addi t3,t3,-8  # subtracts 4 from it %
00001f21 : 00fe5463;   % 1375:                         bge t3,a5,BEAM_COLLISION_PLASMA_BREATH_LOOP_CHECK_Y # If t3 - 8 >= beam's offset, continue to check Y %
00001f22 : 04c0006f;   % 1376:                             j NEXT_IN_BEAM_COLLISION_PLASMA_BREATH_LOOP # Otherwise, plasma breath isn't near beam enough be hit, check next %
00001f23 : 0082ce03;   % 1379:                     lbu t3,8(t0)   # Loads plasma breath's current Y %
00001f24 : 02ee0063;   % 1380:                     beq t3,a4,BEAM_COLLISION_PLASMA_BREATH_LOOP_SAME_Y    # If plasma breath's Y is the same as the beam's %
00001f25 : 00170e93;   % 1381:                     addi t4,a4,1   # Checks beam's base tile (Y + 1) %
00001f26 : 01de0463;   % 1382:                     beq t3,t4,BEAM_COLLISION_PLASMA_BREATH_LOOP_BELLOW  # If plasma breath's X is bellow beam %
00001f27 : 0380006f;   % 1383:                         j NEXT_IN_BEAM_COLLISION_PLASMA_BREATH_LOOP # Otherwise, plasma breath isn't near beam enough be hit, check next %
00001f28 : 0042ce03;   % 1386:                         lbu t3,4(t0)   # Loads plasma breath's Y offset %
00001f29 : 008e0e13;   % 1387:                         addi t3,t3,8 %
00001f2a : 010e4c63;   % 1388:                         blt t3,a6,BEAM_COLLISION_PLASMA_BREATH_LOOP_HIT # If plasma breath's Y offset is less than the beam's Y offset deal damage %
00001f2b : 0280006f;   % 1389:                             j NEXT_IN_BEAM_COLLISION_PLASMA_BREATH_LOOP # Otherwise, plasma breath isn't near beam enough be hit, check next %
00001f2c : 0042ce03;   % 1392:                         lbu t3,4(t0)   # Loads plasma breath's Y offset %
00001f2d : 008e0e13;   % 1393:                         addi t3,t3,8   #  %
00001f2e : 010e5463;   % 1394:                         bge t3,a6,BEAM_COLLISION_PLASMA_BREATH_LOOP_HIT # If plasma breath's Y offset + 8 is greater than the beam's Y offset deal damage %
00001f2f : 0180006f;   % 1395:                             j NEXT_IN_BEAM_COLLISION_PLASMA_BREATH_LOOP # Otherwise, plasma breath isn't near beam enough be hit, check next %
00001f30 : 00028023;   % 1399:                         sb zero,0(t0)     # Disables plasma breath %
00001f31 : 00300313;   % 1400:                         li t1,3           # Loads "Hit to be Disabled"  %
00001f32 : 00650023;   % 1401:                         sb t1,0(a0)       # and stores it on enable byte %
00001f33 : 00050123;   % 1402:                         sb zero,2(a0)     # Resets render counter %
00001f34 : 0140006f;   % 1403:                         j NEXT_IN_BEAM_COLLISION_LOOP  # Beam was deactivated, end procedure here            %
00001f35 : 00a28293;   % 1406:                 addi t0,t0,10  # Going to the next plasma breath's address                                   %
00001f36 : 00138393;   % 1407:                 addi t2,t2,1            # Iterating counter by 1                                    %
00001f37 : 0063d463;   % 1408:                 bge t2,t1, NEXT_IN_BEAM_COLLISION_LOOP       # If all of the plasma breaths were checked, end loop                               %
00001f38 : f49ff06f;   % 1409:                 j BEAM_COLLISION_PLASMA_BREATH_LOOP # otherwise, go back to the loop's beginning  %
00001f39 : 00950513;   % 1412:             addi a0,a0,9  # Going to the next beam's address                                   %
00001f3a : 00160613;   % 1413:             addi a2,a2,1            # Iterating counter by 1                                    %
00001f3b : 00b65463;   % 1414:             bge a2,a1, END_BEAM_COLLISION # If all of the beams were checked, end loop (don't attack)                                 %
00001f3c : b51ff06f;   % 1415:             j BEAM_COLLISION_LOOP # otherwise, go back to the loop's beginning  %
00001f3d : 00012083;   % 1420:         lw ra,0(sp) %
00001f3e : 00410113;   % 1421:         addi sp,sp,4 %
00001f3f : 00008067;   % 1423:         ret  %
00001f40 : ffc10113;   % 1447:     addi sp,sp,-4 %
00001f41 : 00112023;   % 1448:     sw ra,0(sp) %
00001f42 : 0fc0a597;   % 1452:     la a1,CURRENT_MAP    # Won't check for bombs when map is moving %
00001f43 : 3f858593;   % 1452:  %
00001f44 : 0005a583;   % 1453:     lw a1,0(a1)          # Gets current map address %
00001f45 : 0015c783;   % 1456:     lbu a5,1(a1)     # Loads map's matrix width %
00001f46 : 00554803;   % 1457:     lbu a6,5(a0)     # Loads Bomb's current X %
00001f47 : 00754883;   % 1458:     lbu a7,7(a0)     # Loads Bomb's current Y %
00001f48 : 00358593;   % 1460:     addi a1,a1,3     # Adds 3 to the Matrix's address so that it goes to the beginning of matrix %
00001f49 : 02f882b3;   % 1461:     mul t0,a7,a5     # (Bomb's matrix Y + 3)  * Map Matrix's width %
00001f4a : 005802b3;   % 1462:     add t0,a6,t0     # t0 = Bomb's X related to matrix + (Bomb's matrix Y + 3)  * Map Matrix's width %
00001f4b : 005585b3;   % 1463:     add a1,a1,t0     # a1 = Map Matrix's address adjusted for Bomb's X and Y (+3) related to matrix        %
00001f4c : 40f585b3;   % 1466:     sub a1,a1,a5     # Moves matrix one tile up  %
00001f4d : fff88893;   % 1467:     addi a7,a7,-1    # Moves Y one tile up %
00001f4e : 00354e03;   % 1470:     lbu t3,3(a0)     # Loads Bomb's X offset %
00001f4f : 00800293;   % 1471:     li t0, 8   # Loads number 8 for comparing with X offset  %
00001f50 : 005e4a63;   % 1472:     blt t3,t0, START_BREAK_BOMB_COLLISION # If X offset < 8, just check one tile bellow, and consider right doors %
00001f51 : 01c2c463;   % 1473:     blt t0,t3, BOMB_COLLISION_RIGHT # If X offset > 8, check one tile bellow to the right , and consider left doors %
00001f52 : 00c0006f;   % 1475:         j START_BREAK_BOMB_COLLISION            %
00001f53 : 00158593;   % 1479:         addi a1,a1, 1 # Looks to the tile on the right of Bomb's current tile %
00001f54 : 00180813;   % 1480:         addi a6,a6,1  # Increments current X on matrix (+1 X) %
00001f55 : fec10113;   % 1485:         addi sp,sp,-20 %
00001f56 : 00d12823;   % 1486:         sw a3,16(sp) %
00001f57 : 00c12623;   % 1487:         sw a2,12(sp) %
00001f58 : 00b12423;   % 1488:         sw a1,8(sp) %
00001f59 : 00a12223;   % 1489:         sw a0,4(sp) %
00001f5a : 00112023;   % 1490:         sw ra,0(sp) %
00001f5b : 00000513;   % 1492:         li a0,0  # Doesn't matter, since no doors will be checked %
00001f5c : 00300613;   % 1494:         li a2, 3  # Will check 3 tiles %
00001f5d : 00000693;   % 1495:         li a3, 0  # "Horizontal" check  -> will check 3 tiles in a vertical line %
00001f5e : 00000713;   % 1496:         li a4, 0  # Base case: Don't consider doors %
00001f5f : 00300213;   % 1500:         li tp, 3  # Entity collision %
00001f60 : 00001317;   % 1501:         call CHECK_MAP_COLLISION %
00001f61 : fd4300e7;   % 1501:  %
00001f62 : 00a002b3;   % 1502:         mv t0,a0 %
00001f63 : 01012683;   % 1505:         lw a3,16(sp) %
00001f64 : 00c12603;   % 1506:         lw a2,12(sp) %
00001f65 : 00812583;   % 1507:         lw a1,8(sp) %
00001f66 : 00412503;   % 1508:         lw a0,4(sp) %
00001f67 : 00012083;   % 1509:         lw ra,0(sp) %
00001f68 : 01410113;   % 1510:         addi sp,sp,20 %
00001f69 : 00354e03;   % 1513:     lbu t3,3(a0)     # Loads Bomb's X offset %
00001f6a : 00800293;   % 1514:     li t0, 8   # Loads number 8 for comparing with X offset  %
00001f6b : 07c29263;   % 1515:     bne t0,t3,SKIP_SECOND_BREAK_BOMB_COLLISION %
00001f6c : fec10113;   % 1518:         addi sp,sp,-20 %
00001f6d : 00d12823;   % 1519:         sw a3,16(sp) %
00001f6e : 00c12623;   % 1520:         sw a2,12(sp) %
00001f6f : 00b12423;   % 1521:         sw a1,8(sp) %
00001f70 : 00a12223;   % 1522:         sw a0,4(sp) %
00001f71 : 00112023;   % 1523:         sw ra,0(sp) %
00001f72 : 00554803;   % 1525:         lbu a6,5(a0)     # Loads Bomb's current X %
00001f73 : 00754883;   % 1526:         lbu a7,7(a0)     # Loads Bomb's current Y %
00001f74 : fff88893;   % 1527:         addi a7,a7,-1 %
00001f75 : 00000513;   % 1528:         li a0,0  # Doesn't matter, since no doors will be checked %
00001f76 : 00158593;   % 1529:         addi a1,a1,1   %
00001f77 : 00300613;   % 1530:         li a2, 3  # Will check 3 tiles %
00001f78 : 00000693;   % 1531:         li a3, 0  # "Horizontal" check  -> will check 3 tiles in a vertical line %
00001f79 : 00000713;   % 1532:         li a4, 0  # Base case: Don't consider doors %
00001f7a : 00180813;   % 1534:         addi a6,a6,1 %
00001f7b : 00300213;   % 1536:         li tp, 3  # Entity collision %
00001f7c : 00001317;   % 1538:         call CHECK_MAP_COLLISION %
00001f7d : f64300e7;   % 1538:  %
00001f7e : 01012683;   % 1541:         lw a3,16(sp) %
00001f7f : 00c12603;   % 1542:         lw a2,12(sp) %
00001f80 : 00812583;   % 1543:         lw a1,8(sp) %
00001f81 : 00412503;   % 1544:         lw a0,4(sp) %
00001f82 : 00012083;   % 1545:         lw ra,0(sp) %
00001f83 : 01410113;   % 1546:         addi sp,sp,20 %
00001f84 : 00554583;   % 1550:     lbu a1, 5(a0)      # Loads Player's current X (matrix) %
00001f85 : 00754603;   % 1551:     lbu a2, 7(a0)     # Loads Player's current Y (matrix)   %
00001f86 : 00354683;   % 1552:     lbu a3, 3(a0)      # Loads Player's current X offset %
00001f87 : 00454703;   % 1553:     lbu a4, 4(a0)      # Loads Player's current Y offset %
00001f88 : 0fc0a297;   % 1555:     la t0,CURRENT_MAP             # Loads map address %
00001f89 : 2e028293;   % 1555:  %
00001f8a : 0042c283;   % 1556:     lbu t0,4(t0)                  # and from it, loads map's number %
00001f8b : 00700313;   % 1557:     li t1,7                       # Loads 7 to compare with map's number %
00001f8c : 00629463;   % 1558:     bne t0,t1,BOMB_COLLISION_SKIP_RIDLEY         # If not on map 7, skip Ridley and Plasma Breath >:D %
00001f8d : 1140006f;   % 1559:         j BOMB_COLLISION_RIDLEY # Otherwise, skip the rest of the checks %
00001f8e : 0fc0a297;   % 1564:     la t0,Zoomers  # Loads Zoomers address %
00001f8f : 40028293;   % 1564:  %
00001f90 : 0002a283;   % 1566:     lw t0,0(t0)    # Loads the ZoomersA address over the Zoomers address %
00001f91 : 00029463;   % 1567:     bnez t0,CONTINUE_BOMB_COLLISION_ZOOMER  # If there are zoomers in this map %
00001f92 : 0fc0006f;   % 1568:         j BOMB_COLLISION_RIDLEY_SKIP        # If t0 = 0, there are no zoomers in this map %
00001f93 : 0002c303;   % 1572:     lbu t1,0(t0)   # Loads number of Zoomers in current map %
00001f94 : 00000393;   % 1573:     li t2,0        # Counter for zoomers %
00001f95 : 00128293;   % 1574:     addi t0,t0,1   # Goes to next byte (where zoomers from current map start) %
00001f96 : 00028e03;   % 1577:         lb t3,0(t0) # Loads zoomer's health %
00001f97 : 01c04463;   % 1578:         blt zero,t3,CONTINUE_BOMB_COLLISION_ZOOMER_LOOP # If zoomer is alive %
00001f98 : 0d40006f;   % 1580:             j NEXT_IN_BOMB_COLLISION_ZOOMER_LOOP %
00001f99 : 0042ce03;   % 1583:         lbu t3,4(t0)   # Loads zoomer's current X %
00001f9a : 00be0c63;   % 1584:         beq t3,a1,BOMB_COLLISION_ZOOMER_LOOP_CHECK_Y   # If zoomer's X is the same as the beam %
00001f9b : 00158e93;   % 1585:         addi t4,a1,1   # Checks beam's tile to the right %
00001f9c : 01de0863;   % 1586:         beq t3,t4,BOMB_COLLISION_ZOOMER_LOOP_CHECK_Y  # If zoomer's X is to the right of beam %
00001f9d : fff58e93;   % 1587:         addi t4,a1,-1  # Checks beam's tile to the left %
00001f9e : 01de0463;   % 1588:         beq t3,t4,BOMB_COLLISION_ZOOMER_LOOP_CHECK_Y   # If zoomer's X is to the left of beam %
00001f9f : 0b80006f;   % 1589:             j NEXT_IN_BOMB_COLLISION_ZOOMER_LOOP # Otherwise, zoomer isn't near beam enough be hit, check next %
00001fa0 : 0062ce03;   % 1592:             lbu t3,6(t0)   # Loads zoomer's current Y %
00001fa1 : 00ce0e63;   % 1593:             beq t3,a2,BOMB_COLLISION_ZOOMER_LOOP_SAME_Y    # If zoomer's Y is the same as the beam's %
00001fa2 : 00160e93;   % 1594:             addi t4,a2,1   # Checks beam's base tile (Y + 1) %
00001fa3 : 01de0463;   % 1595:             beq t3,t4,BOMB_COLLISION_ZOOMER_LOOP_BELLOW  # If zoomer's Y on beam's base %
00001fa4 : 0a40006f;   % 1596:             j NEXT_IN_BOMB_COLLISION_ZOOMER_LOOP # Otherwise, zoomer isn't near beam enough be hit, check next %
00001fa5 : 0032ce03;   % 1599:                 lbu t3,3(t0)   # Loads zoomer's Y offset %
00001fa6 : 00ee4c63;   % 1600:                 blt t3,a4,BOMB_COLLISION_ZOOMER_LOOP_HIT # If zoomer's Y offset is less than the beam's Y offset deal damage %
00001fa7 : 0980006f;   % 1601:                     j NEXT_IN_BOMB_COLLISION_ZOOMER_LOOP # Otherwise, zoomer isn't near beam enough be hit, check next %
00001fa8 : 0032ce03;   % 1604:                 lbu t3,3(t0)   # Loads zoomer's Y  %
00001fa9 : 008e0e13;   % 1605:                 addi t3,t3,8   #  %
00001faa : 00ee5463;   % 1606:                 bge t3,a4,BOMB_COLLISION_ZOOMER_LOOP_HIT # If zoomer's Y offset + 8 is greater than the beam's Y offset deal damage %
00001fab : 0880006f;   % 1607:                     j NEXT_IN_BOMB_COLLISION_ZOOMER_LOOP # Otherwise, zoomer isn't near beam enough be hit, check next %
00001fac : 0002ce03;   % 1611:                 lbu t3,0(t0)   # Loads zoomer's health %
00001fad : 000e1463;   % 1612:                 bnez t3,CONTINUE_BOMB_COLLISION_ZOOMER_LOOP_HIT    # Zoomer isn't dead  %
00001fae : 1fc0006f;   % 1613:                     j END_BOMB_COLLISION  # Beam was deactivated, end procedure here    %
00001faf : ffae0e13;   % 1615:                 addi t3,t3,-6  # Takes 6 away from it %
00001fb0 : 01c05c63;   % 1616:                 bge zero,t3,BOMB_COLLISION_ZOOMER_LOOP_HIT_DESTROY_ZOOMER  # If zoomer is killed %
00001fb1 : 01c28023;   % 1617:                     sb t3,0(t0)    # and stores it back %
00001fb2 : 0012ce03;   % 1618:                     lbu t3,1(t0)   # Loads zoomer's type %
00001fb3 : 002e0e13;   % 1619:                     addi t3,t3,2   # Adds 2 to it ( will go to damage state) %
00001fb4 : 01c280a3;   % 1620:                     sb t3,1(t0)    # and stores it back %
00001fb5 : 1e00006f;   % 1621:                     j END_BOMB_COLLISION %
00001fb6 : 00028023;   % 1624:                     sb zero,0(t0)  # Stores 0 to zoomer's health %
00001fb7 : 0022c583;   % 1625:                     lbu a1,2(t0)   # Loads zoomer's X offset %
00001fb8 : 0032c603;   % 1626:                     lbu a2,3(t0)   # Loads zoomer's Y offset %
00001fb9 : 0042c683;   % 1627:                     lbu a3,4(t0)   # Loads zoomer's X  %
00001fba : 0062c703;   % 1628:                     lbu a4,6(t0)   # Loads zoomer's Y %
00001fbb : 00400793;   % 1629:                     li a5,4        # Delay %
00001fbc : ff810113;   % 1631:                         addi sp,sp,-8 %
00001fbd : 00a12023;   % 1632:                         sw a0,0(sp) %
00001fbe : 00512223;   % 1633:                         sw t0,4(sp) %
00001fbf : 00000513;   % 1636:                         li a0, 0       # Small explosion %
00001fc0 : ffffb317;   % 1637:                         call EXPLOSION_SPAWN   # Summons explosion %
00001fc1 : 0f4300e7;   % 1637:  %
00001fc2 : 00412283;   % 1639:                         lw t0,4(sp)    # Restores zoomer's address %
00001fc3 : 00b2c503;   % 1640:                         lbu a0,11(t0)  # Loads zoomer's loot value %
00001fc4 : 0022c583;   % 1641:                         lbu a1,2(t0)   # Loads zoomer's X offset %
00001fc5 : 0032c603;   % 1642:                         lbu a2,3(t0)   # Loads zoomer's Y offset %
00001fc6 : 0042c683;   % 1643:                         lbu a3,4(t0)   # Loads zoomer's X  %
00001fc7 : 0062c703;   % 1644:                         lbu a4,6(t0)   # Loads zoomer's Y %
00001fc8 : ffffb317;   % 1645:                         call LOOT_SPAWN   # Summons explosion %
00001fc9 : efc300e7;   % 1645:  %
00001fca : 00012503;   % 1648:                         lw a0,0(sp) %
00001fcb : 00810113;   % 1650:                         addi sp,sp,8 %
00001fcc : 1840006f;   % 1653:                     j END_BOMB_COLLISION  # Beam was deactivated, end procedure here    %
00001fcd : 00c28293;   % 1657:             addi t0,t0,12   # Going to the next zoomer's address                                   %
00001fce : 00138393;   % 1658:             addi t2,t2,1             # Iterating counter by 1                                    %
00001fcf : 0063d463;   % 1659:             bge t2,t1, BOMB_COLLISION_RIDLEY_SKIP # If all of the zoomers were checked, end loop                                   %
00001fd0 : f19ff06f;   % 1660:             j BOMB_COLLISION_ZOOMER_LOOP # otherwise, go back to the loop's beginning                      %
00001fd1 : 1700006f;   % 1663:         j END_BOMB_COLLISION %
00001fd2 : 0fc0a297;   % 1666:         la t0,RIDLEY_INFO %
00001fd3 : 50028293;   % 1666:  %
00001fd4 : 00028303;   % 1667:         lb t1,0(t0) # Loads Ridley's health %
00001fd5 : 00604463;   % 1668:         blt zero,t1,CONTINUE_BOMB_COLLISION_RIDLEY # If Ridley is alive %
00001fd6 : 15c0006f;   % 1669:             j END_BOMB_COLLISION %
00001fd7 : 00100213;   % 1672:         li tp, 1 # tp will start as left %
00001fd8 : 00900e13;   % 1673:         li t3,9   # Loads Ridley's current X %
00001fd9 : 00be0c63;   % 1674:         beq t3,a1,BOMB_COLLISION_RIDLEY_CHECK_Y   # If Ridley's X is the same as the beam's %
00001fda : 00158e93;   % 1675:         addi t4,a1,1   # Checks beam's tile to the right %
00001fdb : 01de0863;   % 1676:         beq t3,t4,BOMB_COLLISION_RIDLEY_CHECK_Y  # If Ridley's X is to the right of beam %
00001fdc : fff58e93;   % 1677:         addi t4,a1,-1  # Checks beam's tile to the left %
00001fdd : 01de0463;   % 1678:         beq t3,t4,BOMB_COLLISION_RIDLEY_CHECK_Y   # If Ridley's X is to the left of beam %
00001fde : 13c0006f;   % 1679:         j END_BOMB_COLLISION # Otherwise, Ridley isn't near beam to be hit, check Plasma Breath   %
00001fdf : 0032ce03;   % 1682:             lbu t3,3(t0)   # Loads Ridley's current Y %
00001fe0 : 02ce0e63;   % 1683:             beq t3,a2,BOMB_COLLISION_RIDLEY_HIT    # If Ridley's Y is the same as the beam's (beam would basically be inside him) %
00001fe1 : 00160e93;   % 1684:             addi t4,a2,1   # Checks beam's base tile (Y + 1) %
00001fe2 : 01de0c63;   % 1685:             beq t3,t4,BOMB_COLLISION_RIDLEY_BELLOW  # If Ridley's Y is bellow beam %
00001fe3 : 001e0e13;   % 1687:             addi t3,t3,1   # Gets ridley's Y + 1 %
00001fe4 : 02ce0663;   % 1688:             beq t3,a2,BOMB_COLLISION_RIDLEY_HIT    # If Ridley's Y + 1 is the same as the beam's, it's a hit (beam would basically be inside him) %
00001fe5 : 001e0e13;   % 1690:             addi t3,t3,1   # Gets ridley's Y + 2 %
00001fe6 : 00ce0a63;   % 1691:             beq t3,a2,BOMB_COLLISION_RIDLEY_SAME_Y    # If Ridley's Y + 2 is the same as the beam's %
00001fe7 : 1180006f;   % 1693:             j END_BOMB_COLLISION # Otherwise, Ridley isn't near beam to be hit, check Plasma Breath    %
00001fe8 : 0022ce03;   % 1696:                 lbu t3,2(t0)   # Loads Ridley's current Y offset %
00001fe9 : 00ee4c63;   % 1697:                 blt t3,a4,BOMB_COLLISION_RIDLEY_HIT # If Ridley's "Y offset" is less than the beam's Y offset deal damage %
00001fea : 10c0006f;   % 1698:                     j END_BOMB_COLLISION # Otherwise, Ridley isn't near beam to be hit, check Plasma Breath    %
00001feb : 0022ce03;   % 1701:                 lbu t3,2(t0)   # Loads Ridley's current Y offset %
00001fec : 008e0e13;   % 1702:                 addi t3,t3,8   #  %
00001fed : 00ee5463;   % 1703:                 bge t3,a4,BOMB_COLLISION_RIDLEY_HIT # If ridley's Y offset + 8 is greater than the beam's Y offset deal damage %
00001fee : 0fc0006f;   % 1704:                     j END_BOMB_COLLISION # Otherwise, Ridley isn't near beam to be hit, check Plasma Breath    %
00001fef : 0002ce03;   % 1708:                 lbu t3,0(t0)   # Loads Ridley's health %
00001ff0 : 0e0e0863;   % 1709:                 beqz t3,BOMB_COLLISION_RIDLEY_HIT_DISABLE_BEAM %
00001ff1 : ffae0e13;   % 1710:                 addi t3,t3,-6  # Takes 1 away from it %
00001ff2 : 01c05c63;   % 1711:                 blez t3,BOMB_COLLISION_RIDLEY_HIT_DESTROY_RIDLEY  # If Ridley is killed %
00001ff3 : 01c28023;   % 1712:                     sb t3,0(t0)    # and stores it back %
00001ff4 : 0012ce03;   % 1713:                     lbu t3,1(t0)   # Loads Ridley's type %
00001ff5 : 001e0e13;   % 1714:                     addi t3,t3,1   # Adds 1 to it ( will go to damage state) %
00001ff6 : 01c280a3;   % 1715:                     sb t3,1(t0)    # and stores it back %
00001ff7 : 0d40006f;   % 1716:                     j BOMB_COLLISION_RIDLEY_HIT_DISABLE_BEAM %
00001ff8 : 00028023;   % 1719:                     sb zero,0(t0)  # Stores 0 to Ridley's health %
00001ff9 : 00600593;   % 1720:                     li a1,6   # Loads Ridley's X offset %
00001ffa : 0022c603;   % 1721:                     lbu a2,2(t0)            # Loads Ridley's Y offset %
00001ffb : 00900693;   % 1722:                     li a3,9          # Loads Ridley's X  %
00001ffc : 0032c703;   % 1723:                     lbu a4,3(t0)            # Loads Ridley's Y %
00001ffd : ffc10113;   % 1725:                         addi sp,sp,-4 %
00001ffe : 00a12023;   % 1726:                         sw a0,0(sp) %
00001fff : 00100513;   % 1728:                         li a0, 1               # Big explosion %
00002000 : 00400793;   % 1729:                         li a5,4                # Delay %
00002001 : ffffb317;   % 1730:                         call EXPLOSION_SPAWN   # Summons explosion %
00002002 : ff0300e7;   % 1730:  %
00002003 : 0fc0a297;   % 1732:                         la t0,RIDLEY_INFO %
00002004 : 43c28293;   % 1732:  %
00002005 : 00600593;   % 1733:                         li a1,6   # Loads Ridley's X offset %
00002006 : 0022c603;   % 1734:                         lbu a2,2(t0)            # Loads Ridley's Y offset %
00002007 : 00900693;   % 1735:                         li a3,9          # Loads Ridley's X  %
00002008 : 00168693;   % 1736:                         addi a3,a3,1 %
00002009 : 0032c703;   % 1737:                         lbu a4,3(t0)            # Loads Ridley's Y %
0000200a : 00170713;   % 1738:                         addi a4,a4,1 %
0000200b : 00300793;   % 1739:                         li a5,3                # Delay %
0000200c : 00100513;   % 1740:                         li a0, 1               # Big explosion %
0000200d : ffffb317;   % 1741:                         call EXPLOSION_SPAWN   # Summons explosion %
0000200e : fc0300e7;   % 1741:  %
0000200f : 0fc0a297;   % 1743:                         la t0,RIDLEY_INFO %
00002010 : 40c28293;   % 1743:  %
00002011 : 00600593;   % 1744:                         li a1,6   # Loads Ridley's X offset %
00002012 : 0022c603;   % 1745:                         lbu a2,2(t0)            # Loads Ridley's Y offset %
00002013 : 00900693;   % 1746:                         li a3,9          # Loads Ridley's X  %
00002014 : fff68693;   % 1747:                         addi a3,a3,-1 %
00002015 : 0032c703;   % 1748:                         lbu a4,3(t0)            # Loads Ridley's Y %
00002016 : 00270713;   % 1749:                         addi a4,a4,2 %
00002017 : 00400793;   % 1750:                         li a5,4                # Delay %
00002018 : 00100513;   % 1751:                         li a0, 1               # Big explosion %
00002019 : ffffb317;   % 1752:                         call EXPLOSION_SPAWN   # Summons explosion %
0000201a : f90300e7;   % 1752:  %
0000201b : 00012503;   % 1754:                         lw a0,0(sp) %
0000201c : 00410113;   % 1755:                         addi sp,sp,4 %
0000201d : ff010113;   % 1758:                         addi sp,sp,-16 %
0000201e : 00a12023;   % 1759:                         sw a0,0(sp) %
0000201f : 00b12223;   % 1760:                         sw a1,4(sp) %
00002020 : 00c12423;   % 1761:                         sw a2,8(sp) %
00002021 : 00d12623;   % 1762:                         sw a3,12(sp) %
00002022 : 00001317;   % 1765:                     call PLAY_ITEM_GET       %
00002023 : 0f0300e7;   % 1765:  %
00002024 : 00012503;   % 1768:                         lw a0,0(sp) %
00002025 : 00412583;   % 1769:                         lw a1,4(sp) %
00002026 : 00812603;   % 1770:                         lw a2,8(sp) %
00002027 : 00c12683;   % 1771:                         lw a3,12(sp) %
00002028 : 01010113;   % 1772:                         addi sp,sp,16 %
00002029 : 00000993;   % 1776:                         li s3,0 %
0000202a : 00100913;   % 1777:                         li s2,1   %
0000202b : f44f806f;   % 1778:                         j SETUP          # end procedure by going to setup %
0000202c : 0040006f;   % 1782:                     j END_BOMB_COLLISION  # Beam was deactivated, end procedure here          %
0000202d : 00012083;   % 1786:         lw ra,0(sp) %
0000202e : 00410113;   % 1787:         addi sp,sp,4 %
0000202f : 00008067;   % 1789:         ret  %
00002030 : 0015c783;   % 1808:     lbu a5,1(a1)  # Loads map's matrix width %
00002031 : 00554803;   % 1809:     lbu a6,5(a0)  # Loads Beam's current X %
00002032 : 00754883;   % 1810:     lbu a7,7(a0)  # Loads Beam's current Y %
00002033 : 00358593;   % 1812:     addi a1,a1,3   # Adds 3 to the Matrix's address so that it goes to the beginning of matrix %
00002034 : 02f882b3;   % 1813:     mul t0,a7,a5   # Beam's Y related to matrix * Map Matrix's width %
00002035 : 005802b3;   % 1814:     add t0,a6,t0   # t0 = Beam's X related to matrix +  Beam's Y related to matrix * Map Matrix's width   %
00002036 : 005585b3;   % 1815:     add a1,a1,t0   # a1 = Map Matrix's address adjusted for Beam's X and Y related to matrix %
00002037 : 00150283;   % 1817:     lb t0, 1(a0) # loads direction %
00002038 : 00028663;   % 1818:     beqz t0,MOVE_BEAM_CHECK_Y     # If direction is 0 (Up)  %
00002039 : 00000213;   % 1819:         li tp, 0 # If it's 0, it's on the first check %
0000203a : 04c0006f;   % 1820:         j MOVE_BEAM_CHECK_X  %
0000203b : 00454283;   % 1823:         lbu t0,4(a0)   # Loads beam's Y offset %
0000203c : 00c00313;   % 1824:         li t1,12       # Number for comparision %
0000203d : 00535463;   % 1825:         bge t1,t0,CONTINUE_MOVE_BEAM_CHECK_Y # If beam's offset <= 12, continue checking %
0000203e : 1380006f;   % 1826:         j MOVE_BEAM_Y_PROPERLY %
0000203f : 00100613;   % 1830:         li a2, 1  # Base case: Check only one tile        %
00002040 : 00100693;   % 1831:         li a3, 1  # Vertical check %
00002041 : 00000713;   % 1832:         li a4, 0  # Base case: Don't consider doors       %
00002042 : 00354e03;   % 1834:         lbu t3,3(a0)     # Loads Beam's X offset %
00002043 : 00800293;   % 1835:         li t0, 8   # Loads number 8 for comparing with X offset  %
00002044 : 005e4863;   % 1836:         blt t3,t0, MOVE_BEAM_CHECK_Y_1_TILE # If X offset < 8, just check one tile bellow, and consider right doors %
00002045 : 01c2c863;   % 1837:         blt t0,t3, MOVE_BEAM_CHECK_Y_1_TILE_RIGHT # If X offset > 8, check one tile bellow to the right , and consider left doors %
00002046 : 00200613;   % 1839:             li a2,2   # Check 2 tiles above beam (one above, the other above to the right) %
00002047 : 0b80006f;   % 1840:             j START_BEAM_COLLISION %
00002048 : 0b40006f;   % 1844:             j START_BEAM_COLLISION %
00002049 : 00100313;   % 1848:             li t1, 1 # Only consider doors on the left side of the map %
0000204a : 00158593;   % 1849:             addi a1,a1, 1 # Looks to the tile on the right of Beam's current tile %
0000204b : 00180813;   % 1850:             addi a6,a6,1  # Increments current X on matrix (+1 X) %
0000204c : 0a40006f;   % 1851:             j START_BEAM_COLLISION  %
0000204d : 00100613;   % 1855:         li a2, 1  # Base case: Check only one tile        %
0000204e : 00000693;   % 1856:         li a3, 0  # Horizontal check %
0000204f : 00000713;   % 1857:         li a4, 0  # Base case: Don't consider doors      %
00002050 : 00454283;   % 1858:         lbu t0,4(a0)   # Loads beam's Y offset %
00002051 : 00400313;   % 1859:         li t1, 4       # For comparision %
00002052 : 0062ce63;   % 1860:         blt t0,t1,CONTINUE_MOVE_BEAM_CHECK_X_GET_DIRECTION  # If less than 4, check current Y only %
00002053 : 00800313;   % 1861:         li t1, 8       # For comparision %
00002054 : 0062d663;   % 1862:         bge t0,t1,CONTINUE_MOVE_BEAM_CHECK_X_BELLOW  # If greater than or equal to 8, check Y bellow %
00002055 : 00200613;   % 1863:             li a2,2    # Otherwise (4 <= Y offset < 8) check both tiles %
00002056 : 00c0006f;   % 1864:             j CONTINUE_MOVE_BEAM_CHECK_X_GET_DIRECTION %
00002057 : 00188893;   % 1867:         addi a7,a7,1  # Goes to tile bellow %
00002058 : 00f585b3;   % 1868:         add a1,a1,a5  # as well as in matrix %
00002059 : 00154283;   % 1878:         lbu t0, 1(a0)  # loads direction %
0000205a : fff28293;   % 1879:         addi t0,t0,-1 # if t0 == 1 (right) it'll be set to 0 %
0000205b : 02028663;   % 1880:         beqz t0,MOVE_BEAM_CHECK_X_RIGHT  # If beam is moving right %
0000205c : 00020863;   % 1882:         beqz tp,CONTINUE_MOVE_BEAM_CHECK_X_LEFT_FIRST_CHECK # If on first check %
0000205d : 00158593;   % 1884:             addi a1,a1, 1  # Looks to the tile on the right of beam's current tile %
0000205e : 00180813;   % 1885:             addi a6,a6,1   # Increments current X on matrix(+1 X) %
0000205f : 00100613;   % 1886:             li a2, 1  # Base case: Check only one tile        %
00002060 : 00354283;   % 1889:             lbu t0,3(a0)   # Loads beam's X offset %
00002061 : 00400313;   % 1890:             li t1,4        # Loads number 4 for comparing with X offset  %
00002062 : 00628463;   % 1891:             beq t0,t1,CONTINUE_MOVE_BEAM_CHECK_X_LEFT_DOORS  # Will check considering only doors %
00002063 : 00029463;   % 1892:             bnez t0,CONTINUE_MOVE_BEAM_CHECK_X_LEFT_SKIP_DOORS  # Will check considering only doors %
00002064 : 00100713;   % 1895:                 li a4,1   # Consider only doors %
00002065 : 0400006f;   % 1898:                 j START_BEAM_COLLISION %
00002066 : 00020a63;   % 1901:         beqz tp,CONTINUE_MOVE_BEAM_CHECK_X_RIGHT_FIRST_CHECK # If on first check %
00002067 : fff58593;   % 1903:             addi a1,a1, -1  # Looks to the tile on the right of beam's current tile %
00002068 : fff80813;   % 1904:             addi a6,a6,-1   # Increments current X on matrix(+1 X) %
00002069 : 00100613;   % 1905:             li a2, 1  # Base case: Check only one tile    %
0000206a : 00c0006f;   % 1906:             j CONTINUE_MOVE_BEAM_CHECK_X_RIGHT %
0000206b : 00158593;   % 1909:             addi a1,a1, 1  # Looks to the tile on the right of beam's current tile %
0000206c : 00180813;   % 1910:             addi a6,a6,1   # Increments current X on matrix(+1 X) %
0000206d : 00354283;   % 1912:             lbu t0,3(a0)   # Loads beam's X offset %
0000206e : 00c00313;   % 1913:             li t1,12        # Loads number 12 for comparing with X offset  %
0000206f : 00628663;   % 1914:             beq t0,t1,CONTINUE_MOVE_BEAM_CHECK_X_RIGHT_DOORS  # Will check considering only doors %
00002070 : 00800313;   % 1915:             li t1,8        # Loads number 8 for comparing with X offset  %
00002071 : 00629463;   % 1916:             bne t0,t1,CONTINUE_MOVE_BEAM_CHECK_X_RIGHT_SKIP_DOORS  # Will check ignoring doors %
00002072 : 00100713;   % 1918:                 li a4,1   # Consider only doors %
00002073 : 08028663;   % 1921:                 beqz t0,MOVE_BEAM_X_PROPERLY # If offset is 0, skip collision check %
00002074 : 0040006f;   % 1922:                 j START_BEAM_COLLISION %
00002075 : ff410113;   % 1926:         addi sp,sp,-12 %
00002076 : 00a12023;   % 1927:         sw a0,0(sp) %
00002077 : 00b12223;   % 1928:         sw a1,4(sp) %
00002078 : 00112423;   % 1929:         sw ra,8(sp) %
00002079 : 00200513;   % 1932:         li a0,2  # Consider both doors (if a4 != 0) %
0000207a : 00200213;   % 1940:         li tp, 2  # Beam collision %
0000207b : 00001317;   % 1942:         call CHECK_MAP_COLLISION %
0000207c : b68300e7;   % 1942:  %
0000207d : 00a002b3;   % 1943:         mv t0,a0 %
0000207e : 00b00233;   % 1944:         mv tp,a1 %
0000207f : 00012503;   % 1947:         lw a0,0(sp) %
00002080 : 00412583;   % 1948:         lw a1,4(sp) %
00002081 : 00812083;   % 1949:         lw ra,8(sp) %
00002082 : 00c10113;   % 1950:         addi sp,sp,12 %
00002083 : f4021ce3;   % 1954:         bnez tp,CONTINUE_MOVE_BEAM_CHECK_X_GET_DIRECTION %
00002084 : 00029a63;   % 1955:         bnez t0,MOVE_BEAM_PROPERLY # If returning anything but 0, continue moving ripper %
00002085 : 00300313;   % 1957:         li t1,3           # Loads "Hit to be Disabled"  %
00002086 : 00650023;   % 1958:         sb t1,0(a0)       # and stores it on enable byte %
00002087 : 00050123;   % 1959:         sb zero,2(a0)     # Resets render counter %
00002088 : 0980006f;   % 1960:         j END_MOVE_BEAM %
00002089 : 00150283;   % 1963:         lb t0, 1(a0) # loads direction %
0000208a : 00028463;   % 1964:         beqz t0,MOVE_BEAM_Y_PROPERLY     # If direction is 0 (Up)  %
0000208b : 02c0006f;   % 1965:         j MOVE_BEAM_X_PROPERLY  %
0000208c : 00754303;   % 1968:         lbu t1, 7(a0)    # Loads beam's current Y %
0000208d : 00650423;   % 1969:         sb t1, 8(a0)     # and stores it on beam's old Y %
0000208e : 00454283;   % 1971:         lbu t0,4(a0)   # Loads beam's current Y offset %
0000208f : ff828293;   % 1972:         addi t0,t0,-8  # moves it up %
00002090 : 0002d863;   % 1974:         bge t0,zero,MOVE_BEAM_Y_PROPERLY_STORE_BEAM # If no correction is needed %
00002091 : fff30313;   % 1976:             addi t1,t1,-1          # Moves Y up one tile %
00002092 : 01028293;   % 1977:             addi t0,t0,16   # adds 16 to offset %
00002093 : 006503a3;   % 1978:             sb t1, 7(a0)     # Stores beam's new Y %
00002094 : 00550223;   % 1981:             sb t0, 4(a0)     # Stores new Y offset %
00002095 : 0640006f;   % 1982:             j END_MOVE_BEAM # Goes to render %
00002096 : 00150283;   % 1985:         lb t0, 1(a0)     # loads direction %
00002097 : 00554303;   % 1986:         lbu t1, 5(a0)    # Loads beam's current X %
00002098 : 00650323;   % 1987:         sb t1, 6(a0)     # and stores it on beam's old X %
00002099 : 0fc0ae17;   % 1989:         la t3,MOVE_X     # Loads MOVE_X %
0000209a : ec8e0e13;   % 1989:  %
0000209b : 000e0e03;   % 1990:         lb t3,0(t3)      # and gets player's movement speed %
0000209c : 00000e93;   % 1991:         li t4,0          # X momentum %
0000209d : 000e0463;   % 1992:         beqz t3,MOVE_BEAM_X_PROPERLY_SKIP_ADD %
0000209e : 00229e93;   % 1993:             slli t4,t0,2     # Multiplies t0 by 4 (so that beam moves +-4) %
0000209f : 00329393;   % 1995:             slli t2,t0,3     # Multiplies t0 by 8 (so that beam moves +-8) %
000020a0 : 00354283;   % 1997:             lbu t0,3(a0)     # Loads beam's current X offset %
000020a1 : 007282b3;   % 1998:             add t0,t0,t2     # moves it %
000020a2 : 01d282b3;   % 1999:             add t0,t0,t4     # and adds player's momentum %
000020a3 : 0002da63;   % 2001:         bge t0,zero,MOVE_BEAM_X_PROPERLY_SKIP_NEGATIVE_CORRECTION %
000020a4 : fff30313;   % 2003:             addi t1,t1,-1          # Moves X one tile to the left %
000020a5 : 01028293;   % 2004:             addi t0,t0,16   # adds 16 to offset %
000020a6 : 006502a3;   % 2005:             sb t1, 5(a0)           # Stores beam's new X %
000020a7 : 0180006f;   % 2006:             j MOVE_BEAM_X_PROPERLY_STORE_BEAM %
000020a8 : 01000393;   % 2010:             li t2,16 %
000020a9 : 0072c863;   % 2011:             blt t0,t2,MOVE_BEAM_X_PROPERLY_STORE_BEAM  # If  0 <= resulting offset < 16, don't change X %
000020aa : 00130313;   % 2013:                 addi t1,t1,1           # Moves X one tile to the right %
000020ab : 407282b3;   % 2014:                 sub t0,t0,t2           # subtracts 16 from offset %
000020ac : 006502a3;   % 2015:                 sb t1, 5(a0)           # Stores beam's new X %
000020ad : 005501a3;   % 2019:             sb t0, 3(a0)     # Stores new X offset %
000020ae : 00008067;   % 2023:         ret %
000020af : 00754603;   % 2052:     lbu a2,7(a0)    # Loads bomb's current Y %
000020b0 : 00c50423;   % 2053:     sb a2,8(a0)     # And stores it on old Y %
000020b1 : 00454683;   % 2054:     lbu a3,4(a0)    # Loads bomb's current Y offset %
000020b2 : 00857553;   % 2058:     fadd.s fa0,fa0,fs0    # fa0 = Bomb's current Y speed + gravity factor        %
000020b3 : c0057e53;   % 2059:     fcvt.w.s t3,fa0       # Sets t3 = floor(fa0) %
000020b4 : 00800293;   % 2061:     li t0,8                    # Loads max speed (8, when falling) %
000020b5 : 005e4663;   % 2062:     blt t3,t0, SKIP_BOMB_MAX_SPEED   # If t3 < 8, skip this part %
000020b6 : 00800e13;   % 2064:         li t3,8 %
000020b7 : d002f553;   % 2065:         fcvt.s.w fa0,t0 %
000020b8 : 01c686b3;   % 2068:         add a3,a3,t3	# Adds the Y Movement to the Bomb's Offset       %
000020b9 : 01000293;   % 2070:         li t0, 16 %
000020ba : 0056c663;   % 2071:         blt a3,t0, SKIP_DOWN_Y_BOMB %
000020bb : 00160613;   % 2073:         addi a2,a2, 1	 # Bomb's Y on matrix += 1 (goes to the right) %
000020bc : 405686b3;   % 2074:         sub a3,a3,t0	 # Offset gets corrected (relative to new Y on matrix coordinate) %
000020bd : 0015c783;   % 2078:         lbu a5,1(a1)     # Loads map's matrix width %
000020be : 00554803;   % 2079:         lbu a6,5(a0)     # Loads Bomb's current X %
000020bf : 00754883;   % 2080:         lbu a7,7(a0)     # Loads Bomb's current Y %
000020c0 : 00358593;   % 2082:         addi a1,a1,3     # Adds 3 to the Matrix's address so that it goes to the beginning of matrix %
000020c1 : 02f882b3;   % 2083:         mul t0,a7,a5     # (Bomb's matrix Y + 3)  * Map Matrix's width %
000020c2 : 005802b3;   % 2084:         add t0,a6,t0     # t0 = Bomb's X related to matrix + (Bomb's matrix Y + 3)  * Map Matrix's width %
000020c3 : 005585b3;   % 2085:         add a1,a1,t0     # a1 = Map Matrix's address adjusted for Bomb's X and Y (+3) related to matrix        %
000020c4 : 00454283;   % 2088:         lbu t0,4(a0)     # Loads Bomb's Y offset     %
000020c5 : 00f585b3;   % 2089:         add a1,a1,a5  # Moves matrix one tile down %
000020c6 : 00188893;   % 2090:         addi a7,a7,1  # Moves Y one tile down %
000020c7 : 00028e63;   % 2091:         beqz t0 CONTINUE_CHECK_Y_DOWN_BOMB   # If Bomb's Y offset == 0, continue checking %
000020c8 : 00f585b3;   % 2094:         add a1,a1,a5  # If Y offset != 0 %
000020c9 : 00188893;   % 2095:         addi a7,a7,1  # If Y offset != 0 %
000020ca : 01000313;   % 2097:         li t1,16  # Loads 16 %
000020cb : 01c282b3;   % 2098:         add t0,t0,t3     # Current Y offset + Y offset modifier %
000020cc : 0062d463;   % 2099:         bge t0,t1 CONTINUE_CHECK_Y_DOWN_BOMB  # If current offset + offset modifier >= 16, continue checking (but check one tile bellow) %
000020cd : 0b00006f;   % 2100:             j MOVE_BOMB_PROPERLY              # Othewise, just move the bomb %
000020ce : 00100713;   % 2105:             li a4, 1  # Base case: Consider doors       %
000020cf : 00100393;   % 2106:             li t2, 1  # Base case: Check only one tile   %
000020d0 : 00354e03;   % 2108:             lbu t3,3(a0)     # Loads Bomb's X offset %
000020d1 : 000e0e63;   % 2109:             beqz t3 CHECK_BOMB_Y_DOWN_BOTH_DOORS # If X offset = 0, just check one tile bellow, and consider both doors %
000020d2 : 00800293;   % 2110:             li t0, 8   # Loads number 8 for comparing with X offset  %
000020d3 : 005e4e63;   % 2111:             blt t3,t0, CHECK_BOMB_Y_DOWN_RIGHT_DOOR # If X offset < 8, just check one tile bellow, and consider right doors %
000020d4 : 03c2c063;   % 2112:             blt t0,t3, CHECK_BOMB_Y_DOWN_LEFT_DOOR # If X offset > 8, check one tile bellow to the right , and consider left doors %
000020d5 : 00200393;   % 2114:                 li t2,2   # Check 2 tiles bellow bomb (one bellow, the other bellow to the right)   %
000020d6 : 00000713;   % 2115:                 li a4,0   # Ignore doors %
000020d7 : 0200006f;   % 2116:                 j START_BOMB_COLLISION %
000020d8 : 00200313;   % 2120:                 li t1, 2 # Consider both doors on the left and on the right sides of the map %
000020d9 : 0180006f;   % 2121:                 j START_BOMB_COLLISION %
000020da : 00000313;   % 2125:                 li t1, 0 # Only consider doors on the right side of the map %
000020db : 0100006f;   % 2126:                 j START_BOMB_COLLISION %
000020dc : 00100313;   % 2130:                 li t1, 1 # Only consider doors on the left side of the map %
000020dd : 00158593;   % 2131:                 addi a1,a1, 1 # Looks to the tile on the right of Bomb's current tile %
000020de : 00180813;   % 2132:                 addi a6,a6,1  # Increments current X on matrix (+1 X) %
000020df : fec10113;   % 2137:                 addi sp,sp,-20 %
000020e0 : 00d12823;   % 2138:                 sw a3,16(sp) %
000020e1 : 00c12623;   % 2139:                 sw a2,12(sp) %
000020e2 : 00b12423;   % 2140:                 sw a1,8(sp) %
000020e3 : 00a12223;   % 2141:                 sw a0,4(sp) %
000020e4 : 00112023;   % 2142:                 sw ra,0(sp) %
000020e5 : 00600533;   % 2145:                 mv a0,t1  # Doesn't matter, since no doors will be checked %
000020e6 : 00700633;   % 2147:                 mv a2,t2  # Only check one tile %
000020e7 : 00100693;   % 2148:                 li a3,1   # Vertical check %
000020e8 : 00100213;   % 2152:                 li tp, 1  # Entity collision %
000020e9 : 00001317;   % 2153:                 call CHECK_MAP_COLLISION %
000020ea : 9b0300e7;   % 2153:  %
000020eb : 00a002b3;   % 2154:                 mv t0,a0 %
000020ec : 01012683;   % 2157:                 lw a3,16(sp) %
000020ed : 00c12603;   % 2158:                 lw a2,12(sp) %
000020ee : 00812583;   % 2159:                 lw a1,8(sp) %
000020ef : 00412503;   % 2160:                 lw a0,4(sp) %
000020f0 : 00012083;   % 2161:                 lw ra,0(sp) %
000020f1 : 01410113;   % 2162:                 addi sp,sp,20 %
000020f2 : 00029e63;   % 2166:             bnez t0, MOVE_BOMB_PROPERLY   # If returning anything but 0, Plasma Breath can move %
000020f3 : d0007553;   % 2168:                 fcvt.s.w fa0,zero # Resets Bomb's jump speed %
000020f4 : 00454283;   % 2170:                 lbu t0,4(a0)   # Loads Bomb's current Y offset   %
000020f5 : 00028663;   % 2171:                 beqz t0,MOVE_BOMB_SKIP_ADJUST_Y   %
000020f6 : 00050223;   % 2172:                     sb zero, 4(a0) # Sets Bomb's Y offset to 0  %
000020f7 : 00c503a3;   % 2173:                     sb a2,7(a0)    # Stores new Y  %
000020f8 : 00c0006f;   % 2176:                     j END_MOVE_BOMB   # Finish procedure                %
000020f9 : 00c503a3;   % 2179:             sb a2,7(a0)     # Stores Bomb's new Y  %
000020fa : 00d50223;   % 2180:             sb a3,4(a0)     # Stores new Y offset %
000020fb : 00008067;   % 2184:         ret %
000020fc : 00454303;   % 2218:     lbu t1,4(a0)  # Loads Zoomer's X %
000020fd : 006502a3;   % 2219:     sb t1,5(a0)   # And stores it in Zoomer's old  %
000020fe : 00654303;   % 2220:     lbu t1,6(a0)  # Loads Zoomer's Y %
000020ff : 006503a3;   % 2221:     sb t1,7(a0)   # And stores it in Zoomer's old Y %
00002100 : 00000613;   % 2223:     li a2, 0      # First stage of check (platform)  %
00002101 : ffc10113;   % 2225:         addi sp,sp,-4 %
00002102 : 00b12023;   % 2226:         sw a1,0(sp) %
00002103 : 00100293;   % 2230:         li t0,1       # In case no collision check is made %
00002104 : 00012583;   % 2232:         lw a1,0(sp)   # Loads map's matrix original address %
00002105 : 0015c783;   % 2233:         lbu a5,1(a1)  # Loads map's matrix width %
00002106 : 00454803;   % 2234:         lbu a6,4(a0)  # Loads Zoomer's current X %
00002107 : 00654883;   % 2235:         lbu a7,6(a0)  # Loads Zoomer's current Y %
00002108 : 00358593;   % 2237:         addi a1,a1,3   # Adds 3 to the Matrix's address so that it goes to the beginning of matrix %
00002109 : 02f88333;   % 2238:         mul t1,a7,a5   # Zoomer's Y related to matrix * Map Matrix's width %
0000210a : 00680333;   % 2239:         add t1,a6,t1   # t1 = Zoomer's X related to matrix +  Zoomer's Y related to matrix * Map Matrix's width   %
0000210b : 006585b3;   % 2240:         add a1,a1,t1   # a1 = Map Matrix's address adjusted for Zoomer's X and Y related to matrix %
0000210c : 00000713;   % 2242:         li a4,0  # Base case: Don't consider doors (if X offset stays 0) %
0000210d : 00100213;   % 2243:         li tp,1  # Base case (will be passed to a2): only check 1 tile (if X offset stays 0) %
0000210e : 00a54303;   % 2245:         lbu t1,10(a0)  # Loads Zoomer's Platform %
0000210f : 00254383;   % 2246:         lbu t2,2(a0)   # Loads Zoomer's X offset %
00002110 : 00354e03;   % 2247:         lbu t3,3(a0)   # Loads Zoomer's Y offset %
00002111 : 00954e83;   % 2248:         lbu t4,9(a0)   # Loads Zoomer's Clock movement %
00002112 : 06031663;   % 2249:         bnez t1,TRY_MOVE_ZOOMER_COLLISION_LEFT %
00002113 : 00100713;   % 2251:             li a4,1  # Base case: Consider doors %
00002114 : 00800313;   % 2252:             li t1,8 %
00002115 : 00731c63;   % 2253:             bne t1,t2,MOVE_ZOOMER_CHECK_DOWN_0_OFF  # If offset != 8, check if it's 0 %
00002116 : 00100713;   % 2254:                 li a4,1  # Base case: Consider doors %
00002117 : 00c70733;   % 2255:                 add a4,a4,a2 # If on second check, consider ONLY doors %
00002118 : 00200213;   % 2256:                 li tp,2  # Check 2 tiles %
00002119 : 40c20233;   % 2257:                 sub tp,tp,a2 # If on second check, check ONLY 1 tile %
0000211a : 00c0006f;   % 2258:                 j MOVE_ZOOMER_CHECK_DOWN_SETUP # start collision check %
0000211b : 00038463;   % 2261:             beqz t2, MOVE_ZOOMER_CHECK_DOWN_SETUP %
0000211c : 3ec0006f;   % 2262:                 j MOVE_ZOOMER_PROPERLY %
0000211d : 00061a63;   % 2265:             bnez a2, MOVE_ZOOMER_CHECK_DOWN_FOWARD %
0000211e : 00188893;   % 2267:                 addi a7,a7,1 # Checking one tile down %
0000211f : 00f585b3;   % 2268:                 add a1,a1,a5 # Updates starting address on map matrix %
00002120 : 00100693;   % 2269:                 li a3,1  # Vertical check %
00002121 : 1600006f;   % 2270:                 j START_ZOOMER_COLLISION %
00002122 : 000e8e63;   % 2274:                 beqz t4, MOVE_ZOOMER_CHECK_DOWN_FOWARD_CLOCKWISE %
00002123 : 00800313;   % 2276:                 li t1,8 %
00002124 : 00730663;   % 2277:                 beq t1,t2,MOVE_ZOOMER_CHECK_DOWN_FOWARD_OFF_8 # If offset == 8, don't alter X %
00002125 : fff80813;   % 2278:                     addi a6,a6,-1   # Checking left tile %
00002126 : fff58593;   % 2279:                     addi a1,a1,-1   # Updates starting address on map matrix %
00002127 : 00000693;   % 2281:                     li a3,0  # Horizontal check %
00002128 : 1440006f;   % 2282:                     j START_ZOOMER_COLLISION %
00002129 : 00180813;   % 2286:                     addi a6,a6,1  # Checking right tile %
0000212a : 00158593;   % 2287:                     addi a1,a1,1   # Updates starting address on map matrix %
0000212b : 00000693;   % 2288:                     li a3,0  # Horizontal check %
0000212c : 1340006f;   % 2289:                     j START_ZOOMER_COLLISION %
0000212d : 00100f13;   % 2292:         TRY_MOVE_ZOOMER_COLLISION_LEFT:  li t5,1 %
0000212e : 07e31463;   % 2293:             bne t1,t5,TRY_MOVE_ZOOMER_COLLISION_UP %
0000212f : 00800313;   % 2295:             li t1,8 %
00002130 : 00731663;   % 2296:             bne t1,t2,MOVE_ZOOMER_CHECK_LEFT_0_OFF  # If X offset != 8, skip it %
00002131 : 00100713;   % 2297:                 li a4,1  # Base case: Consider doors %
00002132 : 40c70733;   % 2298:                 sub a4,a4,a2 # If on second check, don't consider doors            %
00002133 : 000e0463;   % 2301:             beqz t3, MOVE_ZOOMER_CHECK_LEFT_SETUP %
00002134 : 38c0006f;   % 2302:                 j MOVE_ZOOMER_PROPERLY %
00002135 : 00061e63;   % 2305:             bnez a2, MOVE_ZOOMER_CHECK_LEFT_FOWARD %
00002136 : 00800313;   % 2307:                 li t1,8 %
00002137 : 00730663;   % 2308:                 beq t1,t2,MOVE_ZOOMER_CHECK_LEFT_8_OFF  # If X offset is 8, don't update X  %
00002138 : fff80813;   % 2309:                     addi a6,a6,-1  # Checking left tile (or current tile if X offset == 8) %
00002139 : fff58593;   % 2310:                     addi a1,a1,-1   # Updates starting address on map matrix  %
0000213a : 00000693;   % 2312:                 li a3,0  # Horizontal check %
0000213b : 0f80006f;   % 2313:                 j START_ZOOMER_COLLISION %
0000213c : 00800313;   % 2317:                 li t1,8 %
0000213d : 00730463;   % 2318:                 beq t1,t2,MOVE_ZOOMER_CHECK_LEFT_FOWARD_8_OFF  # If X offset is 8, don't consider doors %
0000213e : 00100713;   % 2319:                     li a4,1  # Base case: Consider doors %
0000213f : 000e8a63;   % 2321:                 beqz t4, MOVE_ZOOMER_CHECK_LEFT_FOWARD_CLOCKWISE %
00002140 : fff88893;   % 2323:                     addi a7,a7,-1 # Checking one tile up %
00002141 : 40f585b3;   % 2324:                     sub a1,a1,a5  # Updates starting address on map matrix %
00002142 : 00100693;   % 2325:                     li a3,1  # Vertical check %
00002143 : 0d80006f;   % 2326:                     j START_ZOOMER_COLLISION %
00002144 : 00188893;   % 2330:                     addi a7,a7,1 # Checking one tile down %
00002145 : 00f585b3;   % 2331:                     add a1,a1,a5 # Updates starting address on map matrix %
00002146 : 00100693;   % 2332:                     li a3,1  # Vertical check %
00002147 : 0c80006f;   % 2333:                     j START_ZOOMER_COLLISION %
00002148 : 00200f13;   % 2336:         TRY_MOVE_ZOOMER_COLLISION_UP:  li t5,2 %
00002149 : 07e31463;   % 2337:             bne t1,t5,MOVE_ZOOMER_COLLISION_RIGHT %
0000214a : 00800f13;   % 2339:             li t5,8 %
0000214b : 007f1c63;   % 2340:             bne t5,t2,MOVE_ZOOMER_CHECK_UP_0_OFF  # If offset != 8, check if it's 0 %
0000214c : 00100713;   % 2341:                 li a4,1  # Base case: Consider doors %
0000214d : 00c70733;   % 2342:                 add a4,a4,a2 # If on second check, consider ONLY doors %
0000214e : 00200213;   % 2344:                 li tp,2  # Check 2 tiles %
0000214f : 40c20233;   % 2345:                 sub tp,tp,a2 # If on second check, check ONLY 1 tile %
00002150 : 00c0006f;   % 2347:                 j MOVE_ZOOMER_CHECK_UP_SETUP # start collision check %
00002151 : 00038463;   % 2350:             beqz t2, MOVE_ZOOMER_CHECK_UP_SETUP %
00002152 : 3140006f;   % 2351:                 j MOVE_ZOOMER_PROPERLY %
00002153 : 00061a63;   % 2354:             bnez a2, MOVE_ZOOMER_CHECK_UP_FOWARD %
00002154 : fff88893;   % 2356:                 addi a7,a7,-1 # Checking one tile above %
00002155 : 40f585b3;   % 2357:                 sub a1,a1,a5  # Updates starting address on map matrix %
00002156 : 00100693;   % 2358:                 li a3,1  # Vertical check %
00002157 : 0880006f;   % 2359:                 j START_ZOOMER_COLLISION %
00002158 : 000e8a63;   % 2363:                 beqz t4, MOVE_ZOOMER_CHECK_UP_FOWARD_CLOCKWISE %
00002159 : 00180813;   % 2365:                     addi a6,a6,1  # Checking right tile %
0000215a : 00158593;   % 2366:                     addi a1,a1,1   # Updates starting address on map matrix %
0000215b : 00000693;   % 2367:                     li a3,0  # Horizontal check %
0000215c : 0740006f;   % 2368:                     j START_ZOOMER_COLLISION %
0000215d : 00800f13;   % 2372:                     li t5,8 %
0000215e : 007f0663;   % 2373:                     beq t5,t2,MOVE_ZOOMER_CHECK_UP_FOWARD_CLOCKWISE_0_OFF  # If offset is 8, don't update this %
0000215f : fff80813;   % 2374:                         addi a6,a6,-1  # Checking left tile %
00002160 : fff58593;   % 2375:                         addi a1,a1,-1   # Updates starting address on map matrix %
00002161 : 00000693;   % 2377:                     li a3,0  # Horizontal check %
00002162 : 05c0006f;   % 2378:                     j START_ZOOMER_COLLISION %
00002163 : 00800313;   % 2383:             li t1,8 %
00002164 : 00731863;   % 2384:             bne t1,t2,MOVE_ZOOMER_CHECK_RIGHT_0_OFF  # If X offset != 8, skip this %
00002165 : 00100713;   % 2385:                 li a4,1  # Base case: Consider doors %
00002166 : 00c80833;   % 2387:                 add a6,a6,a2   # Checking right tile %
00002167 : 00c585b3;   % 2388:                 add a1,a1,a2   # Updates starting address on map matrix %
00002168 : 000e0463;   % 2392:             beqz t3, MOVE_ZOOMER_CHECK_RIGHT_SETUP %
00002169 : 2b80006f;   % 2393:                 j MOVE_ZOOMER_PROPERLY %
0000216a : 00061a63;   % 2396:             bnez a2, MOVE_ZOOMER_CHECK_RIGHT_FOWARD %
0000216b : 00180813;   % 2398:                 addi a6,a6,1   # Checking right tile %
0000216c : 00158593;   % 2399:                 addi a1,a1,1   # Updates starting address on map matrix %
0000216d : 00000693;   % 2400:                 li a3,0  # Horizontal check %
0000216e : 02c0006f;   % 2401:                 j START_ZOOMER_COLLISION %
0000216f : 00100713;   % 2405:                 li a4,1  # Base case: Consider doors %
00002170 : 000e8a63;   % 2406:                 beqz t4, MOVE_ZOOMER_CHECK_RIGHT_FOWARD_CLOCKWISE %
00002171 : 00188893;   % 2408:                     addi a7,a7,1 # Checking one tile down %
00002172 : 00f585b3;   % 2409:                     add a1,a1,a5 # Updates starting address on map matrix %
00002173 : 00100693;   % 2410:                     li a3,1  # Vertical check %
00002174 : 0140006f;   % 2411:                     j START_ZOOMER_COLLISION %
00002175 : fff88893;   % 2415:                     addi a7,a7,-1 # Checking one tile up %
00002176 : 40f585b3;   % 2416:                     sub a1,a1,a5  # Updates starting address on map matrix %
00002177 : 00100693;   % 2417:                     li a3,1  # Vertical check %
00002178 : 0040006f;   % 2418:                     j START_ZOOMER_COLLISION %
00002179 : ff010113;   % 2422:             addi sp,sp,-16 %
0000217a : 00112023;   % 2423:             sw ra,0(sp) %
0000217b : 00a12223;   % 2424:             sw a0,4(sp) %
0000217c : 00b12423;   % 2425:             sw a1,8(sp) %
0000217d : 00c12623;   % 2426:             sw a2,12(sp) %
0000217e : 00200513;   % 2429:             li a0,2  # All doors should be checked %
0000217f : 00400633;   % 2431:             mv a2,tp #li a2,1  # Only check one tile %
00002180 : 00100213;   % 2437:             li tp, 1  # Entity collision %
00002181 : 00000317;   % 2439:             call CHECK_MAP_COLLISION %
00002182 : 750300e7;   % 2439:  %
00002183 : 00a002b3;   % 2440:             mv t0,a0   # Stores result from a0 to t0 %
00002184 : 00b00233;   % 2441:             mv tp,a1   # Stores result from a1 to tp %
00002185 : 00012083;   % 2444:             lw ra,0(sp) %
00002186 : 00412503;   % 2445:             lw a0,4(sp) %
00002187 : 00812583;   % 2446:             lw a1,8(sp) %
00002188 : 00c12603;   % 2447:             lw a2,12(sp) %
00002189 : 01010113;   % 2448:             addi sp,sp,16 %
0000218a : 00060463;   % 2451:         beqz a2, MOVE_ZOOMER_FIRST_CHECK  %
0000218b : 18c0006f;   % 2452:             j MOVE_ZOOMER_SECOND_CHECK %
0000218c : 04029c63;   % 2456:             bnez t0, MOVE_ZOOMER_CHANGE_PLATFORM # If returning anything but 0, change zoomer's platform %
0000218d : 00800f13;   % 2457:             li t5,8 %
0000218e : 00254383;   % 2458:             lbu t2,2(a0)   # Loads Zoomer's X offset %
0000218f : 047f1263;   % 2459:             bne t5,t2,MOVE_ZOOMER_REPEAT_LOOP # If zoomer's X isn't 8, treat it as solid %
00002190 : 04020063;   % 2460:             beqz tp,MOVE_ZOOMER_REPEAT_LOOP # If zoomer isn't on top of a door, treat as solid %
00002191 : 00a54303;   % 2462:                 lbu t1,10(a0)  # Loads Zoomer's Platform %
00002192 : 00354e03;   % 2463:                 lbu t3,3(a0)   # Loads Zoomer's Y offset %
00002193 : 00954e83;   % 2464:                 lbu t4,9(a0)   # Loads Zoomer's Clock movement %
00002194 : 02031863;   % 2465:                 bnez t1,MOVE_ZOOMER_REPEAT_LOOP %
00002195 : 000e8c63;   % 2467:                     beqz t4, MOVE_ZOOMER_CHANGE_PLATFORM_DOWN_CLOCKWISE_OFF_8 %
00002196 : 00300313;   % 2469:                         li t1, 3       # Sets platform to 3 (on the right) %
00002197 : 00200e13;   % 2470:                         li t3, 2       # Sets Y offset to 4 %
00002198 : 00650523;   % 2472:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
00002199 : 01c501a3;   % 2473:                         sb t3,3(a0)   # Stores Zoomer's new Y offset %
0000219a : 2e00006f;   % 2474:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
0000219b : 00100313;   % 2478:                         li t1, 1       # Sets platform to 1 (on the left) %
0000219c : 00200e13;   % 2480:                         li t3, 2       # Sets Y offset to 4 %
0000219d : 00650523;   % 2482:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
0000219e : 01c501a3;   % 2483:                         sb t3,3(a0)   # Stores Zoomer's new Y offset %
0000219f : 2cc0006f;   % 2484:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
000021a0 : 00100613;   % 2488:                 li a2,1 # Loads second check state %
000021a1 : d89ff06f;   % 2489:                 j MOVE_ZOOMER_CHECK_LOOP # and return to the beginning %
000021a2 : 00a54303;   % 2492:                 lbu t1,10(a0)  # Loads Zoomer's Platform %
000021a3 : 00254383;   % 2493:                 lbu t2,2(a0)   # Loads Zoomer's X offset %
000021a4 : 00354e03;   % 2494:                 lbu t3,3(a0)   # Loads Zoomer's Y offset %
000021a5 : 00954e83;   % 2495:                 lbu t4,9(a0)   # Loads Zoomer's Clock movement %
000021a6 : 02031863;   % 2496:                 bnez t1,TRY_MOVE_ZOOMER_CHANGE_PLATFORM_LEFT %
000021a7 : 000e8c63;   % 2498:                     beqz t4, MOVE_ZOOMER_CHANGE_PLATFORM_DOWN_CLOCKWISE %
000021a8 : 00300313;   % 2500:                         li t1, 3       # Sets platform to 3 (on the right) %
000021a9 : 00200e13;   % 2502:                         li t3, 2       # Sets Y offset to 4 %
000021aa : 00650523;   % 2504:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
000021ab : 01c501a3;   % 2505:                         sb t3,3(a0)   # Stores Zoomer's new Y offset %
000021ac : 2980006f;   % 2506:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
000021ad : 00100313;   % 2510:                         li t1, 1       # Sets platform to 1 (on the left) %
000021ae : 00200e13;   % 2512:                         li t3, 2       # Sets Y offset to 4 %
000021af : 00650523;   % 2514:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
000021b0 : 01c501a3;   % 2515:                         sb t3,3(a0)   # Stores Zoomer's new Y offset %
000021b1 : 2840006f;   % 2516:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
000021b2 : 00100f13;   % 2518:                 TRY_MOVE_ZOOMER_CHANGE_PLATFORM_LEFT:  li t5,1 %
000021b3 : 07e31063;   % 2519:                 bne t1,t5,TRY_MOVE_ZOOMER_CHANGE_PLATFORM_UP %
000021b4 : 020e8e63;   % 2521:                     beqz t4, MOVE_ZOOMER_CHANGE_PLATFORM_LEFT_CLOCKWISE %
000021b5 : 00000313;   % 2523:                         li t1, 0       # Sets platform to 0 (bellow) %
000021b6 : 00800f13;   % 2524:                         li t5,8 %
000021b7 : 027f0063;   % 2525:                         beq t5,t2,MOVE_ZOOMER_CHANGE_PLATFORM_LEFT_OFF_8 # If offset == 8, don't alter X %
000021b8 : 00e00393;   % 2526:                             li t2, 14      # Sets X offset to 12 %
000021b9 : 00454e83;   % 2527:                             lbu t4,4(a0)   # Loads Zoomer's X %
000021ba : fffe8e93;   % 2528:                             addi t4,t4,-1  # Subtracts 1 from it (offset was reduced) %
000021bb : 00650523;   % 2531:                             sb t1,10(a0)  # Stores Zoomer's new Platform %
000021bc : 00750123;   % 2532:                             sb t2,2(a0)   # Stores Zoomer's new X offset %
000021bd : 01d50223;   % 2533:                             sb t4,4(a0)   # Stores Zoomer's new X %
000021be : 2500006f;   % 2534:                             j END_MOVE_ZOOMER # Ends Move Zoomer %
000021bf : 00600393;   % 2537:                             li t2, 6       # Sets X offset to 6 %
000021c0 : 00650523;   % 2540:                             sb t1,10(a0)  # Stores Zoomer's new Platform %
000021c1 : 00750123;   % 2541:                             sb t2,2(a0)   # Stores Zoomer's new X offset %
000021c2 : 2400006f;   % 2542:                             j END_MOVE_ZOOMER # Ends Move Zoomer %
000021c3 : 00200313;   % 2547:                         li t1, 2       # Sets platform to 2 (above) %
000021c4 : 00e00393;   % 2548:                         li t2, 14      # Sets X offset to 12 %
000021c5 : 00454e83;   % 2549:                         lbu t4,4(a0)   # Loads Zoomer's X %
000021c6 : fffe8e93;   % 2550:                         addi t4,t4,-1  # Subtracts 1 from it (offset was reduced) %
000021c7 : 00650523;   % 2553:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
000021c8 : 00750123;   % 2554:                         sb t2,2(a0)   # Stores Zoomer's new X offset %
000021c9 : 01d50223;   % 2555:                         sb t4,4(a0)   # Stores Zoomer's new X %
000021ca : 2200006f;   % 2556:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
000021cb : 00200f13;   % 2558:                 TRY_MOVE_ZOOMER_CHANGE_PLATFORM_UP:  li t5,2 %
000021cc : 05e31463;   % 2559:                 bne t1,t5,MOVE_ZOOMER_CHANGE_PLATFORM_RIGHT %
000021cd : 020e8263;   % 2561:                     beqz t4, MOVE_ZOOMER_CHANGE_PLATFORM_UP_CLOCKWISE %
000021ce : 00100313;   % 2563:                         li t1, 1       # Sets platform to 1 (on the left) %
000021cf : 00e00e13;   % 2565:                         li t3, 14      # Sets Y offset to 12 %
000021d0 : 00654e83;   % 2566:                         lbu t4,6(a0)   # Loads Zoomer's Y %
000021d1 : fffe8e93;   % 2567:                         addi t4,t4,-1  # Subtracts 1 from it (offset was reduced) %
000021d2 : 00650523;   % 2569:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
000021d3 : 01c501a3;   % 2570:                         sb t3,3(a0)   # Stores Zoomer's new Y offset %
000021d4 : 01d50323;   % 2571:                         sb t4,6(a0)   # Stores Zoomer's new Y %
000021d5 : 1f40006f;   % 2572:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
000021d6 : 00300313;   % 2576:                         li t1, 3       # Sets platform to 3 (on the right) %
000021d7 : 00e00e13;   % 2578:                         li t3, 14      # Sets Y offset to 12 %
000021d8 : 00654e83;   % 2579:                         lbu t4,6(a0)   # Loads Zoomer's Y %
000021d9 : fffe8e93;   % 2580:                         addi t4,t4,-1  # Subtracts 1 from it (offset was reduced) %
000021da : 00650523;   % 2582:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
000021db : 01c501a3;   % 2583:                         sb t3,3(a0)   # Stores Zoomer's new Y offset %
000021dc : 01d50323;   % 2584:                         sb t4,6(a0)   # Stores Zoomer's new Y %
000021dd : 1d40006f;   % 2585:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
000021de : 000e8c63;   % 2589:                     beqz t4, MOVE_ZOOMER_CHANGE_PLATFORM_RIGHT_CLOCKWISE %
000021df : 00200313;   % 2591:                         li t1, 2       # Sets platform to 2 (above) %
000021e0 : 00200393;   % 2592:                         li t2, 2       # Sets X offset to 4 %
000021e1 : 00650523;   % 2595:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
000021e2 : 00750123;   % 2596:                         sb t2,2(a0)   # Stores Zoomer's new X offset %
000021e3 : 1bc0006f;   % 2597:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
000021e4 : 00000313;   % 2601:                         li t1, 0       # Sets platform to 0 (bellow) %
000021e5 : 00038a63;   % 2602:                         beqz t2,MOVE_ZOOMER_CHANGE_PLATFORM_RIGHT_CLOCKWISE_0 %
000021e6 : 00a00393;   % 2603:                             li t2, 10      # Sets X offset to 10 %
000021e7 : 00650523;   % 2606:                             sb t1,10(a0)  # Stores Zoomer's new Platform %
000021e8 : 00750123;   % 2607:                             sb t2,2(a0)   # Stores Zoomer's new X offset %
000021e9 : 1a40006f;   % 2608:                             j END_MOVE_ZOOMER # Ends Move Zoomer %
000021ea : 00200393;   % 2610:                             li t2, 2      # Sets X offset to 4 %
000021eb : 00650523;   % 2613:                             sb t1,10(a0)  # Stores Zoomer's new Platform %
000021ec : 00750123;   % 2614:                             sb t2,2(a0)   # Stores Zoomer's new X offset %
000021ed : 1940006f;   % 2615:                             j END_MOVE_ZOOMER # Ends Move Zoomer %
000021ee : 0a029263;   % 2619:             bnez t0, MOVE_ZOOMER_PROPERLY  # If returning anything but 0, properly move zoomer %
000021ef : 00a54303;   % 2621:                 lbu t1,10(a0)  # Loads Zoomer's Platform %
000021f0 : 00954e83;   % 2623:                 lbu t4,9(a0)   # Loads Zoomer's Clock movement %
000021f1 : 02031863;   % 2624:                 bnez t1,TRY_MOVE_ZOOMER_CHANGE_PLATFORM_LEFT_V2 %
000021f2 : 00254383;   % 2626:                     lbu t2,2(a0)   # Loads Zoomer's new X offset %
000021f3 : 00800f13;   % 2627:                     li t5,8 %
000021f4 : 007f0463;   % 2628:                     beq t5,t2,CONTINUE_MOVE_ZOOMER_CHANGE_PLATFORM_DOWN # If offset == 8, continue %
000021f5 : 08021463;   % 2630:                         bnez tp,MOVE_ZOOMER_PROPERLY # If there was a door, don't change direction %
000021f6 : 000e8863;   % 2632:                     beqz t4, MOVE_ZOOMER_CHANGE_PLATFORM_DOWN_CLOCKWISE_V2 %
000021f7 : 00100313;   % 2634:                         li t1, 1       # Sets platform to 1 (on the left) %
000021f8 : 00650523;   % 2635:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
000021f9 : 1640006f;   % 2636:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
000021fa : 00300313;   % 2640:                         li t1, 3       # Sets platform to 3 (on the right) %
000021fb : 00650523;   % 2641:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
000021fc : 1580006f;   % 2642:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
000021fd : 00100f13;   % 2644:                 TRY_MOVE_ZOOMER_CHANGE_PLATFORM_LEFT_V2:  li t5,1 %
000021fe : 03e31063;   % 2645:                 bne t1,t5,TRY_MOVE_ZOOMER_CHANGE_PLATFORM_UP_V2 %
000021ff : 000e8863;   % 2647:                     beqz t4, MOVE_ZOOMER_CHANGE_PLATFORM_LEFT_CLOCKWISE_V2 %
00002200 : 00200313;   % 2649:                         li t1, 2       # Sets platform to 2 (above) %
00002201 : 00650523;   % 2650:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
00002202 : 1400006f;   % 2651:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
00002203 : 00000313;   % 2655:                         li t1, 0       # Sets platform to 0 (bellow) %
00002204 : 00650523;   % 2656:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
00002205 : 1340006f;   % 2657:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
00002206 : 00200f13;   % 2659:                 TRY_MOVE_ZOOMER_CHANGE_PLATFORM_UP_V2:  li t5,2 %
00002207 : 03e31063;   % 2660:                 bne t1,t5,MOVE_ZOOMER_CHANGE_PLATFORM_RIGHT_V2 %
00002208 : 000e8863;   % 2662:                     beqz t4, MOVE_ZOOMER_CHANGE_PLATFORM_UP_CLOCKWISE_V2 %
00002209 : 00300313;   % 2664:                         li t1, 3       # Sets platform to 3 (on the right) %
0000220a : 00650523;   % 2665:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
0000220b : 11c0006f;   % 2666:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
0000220c : 00100313;   % 2670:                         li t1, 1       # Sets platform to 1 (on the left) %
0000220d : 00650523;   % 2671:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
0000220e : 1100006f;   % 2672:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
0000220f : 02021063;   % 2676:                     bnez tp,MOVE_ZOOMER_PROPERLY %
00002210 : 000e8863;   % 2677:                     beqz t4, MOVE_ZOOMER_CHANGE_PLATFORM_RIGHT_CLOCKWISE_V2 %
00002211 : 00000313;   % 2679:                         li t1, 0       # Sets platform to 0 (bellow) %
00002212 : 00650523;   % 2680:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
00002213 : 0fc0006f;   % 2681:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
00002214 : 00200313;   % 2685:                         li t1, 2       # Sets platform to 2 (above) %
00002215 : 00650523;   % 2686:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
00002216 : 0f00006f;   % 2687:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
00002217 : 00a54303;   % 2691:             lbu t1,10(a0)  # Loads Zoomer's Platform %
00002218 : 00254383;   % 2692:             lbu t2,2(a0)   # Loads Zoomer's X offset %
00002219 : 00354e03;   % 2693:             lbu t3,3(a0)   # Loads Zoomer's Y offset %
0000221a : 00954e83;   % 2694:             lbu t4,9(a0)   # Loads Zoomer's Clock movement %
0000221b : 00031c63;   % 2695:             bnez t1,TRY_MOVE_ZOOMER_PROPERLY_LEFT %
0000221c : 000e8663;   % 2697:                 beqz t4, MOVE_ZOOMER_PROPERLY_DOWN_CLOCKWISE %
0000221d : ffe38393;   % 2699:                     addi t2,t2,-2     # Updates X offset %
0000221e : 0540006f;   % 2701:                     j MOVE_ZOOMER_PROPERLY_OFFSET_CHECK # Checking if offset is ok %
0000221f : 00238393;   % 2705:                     addi t2,t2,2     # Updates X offset %
00002220 : 04c0006f;   % 2707:                     j MOVE_ZOOMER_PROPERLY_OFFSET_CHECK # Checking if offset is ok %
00002221 : 00100f13;   % 2709:             TRY_MOVE_ZOOMER_PROPERLY_LEFT:  li t5,1 %
00002222 : 01e31c63;   % 2710:             bne t1,t5,TRY_MOVE_ZOOMER_PROPERLY_UP %
00002223 : 000e8663;   % 2712:                 beqz t4, MOVE_ZOOMER_PROPERLY_LEFT_CLOCKWISE %
00002224 : ffee0e13;   % 2715:                     addi t3,t3,-2     # Updates Y offset %
00002225 : 0380006f;   % 2716:                     j MOVE_ZOOMER_PROPERLY_OFFSET_CHECK # Checking if offset is ok %
00002226 : 002e0e13;   % 2721:                     addi t3,t3,2     # Updates Y offset %
00002227 : 0300006f;   % 2722:                     j MOVE_ZOOMER_PROPERLY_OFFSET_CHECK # Checking if offset is ok %
00002228 : 00200f13;   % 2724:             TRY_MOVE_ZOOMER_PROPERLY_UP:  li t5,2 %
00002229 : 01e31c63;   % 2725:             bne t1,t5,MOVE_ZOOMER_PROPERLY_RIGHT %
0000222a : 000e8663;   % 2727:                 beqz t4, MOVE_ZOOMER_PROPERLY_UP_CLOCKWISE %
0000222b : 00238393;   % 2729:                     addi t2,t2,2     # Updates X offset %
0000222c : 01c0006f;   % 2731:                     j MOVE_ZOOMER_PROPERLY_OFFSET_CHECK # Checking if offset is ok %
0000222d : ffe38393;   % 2735:                     addi t2,t2,-2     # Updates X offset %
0000222e : 0140006f;   % 2737:                     j MOVE_ZOOMER_PROPERLY_OFFSET_CHECK # Checking if offset is ok %
0000222f : 000e8663;   % 2741:                 beqz t4, MOVE_ZOOMER_PROPERLY_RIGHT_CLOCKWISE %
00002230 : 002e0e13;   % 2744:                     addi t3,t3,2     # Updates Y offset %
00002231 : 0080006f;   % 2745:                     j MOVE_ZOOMER_PROPERLY_OFFSET_CHECK # Checking if offset is ok %
00002232 : ffee0e13;   % 2750:                     addi t3,t3,-2     # Updates Y offset %
00002233 : 00750123;   % 2754:                 sb t2,2(a0)   # Stores Zoomer's new X offset (may change depending on next checks) %
00002234 : 0003de63;   % 2755:                 bge t2,zero, SKIP_MOVE_ZOOMER_PROPERLY_X_OFFSET_NEGATIVE %
00002235 : 01038393;   % 2757:                     addi t2,t2,16 # adds 16 to offset %
00002236 : 00454e83;   % 2758:                     lbu t4,4(a0)         # Loads Zoomer's X %
00002237 : fffe8e93;   % 2759:                     addi t4,t4,-1        # subtracts 1 from it %
00002238 : 00750123;   % 2761:                     sb t2,2(a0)          # Stores Zoomer's new X offset %
00002239 : 01d50223;   % 2762:                     sb t4,4(a0)          # Stores Zoomer's new X %
0000223a : 0200006f;   % 2763:                     j MOVE_ZOOMER_PROPERLY_OFFSET_CHECK_Y    # check Y offset %
0000223b : 01000293;   % 2767:                 li t0,16 %
0000223c : 0053cc63;   % 2768:                 blt t2,t0,MOVE_ZOOMER_PROPERLY_OFFSET_CHECK_Y # X offset is ok %
0000223d : 405383b3;   % 2770:                     sub t2,t2,t0         # subtracts 16 to offset %
0000223e : 00454e83;   % 2771:                     lbu t4,4(a0)         # Loads Zoomer's X %
0000223f : 001e8e93;   % 2772:                     addi t4,t4,1         # adds 1 from it %
00002240 : 00750123;   % 2774:                     sb t2,2(a0)          # Stores Zoomer's new X offset %
00002241 : 01d50223;   % 2775:                     sb t4,4(a0)          # Stores Zoomer's new X %
00002242 : 01c501a3;   % 2779:                 sb t3,3(a0)   # Stores Zoomer's new X offset (may change depending on next checks) %
00002243 : 000e5e63;   % 2780:                 bge t3,zero, SKIP_MOVE_ZOOMER_PROPERLY_Y_OFFSET_NEGATIVE %
00002244 : 010e0e13;   % 2782:                     addi t3,t3,16 # adds 16 to offset %
00002245 : 00654e83;   % 2783:                     lbu t4,6(a0)         # Loads Zoomer's Y %
00002246 : fffe8e93;   % 2784:                     addi t4,t4,-1        # subtracts 1 from it %
00002247 : 01c501a3;   % 2786:                     sb t3,3(a0)          # Stores Zoomer's new Y offset %
00002248 : 01d50323;   % 2787:                     sb t4,6(a0)          # Stores Zoomer's new Y %
00002249 : 0240006f;   % 2788:                     j END_MOVE_ZOOMER    # Finishes procedure %
0000224a : 01000293;   % 2792:                 li t0,16 %
0000224b : 005e4e63;   % 2793:                 blt t3,t0,END_MOVE_ZOOMER # Y offset is ok %
0000224c : 405e0e33;   % 2795:                     sub t3,t3,t0         # subtracts 16 to offset %
0000224d : 00654e83;   % 2796:                     lbu t4,6(a0)         # Loads Zoomer's Y %
0000224e : 001e8e93;   % 2797:                     addi t4,t4,1         # adds 1 from it %
0000224f : 01c501a3;   % 2799:                     sb t3,3(a0)          # Stores Zoomer's new Y offset %
00002250 : 01d50323;   % 2800:                     sb t4,6(a0)          # Stores Zoomer's new Y %
00002251 : 0040006f;   % 2801:                     j END_MOVE_ZOOMER    # Finishes procedure %
00002252 : 00410113;   % 2806:         addi sp,sp,4 %
00002253 : 00008067;   % 2808:         ret %
00002254 : 00354303;   % 2833:     lbu t1,3(a0)  # Loads Ripper's X %
00002255 : 00650223;   % 2834:     sb t1,4(a0)   # And stores it in Ripper's old  %
00002256 : 00554303;   % 2835:     lbu t1,5(a0)  # Loads Ripper's Y %
00002257 : 00650323;   % 2836:     sb t1,6(a0)   # And stores it in Ripper's old Y %
00002258 : 00100293;   % 2839:     li t0,1       # In case no collision check is made %
00002259 : 00254303;   % 2840:     lbu t1,2(a0)  # Loads Ripper's X offset %
0000225a : 06031e63;   % 2842:     bnez t1,SKIP_RIPPER_COLLISION   # If offset isn't 0, just move ripper %
0000225b : 0015c783;   % 2844:         lbu a5,1(a1)  # Loads map's matrix width %
0000225c : 00354803;   % 2845:         lbu a6,3(a0)  # Loads Ripper's current X %
0000225d : 00554883;   % 2846:         lbu a7,5(a0)  # Loads Ripper's current Y %
0000225e : 00358593;   % 2848:         addi a1,a1,3   # Adds 3 to the Matrix's address so that it goes to the beginning of matrix %
0000225f : 02f882b3;   % 2849:         mul t0,a7,a5   # Ripper's Y related to matrix * Map Matrix's width %
00002260 : 005802b3;   % 2850:         add t0,a6,t0   # t0 = Ripper's X related to matrix +  Ripper's Y related to matrix * Map Matrix's width   %
00002261 : 005585b3;   % 2851:         add a1,a1,t0   # a1 = Map Matrix's address adjusted for Ripper's X and Y related to matrix %
00002262 : 00154283;   % 2853:         lbu t0,1(a0)  # Loads Ripper's direction %
00002263 : 00028863;   % 2854:         beqz t0,RIPPER_COLLISION_RIGHT   # If moving right %
00002264 : fff80813;   % 2856:             addi a6,a6,-1 # Checking tile to the left %
00002265 : fff58593;   % 2857:             addi a1,a1,-1 # Updates starting address on map matrix %
00002266 : 00c0006f;   % 2858:             j START_RIPPER_COLLISION %
00002267 : 00180813;   % 2861:             addi a6,a6,1 # Checking tile to the right %
00002268 : 00158593;   % 2862:             addi a1,a1,1 # Updates starting address on map matrix %
00002269 : ff410113;   % 2867:         addi sp,sp,-12 %
0000226a : 00a12023;   % 2868:         sw a0,0(sp) %
0000226b : 00b12223;   % 2869:         sw a1,4(sp) %
0000226c : 00112423;   % 2870:         sw ra,8(sp) %
0000226d : 00200513;   % 2873:         li a0,2  # Doesn't matter, since no doors will be checked %
0000226e : 00100613;   % 2875:         li a2,1  # Only check one tile %
0000226f : 00000693;   % 2876:         li a3,0  # Horizontal check %
00002270 : 00000713;   % 2877:         li a4,0  # Don't consider doors (since it never spawns there) %
00002271 : 00100213;   % 2881:         li tp, 1  # Entity collision %
00002272 : 00000317;   % 2883:         call CHECK_MAP_COLLISION %
00002273 : 38c300e7;   % 2883:  %
00002274 : 00a002b3;   % 2884:         mv t0,a0 %
00002275 : 00012503;   % 2887:         lw a0,0(sp) %
00002276 : 00412583;   % 2888:         lw a1,4(sp) %
00002277 : 00812083;   % 2889:         lw ra,8(sp) %
00002278 : 00c10113;   % 2890:         addi sp,sp,12 %
00002279 : 00154303;   % 2895:         lbu t1,1(a0)  # Loads Ripper's direction %
0000227a : 00029863;   % 2896:         bnez t0, CONTINUE_MOVE_RIPPER  # If returning anything but 0, continue moving ripper %
0000227b : 00134313;   % 2898:             xori t1,t1,1  # Inverts direction %
0000227c : 006500a3;   % 2899:             sb t1,1(a0)   # and stores it back %
0000227d : 00008067;   % 2900:             ret # and finish procedure %
0000227e : 00354283;   % 2904:             lbu t0,3(a0)  # Loads Ripper's X %
0000227f : 00254383;   % 2905:             lbu t2,2(a0)  # Loads Ripper's X offset %
00002280 : 02030063;   % 2906:             beqz t1,MOVE_RIPPER_RIGHT  # If direction is to the right %
00002281 : ffe38393;   % 2908:                 addi t2,t2,-2   # Movement for ripper to the left %
00002282 : 0003d663;   % 2909:                 bge t2,zero,MOVE_RIPPER_LEFT_SKIP_CORRECTION %
00002283 : 01038393;   % 2910:                     addi t2,t2,16 # adds 16 to offset %
00002284 : fff28293;   % 2911:                     addi t0,t0,-1        # subtracts 1 from X %
00002285 : 005501a3;   % 2913:                     sb t0,3(a0)    # Stores Ripper's new X %
00002286 : 00750123;   % 2914:                     sb t2,2(a0)    # Stores Ripper's new X offset %
00002287 : 00008067;   % 2915:                     ret # and finish procedure %
00002288 : 00238393;   % 2918:                 addi t2,t2,2      # Movement for ripper to the right %
00002289 : 01000313;   % 2919:                 li t1,16   # loads 16 %
0000228a : 0063c663;   % 2920:                 blt t2,t1,MOVE_RIPPER_RIGHT_SKIP_CORRECTION %
0000228b : 406383b3;   % 2921:                     sub t2,t2,t1  # subtracts 16 from offset %
0000228c : 00128293;   % 2922:                     addi t0,t0,1  # subtracts 1 from X %
0000228d : 005501a3;   % 2924:                     sb t0,3(a0)   # Stores Ripper's new X %
0000228e : 00750123;   % 2925:                     sb t2,2(a0)   # Stores Ripper's new X offset %
0000228f : 00008067;   % 2926:                     ret # and finish procedure %
00002290 : 00254683;   % 2954:     lbu a3,2(a0)    # Loads Ridley's Y offset %
00002291 : 00354603;   % 2956:     lbu a2,3(a0)  # Loads Ridley's Y %
00002292 : 00c50223;   % 2957:     sb a2,4(a0)   # And stores it in Ridley's old Y %
00002293 : 00750283;   % 2960:     lb t0,7(a0)   # Loads Ridley's MOVE_Y %
00002294 : 00850383;   % 2961:     lb t2,8(a0)   # Loads JUMP information %
00002295 : 0002c663;   % 2962:     blt t0,zero, MOVE_RIDLEY_UP   # In case MOVE_Y = -1 %
00002296 : 02029663;   % 2963:     bnez t0, ITERATE_RIDLEY_JUMP  # In case of MOVE_Y = 1, just iterate jump downards %
00002297 : 1280006f;   % 2965:         j MOVE_RIDLEY_PROPERLY %
00002298 : c00a7353;   % 2968:         fcvt.w.s t1,fs4                    # gets Ridley's current Y speed (truncated) %
00002299 : 00035663;   % 2969:         bge t1,zero, SWITCH_RIDLEY_DOWN    # if less then zero, switch down %
0000229a : 02800313;   % 2970:         li t1, 40             # maximum height of jump  %
0000229b : 0063cc63;   % 2971:         blt t2, t1, ITERATE_RIDLEY_JUMP    # if still not there, iterate jump %
0000229c : 00100313;   % 2974:                 li t1, 1         # Loads 1 (Down)        %
0000229d : 006503a3;   % 2975:                 sb t1, 7(a0)     # Switches MOVE_Y to 1 (Down)   %
0000229e : 00050423;   % 2976:                 sb zero, 8(a0)   # reset jump information %
0000229f : d0007a53;   % 2978:                 fcvt.s.w fs4,zero       # Sets speed to zero        %
000022a0 : 1300006f;   % 2979:                 j END_MOVE_RIDLEY   %
000022a1 : 008a7a53;   % 2982:             fadd.s fs4,fs4,fs0    # fs4 = Ridley's current Y speed + gravity factor        %
000022a2 : c00a7e53;   % 2983:             fcvt.w.s t3,fs4       # Sets t3 = floor(fs4) %
000022a3 : 01c002b3;   % 2993:             mv t0,t3                # moves t3 to t0 %
000022a4 : 0002d463;   % 2994:             bge t0,zero, SKIP_ABS_RIDLEY   # if t0 >= 0, skip this %
000022a5 : 405002b3;   % 2995:                 sub t0,zero,t0             # otherwise, t0 will be its opposite  %
000022a6 : 005383b3;   % 2997:                 add t2,t2,t0               # t0 to t2 (JUMP factor) %
000022a7 : 00750423;   % 2998:                 sb t2, 8(a0)               # and stores it %
000022a8 : 01c686b3;   % 3000:         add a3,a3,t3	# Adds the Y Movement to the Ridley's Offset %
000022a9 : 0006d663;   % 3002:         bge a3,zero,SKIP_UP_Y_RIDLEY %
000022aa : fff60613;   % 3004:         addi a2, a2, -1		    # Ridley's Y on matrix -= 1 (goes to the left) %
000022ab : 01068693;   % 3005:         addi a3, a3, 16  # Offset gets corrected (relative to new Y on matrix coordinate) %
000022ac : 01000293;   % 3008:             li t0, 16 %
000022ad : 0056c663;   % 3009:             blt a3,t0, SKIP_DOWN_Y_RIDLEY %
000022ae : 00160613;   % 3011:             addi a2,a2, 1	 # Ridley's Y on matrix += 1 (goes to the right) %
000022af : 405686b3;   % 3012:             sub a3,a3,t0	 # Offset gets corrected (relative to new Y on matrix coordinate) %
000022b0 : 00100293;   % 3016:         li t0,1       # In case no collision check is made %
000022b1 : 00750303;   % 3017:         lb t1,7(a0)   # Loads Ridley's MOVE_Y %
000022b2 : 0a034e63;   % 3018:         blt t1,zero,MOVE_RIDLEY_PROPERLY # If moving up, doesn't need collision (he doesn't jump to high) %
000022b3 : 00254283;   % 3020:             lbu t0,2(a0)   # Loads Ridley's Y offset %
000022b4 : 00a00313;   % 3021:             li t1, 10      # For comparing %
000022b5 : 01c282b3;   % 3022:             add t0,t0,t3   # Current Y offset + Y offset modifier %
000022b6 : 0062d463;   % 3024:             bge t0,t1 CONTINUE_RIDLEY_COLLISION    # If the result >= 10, continue checking %
000022b7 : 0a80006f;   % 3025:                 j MOVE_RIDLEY_PROPERLY             # Othewise, just move the reptile dragon thing ¯\_(ツ)_/¯ %
000022b8 : 00750283;   % 3028:             lb t0,7(a0)   # Loads Ridley's MOVE_Y %
000022b9 : 00504463;   % 3029:             bgt t0,zero CONTINUE_RIDLEY_COLLISION_2   # In case MOVE_Y = 1 %
000022ba : 09c0006f;   % 3030:                 j MOVE_RIDLEY_PROPERLY # If MOVE_Y = 0 or -1 %
000022bb : 0015c783;   % 3033:             lbu a5,1(a1)     # Loads map's matrix width %
000022bc : 00900813;   % 3034:             li a6,9   # Loads Ridley's current X %
000022bd : 00354883;   % 3035:             lbu a7,3(a0)     # Loads Ridley's current Y %
000022be : 00388893;   % 3036:             addi a7,a7,3     # adds 3 to Y, so that address will be 3 tiles down %
000022bf : 00358593;   % 3038:             addi a1,a1,3          # Adds 3 to the Matrix's address so that it goes to the beginning of matrix %
000022c0 : 02f882b3;   % 3039:             mul t0,a7,a5          # (Ridley's matrix Y + 3)  * Map Matrix's width %
000022c1 : 005802b3;   % 3040:             add t0,a6,t0          # t0 = Ridley's X related to matrix + (Ridley's matrix Y + 3)  * Map Matrix's width %
000022c2 : 005585b3;   % 3041:             add a1,a1,t0          # a1 = Map Matrix's address adjusted for Ridley's X and Y (+3) related to matrix        %
000022c3 : fec10113;   % 3045:                 addi sp,sp,-20 %
000022c4 : 00d12823;   % 3046:                 sw a3,16(sp) %
000022c5 : 00c12623;   % 3047:                 sw a2,12(sp) %
000022c6 : 00b12423;   % 3048:                 sw a1,8(sp) %
000022c7 : 00a12223;   % 3049:                 sw a0,4(sp) %
000022c8 : 00112023;   % 3050:                 sw ra,0(sp) %
000022c9 : 00200513;   % 3053:                 li a0,2  # Doesn't matter, since no doors will be checked %
000022ca : 00100613;   % 3055:                 li a2,1  # Only check one tile %
000022cb : 00100693;   % 3056:                 li a3,1  # Vertical check %
000022cc : 00000713;   % 3057:                 li a4,0  # Don't consider doors (since it never spawns there) %
000022cd : 00100213;   % 3061:                 li tp, 1  # Entity collision %
000022ce : 00000317;   % 3062:                 call CHECK_MAP_COLLISION %
000022cf : 21c300e7;   % 3062:  %
000022d0 : 00a002b3;   % 3063:                 mv t0,a0 %
000022d1 : 01012683;   % 3066:                 lw a3,16(sp) %
000022d2 : 00c12603;   % 3067:                 lw a2,12(sp) %
000022d3 : 00812583;   % 3068:                 lw a1,8(sp) %
000022d4 : 00412503;   % 3069:                 lw a0,4(sp) %
000022d5 : 00012083;   % 3070:                 lw ra,0(sp) %
000022d6 : 01410113;   % 3071:                 addi sp,sp,20 %
000022d7 : 02029463;   % 3075:             bnez t0, MOVE_RIDLEY_PROPERLY   # If returning anything but 0, Ridley can move %
000022d8 : d0007a53;   % 3077:                 fcvt.s.w fs4,zero # Resets Ridley's jump speed %
000022d9 : 000503a3;   % 3078:                 sb zero, 7(a0) # RIDLEY_MOVE_Y = 0 %
000022da : 00050423;   % 3079:                 sb zero, 8(a0) # RIDLEY_JUMP = 0 %
000022db : 00a00293;   % 3081:                 li t0,10        # setting new Y offset     %
000022dc : 00550123;   % 3082:                 sb t0,2(a0)     # Sets Ridley's Y offset to 10 %
000022dd : 00954283;   % 3084:                 lbu t0, 9(a0)   # Loads jump cooldown %
000022de : 00029663;   % 3085:                 bnez t0,MOVE_RIDLEY_SKIP_COOLDOWN_RESET  # If cooldown isn't 0, don't reset it %
000022df : 01400293;   % 3087:                     li t0,20   %
000022e0 : 005504a3;   % 3088:                     sb t0, 9(a0) %
000022e1 : 00954283;   % 3093:             lbu t0, 9(a0)   # Loads jump cooldown  %
000022e2 : 00029863;   % 3094:             bnez t0,MOVE_RIDLEY_PROPERLY_ITERATE_COOLDOWN %
000022e3 : 00c501a3;   % 3096:                 sb a2,3(a0)     # Stores Ridley's new Y  %
000022e4 : 00d50123;   % 3097:                 sb a3,2(a0)     # Stores new Y offset %
000022e5 : 01c0006f;   % 3098:                 j END_MOVE_RIDLEY %
000022e6 : fff28293;   % 3102:                 addi t0,t0,-1   # Takes 1 from cooldown %
000022e7 : 00029863;   % 3103:                 bnez t0,MOVE_RIDLEY_PROPERLY_FINISH_ITERATE_COOLDOWN %
000022e8 : 21398a53;   % 3105:                     fmv.s fs4,fs3  # moves ridley's initial speed to fs4 %
000022e9 : fff00313;   % 3106:                     li t1,-1       # Loads -1 (Up) %
000022ea : 006503a3;   % 3107:                     sb t1,7(a0)    # and stores it on Ridley's MOVE_Y %
000022eb : 005504a3;   % 3111:                     sb t0, 9(a0)   # Loads jump cooldown %
000022ec : 00008067;   % 3115:         ret %
000022ed : 00654e03;   % 3146:     lbu t3,6(a0) # Loads plasma breath's current X %
000022ee : 01c503a3;   % 3147:     sb t3,7(a0)  # And stores it on old X %
000022ef : 00354283;   % 3149:     lbu t0,3(a0) # Loads plasma breath's X offset %
000022f0 : 00154303;   % 3150:     lbu t1,1(a0) # Loads plasma breath's X movement (always positive) %
000022f1 : 006282b3;   % 3152:     add t0,t0,t1 # Adds X movement to X offset %
000022f2 : 01000393;   % 3154:     li t2,16 # Loads 16 %
000022f3 : 0072c663;   % 3155:     blt t0,t2,MOVE_PLASMA_BREATH_SKIP_CORRECTION # If less than 16, skip correction %
000022f4 : 001e0e13;   % 3156:         addi t3,t3,1   # Adds 1 to X %
000022f5 : 407282b3;   % 3157:         sub t0,t0,t2   # Corrects X offset  %
000022f6 : 01c50323;   % 3159:         sb t3,6(a0)    # Stores new X (or the same, if unaltered) %
000022f7 : 005501a3;   % 3160:         sb t0,3(a0)    # Stores new X offset %
000022f8 : 01000313;   % 3162:     li t1,16  # Loads X where plasma breath should be disabled %
000022f9 : 006e4663;   % 3163:     blt t3,t1,MOVE_PLASMA_BREATH_KEEP  # If it didn't surpass the threshold, continue %
000022fa : 00200313;   % 3165:         li t1,2     # Loads "To be Disabled"  %
000022fb : 00650023;   % 3166:         sb t1,0(a0) # and stores it on enable byte %
000022fc : 00854603;   % 3172:     lbu a2,8(a0)    # Loads plasma breath's current Y %
000022fd : 00c504a3;   % 3173:     sb a2,9(a0)     # And stores it on old Y %
000022fe : 00454683;   % 3174:     lbu a3,4(a0)    # Loads plasma breath's current Y offset %
000022ff : 00250283;   % 3177:     lb t0,2(a0)   # Loads Plasma Breath's MOVE_Y %
00002300 : 0002c463;   % 3179:     blt t0,zero, MOVE_PLASMA_BREATH_UP   # In case MOVE_Y = -1  %
00002301 : 01c0006f;   % 3180:         j ITERATE_PLASMA_BREATH_JUMP     # Otherwise, just iterate %
00002302 : c0057353;   % 3183:         fcvt.w.s t1,fa0                           # Gets Plasma Breath's current Y speed (truncated) %
00002303 : 00035463;   % 3184:         bge t1,zero, SWITCH_PLASMA_BREATH_DOWN    # If less then zero, switch down %
00002304 : 0100006f;   % 3185:         j ITERATE_PLASMA_BREATH_JUMP                     # If still not there, iterate jump %
00002305 : 00100313;   % 3188:                 li t1, 1         # Loads 1 (Down)        %
00002306 : 00650123;   % 3189:                 sb t1, 2(a0)     # Switches MOVE_Y to 1 (Down)  %
00002307 : 1340006f;   % 3192:                 j END_MOVE_PLASMA_BREATH %
00002308 : 00857553;   % 3195:             fadd.s fa0,fa0,fs0    # fa0 = Plasma Breath's current Y speed + gravity factor        %
00002309 : c0057e53;   % 3196:             fcvt.w.s t3,fa0       # Sets t3 = floor(fa0) %
0000230a : 00800293;   % 3198:             li t0,8             # Loads max speed (8, when falling) %
0000230b : 005e4663;   % 3199:             blt t3,t0, SKIP_PLASMA_MAX_SPEED   # If t3 < 8, skip this part %
0000230c : 00800e13;   % 3201:                 li t3,8 %
0000230d : d002f553;   % 3202:                 fcvt.s.w fa0,t0 %
0000230e : 01c686b3;   % 3213:         add a3,a3,t3	# Adds the Y Movement to the Plasma Breath's Offset       %
0000230f : 0006d663;   % 3214:         bge a3,zero,SKIP_UP_Y_PLASMA_BREATH %
00002310 : fff60613;   % 3216:         addi a2, a2, -1		    # Plasma Breath's Y on matrix -= 1 (goes to the left) %
00002311 : 01068693;   % 3217:         addi a3, a3, 16  # Offset gets corrected (relative to new Y on matrix coordinate) %
00002312 : 01000293;   % 3220:             li t0, 16 %
00002313 : 0056c663;   % 3221:             blt a3,t0, SKIP_DOWN_Y_PLASMA_BREATH %
00002314 : 00160613;   % 3223:             addi a2,a2, 1	 # Plasma Breath's Y on matrix += 1 (goes to the right) %
00002315 : 405686b3;   % 3224:             sub a3,a3,t0	 # Offset gets corrected (relative to new Y on matrix coordinate) %
00002316 : 0015c783;   % 3230:         lbu a5,1(a1)     # Loads map's matrix width %
00002317 : 00654803;   % 3231:         lbu a6,6(a0)     # Loads plasma breath's current X %
00002318 : 00854883;   % 3232:         lbu a7,8(a0)     # Loads plasma breath's current Y %
00002319 : 00358593;   % 3234:         addi a1,a1,3     # Adds 3 to the Matrix's address so that it goes to the beginning of matrix %
0000231a : 02f882b3;   % 3235:         mul t0,a7,a5     # (Plasma Breath's matrix Y + 3)  * Map Matrix's width %
0000231b : 005802b3;   % 3236:         add t0,a6,t0     # t0 = Plasma Breath's X related to matrix + (Plasma Breath's matrix Y + 3)  * Map Matrix's width %
0000231c : 005585b3;   % 3237:         add a1,a1,t0     # a1 = Map Matrix's address adjusted for Plasma Breath's X and Y (+3) related to matrix        %
0000231d : 00454283;   % 3239:         lbu t0,4(a0)     # Loads Plasma Breath's Y offset %
0000231e : 00250303;   % 3240:         lb t1,2(a0)      # Loads Plasma Breath's MOVE_Y %
0000231f : 00034463;   % 3241:         blt t1,zero, CHECK_Y_UP_PLASMA_BREATH # If t1 < 0, check up,  %
00002320 : 0180006f;   % 3242:         j CHECK_Y_DOWN_PLASMA_BREATH          # otherwise check down %
00002321 : 00800313;   % 3245:             li t1, 8       # For comparing %
00002322 : 01c282b3;   % 3246:             add t0,t0,t3   # Current Y offset + Y offset modifier %
00002323 : 00535463;   % 3247:             bge t1,t0 CONTINUE_PLASMA_BREATH_COLLISION_UP    # If the result <= 8, continue checking %
00002324 : 0b80006f;   % 3248:                 j MOVE_PLASMA_BREATH_PROPERLY  # Othewise, just move the fourth state of matter breath  %
00002325 : 02c0006f;   % 3253:                 j START_PLASMA_BREATH_COLLISION %
00002326 : 00f585b3;   % 3256:             add a1,a1,a5  # Moves matrix one tile down %
00002327 : 00188893;   % 3257:             addi a7,a7,1  # Moves Y one tile down %
00002328 : 000e0e63;   % 3258:             beqz t3 CONTINUE_CHECK_Y_DOWN_PLASMA_BREATH   # If plasma breath's Y offset == 0, continue checking %
00002329 : 00f585b3;   % 3261:             add a1,a1,a5  # If Y offset != 0 %
0000232a : 00188893;   % 3262:             addi a7,a7,1  # If Y offset != 0 %
0000232b : 01000313;   % 3264:             li t1,16  # Loads 16 %
0000232c : 01c282b3;   % 3265:             add t0,t0,t3     # Current Y offset + Y offset modifier %
0000232d : 0062d463;   % 3266:             bge t0,t1 CONTINUE_CHECK_Y_DOWN_PLASMA_BREATH  # If current offset + offset modifier >= 16, continue checking (but check one tile bellow) %
0000232e : 0900006f;   % 3267:                 j MOVE_PLASMA_BREATH_PROPERLY              # Othewise, just move the the fourth state of matter breath (Ha, you've only read one "the") %
0000232f : 0040006f;   % 3272:                 j START_PLASMA_BREATH_COLLISION %
00002330 : fec10113;   % 3276:                 addi sp,sp,-20 %
00002331 : 00d12823;   % 3277:                 sw a3,16(sp) %
00002332 : 00c12623;   % 3278:                 sw a2,12(sp) %
00002333 : 00b12423;   % 3279:                 sw a1,8(sp) %
00002334 : 00a12223;   % 3280:                 sw a0,4(sp) %
00002335 : 00112023;   % 3281:                 sw ra,0(sp) %
00002336 : 00200513;   % 3284:                 li a0,2  # Doesn't matter, since no doors will be checked %
00002337 : 00100613;   % 3286:                 li a2,1  # Only check one tile %
00002338 : 00100693;   % 3287:                 li a3,1  # Vertical check %
00002339 : 00000713;   % 3288:                 li a4,0  # Don't consider doors (since it never spawns there) %
0000233a : 00100213;   % 3292:                 li tp, 1  # Entity collision %
0000233b : 00000317;   % 3293:                 call CHECK_MAP_COLLISION %
0000233c : 068300e7;   % 3293:  %
0000233d : 00a002b3;   % 3294:                 mv t0,a0 %
0000233e : 01012683;   % 3297:                 lw a3,16(sp) %
0000233f : 00c12603;   % 3298:                 lw a2,12(sp) %
00002340 : 00812583;   % 3299:                 lw a1,8(sp) %
00002341 : 00412503;   % 3300:                 lw a0,4(sp) %
00002342 : 00012083;   % 3301:                 lw ra,0(sp) %
00002343 : 01410113;   % 3302:                 addi sp,sp,20 %
00002344 : 02029c63;   % 3306:             bnez t0, MOVE_PLASMA_BREATH_PROPERLY   # If returning anything but 0, Plasma Breath can move %
00002345 : 20a51553;   % 3309:                 fneg.s fa0,fa0  # Invert speed %
00002346 : 00250283;   % 3311:                 lb t0,2(a0)   # Loads Plasma Breath's MOVE_Y, %
00002347 : 40500333;   % 3312:                 neg t1,t0     # inverts it, %
00002348 : 00250303;   % 3313:                 lb t1,2(a0)   # and stores it back %
00002349 : 0002cc63;   % 3315:                 blt t0,zero,SWITCH_PLASMA_BREATH_DOWN_2 # If t0 (old MOVE_Y) <= -1 adjust coordinates %
0000234a : 00454283;   % 3317:                     lbu t0,4(a0)   # Loads plasma breath's current Y offset   %
0000234b : 00028663;   % 3318:                     beqz t0,MOVE_PLASMA_BREATH_SKIP_ADJUST_Y   %
0000234c : 00050223;   % 3319:                         sb zero, 4(a0) # Sets plasma breath's Y offset to 0      %
0000234d : 00c50423;   % 3320:                         sb a2,8(a0)    # Stores new Y  %
0000234e : 0180006f;   % 3323:                         j END_MOVE_PLASMA_BREATH   # Finish procedure %
0000234f : 00800293;   % 3327:                     li t0,8      # Loads new Y offset %
00002350 : 00550223;   % 3328:                     sb t0,4(a0)  # and stores it back %
00002351 : 00c0006f;   % 3329:                     j END_MOVE_PLASMA_BREATH   # Finish procedure %
00002352 : 00c50423;   % 3332:             sb a2,8(a0)     # Stores Plasma Breath's new Y  %
00002353 : 00d50223;   % 3333:             sb a3,4(a0)     # Stores new Y offset %
00002354 : 00008067;   % 3337:         ret %
00002355 : 00400f33;   % 3370: mv t5,tp %
00002356 : 00a00233;   % 3371: mv tp,a0 # Moves door check to tp %
00002357 : 00100513;   % 3372: li a0,1  # Sets a0 to 1 (can move) %
00002358 : 00000f93;   % 3373: li t6,0  # Sets t6 to 0 (no doors detected) %
00002359 : 00051863;   % 3377:         bnez a0, CONTINUE_CHECK_MAP_COLLISION_1 # Otherwise, continue check %
0000235a : 00300293;   % 3378:         li t0,3 %
0000235b : 01e28463;   % 3379:         beq t0,t5,CONTINUE_CHECK_MAP_COLLISION_1 # If checking with bombs, ignore regular collision rules %
0000235c : 22c0006f;   % 3380:         j END_COLLISON_MAP %
0000235d : 00c04463;   % 3384:             blt zero, a2, CONTINUE_CHECK_MAP_COLLISION_2 %
0000235e : 2240006f;   % 3385:             j END_COLLISON_MAP %
0000235f : 0005c303;   % 3388:             lbu t1, 0(a1) # Loads tile from current map %
00002360 : 0ff00293;   % 3389:             li t0,255 %
00002361 : 02629c63;   % 3390:             bne t0,t1, NOT_CAPSULE_CHECK %
00002362 : 0fc09297;   % 3392:                 la t0, ITEM_CAPSULE_INFO %
00002363 : 3d428293;   % 3392:  %
00002364 : 0002c303;   % 3393:                 lbu t1,0(t0) %
00002365 : 02031263;   % 3394:                 bnez t1, SKIP_CAPSULE_CHECK  # If broken %
00002366 : 00200313;   % 3395:                     li t1,2 %
00002367 : 01e31c63;   % 3396:                     bne t1,t5,CAPSULE_CHECK_NOT_BEAM %
00002368 : 00100313;   % 3397:                         li t1,1 %
00002369 : 00628023;   % 3398:                         sb t1,0(t0) %
0000236a : 0fc09297;   % 3399:                         la t0, BOMB_POWER_INFO %
0000236b : 3b228293;   % 3399:  %
0000236c : 00628023;   % 3400:                         sb t1,0(t0) %
0000236d : 1c00006f;   % 3402:                         j COLLISION_BLOCKED      # Otherwise, it's blocked %
0000236e : 1c00006f;   % 3404:                         j CONTINUE_CHECK_MAP_COLLISION_3 %
0000236f : 00070e63;   % 3407:             beqz a4, SKIP_DOOR_CHECK_MAP_COLLISION  # If a4 = 0 (don't consider door), skip door check  %
00002370 : 02800293;   % 3408:                 li t0,40   # Tile where doors start %
00002371 : 00534463;   % 3409:                 blt t1,t0, NOT_DOOR_CHECK_MAP_COLLISION # If current tile isn't a door    %
00002372 : 10c0006f;   % 3410:                 j COLLISION_DOOR  # If tile is a door (t1 >= 40) %
00002373 : 00100293;   % 3412:                     li t0,1   # Consider all tiles %
00002374 : 00570463;   % 3413:                     beq a4,t0, SKIP_DOOR_CHECK_MAP_COLLISION # If no door was detected and other tiles should be checked, continue %
00002375 : 1a40006f;   % 3414:                     j CONTINUE_CHECK_MAP_COLLISION_3  # If no door was detected and only doors should be checked, skip to the end %
00002376 : 00400293;   % 3416:                 li t0, 4      # Loads t0 = 4 for comparison %
00002377 : 08535463;   % 3417:                 bge t1,t0,COLLISION_NOT_BACKGROUND # If tile isn't part of background or isn't breakable (t1 >= 4) %
00002378 : 00100293;   % 3419:                     li t0,1 %
00002379 : 00628463;   % 3420:                     beq t0,t1, COLLISION_BREAKABLE   # If tile is breakable, there needs to be a check if it was broken %
0000237a : 1900006f;   % 3421:                     j CONTINUE_CHECK_MAP_COLLISION_3 # Otherwise, continue checking collision %
0000237b : 0fc09297;   % 3424:                 la t0,NEXT_MAP # Loads NEXT_MAP address %
0000237c : 32028293;   % 3424:  %
0000237d : 00a2c283;   % 3425:                 lbu t0,10(t0)  # Gets the Render Next Map byte	 %
0000237e : 00028a63;   % 3426:                 beqz t0, COLLISION_BREAKABLE_CURRENT   # If Render Next Map Door == 0, render current map's door %
0000237f : 0fc09297;   % 3428:                     la t0,Blocks_Next  # Loads blocks address %
00002380 : 41028293;   % 3428:  %
00002381 : 0002a283;   % 3429:                     lw t0,0(t0)        # and loads the breakable block address %
00002382 : 0100006f;   % 3430:                     j CONTINUE_COLLISION_BREAKABLE %
00002383 : 0fc09297;   % 3433:                     la t0,Blocks  # Loads blocks address %
00002384 : 3fc28293;   % 3433:  %
00002385 : 0002a283;   % 3434:                     lw t0,0(t0)   # and loads the breakable block address %
00002386 : 04028463;   % 3438:                     beqz t0,COLLISION_BREAKABLE_NOT_BLOCKING %
00002387 : 0012c303;   % 3440:                     lbu t1,1(t0)  # Gets Y where blocks start %
00002388 : 40688333;   % 3441:                     sub t1,a7,t1  # Sets current Y to be related to Y where blocks start %
00002389 : 0022c383;   % 3443:                     lbu t2,2(t0)  # Loads width %
0000238a : 02730333;   % 3444:                     mul t1,t1,t2  # and multiplies it by current Y	 %
0000238b : 0002c383;   % 3446:                     lbu t2,0(t0)  # Gets X where blocks start %
0000238c : 407803b3;   % 3447:                     sub t2,a6,t2  # Sets current X to be related to X where blocks start %
0000238d : 00730333;   % 3449:                     add t1,t1,t2  # adds X to it %
0000238e : 00428293;   % 3451:                     addi t0,t0,4  # Skip first 4 information bytes %
0000238f : 005302b3;   % 3452:                     add t0,t1,t0  # and adds t4 to it %
00002390 : 00028303;   % 3454:                     lb t1,0(t0)  # Loads t0  %
00002391 : 00031e63;   % 3455:                     bnez t1, COLLISION_BREAKABLE_NOT_BLOCKING  # If block is destroyed, can go through %
00002392 : 00300313;   % 3457:                     li t1,3 # To check if it was colliding with exploding bomb %
00002393 : 006f1863;   % 3458:                     bne t5,t1, COLLISION_BREAKABLE_BLOCKING %
00002394 : 00100313;   % 3460:                         li t1,1 %
00002395 : 00628023;   % 3461:                         sb t1,0(t0)  # Sets t0 to 1 (first phase of exploding)  %
00002396 : 1200006f;   % 3462:                         j CONTINUE_CHECK_MAP_COLLISION_3     # Otherwise, finish this iteration's checks %
00002397 : 1180006f;   % 3464:                         j COLLISION_BLOCKED %
00002398 : 1180006f;   % 3468:                 j CONTINUE_CHECK_MAP_COLLISION_3 %
00002399 : 00628863;   % 3471:                 beq t0,t1,COLLISION_DOOR_FRAME  # If t1 = 4, it's a door frame %
0000239a : 02400293;   % 3472:                 li t0,36   # Tile from which collision behaves differently %
0000239b : 04535c63;   % 3473:                 bge t1,t0, COLLISION_SPECIAL_2  # If current tile is a door or a damaging tile (t1 >= 36) %
0000239c : 1040006f;   % 3474:                     j COLLISION_BLOCKED # If tile isn't special (3 < t1 < 36) %
0000239d : 0e0f1e63;   % 3477:                 bnez t5,COLLISION_DOOR_FRAME_COLLISION_BLOCKED  # If not player, consider this a solid object %
0000239e : 000002b3;   % 3478:                 mv t0,zero   # Resets counter %
0000239f : 0fc09317;   % 3479:                 la t1, Frames # Loads Frames address %
000023a0 : 65030313;   % 3479:  %
000023a1 : 00032303;   % 3480:                 lw t1,0(t1)	 # Gets the current map's door frame address %
000023a2 : 00034383;   % 3481:                 lbu t2,0(t1) # Gets the number of door frames in this map %
000023a3 : 00130313;   % 3482:                 addi t1,t1,1 # Starting address of the map's first door frame %
000023a4 : 00034e03;   % 3485:                     lbu t3, 0(t1) # Loads door frame's X on matrix %
000023a5 : 010e1e63;   % 3486:                     bne t3, a6, NEXT_IN_COLLISION_DOOR_FRAME_LOOP # If door frame's X isn't the same as current X, skip it        %
000023a6 : 00134e03;   % 3487:                     lbu t3, 1(t1) # Loads door frame's Y on matrix %
000023a7 : 41c88e33;   % 3488:                     sub t3,a7,t3  # t3 needs to be equal to 0, 1 or 2 in order to be a tile from this door frame %
000023a8 : 00200e93;   % 3489:                     li t4,2       # 2 is the threshold to be compared with t3 %
000023a9 : 01cee663;   % 3490:                     bgtu t3,t4, NEXT_IN_COLLISION_DOOR_FRAME_LOOP # If current Y is above the door frame's uppermost Y or bellow it's downmost Y, skip it                        %
000023aa : 00600533;   % 3492:                         mv a0,t1       # Moves current door frame's address to a0 %
000023ab : 9e8fd06f;   % 3493:                         j CHANGE_MAP                             %
000023ac : 00630313;   % 3495:                         addi t1,t1,6 # Going to the next door frame's address                                   %
000023ad : 00128293;   % 3496:                         addi t0,t0,1 # Iterating counter by 1                                    %
000023ae : 0072d463;   % 3497:                         bge t0,t2, END_COLLISION_DOOR_FRAME_LOOP # If all of the map's door frames were checked, end loop                                   %
000023af : fd5ff06f;   % 3498:                         j COLLISION_DOOR_FRAME_LOOP # otherwise, go back to the loop's beginning                      %
000023b0 : 0b80006f;   % 3501:                     j CONTINUE_CHECK_MAP_COLLISION_3      %
000023b1 : 02800293;   % 3505:                 li t0,40   # Tile from which door tiles begin %
000023b2 : 00534463;   % 3506:                 blt t1,t0, CONTINUE_COLLISION_SCPECIAL_2   # If tile is a door (t1 >= 40) %
000023b3 : 0ac0006f;   % 3507:                     j CONTINUE_CHECK_MAP_COLLISION_3     # Otherwise, finish this iteration's checks %
000023b4 : 0a40006f;   % 3511:                     j COLLISION_BLOCKED # For now >:[ %
000023b5 : 000002b3;   % 3514:                 mv t0,zero   # Resets counter %
000023b6 : 0fc09317;   % 3515:                 la t1, Doors # Loads Doors address %
000023b7 : 5b430313;   % 3515:  %
000023b8 : 00032303;   % 3516:                 lw t1,0(t1)	 # Gets the current map's door address %
000023b9 : 00034383;   % 3517:                 lbu t2,0(t1) # Gets the number of doors in this map %
000023ba : 00130313;   % 3518:                 addi t1,t1,1 # Starting address of the map's first door %
000023bb : 00034e03;   % 3521:                     lbu t3, 0(t1) # Loads door's X on matrix %
000023bc : 070e1663;   % 3522:                     bne t3, a6, NEXT_IN_COLLISION_DOOR_LOOP # If door's X isn't the same as current X, skip this door %
000023bd : 00134e03;   % 3523:                     lbu t3, 1(t1) # Loads door's Y on matrix %
000023be : 41c88e33;   % 3524:                     sub t3,a7,t3  # t3 needs to be equal to 0, 1 or 2 in order to be a tile from this door %
000023bf : 00200e93;   % 3525:                     li t4,2       # 2 is the threshold to be compared with t3 %
000023c0 : 05ceee63;   % 3526:                     bgtu t3,t4, NEXT_IN_COLLISION_DOOR_LOOP # If current Y is above the door's uppermost Y or bellow it's downmost Y, skip this door                         %
000023c1 : 024e8063;   % 3528:                         beq t4,tp,AFTER_COLLISION_DOOR_LOOP_DIRECTION_CHECK # If tp = 2, check any type of door %
000023c2 : 00034e03;   % 3529:                         lbu t3, 0(t1) # Loads door's X on matrix  %
000023c3 : 00020663;   % 3530:                         beqz tp,COLLISION_DOOR_LOOP_CHECK_RIGHT # If tp = 0, check if door is on right wall %
000023c4 : 01c20a63;   % 3532:                             beq tp,t3,AFTER_COLLISION_DOOR_LOOP_DIRECTION_CHECK # If t3 = 1, door is on left wall; continue checking collision %
000023c5 : 0580006f;   % 3533:                             j END_COLLISION_DOOR_LOOP # Otherwise, door is on right wall and not on left wall (stop checking) %
000023c6 : 00100e93;   % 3535:                             li t4, 1 # 1 is the threshold of when a door can be on right wall %
000023c7 : 01cec463;   % 3536:                             bgt t3,t4, AFTER_COLLISION_DOOR_LOOP_DIRECTION_CHECK # If t3 > 1, door is on right wall; continue checking collision %
000023c8 : 04c0006f;   % 3537:                             j END_COLLISION_DOOR_LOOP # Otherwise, door is on left wall and not on right wall (stop checking) %
000023c9 : 00234e83;   % 3539:                             lbu t4, 2(t1) # Loads door's state %
000023ca : 040e9263;   % 3540:                             bnez t4, END_COLLISION_DOOR_LOOP # If door is open or opening, player can move through  %
000023cb : 00200e93;   % 3541:                                 li t4,2 # Comparing if it's beam collision %
000023cc : 01df1c63;   % 3542:                                 bne t5,t4,NOT_BEAM_COLLISION %
000023cd : 00100e93;   % 3543:                                     li t4,1       # Loads 1 (opening/closing) %
000023ce : 01d30123;   % 3544:                                     sb t4,2(t1)   # and stores it on door's state byte   %
000023cf : ffe00e93;   % 3545:                                     li t4,-2  # Gets new counter (related to opening door -- negative, in order to open) %
000023d0 : 01d301a3;   % 3546:                                     sb t4,3(t1)         # and stores it on door's counter byte   %
000023d1 : 0300006f;   % 3547:                                     j COLLISION_BLOCKED # Door is closed and player can't move %
000023d2 : 020f9663;   % 3550:                                 bnez t6,COLLISION_BLOCKED  # if t6 != 0 , don't update it %
000023d3 : 00034e03;   % 3551:                                     lbu t3, 0(t1) # Loads door's X on matrix  %
000023d4 : 01de2fb3;   % 3552:                                     slt t6,t3,t4   # door's x < 2 ? t6 = 1 : t6 = 0 %
000023d5 : 001f8f93;   % 3553:                                     addi t6,t6,1   # If right door, t6 = 1; left door, t6 = 2 %
000023d6 : 01c0006f;   % 3554:                                     j COLLISION_BLOCKED # Otherwise, door is closed and player can't move                    %
000023d7 : 00430313;   % 3556:                         addi t1,t1,4 # Going to the next door's address                                   %
000023d8 : 00128293;   % 3557:                         addi t0,t0,1 # Iterating counter by 1                                    %
000023d9 : 0072d463;   % 3558:                         bge t0,t2, END_COLLISION_DOOR_LOOP # If all of the map's doors were checked, end loop                                   %
000023da : f85ff06f;   % 3559:                         j COLLISION_DOOR_LOOP # otherwise, go back to the loop's beginning                      %
000023db : 00c0006f;   % 3562:                     j CONTINUE_CHECK_MAP_COLLISION_3                                                                  %
000023dc : 00300f93;   % 3565:                 li t6,3   %
000023dd : 00000513;   % 3567:                 li a0,0 # Player can't move   %
000023de : 00069a63;   % 3571:             bnez a3, CHECK_MAP_COLLISION_VERTICAL %
000023df : 00f585b3;   % 3573:                 add a1,a1,a5   # a1 = current tile address + matrix width (+1 Y) %
000023e0 : 00188893;   % 3574:                 addi a7,a7,1   # a7++ (+1 Y) %
000023e1 : fff60613;   % 3575:                 addi a2,a2,-1  # Iterates a2 (a2--) %
000023e2 : dddff06f;   % 3576:                 j MAP_COLLISION_LOOP %
000023e3 : 00158593;   % 3579:                 addi a1,a1,1   # a1 = current tile address + 1 (+1 X) %
000023e4 : 00180813;   % 3580:                 addi a6,a6,1   # a6++ (+1 X) %
000023e5 : fff60613;   % 3581:                 addi a2,a2,-1  # Iterates a2 (a2--) %
000023e6 : dcdff06f;   % 3582:                 j MAP_COLLISION_LOOP %
000023e7 : 01f005b3;   % 3585:     mv a1,t6  # moves t6 (0 - no door, 1 - right door, 2 - left door, 3 - door frame) %
000023e8 : 00008067;   % 3586:     ret %
000023e9 : 0fc07297;   % 8: 			la		t0, MUSIC_NOTAS %
000023ea : 05c28293;   % 8:  %
000023eb : 0fc08317;   % 9: 			la		t1, MUSIC_STATUS %
000023ec : 14430313;   % 9:  %
000023ed : 00532223;   % 10: 			sw		t0, 4(t1) %
000023ee : 00032023;   % 11: 			sw		zero, 0(t1) %
000023ef : 00008067;   % 13: 			ret %
000023f0 : 0fc08517;   % 21: MUSIC.PLAY:		la		a0, MUSIC_STATUS %
000023f1 : 13050513;   % 21:  %
000023f2 : 00000613;   % 22: 			li		a2, 0 %
000023f3 : 03200693;   % 23: 			li		a3, 50 %
000023f4 : 00052283;   % 25: 			lw		t0, 0(a0) %
000023f5 : 00028663;   % 26: 			beqz		t0, MUSIC.PLAY.NOTE %
000023f6 : c0102373;   % 28: 			csrr		t1, 3073		# current time %
000023f7 : 04536263;   % 29: 			bltu		t1, t0, MUSIC.RET	# if (now < next note) do nothing ELSE play note %
000023f8 : 00452283;   % 31: MUSIC.PLAY.NOTE:	lw		t0, 4(a0)		# t0 = current note address %
000023f9 : 0002a303;   % 32: 			lw		t1, 0(t0)		# nota %
000023fa : 0042a383;   % 33: 			lw		t2, 4(t0)		# duracao %
000023fb : 00030e63;   % 35: 			beqz		t1, MUSIC.LAST.PLAYED	# nota == 0, s� espera %
000023fc : 00a00e33;   % 37: 			mv		t3, a0		# salva a0 %
000023fd : 00600533;   % 39: 			mv		a0, t1		# a0 = nota %
000023fe : 007005b3;   % 40: 			mv		a1, t2		# a1 = duracao %
000023ff : 01f00893;   % 41: 			li		a7, 31		# define a chamada de syscall %
00002400 : 00000073;   % 42: 			ecall				# toca a nota %
00002401 : 01c00533;   % 44: 			mv		a0, t3		# restaura a0 %
00002402 : f8038ee3;   % 46: MUSIC.LAST.PLAYED:	beqz		t2, MUSIC.SETUP	# nota == 0 e duracao == 0, recomeca %
00002403 : c0102e73;   % 48: 			csrr		t3, 3073	# current time %
00002404 : 007e0e33;   % 49: 			add		t3, t3, t2	# current time + note duration = next note time %
00002405 : 01c52023;   % 50: 			sw		t3, 0(a0)	# save next note time %
00002406 : 00828293;   % 52: 			addi		t0, t0, 8	# incrementa endere�o da proxima nota %
00002407 : 00552223;   % 53: 			sw		t0, 4(a0)	# salva proxima nota %
00002408 : 00008067;   % 55: MUSIC.RET:		ret %
00002409 : 0fc08297;   % 5: 	la t0,Brinstar %
0000240a : 0d428293;   % 5:  %
0000240b : 00028023;   % 6: 	sb zero,(t0) %
0000240c : 0fc08297;   % 8: 	la t0,Brinstar_Lead_0 %
0000240d : 0d028293;   % 8:  %
0000240e : 00029123;   % 9: 	sh zero,2(t0)	 %
0000240f : 0002a223;   % 10: 	sw zero,4(t0) %
00002410 : 00c28313;   % 11: 	addi t1, t0, 12	# Gets next note address %
00002411 : 0062a423;   % 12: 	sw t1,8(t0) %
00002412 : 0fc08297;   % 14: 	la t0,Brinstar_Lead_1 %
00002413 : 33428293;   % 14:  %
00002414 : 00029123;   % 15: 	sh zero,2(t0)	 %
00002415 : 0002a223;   % 16: 	sw zero,4(t0) %
00002416 : 00c28313;   % 17: 	addi t1, t0, 12	# Gets next note address %
00002417 : 0062a423;   % 18: 	sw t1,8(t0) %
00002418 : 0fc08297;   % 20: 	la t0,Brinstar_Bass %
00002419 : 5e028293;   % 20:  %
0000241a : 00029123;   % 21: 	sh zero,2(t0)	 %
0000241b : 0002a223;   % 22: 	sw zero,4(t0) %
0000241c : 00c28313;   % 23: 	addi t1, t0, 12	# Gets next note address %
0000241d : 0062a423;   % 24: 	sw t1,8(t0) %
0000241e : 00008067;   % 26: 	ret %
0000241f : 00008067;   % 29: 	ret %
00002420 : 0fc08297;   % 33: 	la t0,Brinstar %
00002421 : 07828293;   % 33:  %
00002422 : 0002c283;   % 34: 	lbu t0,(t0) %
00002423 : 06028063;   % 36: 	beqz t0, SKIP_PLAY_BRINSTAR %
00002424 : ffc10113;   % 38: 		addi sp,sp,-4 %
00002425 : 00112023;   % 39: 		sw ra,0(sp) %
00002426 : 0fc08517;   % 42: 		la a0,Brinstar_Lead_0 %
00002427 : 06850513;   % 42:  %
00002428 : 00000317;   % 43: 		call PLAY_MUSIC %
00002429 : 050300e7;   % 43:  %
0000242a : 0fc08517;   % 45: 		la a0,Brinstar_Lead_1 %
0000242b : 2d450513;   % 45:  %
0000242c : 00000317;   % 46: 		call PLAY_MUSIC %
0000242d : 040300e7;   % 46:  %
0000242e : 0fc08517;   % 48: 		la a0,Brinstar_Bass %
0000242f : 58850513;   % 48:  %
00002430 : 00000317;   % 49: 		call PLAY_MUSIC %
00002431 : 030300e7;   % 49:  %
00002432 : 00088e63;   % 52: 		beqz a7,FINISH_PLAY_BRINSTAR %
00002433 : 00000317;   % 53: 			call RESET_MUSIC %
00002434 : f58300e7;   % 53:  %
00002435 : 00100313;   % 54: 			li t1,1	 %
00002436 : 0fc08297;   % 55: 			la t0,Brinstar %
00002437 : 02028293;   % 55:  %
00002438 : 00628023;   % 56: 			sb t1,0(t0)	 %
00002439 : 00012083;   % 60:         lw ra,0(sp) %
0000243a : 00410113;   % 61:         addi sp,sp,4 %
0000243b : 00008067;   % 65: 	ret %
0000243c : 00000613;   % 75: 	li a2,0      # Instrument %
0000243d : 03200693;   % 76: 	li a3,50     # Volume %
0000243e : 00452283;   % 78: 	lw t0,4(a0)  # Loads time last note played %
0000243f : 00028863;   % 79: 	beqz t0,START_PLAY_MUSIC   # If zero, play music %
00002440 : 00000893;   % 81: 		li a7,0 %
00002441 : c0102373;   % 82: 		csrr t1, 3073		        # current time %
00002442 : 06536663;   % 83: 		bltu t1, t0, END_PLAY_MUSIC	# if current time hasn't surpassed time estipulated by previous note, don't play note  %
00002443 : 00852283;   % 86: 	lw t0,8(a0)  # Loads current note's address %
00002444 : 0002a303;   % 87: 	lw t1,0(t0)	 # Loads note %
00002445 : 0042a383;   % 88: 	lw t2,4(t0)	 # Loads duration %
00002446 : 00030e63;   % 90: 	beqz t1, MUSIC_REST  # If note is 0, it's a rest %
00002447 : 00a00e33;   % 92: 	mv t3, a0    # Saves a0 %
00002448 : 00600533;   % 94: 	mv a0, t1		# a0 = note %
00002449 : 007005b3;   % 95: 	mv a1, t2		# a1 = duration %
0000244a : 01f00893;   % 96: 	li a7, 31		# play note syscall %
0000244b : 00000073;   % 97: 	ecall %
0000244c : 01c00533;   % 99: 	mv a0, t3    # Restores it back %
0000244d : c0102e73;   % 102: 	csrr t3, 3073	# current time %
0000244e : 007e0e33;   % 103: 	add t3, t3, t2	# current time + note duration = next note time %
0000244f : 01c52223;   % 104: 	sw t3, 4(a0)	# save next note time %
00002450 : 00255e03;   % 106: 	lhu t3,2(a0) # Current note %
00002451 : 00055303;   % 107: 	lhu t1,0(a0) # Total number of notes %
00002452 : 001e0e13;   % 108: 	addi t3,t3,1 %
00002453 : 01c51123;   % 109: 	sh t3,2(a0)  # Stores it back %
00002454 : 006e4c63;   % 110: 	blt t3,t1,CONTINUE_PLAYING %
00002455 : 00051123;   % 112: 		sh zero,2(a0) %
00002456 : 00c50313;   % 113: 		addi t1,a0,12 %
00002457 : 00652423;   % 114: 		sw t1,8(a0) %
00002458 : 00100893;   % 115: 		li a7,1              # Returns 1  %
00002459 : 0100006f;   % 117: 		j END_PLAY_MUSIC %
0000245a : 00828293;   % 119: 		addi t0, t0, 8	# Gets next note address %
0000245b : 00552423;   % 120: 		sw t0, 8(a0)	# Saves it %
0000245c : 00000893;   % 122: 		li a7,0              # Returns 0 %
0000245d : 00008067;   % 124: END_PLAY_MUSIC:		ret %
0000245e : ffc10113;   % 130: 		addi sp,sp,-4 %
0000245f : 00112023;   % 131: 		sw ra,0(sp) %
00002460 : 0fc09297;   % 135: 	la t0,Item_Get_0 %
00002461 : dc428293;   % 135:  %
00002462 : 00029123;   % 136: 	sh zero,2(t0)	 %
00002463 : 0002a223;   % 137: 	sw zero,4(t0) %
00002464 : 00c28313;   % 138: 	addi t1, t0, 12	# Gets next note address %
00002465 : 0062a423;   % 139: 	sw t1,8(t0) %
00002466 : 0fc09297;   % 141: 	la t0,Item_Get_1 %
00002467 : e4828293;   % 141:  %
00002468 : 00029123;   % 142: 	sh zero,2(t0)	 %
00002469 : 0002a223;   % 143: 	sw zero,4(t0) %
0000246a : 00c28313;   % 144: 	addi t1, t0, 12	# Gets next note address %
0000246b : 0062a423;   % 145: 	sw t1,8(t0) %
0000246c : 0fc09297;   % 147: 	la t0,Item_Get_2 %
0000246d : ea428293;   % 147:  %
0000246e : 00029123;   % 148: 	sh zero,2(t0)	 %
0000246f : 0002a223;   % 149: 	sw zero,4(t0) %
00002470 : 00c28313;   % 150: 	addi t1, t0, 12	# Gets next note address %
00002471 : 0062a423;   % 151: 	sw t1,8(t0) %
00002472 : 0fc09297;   % 153: 	la t0,Item_Get_3 %
00002473 : ea828293;   % 153:  %
00002474 : 00029123;   % 154: 	sh zero,2(t0)	 %
00002475 : 0002a223;   % 155: 	sw zero,4(t0) %
00002476 : 00c28313;   % 156: 	addi t1, t0, 12	# Gets next note address %
00002477 : 0062a423;   % 157: 	sw t1,8(t0) %
00002478 : 0fc09297;   % 159: 	la t0,Item_Get_4 %
00002479 : eac28293;   % 159:  %
0000247a : 00029123;   % 160: 	sh zero,2(t0)	 %
0000247b : 0002a223;   % 161: 	sw zero,4(t0) %
0000247c : 00c28313;   % 162: 	addi t1, t0, 12	# Gets next note address %
0000247d : 0062a423;   % 163: 	sw t1,8(t0) %
0000247e : 0fc09297;   % 165: 	la t0,Item_Get_5 %
0000247f : ec028293;   % 165:  %
00002480 : 00029123;   % 166: 	sh zero,2(t0)	 %
00002481 : 0002a223;   % 167: 	sw zero,4(t0) %
00002482 : 00c28313;   % 168: 	addi t1, t0, 12	# Gets next note address %
00002483 : 0062a423;   % 169: 	sw t1,8(t0) %
00002484 : 0fc09517;   % 172: 		la a0,Item_Get_0 %
00002485 : d3450513;   % 172:  %
00002486 : 00000317;   % 173: 		call PLAY_MUSIC %
00002487 : ed8300e7;   % 173:  %
00002488 : 0fc09517;   % 175: 		la a0,Item_Get_1 %
00002489 : dc050513;   % 175:  %
0000248a : 00000317;   % 176: 		call PLAY_MUSIC %
0000248b : ec8300e7;   % 176:  %
0000248c : 0fc09517;   % 178: 		la a0,Item_Get_2 %
0000248d : e2450513;   % 178:  %
0000248e : 00000317;   % 179: 		call PLAY_MUSIC %
0000248f : eb8300e7;   % 179:  %
00002490 : 0fc09517;   % 181: 		la a0,Item_Get_3 %
00002491 : e3050513;   % 181:  %
00002492 : 00000317;   % 182: 		call PLAY_MUSIC %
00002493 : ea8300e7;   % 182:  %
00002494 : 0fc09517;   % 184: 		la a0,Item_Get_4 %
00002495 : e3c50513;   % 184:  %
00002496 : 00000317;   % 185: 		call PLAY_MUSIC	 %
00002497 : e98300e7;   % 185:  %
00002498 : 0fc09517;   % 187: 		la a0,Item_Get_5 %
00002499 : e5850513;   % 187:  %
0000249a : 00000317;   % 188: 		call PLAY_MUSIC	 %
0000249b : e88300e7;   % 188:  %
0000249c : fa0880e3;   % 190: 	beqz a7,ITEM_GET_LOOP %
0000249d : 00000317;   % 192: 	call RESET_MUSIC %
0000249e : db0300e7;   % 192:  %
0000249f : c0102373;   % 195: 	csrr t1,3073                       # Gets current time for loop %
000024a0 : c01022f3;   % 197: 	    csrr t0,3073                 # Gets current time %
000024a1 : 406282b3;   % 198: 	    sub t0, t0, t1               # t0 = current time - last frame's time %
000024a2 : 3e800393;   % 199: 	    li t2, 1000        # Loads power_up_delay %
000024a3 : fe72eae3;   % 200: 	    bltu t0,t2, ITEM_DELAY_LOOP  # While t0 < minimum time for a frame, keep looping %
000024a4 : 00100313;   % 203: 	li t1,1	 %
000024a5 : 0fc08297;   % 204: 	la t0,Brinstar %
000024a6 : e6428293;   % 204:  %
000024a7 : 00628023;   % 205: 	sb t1,0(t0)	 %
000024a8 : 00012083;   % 208: 	lw ra,0(sp) %
000024a9 : 00410113;   % 209: 	addi sp,sp,4 %
000024aa : 00008067;   % 211: 	ret %
END;
