DEPTH = 16384;
WIDTH = 32;
ADDRESS_RADIX = HEX;
DATA_RADIX = HEX;
CONTENT
BEGIN
00000000 : 00004217;   % 224:  	la 	tp, ExceptionHandling	# carrega em tp o endere�o base das rotinas do sistema ECALL %
00000001 : 68820213;   % 224:  %
00000002 : 00521073;   % 225:  	csrw 	tp, utvec 		# seta utvec para o endere�o tp %
00000003 : 0000e073;   % 226:  	csrsi 	ustatus, 1 		# seta o bit de habilita��o de interrup��o em ustatus (reg 0)																																																				 %
00000004 : 00000413;   % 15: 	li s0, 0  # Initial frame %
00000005 : 00000493;   % 16: 	li s1, 0  # Reseting time %
00000006 : 00100913;   % 17: 	li s2, 1  # Game loop state  %
00000007 : 00000993;   % 18: 	li s3, 0  # Select state %
00000008 : 0fc10297;   % 20: 	la t0, GRAVITY_FACTOR %
00000009 : 13c28293;   % 20:  %
0000000a : 0002a407;   % 21: 	flw fs0,0(t0) %
0000000b : 0fc10297;   % 22: 	la t0, JUMP_SPEED %
0000000c : 13428293;   % 22:  %
0000000d : 0002a487;   % 23: 	flw fs1,0(t0) %
0000000e : 0fc10297;   % 25: 	la t0, RIDLEY_JUMP_SPEED %
0000000f : 42c28293;   % 25:  %
00000010 : 0002a987;   % 26: 	flw fs3,0(t0) %
00000011 : 7a40006f;   % 28: 	j SETUP %
00000012 : c0102573;   % 61:     csrr a0,3073 %
00000013 : 40950533;   % 62:     sub a0, a0, s1 #  # a0 = current time - last frame's time %
00000014 : 03200293;   % 63:     li t0, 50	# Loads frame rate (time (in ms) per frame) %
00000015 : fe556ae3;   % 64:     bltu a0,t0, GAME_LOOP  # While a0 < minimum time for a frame, keep looping  %
00000016 : 00144413;   % 67:     xori s0,s0,1		    # Switches frame value (register) %
00000017 : 00009317;   % 69: 	call MUSIC.PLAY %
00000018 : b0c300e7;   % 69:  %
00000019 : 00000317;   % 71: 	call INPUT_CHECK	    # Checks player's input %
0000001a : 258300e7;   % 71:  %
0000001b : 00001317;   % 73: 	call PHYSICS            # Physics operations %
0000001c : 288300e7;   % 73:  %
0000001d : 00001317;   % 75: 	call UPDATE_DOORS       # Updates doors %
0000001e : 120300e7;   % 75:  %
0000001f : 00006317;   % 76: 	call MAP_MOVE_RENDER    # Renders map when necessary %
00000020 : f80300e7;   % 76:  %
00000021 : 00003317;   % 78: 	call MARU_MARI_OPERATIONS %
00000022 : ae8300e7;   % 78:  %
00000023 : 00003317;   % 80: 	call BOMB_POWER_OPERATIONS %
00000024 : bc4300e7;   % 80:  %
00000025 : 00003317;   % 82: 	call ITEM_CAPSULE_OPERATIONS %
00000026 : c98300e7;   % 82:  %
00000027 : 00000513;   % 84: 	li a0,0 %
00000028 : 00003317;   % 85: 	call ENEMY_OPERATIONS %
00000029 : 1e8300e7;   % 85:  %
0000002a : 00002317;   % 87: 	call BEAMS_OPERATIONS %
0000002b : 758300e7;   % 87:  %
0000002c : 00007317;   % 89: 	call UPDATE_STATUS      # Updates player's sprite status %
0000002d : 88c300e7;   % 89:  %
0000002e : 00000513;   % 91: 	li a0, 0     # Rendering player operation %
0000002f : 00000593;   % 92: 	li a1, 0     # Rendering full player %
00000030 : 00002317;   % 93: 	call RENDER_PLAYER	 %
00000031 : 988300e7;   % 93:  %
00000032 : 00003317;   % 95: 	call LOOT_OPERATIONS %
00000033 : de8300e7;   % 95:  %
00000034 : 00003317;   % 97: 	call BOMBS_OPERATIONS %
00000035 : 8a4300e7;   % 97:  %
00000036 : 00003317;   % 98: 	call EXPLOSIONS_OPERATIONS %
00000037 : f78300e7;   % 98:  %
00000038 : 00002317;   % 100: 	call RENDER_DOOR_FRAMES %
00000039 : 00c300e7;   % 100:  %
0000003a : 00007317;   % 102: 	call PLAYER_COLLISION  # Will see if player was hit by an enemy %
0000003b : cec300e7;   % 102:  %
0000003c : 00007317;   % 104: 	call BEAM_COLLISION  # Will see if beam hit an enemy %
0000003d : 354300e7;   % 104:  %
0000003e : 00000513;   % 106: 	li a0, 0     # Rendering UI operation %
0000003f : 00002317;   % 107: 	call RENDER_UI	 %
00000040 : cec300e7;   % 107:  %
00000041 : ff2002b7;   % 110: 	li t0,0xFF200604	# Loads Bitmap Display address %
00000042 : 60428293;   % 110:  %
00000043 : 0082a023;   % 111: 	sw s0,0(t0)         # Stores new frame value (from s0) on Bitmap Display %
00000044 : c01024f3;   % 113: 	csrr s1,3073        # New time is stored in s1, in order to be compared later		 %
00000045 : f35ff06f;   % 115: 	j GAME_LOOP	        # Returns to loop's beginning %
00000046 : c0102573;   % 120:     csrr a0,3073 %
00000047 : 40950533;   % 121:     sub a0, a0, s1 				# a0 = current time - last frame's time %
00000048 : 03200293;   % 122:     li t0, 50			# Loads frame rate (time (in ms) per frame) %
00000049 : fe556ae3;   % 123:     bltu a0,t0, MENU2_LOOP  # While a0 < minimum time for a frame, keep looping  %
0000004a : 00144413;   % 126:     xori s0,s0,1		    # Switches frame value (register) %
0000004b : 00000317;   % 128: 	call INPUT_CHECK	    # Checks player's input %
0000004c : 190300e7;   % 128:  %
0000004d : 00000513;   % 130: 	li a0,0               # Black %
0000004e : 00000593;   % 131: 	li a1,0               # Starting X (0) %
0000004f : 00000613;   % 132: 	li a2,0               # Starting Y (0) %
00000050 : 14000693;   % 133: 	li a3,320    # Gets width %
00000051 : 0f000713;   % 134: 	li a4,240   # Gets height %
00000052 : 008007b3;   % 135: 	mv a5,s0              # Gets frame %
00000053 : 00000813;   % 136: 	li a6,0               # Render per word %
00000054 : 00002317;   % 137: 	call RENDER_COLOR %
00000055 : 868300e7;   % 137:  %
00000056 : 0fc10517;   % 139: 	la a0,Select_UI %
00000057 : 49750513;   % 139:  %
00000058 : 07000593;   % 140: 	li a1,112             # Starting X (0) %
00000059 : 06100613;   % 141: 	li a2,97              # Starting Y (0) %
0000005a : 00098463;   % 142: 	beqz s3,SKIP_SELECT_CONTINUE %
0000005b : 01860613;   % 143: 		addi a2,a2,24     # If selecting continue, render further down %
0000005c : 00800693;   % 145: 	li a3,8               # Gets width %
0000005d : 00800713;   % 146: 	li a4,8               # Gets height %
0000005e : 008007b3;   % 147: 	mv a5,s0              # Gets frame %
0000005f : 00000813;   % 148: 	li a6,0               # Only one sprite, so status is 0 %
00000060 : 00000893;   % 149: 	li a7,0               # Normal render %
00000061 : 00001317;   % 150: 	call RENDER_WORD %
00000062 : 7a8300e7;   % 150:  %
00000063 : 0fc10517;   % 152: 	la a0,START_TXT %
00000064 : f7c50513;   % 152:  %
00000065 : 08000593;   % 153: 	li a1,128             # a1 = column %
00000066 : 06000613;   % 154: 	li a2,96              # a2 = row  %
00000067 : 0ea00693;   % 155: 	li a3,0x00EA          # a3 = colors  %
00000068 : 00800733;   % 156: 	mv a4,s0              # a4 = frame %
00000069 : 00100793;   % 157: 	li a5,1               # Font %
0000006a : 06800893;   % 158: 	li a7,104 # syscal for 'print integer' %
0000006b : 00000073;   % 159: 	ecall %
0000006c : 0fc10517;   % 161: 	la a0,CONTINUE_TXT %
0000006d : f5e50513;   % 161:  %
0000006e : 08000593;   % 162: 	li a1,128             # a1 = column %
0000006f : 07800613;   % 163: 	li a2,120             # a2 = row  %
00000070 : 0ea00693;   % 164: 	li a3,0x00EA          # a3 = colors  %
00000071 : 00800733;   % 165: 	mv a4,s0              # a4 = frame %
00000072 : 00100793;   % 166: 	li a5,1               # Font %
00000073 : 06800893;   % 167: 	li a7,104 # syscal for 'print integer' %
00000074 : 00000073;   % 168: 	ecall %
00000075 : ff2002b7;   % 171: 	li t0,0xFF200604	# Loads Bitmap Display address %
00000076 : 60428293;   % 171:  %
00000077 : 0082a023;   % 172: 	sw s0,0(t0)         # Stores new frame value (from s0) on Bitmap Display %
00000078 : c01024f3;   % 174: 	csrr s1,3073        # New time is stored in s1, in order to be compared later		 %
00000079 : f35ff06f;   % 176: 	j MENU2_LOOP	# Returns to loop's beginning %
0000007a : 00000513;   % 179: 	li a0,0               # Black %
0000007b : 00000593;   % 180: 	li a1,0               # Starting X (0) %
0000007c : 00000613;   % 181: 	li a2,0               # Starting Y (0) %
0000007d : 14000693;   % 182: 	li a3,320    # Gets width %
0000007e : 0f000713;   % 183: 	li a4,240   # Gets height %
0000007f : 00000793;   % 184: 	li a5,0               # Gets frame %
00000080 : 00000813;   % 185: 	li a6,0               # Render per word %
00000081 : 00001317;   % 186: 	call RENDER_COLOR %
00000082 : 7b4300e7;   % 186:  %
00000083 : 0fc10517;   % 188: 	la a0,GAME_OVER_TXT %
00000084 : f0b50513;   % 188:  %
00000085 : 07800593;   % 189: 	li a1,120             # a1 = column %
00000086 : 07400613;   % 190: 	li a2,116             # a2 = row  %
00000087 : 0ff00693;   % 191: 	li a3,0x00ff          # a3 = colors  %
00000088 : 00000713;   % 192: 	li a4,0               # a4 = frame %
00000089 : 00100793;   % 193: 	li a5,1               # Font %
0000008a : 06800893;   % 194: 	li a7,104 # syscal for 'print integer' %
0000008b : 00000073;   % 195: 	ecall %
0000008c : 00000513;   % 197: 	li a0,0               # Black %
0000008d : 00000593;   % 198: 	li a1,0               # Starting X (0) %
0000008e : 00000613;   % 199: 	li a2,0               # Starting Y (0) %
0000008f : 14000693;   % 200: 	li a3,320    # Gets width %
00000090 : 0f000713;   % 201: 	li a4,240   # Gets height %
00000091 : 00100793;   % 202: 	li a5,1               # Gets frame %
00000092 : 00000813;   % 203: 	li a6,0               # Render per word %
00000093 : 00001317;   % 204: 	call RENDER_COLOR %
00000094 : 76c300e7;   % 204:  %
00000095 : 0fc10517;   % 206: 	la a0,GAME_OVER_TXT %
00000096 : ec350513;   % 206:  %
00000097 : 07800593;   % 207: 	li a1,120             # a1 = column %
00000098 : 07400613;   % 208: 	li a2,116             # a2 = row  %
00000099 : 0ff00693;   % 209: 	li a3,0x00ff          # a3 = colors  %
0000009a : 00100713;   % 210: 	li a4,1               # a4 = frame %
0000009b : 00100793;   % 211: 	li a5,1               # Font %
0000009c : 06800893;   % 212: 	li a7,104 # syscal for 'print integer' %
0000009d : 00000073;   % 213: 	ecall %
0000009e : c01024f3;   % 215: 	csrr s1,3073        # New time is stored in s1, in order to be compared later %
0000009f : c0102573;   % 219:     csrr a0,3073 %
000000a0 : 40950533;   % 220:     sub a0, a0, s1 				# a0 = current time - last frame's time %
000000a1 : 3e800293;   % 221:     li t0, 1000			# Loads frame rate (time (in ms) per frame) %
000000a2 : fe556ae3;   % 222:     bltu a0,t0, GAME_OVER_LOOP_PREP2  # While a0 < minimum time for a frame, keep looping  %
000000a3 : c0102573;   % 226:     csrr a0,3073 %
000000a4 : 40950533;   % 227:     sub a0, a0, s1 				# a0 = current time - last frame's time %
000000a5 : 03200293;   % 228:     li t0, 50			# Loads frame rate (time (in ms) per frame) %
000000a6 : fe556ae3;   % 229:     bltu a0,t0, GAME_OVER_LOOP  # While a0 < minimum time for a frame, keep looping  %
000000a7 : 00144413;   % 232:     xori s0,s0,1		    # Switches frame value (register) %
000000a8 : 00000317;   % 234: 	call INPUT_CHECK	    # Checks player's input %
000000a9 : 01c300e7;   % 234:  %
000000aa : ff2002b7;   % 237: 	li t0,0xFF200604	# Loads Bitmap Display address %
000000ab : 60428293;   % 237:  %
000000ac : 0082a023;   % 238: 	sw s0,0(t0)         # Stores new frame value (from s0) on Bitmap Display %
000000ad : c01024f3;   % 240: 	csrr s1,3073        # New time is stored in s1, in order to be compared later		 %
000000ae : fd5ff06f;   % 242: 	j GAME_OVER_LOOP	# Returns to loop's beginning %
000000af : 0fc10517;   % 17:     la a0, PLYR_STATUS   # Loads Player Status %
000000b0 : e8e50513;   % 17:  %
000000b1 : 0fc10597;   % 18:     la a1, PLYR_POS      # Loads Player Pos %
000000b2 : e7a58593;   % 18:  %
000000b3 : ff200337;   % 21:     li t1,0xFF200000  	  # KDMMIO Address %
000000b4 : 00030313;   % 21:  %
000000b5 : 00032283;   % 22:     lw t0, 0(t1)	      # Reads the Keyboard Control bit %
000000b6 : 0012f293;   % 23:     andi t0, t0, 0x0001	  # Masks the least significant bit   %
000000b7 : 00100393;   % 27:     li t2,1                # Menu2 number %
000000b8 : 03238863;   % 28:     beq t2,s2,MENU2_CHECK  # If on menu2 %
000000b9 : 00200393;   % 30:     li t2,2                # Game scene number %
000000ba : 01238663;   % 31:     beq t2,s2,GAME_CHECK   # If on game %
000000bb : 00300393;   % 33:     li t2,3                     # Game over scene number %
000000bc : 01238663;   % 34:     beq t2,s2,GAME_OVER_CHECK   # If on game over %
000000bd : 08029063;   % 37:         bnez t0, CONTINUE_GAME_CHECK    # If an input is detected, continue checking %
000000be : 2040006f;   % 38:         j NO_CHEAT_INPUT 		        # otherwise no input was detected, but check for other non-cheat inputs  %
000000bf : 00029463;   % 41:              bnez t0, CONTINUE_GAME_OVER_CHECK   # If any input is detected, continue %
000000c0 : 4e40006f;   % 42:             j END_INPUT_CHECK               # end procedure %
000000c1 : 00000993;   % 46:             li s3,0 %
000000c2 : 00100913;   % 47:             li s2,1   %
000000c3 : 4dc0006f;   % 48:             j SETUP          # end procedure by going to setup %
000000c4 : 00029463;   % 51:        bnez t0, CONTINUE_MENU2_CHECK       # If any input is detected, continue %
000000c5 : 4d00006f;   % 53:             j END_INPUT_CHECK               # end procedure %
000000c6 : 00432283;   % 56:             lw t0, 4(t1)   # Reads key value %
000000c7 : 07700313;   % 58:             li t1, 'w'	   # Loads ascii value of 'w' key %
000000c8 : 00629663;   % 59:             bne t0, t1, CHECK_INPUT.MENU2_S %
000000c9 : 00000993;   % 60:                 li s3,0 %
000000ca : 4bc0006f;   % 61:                 j END_INPUT_CHECK               # end procedure %
000000cb : 07300313;   % 64:             li t1, 's'	# Loads ascii value of 's' key %
000000cc : 00629663;   % 65:             bne t0, t1, CHECK_INPUT.MENU2_ENTER %
000000cd : 00100993;   % 66:                 li s3,1 %
000000ce : 4ac0006f;   % 67:                 j END_INPUT_CHECK               # end procedure %
000000cf : 00a00313;   % 70:             li t1, '\n'	# Loads ascii value of ENTER key %
000000d0 : fc629ae3;   % 71:             bne t0, t1, MENU2_NO_INPUT %
000000d1 : 0fc10297;   % 72:                 la t0,PLYR_INFO %
000000d2 : df828293;   % 72:  %
000000d3 : 01e00313;   % 73:                 li t1, 30 %
000000d4 : 00628023;   % 74:                 sb t1,0(t0)     # Map 1 %
000000d5 : 0fc10297;   % 75:                 la t0, MAP_INFO # Loads Map Info address %
000000d6 : dd428293;   % 75:  %
000000d7 : 00100313;   % 76:                 li t1,1         # Map 1 %
000000d8 : 00628023;   % 77:                 sb t1, 0(t0)    # Stores map 1 number %
000000d9 : 00400313;   % 78:                 li t1,4         # 4 - Force switch %
000000da : 006280a3;   % 79:                 sb t1, 1(t0)    # Stores render byte %
000000db : 00200913;   % 80:                 li s2,2   %
000000dc : 4780006f;   % 81:                 j SETUP                         # end procedure by going to setup %
000000dd : 00432283;   % 85:     lw t0, 4(t1)   # Reads key value %
000000de : 03100313;   % 88:     li t1, '1' %
000000df : 00629463;   % 89:     bne t0,t1, CHECK_INPUT.2 %
000000e0 : 0680006f;   % 90:     j INPUT.1 %
000000e1 : 03200313;   % 93:     li t1, '2' %
000000e2 : 00629463;   % 94:     bne t0,t1, CHECK_INPUT.3 %
000000e3 : 0800006f;   % 95:     j INPUT.2 %
000000e4 : 03300313;   % 98:     li t1, '3' %
000000e5 : 00629463;   % 99:     bne t0,t1, CHECK_INPUT.4 %
000000e6 : 0980006f;   % 100:     j INPUT.3 %
000000e7 : 03400313;   % 103:     li t1, '4' %
000000e8 : 00629463;   % 104:     bne t0,t1, CHECK_INPUT.5 %
000000e9 : 0b00006f;   % 105:     j INPUT.4 %
000000ea : 03500313;   % 108:     li t1, '5' %
000000eb : 00629463;   % 109:     bne t0,t1, CHECK_INPUT.6 %
000000ec : 0c80006f;   % 110:     j INPUT.5 %
000000ed : 03600313;   % 113:     li t1, '6' %
000000ee : 00629463;   % 114:     bne t0,t1, CHECK_INPUT.7 %
000000ef : 0e00006f;   % 115:     j INPUT.6 %
000000f0 : 03700313;   % 118:     li t1, '7' %
000000f1 : 00629463;   % 119:     bne t0,t1, CHECK_INPUT.O %
000000f2 : 0f80006f;   % 120:     j INPUT.7 %
000000f3 : 06f00313;   % 123:     li t1, 'o' %
000000f4 : 00629463;   % 124:     bne t0,t1, CHECK_INPUT.0 %
000000f5 : 1100006f;   % 125:     j INPUT.O %
000000f6 : 03000313;   % 128:     li t1, '0'	 %
000000f7 : 00629463;   % 129:     bne t0,t1, GOTO_NO_CHEAT_INPUT %
000000f8 : 10c0006f;   % 130:     j INPUT.0 	 %
000000f9 : 1180006f;   % 133:         j NO_CHEAT_INPUT %
000000fa : 0fc10297;   % 136:         la t0 MAP_INFO %
000000fb : d4028293;   % 136:  %
000000fc : 00100313;   % 137:         li t1, 1 %
000000fd : 00628023;   % 138:         sb t1, 0(t0) %
000000fe : 00400313;   % 139:         li t1, 4 %
000000ff : 006280a3;   % 140:         sb t1, 1(t0) %
00000100 : 00000313;   % 142:         li t1,0 %
00000101 : 006500a3;   % 143:         sb t1,1(a0) %
00000102 : 3e00006f;   % 145:         j SETUP %
00000103 : 0fc10297;   % 148:         la t0 MAP_INFO %
00000104 : d1c28293;   % 148:  %
00000105 : 00200313;   % 149:         li t1, 2 %
00000106 : 00628023;   % 150:         sb t1, 0(t0) %
00000107 : 00400313;   % 151:         li t1, 4 %
00000108 : 006280a3;   % 152:         sb t1, 1(t0) %
00000109 : 00000313;   % 154:         li t1,0 %
0000010a : 006500a3;   % 155:         sb t1,1(a0) %
0000010b : 3bc0006f;   % 157:         j SETUP %
0000010c : 0fc10297;   % 160:         la t0 MAP_INFO %
0000010d : cf828293;   % 160:  %
0000010e : 00300313;   % 161:         li t1, 3 %
0000010f : 00628023;   % 162:         sb t1, 0(t0) %
00000110 : 00400313;   % 163:         li t1, 4 %
00000111 : 006280a3;   % 164:         sb t1, 1(t0) %
00000112 : 00000313;   % 166:         li t1,0 %
00000113 : 006500a3;   % 167:         sb t1,1(a0) %
00000114 : 3980006f;   % 169:         j SETUP %
00000115 : 0fc10297;   % 172:         la t0 MAP_INFO %
00000116 : cd428293;   % 172:  %
00000117 : 00400313;   % 173:         li t1, 4 %
00000118 : 00628023;   % 174:         sb t1, 0(t0) %
00000119 : 00400313;   % 175:         li t1, 4 %
0000011a : 006280a3;   % 176:         sb t1, 1(t0) %
0000011b : 00000313;   % 178:         li t1,0 %
0000011c : 006500a3;   % 179:         sb t1,1(a0) %
0000011d : 3740006f;   % 181:         j SETUP %
0000011e : 0fc10297;   % 184:         la t0 MAP_INFO %
0000011f : cb028293;   % 184:  %
00000120 : 00500313;   % 185:         li t1, 5 %
00000121 : 00628023;   % 186:         sb t1, 0(t0) %
00000122 : 00400313;   % 187:         li t1, 4 %
00000123 : 006280a3;   % 188:         sb t1, 1(t0) %
00000124 : 00100313;   % 190:         li t1,1 %
00000125 : 006500a3;   % 191:         sb t1,1(a0) %
00000126 : 3500006f;   % 193:         j SETUP %
00000127 : 0fc10297;   % 196:         la t0 MAP_INFO %
00000128 : c8c28293;   % 196:  %
00000129 : 00600313;   % 197:         li t1, 6 %
0000012a : 00628023;   % 198:         sb t1, 0(t0) %
0000012b : 00400313;   % 199:         li t1, 4 %
0000012c : 006280a3;   % 200:         sb t1, 1(t0) %
0000012d : 00100313;   % 202:         li t1,1 %
0000012e : 006500a3;   % 203:         sb t1,1(a0) %
0000012f : 32c0006f;   % 205:         j SETUP %
00000130 : 0fc10297;   % 208:         la t0 MAP_INFO %
00000131 : c6828293;   % 208:  %
00000132 : 00700313;   % 209:         li t1, 7 %
00000133 : 00628023;   % 210:         sb t1, 0(t0) %
00000134 : 00400313;   % 211:         li t1, 4 %
00000135 : 006280a3;   % 212:         sb t1, 1(t0) %
00000136 : 00100313;   % 214:         li t1,1 %
00000137 : 006500a3;   % 215:         sb t1,1(a0) %
00000138 : 3080006f;   % 217:         j SETUP %
00000139 : 00000513;   % 220:         li a0, 0    # open doors %
0000013a : 56d0006f;   % 222:         j CHANGE_DOORS_STATE %
0000013b : 00200513;   % 225:         li a0,2 %
0000013c : 00a00593;   % 226:         li a1,10 %
0000013d : 5d00606f;   % 227:         j DAMAGE_PLAYER %
0000013e : 2ec0006f;   % 228:         j END_INPUT_CHECK %
0000013f : ff200637;   % 233:     li a2,0xFF200520	# Loads KEY0 address   (1<<(code)) %
00000140 : 52060613;   % 233:  %
00000141 : 00062603;   % 234:     lw a2,0(a2)     # and loads its contents to a2 %
00000142 : ff2006b7;   % 236: 	li a3,0xFF200524	# Loads KEY1 address   (1<<(code - 32)) %
00000143 : 52468693;   % 236:  %
00000144 : 0006a683;   % 237:     lw a3,0(a3)     # and loads its contents to a3 %
00000145 : ff200737;   % 239: 	li a4,0xFF200528	# Loads KEY2 address   (1<<(code - 64)) %
00000146 : 52870713;   % 239:  %
00000147 : 00072703;   % 240:     lw a4,0(a4)     # and loads its contents to a4 %
00000148 : ff2007b7;   % 242: 	li a5,0xFF20052C	# Loads KEY3 address   (1<<(code - 96)) %
00000149 : 52c78793;   % 242:  %
0000014a : 0007a783;   % 243:     lw a5,0(a5)     # and loads its contents to a5 %
0000014b : 00d66eb3;   % 245:     or t4,a2,a3     # t4 == 0 only if there's no input in a2 and a3 %
0000014c : 00eeeeb3;   % 246:     or t4,t4,a4     # t4 == 0 only if there's no input in a2, a3 and a4 %
0000014d : 00feeeb3;   % 247:     or t4,t4,a5     # t4 == 0 only if there's no input in a2, a3, a4 and a5 %
0000014e : 00000813;   % 249:     li a6,0         # Sets a6 to 0 (no key was pressed) as a default %
0000014f : 040e9463;   % 250:     bnez t4,CONTINUE_NO_CHEAT_INPUT_CHECK  # If there's any input at all %
00000150 : 0fc10297;   % 253:         la t0, PLYR_INPUT # Loads PLYR_INPUT address %
00000151 : c1328293;   % 253:  %
00000152 : 00080c63;   % 254:         beqz a6,CONTINUE_NO_INPUT   # If no key was pressed %
00000153 : 0002c383;   % 256:             lbu t2,0(t0)      # Loads PLYR_INPUT's value %
00000154 : 00039663;   % 257:             bnez t2, DONT_UPDATE_PLYR_INPUT  # If it isn't 0, don't update it %
00000155 : 00100393;   % 258:                 li t2, 1      # Otherwise, there's input %
00000156 : 00728023;   % 259:                 sb t2, 0(t0)  # store it %
00000157 : 2880006f;   % 261:                 j END_INPUT_CHECK   # End input check %
00000158 : 00000393;   % 264:         li t2, 0   # There isn't input %
00000159 : 00728023;   % 265:         sb t2, 0(t0)  %
0000015a : 0fc10517;   % 267:         la a0, PLYR_STATUS      # Loads Player Status %
0000015b : be250513;   % 267:  %
0000015c : 00000313;   % 268:         li t1, 0        # Loads vertical direction (0 = normal) %
0000015d : 00650123;   % 269:         sb t1, 2(a0)    # Stores new direction on PLYR_STATUS %
0000015e : 006502a3;   % 271:         sb t1, 5(a0)                   %
0000015f : 00050323;   % 272: 	    sb zero, 6(a0)      # Stores new direction on MOVE_X %
00000160 : 2640006f;   % 273:         j END_INPUT_CHECK  %
00000161 : 00100213;   % 278:     li tp,1         # Number that will be shifted for comparisions %
00000162 : 01d00e93;   % 281:     li t4,0x1D      # W sanscode         %
00000163 : 01d21eb3;   % 282:     sll t4,tp,t4    # (1<<(29)) %
00000164 : 00cefeb3;   % 283:     and t4,t4,a2    # will be !=0 if W is being pressed %
00000165 : 000e9463;   % 284:     bnez t4,INPUT.W # if pressing W %
00000166 : 0340006f;   % 285:         j CHECK_INPUT.A # Otherwise, check if A was pressed %
00000167 : 00100813;   % 288:         li a6,1         # Sets a6 to 1 (a key was pressed) %
00000168 : 00454e83;   % 289:         lbu t4, 4(a0) # Loads player's abilities %
00000169 : 020e8063;   % 290:         beqz t4, W.NOT_MORPH_BALL # t4 != 0 ? BALL = OFF : BALL = ON (If on ball mode, deactivate it) %
0000016a : ffc10113;   % 292:             addi sp,sp,-4 %
0000016b : 00112023;   % 293:             sw ra,0(sp) %
0000016c : 00006317;   % 295:             call OUT_OF_MORPH_BALL      # Only changes temporary  %
0000016d : 4c0300e7;   % 295:  %
0000016e : 00012083;   % 297:             lw ra,0(sp) %
0000016f : 00410113;   % 298:             addi sp,sp,4 %
00000170 : 00c0006f;   % 300:             j CHECK_INPUT.A %
00000171 : 00100e93;   % 302:         li t4, 1      # Loads vertical direction (1 = up) %
00000172 : 01d50123;   % 303:         sb t4, 2(a0)  # Stores new direction on PLYR_STATUS %
00000173 : 01c00e93;   % 308:     li t4,0x1C      # A sanscode         %
00000174 : 01d21eb3;   % 309:     sll t4,tp,t4    # (1<<(28)) %
00000175 : 00cefeb3;   % 310:     and t4,t4,a2    # will be !=0 if A is being pressed %
00000176 : 000e9463;   % 311:     bnez t4,INPUT.A # if pressing A %
00000177 : 0140006f;   % 312:         j CHECK_INPUT.D # Otherwise, check if D was pressed %
00000178 : 00100813;   % 315:         li a6,1         # Sets a6 to 1 (a key was pressed) %
00000179 : fff00e93;   % 316:         li t4, -1     # Loads direction for MOVE_X (-1 = left) %
0000017a : 01d50323;   % 317:         sb t4, 6(a0)  # Stores new direction on MOVE_X %
0000017b : 0280006f;   % 318:         j CHECK_INPUT.S # If A was pressed, ignore D   (muahhahahahahah)    %
0000017c : 02300e93;   % 322:     li t4,0x23      # D sanscode   %
0000017d : fe0e8e93;   % 323:     addi t4,t4,-32  # adjusts it for comparision       %
0000017e : 01d21eb3;   % 324:     sll t4,tp,t4    # (1<<(0x23 - 32)) %
0000017f : 00defeb3;   % 325:     and t4,t4,a3    # will be !=0 if D is being pressed %
00000180 : 000e9463;   % 326:     bnez t4,INPUT.D # if pressing D %
00000181 : 0100006f;   % 327:         j CHECK_INPUT.S # Otherwise, check if S was pressed %
00000182 : 00100813;   % 330:         li a6,1         # Sets a6 to 1 (a key was pressed) %
00000183 : 00100e93;   % 331:         li t4, 1      # Loads direction for MOVE_X (1 = right) %
00000184 : 01d50323;   % 332:         sb t4, 6(a0)  # Stores new direction on MOVE_X %
00000185 : 01b00e93;   % 337:     li t4,0x1B      # S sanscode         %
00000186 : 01d21eb3;   % 338:     sll t4,tp,t4    # (1<<(27)) %
00000187 : 00cefeb3;   % 339:     and t4,t4,a2    # will be !=0 if S is being pressed %
00000188 : 000e9463;   % 340:     bnez t4,INPUT.S # if pressing S %
00000189 : 03c0006f;   % 341:         j CHECK_INPUT.SPACE # Otherwise, check if Space was pressed %
0000018a : 00100813;   % 344:         li a6,1         # Sets a6 to 1 (a key was pressed) %
0000018b : fff5ce83;   % 345:         lbu t4, -1(a1) # Loads player's abilities %
0000018c : 00750f03;   % 346:         lb t5, 7(a0)  # Loads direction on MOVE_Y %
0000018d : 01d02eb3;   % 347:         slt t4, zero, t4 # t4 > 0 ? t4=1 : t4=0 --> if t4 = 1 or 2 (morph ball ability aquired) then go into morph ball %
0000018e : 020f1463;   % 349:         bnez t5, SkipMorphBallTransformation %
0000018f : 020e8263;   % 350:         beqz t4, SkipMorphBallTransformation  %
00000190 : 00450e83;   % 351:         lb t4, 4(a0) # loads ball mode  %
00000191 : 000e9e63;   % 352:         bnez t4, SkipMorphBallTransformation %
00000192 : ffc10113;   % 354:             addi sp,sp,-4 %
00000193 : 00112023;   % 355:             sw ra,0(sp) %
00000194 : 00006317;   % 357:             call INTO_MORPH_BALL      # Only changes temporary  %
00000195 : 414300e7;   % 357:  %
00000196 : 00012083;   % 359:             lw ra,0(sp) %
00000197 : 00410113;   % 360:             addi sp,sp,4 %
00000198 : 02900e93;   % 367:     li t4,0x29      # SPACE sanscode   %
00000199 : fe0e8e93;   % 368:     addi t4,t4,-32  # adjusts it for comparision       %
0000019a : 01d21eb3;   % 369:     sll t4,tp,t4    # (1<<(0x23 - 32)) %
0000019b : 00defeb3;   % 370:     and t4,t4,a3    # will be !=0 if SPACE is being pressed %
0000019c : 000e9463;   % 371:     bnez t4,INPUT.SPACE # if pressing SPACE %
0000019d : 04c0006f;   % 372:         j CHECK_INPUT.K # Otherwise, check if K was pressed %
0000019e : 00100813;   % 375:         li a6,1         # Sets a6 to 1 (a key was pressed) %
0000019f : 00450e83;   % 376:         lb t4, 4(a0) # loads ball mode  %
000001a0 : 020e8063;   % 377:         beqz t4, SPACE.NOT_MORPH_BALL %
000001a1 : ffc10113;   % 379:             addi sp,sp,-4 %
000001a2 : 00112023;   % 380:             sw ra,0(sp) %
000001a3 : 00006317;   % 382:             call OUT_OF_MORPH_BALL      # Only changes temporary  %
000001a4 : 3e4300e7;   % 382:  %
000001a5 : 00012083;   % 384:             lw ra,0(sp) %
000001a6 : 00410113;   % 385:             addi sp,sp,4 %
000001a7 : 0240006f;   % 387:             j CHECK_INPUT.K %
000001a8 : 00750303;   % 389:             lb t1, 7(a0)  # Loads current direction on MOVE_Y %
000001a9 : 00030463;   % 390:             beqz t1, CAN_JUMP %
000001aa : 0180006f;   % 391:             j CHECK_INPUT.K %
000001ab : 00100313;   % 393:                 li t1, 1     # Loads ground position (1 = freefall) %
000001ac : 006501a3;   % 394:                 sb t1, 3(a0) # Stores new direction on PLYR_STATUS %
000001ad : fff00313;   % 396:                 li t1, -1      # Loads direction for MOVE_Y (-1 = up) %
000001ae : 006503a3;   % 397:                 sb t1, 7(a0)   # Stores new direction on MOVE_Y %
000001af : 20948953;   % 400:                 fmv.s fs2,fs1  # Sets fs2 (player's Y speed) to -9  %
000001b0 : 04200e93;   % 405:     li t4,0x42      # K sanscode   %
000001b1 : fc0e8e93;   % 406:     addi t4,t4,-64  # adjusts it for comparision       %
000001b2 : 01d21eb3;   % 407:     sll t4,tp,t4    # (1<<(0x23 - 64)) %
000001b3 : 00eefeb3;   % 408:     and t4,t4,a4    # will be !=0 if K is being pressed %
000001b4 : 000e9463;   % 409:     bnez t4,INPUT.K # if pressing K %
000001b5 : 0cc0006f;   % 410:         j CHECK_INPUT.J # Otherwise, check if J was pressed %
000001b6 : 00100813;   % 413:         li a6,1            # Sets a6 to 1 (a key was pressed) %
000001b7 : 00450e83;   % 414:         lb t4, 4(a0)       # loads ball mode  %
000001b8 : 060e8463;   % 415:         beqz t4, K.SHOOT   # If standing %
000001b9 : fff5ce03;   % 416:             lbu t3,-1(a1)  # Loads number of abilities %
000001ba : 00300313;   % 417:             li t1,3        # Number where bomb ability is aquired %
000001bb : 006e5463;   % 418:             bge t3,t1,K.PLACE_BOMB   # If player can place bombs %
000001bc : 0b00006f;   % 419:                 j CHECK_INPUT.J      # otherwise, skip it %
000001bd : fe010113;   % 423:                 addi sp,sp,-32 %
000001be : 01012e23;   % 424:                 sw a6,28(sp) %
000001bf : 00f12c23;   % 425:                 sw a5,24(sp) %
000001c0 : 00e12a23;   % 426:                 sw a4,20(sp) %
000001c1 : 00d12823;   % 427:                 sw a3,16(sp) %
000001c2 : 00c12623;   % 428:                 sw a2,12(sp) %
000001c3 : 00b12423;   % 429:                 sw a1,8(sp) %
000001c4 : 00a12223;   % 430:                 sw a0,4(sp) %
000001c5 : 00112023;   % 431:                 sw ra,0(sp) %
000001c6 : 00002317;   % 433:                 call BOMB_SPAWN %
000001c7 : 03c300e7;   % 433:  %
000001c8 : 01c12803;   % 435:                 lw a6,28(sp) %
000001c9 : 01812783;   % 436:                 lw a5,24(sp) %
000001ca : 01412703;   % 437:                 lw a4,20(sp) %
000001cb : 01012683;   % 438:                 lw a3,16(sp) %
000001cc : 00c12603;   % 439:                 lw a2,12(sp) %
000001cd : 00812583;   % 440:                 lw a1,8(sp) %
000001ce : 00412503;   % 441:                 lw a0,4(sp) %
000001cf : 00012083;   % 442:                 lw ra,0(sp) %
000001d0 : 02010113;   % 443:                 addi sp,sp,32 %
000001d1 : 05c0006f;   % 445:                 j CHECK_INPUT.J     %
000001d2 : 00100e93;   % 448:             li t4, 1     # Loads attacking status (1 = attacking) %
000001d3 : 01d502a3;   % 449:             sb t4, 5(a0) # Stores new attack status on PLYR_STATUS %
000001d4 : fe010113;   % 451:                 addi sp,sp,-32 %
000001d5 : 01012e23;   % 452:                 sw a6,28(sp) %
000001d6 : 00f12c23;   % 453:                 sw a5,24(sp) %
000001d7 : 00e12a23;   % 454:                 sw a4,20(sp) %
000001d8 : 00d12823;   % 455:                 sw a3,16(sp) %
000001d9 : 00c12623;   % 456:                 sw a2,12(sp) %
000001da : 00b12423;   % 457:                 sw a1,8(sp) %
000001db : 00a12223;   % 458:                 sw a0,4(sp) %
000001dc : 00112023;   % 459:                 sw ra,0(sp) %
000001dd : 00002317;   % 461:                 call BEAM_SPAWN %
000001de : ee8300e7;   % 461:  %
000001df : 01c12803;   % 463:                 lw a6,28(sp) %
000001e0 : 01812783;   % 464:                 lw a5,24(sp) %
000001e1 : 01412703;   % 465:                 lw a4,20(sp) %
000001e2 : 01012683;   % 466:                 lw a3,16(sp) %
000001e3 : 00c12603;   % 467:                 lw a2,12(sp) %
000001e4 : 00812583;   % 468:                 lw a1,8(sp) %
000001e5 : 00412503;   % 469:                 lw a0,4(sp) %
000001e6 : 00012083;   % 470:                 lw ra,0(sp) %
000001e7 : 02010113;   % 471:                 addi sp,sp,32 %
000001e8 : 03b00e93;   % 477:     li t4,0x3B      # J sanscode   %
000001e9 : fe0e8e93;   % 478:     addi t4,t4,-32  # adjusts it for comparision       %
000001ea : 01d21eb3;   % 479:     sll t4,tp,t4    # (1<<(0x23 - 64)) %
000001eb : 00defeb3;   % 480:     and t4,t4,a3    # will be !=0 if J is being pressed %
000001ec : 000e9463;   % 481:     bnez t4,INPUT.J # if pressing J %
000001ed : d8dff06f;   % 482:         j NO_INPUT  # There's no input %
000001ee : 00100813;   % 486:         li a6,1         # Sets a6 to 1 (a key was pressed) %
000001ef : 0fc10f17;   % 487:         la t5, PLYR_INFO_2    # Loads address to PLYR_INFO_2 %
000001f0 : 998f0f13;   % 487:  %
000001f1 : 001f4e83;   % 488:         lbu t4,1(t5)          # Loads missile cooldown %
000001f2 : 000e9863;   % 489:         bnez t4,SKIP_ENABLE_MISSILE  # If cooldown != 0, don't enable byte %
000001f3 : 000f4f83;   % 490:             lbu t6,0(t5)          # Loads missile enable byte %
000001f4 : 001fcf93;   % 491:             xori t6,t6,1          # Switches its value %
000001f5 : 01ff0023;   % 492:             sb t6,0(t5)           # and stores it back %
000001f6 : 001ece93;   % 494:             xori t4,t4,1      # Switches cooldown value %
000001f7 : 01df00a3;   % 495:             sb t4,1(t5)       # and stores it back %
000001f8 : d61ff06f;   % 496:         j NO_INPUT   # needs to go there for last check :/ %
000001f9 : 00008067;   % 500: 		ret	 %
000001fa : 00008317;   % 18:     call MUSIC.SETUP %
000001fb : 364300e7;   % 18:  %
000001fc : 00100313;   % 21:     li t1,1                # Menu 2 scene number %
000001fd : 01230a63;   % 22:     beq t1,s2,SETUP_MENU2  # If on game menu 2 %
000001fe : 00200313;   % 24:     li t1,2                # Game scene number %
000001ff : 01230a63;   % 25:     beq t1,s2,SETUP_GAME   # If on game %
00000200 : 00300313;   % 27:     li t1,3                     # Game over scene number %
00000201 : 01230463;   % 28:     beq t1,s2,SETUP_GAME_OVER   # If on game over %
00000202 : 911ff06f;   % 31:         j MENU2_LOOP %
00000203 : 9ddff06f;   % 35:         j GAME_OVER_LOOP_PREP %
00000204 : 0fc10297;   % 40:     la t0, NEXT_MAP   # Loads NEXT_MAP address %
00000205 : 92028293;   % 40:  %
00000206 : 00028523;   % 41:     sb zero,10(t0)    # Stores 0 on Render Next Map Door (in order to render current map's doors properly) %
00000207 : 0fc10297;   % 44:     la t0, MAP_INFO # Loads Map Info address %
00000208 : 90c28293;   % 44:  %
00000209 : 0002c303;   % 45:     lbu t1, 0 (t0)  # Loads byte related to map number %
0000020a : 0012c383;   % 46:     lbu t2, 1 (t0)  # Loads rendering byte (0 - don't render, 1 - render once, 2 - render twice,  %
0000020b : 0fc10e97;   % 49:     la t4, Doors    # Doors info address %
0000020c : c70e8e93;   % 49:  %
0000020d : 0fc10f17;   % 50:     la t5, Frames   # Frames info address %
0000020e : ca8f0f13;   % 50:  %
0000020f : 00100293;   % 52:     li t0, 1  %
00000210 : 00629463;   % 53:     bne t0, t1, SKIP_MAP1_SETUP  %
00000211 : 0ac0006f;   % 54:     j MAP1_SETUP %
00000212 : 00200293;   % 57:         li t0, 2  %
00000213 : 00629463;   % 58:         bne t0, t1, SKIP_MAP2_SETUP  %
00000214 : 1cc0006f;   % 59:         j MAP2_SETUP %
00000215 : 00300293;   % 62:         li t0, 3  %
00000216 : 00629463;   % 63:         bne t0, t1, SKIP_MAP3_SETUP  %
00000217 : 2fc0006f;   % 64:         j MAP3_SETUP %
00000218 : 00400293;   % 67:         li t0, 4 %
00000219 : 00629463;   % 68:         bne t0, t1, SKIP_MAP4_SETUP  %
0000021a : 41c0006f;   % 69:         j MAP4_SETUP %
0000021b : 00500293;   % 72:         li t0, 5  %
0000021c : 00629463;   % 73:         bne t0, t1, SKIP_MAP5_SETUP  %
0000021d : 5440006f;   % 74:         j MAP5_SETUP %
0000021e : 00600293;   % 77:         li t0, 6 %
0000021f : 00629463;   % 78:         bne t0, t1, SKIP_MAP6_SETUP  %
00000220 : 6640006f;   % 79:         j MAP6_SETUP %
00000221 : 00700293;   % 82:             li t0, 7  %
00000222 : 00629463;   % 83:             bne t0, t1, SKIP_MAP7_SETUP  %
00000223 : 77c0006f;   % 84:             j MAP7_SETUP %
00000224 : 00700513;   % 87:         li a0, 7 %
00000225 : 00000593;   % 88:         li a1, 0 %
00000226 : 00000613;   % 89:         li a2, 0 %
00000227 : 14000693;   % 90:         li a3, 320 %
00000228 : 0f000713;   % 91:         li a4, 240 %
00000229 : 00000793;   % 92:         li a5, 0 %
0000022a : 00000813;   % 93:         li a6, 0	 %
0000022b : 00001317;   % 95:         call RENDER_COLOR %
0000022c : 10c300e7;   % 95:  %
0000022d : 00700513;   % 97:         li a0, 7 %
0000022e : 00000593;   % 98:         li a1, 0 %
0000022f : 00000613;   % 99:         li a2, 0 %
00000230 : 14000693;   % 100:         li a3, 320 %
00000231 : 0f000713;   % 101:         li a4, 240 %
00000232 : 00100793;   % 102:         li a5, 1 %
00000233 : 00000813;   % 103:         li a6, 0 %
00000234 : 00001317;   % 104:         call RENDER_COLOR %
00000235 : 0e8300e7;   % 104:  %
00000236 : 00001537;   % 106: 	    li a0, 3000 %
00000237 : bb850513;   % 106:  %
00000238 : 02000893;   % 107: 	    li a7,32 %
00000239 : 00000073;   % 108: 	    ecall %
0000023a : 00a00893;   % 109: 	    li a7, 10 %
0000023b : 00000073;   % 110:         ecall	    					 %
0000023c : 0fc10297;   % 113:         la t0, Doors1   # Doors address %
0000023d : bb428293;   % 113:  %
0000023e : 005ea023;   % 114:         sw t0,0(t4)     # Stores Doors1 address on Doors address %
0000023f : 0fc10297;   % 116:         la t0, Frames1  # Frames address %
00000240 : be428293;   % 116:  %
00000241 : 005f2023;   % 117:         sw t0,0(t5)     # Stores Frames1 address on Doors address %
00000242 : 0fc10297;   % 119:         la t0,Zoomers   # Zoomers address %
00000243 : 94028293;   % 119:  %
00000244 : 0fc10317;   % 120:         la t1,Zoomers1  # Loads Zoomers1 address for Map 1 %
00000245 : 94030313;   % 120:  %
00000246 : 0062a023;   % 121:         sw t1,0(t0)     # and stores it %
00000247 : 0fc10297;   % 123:         la t0,Rippers   # Rippers address %
00000248 : aec28293;   % 123:  %
00000249 : 0002a023;   % 124:         sw zero,0(t0)   # Stores 0 to it (no rippers) %
0000024a : 0fc10297;   % 126:         la t0,Blocks    # Blocks address %
0000024b : 8f028293;   % 126:  %
0000024c : 0002a023;   % 127:         sw zero,0(t0)   # Stores 0 to it (no breakable blocks) %
0000024d : 0fc13517;   % 129:         la a0, Map1 	# Map Address      %
0000024e : 20050513;   % 129:  %
0000024f : 0fc0f297;   % 130:         la t0, CURRENT_MAP # Loads CURRENT_MAP address %
00000250 : 7e828293;   % 130:  %
00000251 : 00a2a023;   % 131:         sw a0, 0(t0)    # Stores Map1 address on CURRENT_MAP %
00000252 : 0062c583;   % 133:         lbu a1, 6(t0)   # Loads current X on Map (starting X on Matrix (top left)) %
00000253 : 0072c603;   % 134:         lbu a2, 7(t0)   # Loads current Y on Map (starting Y on Matrix (top left))	 %
00000254 : 0082c683;   % 135:         lbu a3, 8(t0)   # Loads current X offset on Map %
00000255 : 0092c703;   % 136:         lbu a4, 9(t0)   # Loads current Y offset on Map	 %
00000256 : 00400313;   % 138:         li t1, 4 %
00000257 : 06639263;   % 139:         bne t2, t1 CONTINUE_MAP1_SETUP %
00000258 : 00200393;   % 141:             li t2, 2 %
00000259 : 007282a3;   % 142:             sb t2, 5 (t0)  # Stores new rendering byte (2 - render twice)  %
0000025a : 01700593;   % 145:             li a1, 23 %
0000025b : 00b28323;   % 146:             sb a1, 6(t0)   # Stores new X on Map (starting X on Matrix (top left)) %
0000025c : 00000613;   % 147:             li a2, 0 %
0000025d : 00c283a3;   % 148:             sb a2, 7(t0)   # Stores new Y on Map (starting Y on Matrix (top left))	 %
0000025e : 00800693;   % 149:             li a3, 8 %
0000025f : 00d28423;   % 150:             sb a3, 8(t0)   # Stores new X offset on Map %
00000260 : 00000713;   % 151:             li a4, 0 %
00000261 : 00e284a3;   % 152:             sb a4, 9(t0)   # Stores new Y offset on Map	 %
00000262 : 0fc0f297;   % 155:             la t0, PLYR_POS %
00000263 : 7b628293;   % 155:  %
00000264 : 09800313;   % 156:             li t1, 152 %
00000265 : 00629023;   % 157:             sh t1, 0(t0)   # Stores new player's X related to the screen %
00000266 : 0a000313;   % 158:             li t1, 160 %
00000267 : 00628223;   % 159:             sb t1, 4(t0)   # Stores new player's Y related to the screen %
00000268 : 00000313;   % 161:             li t1, 0     %
00000269 : 00628323;   % 162:             sb t1, 6(t0)   # Stores new player's X offset %
0000026a : 00000313;   % 163:             li t1, 0 %
0000026b : 006283a3;   % 164:             sb t1, 7(t0)   # Stores new player's Y offset %
0000026c : 02100313;   % 166:             li t1, 33 %
0000026d : 00628423;   % 167:             sb t1, 8(t0)   # Stores new player's X related to the matrix %
0000026e : 00a00313;   % 168:             li t1, 10 %
0000026f : 00628523;   % 169:             sb t1, 10(t0)  # Stores new player's Y related to the matrix %
00000270 : 00000793;   % 172:         li a5, 0		# Frame = 0 %
00000271 : 01400813;   % 173:         li a6, 20	# Screen Width = 20 %
00000272 : 00f00893;   % 174:         li a7, 15	# Screen Height = 15 %
00000273 : 00000e13;   % 175:         li t3, 0		# Starting X for rendering (top left, related to Matrix) %
00000274 : 00000393;   % 176:         li t2, 0		# Starting Y for rendering (top left, related to Matrix) %
00000275 : 00000213;   % 177:         li tp, 0        # Map won't be dislocated %
00000276 : 00002317;   % 179:         call RENDER_MAP %
00000277 : 828300e7;   % 179:  %
00000278 : 0fc0f297;   % 181:         la t0, CURRENT_MAP # Loads CURRENT_MAP address %
00000279 : 74428293;   % 181:  %
0000027a : 0062c583;   % 182:         lbu a1, 6(t0)   # Loads current X on Map (starting X on Matrix (top left)) %
0000027b : 0072c603;   % 183:         lbu a2, 7(t0)   # Loads current Y on Map (starting Y on Matrix (top left))	 %
0000027c : 0082c683;   % 184:         lbu a3, 8(t0)   # Loads current X offset on Map %
0000027d : 0092c703;   % 185:         lbu a4, 9(t0)   # Loads current Y offset on Map %
0000027e : 00100793;   % 186:         li a5, 1		# Frame = 0 %
0000027f : 01400813;   % 187:         li a6, 20	# Screen Width = 20 %
00000280 : 00f00893;   % 188:         li a7, 15	# Screen Height = 15 %
00000281 : 00000e13;   % 189:         li t3, 0		# Starting X for rendering (top left, related to Matrix) %
00000282 : 00000393;   % 190:         li t2, 0		# Starting Y for rendering (top left, related to Matrix) %
00000283 : 00000213;   % 191:         li tp, 0        # Map won't be dislocated %
00000284 : 00001317;   % 193:         call RENDER_MAP %
00000285 : 7f0300e7;   % 193:  %
00000286 : 7140006f;   % 195:         j END_SETUP %
00000287 : 0fc10297;   % 198:         la t0, Doors2   # Doors address %
00000288 : a8d28293;   % 198:  %
00000289 : 005ea023;   % 199:         sw t0,0(t4)     # Stores Doors2 address on Doors address %
0000028a : 0fc10297;   % 201:         la t0, Frames2  # Frames address %
0000028b : abf28293;   % 201:  %
0000028c : 005f2023;   % 202:         sw t0,0(t5)     # Stores Frames2 address on Doors address %
0000028d : 0fc10297;   % 204:         la t0,Zoomers   # Zoomers address %
0000028e : 81428293;   % 204:  %
0000028f : 0fc10317;   % 205:         la t1,Zoomers2  # Loads Zoomers2 address for Map 2 %
00000290 : 85d30313;   % 205:  %
00000291 : 0062a023;   % 206:         sw t1,0(t0)     # and stores it %
00000292 : 0fc10297;   % 208:         la t0,Rippers   # Rippers address %
00000293 : 9c028293;   % 208:  %
00000294 : 0fc10317;   % 209:         la t1,Rippers2  # Loads Rippers2 address for Map 2 %
00000295 : 9c030313;   % 209:  %
00000296 : 0062a023;   % 210:         sw t1,0(t0)     # and stores it %
00000297 : 0fc0f297;   % 212:         la t0,Blocks    # Blocks address %
00000298 : 7bc28293;   % 212:  %
00000299 : 0fc0f317;   % 213:         la t1,Blocks2   # Loads Blocks2 address for Map 2 %
0000029a : 7bc30313;   % 213:  %
0000029b : 0062a023;   % 214:         sw t1,0(t0)     # and stores it %
0000029c : 0fc13517;   % 216:         la a0, Map2 	# Map Address      %
0000029d : 44b50513;   % 216:  %
0000029e : 0fc0f297;   % 217:         la t0, CURRENT_MAP # Loads CURRENT_MAP address %
0000029f : 6ac28293;   % 217:  %
000002a0 : 00a2a023;   % 218:         sw a0, 0(t0)    # Stores Map2 address on CURRENT_MAP %
000002a1 : 0062c583;   % 220:         lbu a1, 6(t0)   # Loads current X on Map (starting X on Matrix (top left)) %
000002a2 : 0072c603;   % 221:         lbu a2, 7(t0)   # Loads current Y on Map (starting Y on Matrix (top left))	 %
000002a3 : 0082c683;   % 222:         lbu a3, 8(t0)   # Loads current X offset on Map %
000002a4 : 0092c703;   % 223:         lbu a4, 9(t0)   # Loads current Y offset on Map		 %
000002a5 : 00400313;   % 225:         li t1, 4 %
000002a6 : 06639263;   % 226:         bne t2, t1 CONTINUE_MAP2_SETUP %
000002a7 : 00200393;   % 228:             li t2, 2 %
000002a8 : 007282a3;   % 229:             sb t2, 5 (t0)  # Stores new rendering byte (2 - render twice)  %
000002a9 : 00000593;   % 232:             li a1, 0 %
000002aa : 00b28323;   % 233:             sb a1, 6(t0)   # Stores new X on Map (starting X on Matrix (top left)) %
000002ab : 00000613;   % 234:             li a2, 0 %
000002ac : 00c283a3;   % 235:             sb a2, 7(t0)   # Stores new Y on Map (starting Y on Matrix (top left))	 %
000002ad : 00000693;   % 236:             li a3, 0 %
000002ae : 00d28423;   % 237:             sb a3, 8(t0)   # Stores new X offset on Map %
000002af : 00000713;   % 238:             li a4, 0 %
000002b0 : 00e284a3;   % 239:             sb a4, 9(t0)   # Stores new Y offset on Map	 %
000002b1 : 0fc0f297;   % 242:             la t0, PLYR_POS %
000002b2 : 67a28293;   % 242:  %
000002b3 : 02000313;   % 243:             li t1, 32 %
000002b4 : 00629023;   % 244:             sh t1, 0(t0)   # Stores new player's X related to the screen %
000002b5 : 06000313;   % 245:             li t1, 96 %
000002b6 : 00628223;   % 246:             sb t1, 4(t0)   # Stores new player's Y related to the screen %
000002b7 : 00000313;   % 248:             li t1, 0     %
000002b8 : 00628323;   % 249:             sb t1, 6(t0)   # Stores new player's X offset %
000002b9 : 00000313;   % 250:             li t1, 0 %
000002ba : 006283a3;   % 251:             sb t1, 7(t0)   # Stores new player's Y offset %
000002bb : 00200313;   % 253:             li t1, 2 %
000002bc : 00628423;   % 254:             sb t1, 8(t0)   # Stores new player's X related to the matrix %
000002bd : 00600313;   % 255:             li t1, 6 %
000002be : 00628523;   % 256:             sb t1, 10(t0)  # Stores new player's Y related to the matrix %
000002bf : 00000793;   % 259:         li a5, 0		# Frame = 0 %
000002c0 : 01400813;   % 260:         li a6, 20	# Screen Width = 20 %
000002c1 : 00f00893;   % 261:         li a7, 15	# Screen Height = 15 %
000002c2 : 00000e13;   % 262:         li t3, 0		# Starting X for rendering (top left, related to Matrix) %
000002c3 : 00000393;   % 263:         li t2, 0		# Starting Y for rendering (top left, related to Matrix) %
000002c4 : 00000213;   % 264:         li tp, 0        # Map won't be dislocated %
000002c5 : 00001317;   % 266:         call RENDER_MAP %
000002c6 : 6ec300e7;   % 266:  %
000002c7 : 0fc0f297;   % 268:         la t0, CURRENT_MAP # Loads CURRENT_MAP address %
000002c8 : 60828293;   % 268:  %
000002c9 : 0062c583;   % 269:         lbu a1, 6(t0)   # Loads current X on Map (starting X on Matrix (top left)) %
000002ca : 0072c603;   % 270:         lbu a2, 7(t0)   # Loads current Y on Map (starting Y on Matrix (top left))	 %
000002cb : 0082c683;   % 271:         lbu a3, 8(t0)   # Loads current X offset on Map %
000002cc : 0092c703;   % 272:         lbu a4, 9(t0)   # Loads current Y offset on Map	 %
000002cd : 00100793;   % 273:         li a5, 1		# Frame = 1 %
000002ce : 01400813;   % 274:         li a6, 20	# Screen Width = 20 %
000002cf : 00f00893;   % 275:         li a7, 15	# Screen Height = 15 %
000002d0 : 00000e13;   % 276:         li t3, 0		# Starting X for rendering (top left, related to Matrix) %
000002d1 : 00000393;   % 277:         li t2, 0		# Starting Y for rendering (top left, related to Matrix) %
000002d2 : 00000213;   % 278:         li tp, 0        # Map won't be dislocated %
000002d3 : 00001317;   % 279:         call RENDER_MAP %
000002d4 : 6b4300e7;   % 279:  %
000002d5 : 5d80006f;   % 281:         j END_SETUP %
000002d6 : 0fc10297;   % 284:         la t0, Doors3   # Doors address %
000002d7 : 95e28293;   % 284:  %
000002d8 : 005ea023;   % 285:         sw t0,0(t4)     # Stores Doors3 address on Doors address %
000002d9 : 0fc10297;   % 287:         la t0, Frames3  # Frames address %
000002da : 99628293;   % 287:  %
000002db : 005f2023;   % 288:         sw t0,0(t5)     # Stores Frames3 address on Doors address %
000002dc : 0fc0f297;   % 290:         la t0,Zoomers   # Zoomers address %
000002dd : 6d828293;   % 290:  %
000002de : 0fc0f317;   % 291:         la t1,Zoomers3  # Loads Zoomers3 address for Map 3 %
000002df : 78e30313;   % 291:  %
000002e0 : 0062a023;   % 292:         sw t1,0(t0)     # and stores it %
000002e1 : 0fc10297;   % 294:         la t0,Rippers   # Rippers address %
000002e2 : 88428293;   % 294:  %
000002e3 : 0002a023;   % 295:         sw zero,0(t0)   # Stores 0 to it (no rippers) %
000002e4 : 0fc0f297;   % 297:         la t0,Blocks    # Blocks address %
000002e5 : 68828293;   % 297:  %
000002e6 : 0002a023;   % 298:         sw zero,0(t0)   # Stores 0 to it (no breakable blocks) %
000002e7 : 0fc13517;   % 300:         la a0, Map3 	# Map Address      %
000002e8 : 6a650513;   % 300:  %
000002e9 : 0fc0f297;   % 301:         la t0, CURRENT_MAP # Loads CURRENT_MAP address %
000002ea : 58028293;   % 301:  %
000002eb : 00a2a023;   % 302:         sw a0, 0(t0)    # Stores Map3 address on CURRENT_MAP %
000002ec : 0062c583;   % 304:         lbu a1, 6(t0)   # Loads current X on Map (starting X on Matrix (top left)) %
000002ed : 0072c603;   % 305:         lbu a2, 7(t0)   # Loads current Y on Map (starting Y on Matrix (top left))	 %
000002ee : 0082c683;   % 306:         lbu a3, 8(t0)   # Loads current X offset on Map %
000002ef : 0092c703;   % 307:         lbu a4, 9(t0)   # Loads current Y offset on Map		 %
000002f0 : 00400313;   % 309:         li t1, 4 %
000002f1 : 06639263;   % 310:         bne t2, t1 CONTINUE_MAP3_SETUP %
000002f2 : 00200393;   % 312:             li t2, 2 %
000002f3 : 007282a3;   % 313:             sb t2, 5 (t0)  # Stores new rendering byte (2 - render twice)  %
000002f4 : 00000593;   % 316:             li a1, 0 %
000002f5 : 00b28323;   % 317:             sb a1, 6(t0)   # Stores new X on Map (starting X on Matrix (top left)) %
000002f6 : 00000613;   % 318:             li a2, 0 %
000002f7 : 00c283a3;   % 319:             sb a2, 7(t0)   # Stores new Y on Map (starting Y on Matrix (top left))	 %
000002f8 : 00000693;   % 320:             li a3, 0 %
000002f9 : 00d28423;   % 321:             sb a3, 8(t0)   # Stores new X offset on Map %
000002fa : 00000713;   % 322:             li a4, 0 %
000002fb : 00e284a3;   % 323:             sb a4, 9(t0)   # Stores new Y offset on Map	 %
000002fc : 0fc0f297;   % 326:             la t0, PLYR_POS %
000002fd : 54e28293;   % 326:  %
000002fe : 02000313;   % 327:             li t1, 32 %
000002ff : 00629023;   % 328:             sh t1, 0(t0)   # Stores new player's X related to the screen %
00000300 : 06000313;   % 329:             li t1, 96 %
00000301 : 00628223;   % 330:             sb t1, 4(t0)   # Stores new player's Y related to the screen %
00000302 : 00000313;   % 332:             li t1, 0     %
00000303 : 00628323;   % 333:             sb t1, 6(t0)   # Stores new player's X offset %
00000304 : 00000313;   % 334:             li t1, 0 %
00000305 : 006283a3;   % 335:             sb t1, 7(t0)   # Stores new player's Y offset %
00000306 : 00200313;   % 337:             li t1, 2 %
00000307 : 00628423;   % 338:             sb t1, 8(t0)   # Stores new player's X related to the matrix %
00000308 : 00600313;   % 339:             li t1, 6 %
00000309 : 00628523;   % 340:             sb t1, 10(t0)  # Stores new player's Y related to the matrix %
0000030a : 00000793;   % 343:         li a5, 0		# Frame = 0 %
0000030b : 01400813;   % 344:         li a6, 20	# Screen Width = 20 %
0000030c : 00f00893;   % 345:         li a7, 15	# Screen Height = 15 %
0000030d : 00000e13;   % 346:         li t3, 0		# Starting X for rendering (top left, related to Matrix) %
0000030e : 00000393;   % 347:         li t2, 0		# Starting Y for rendering (top left, related to Matrix) %
0000030f : 00000213;   % 348:         li tp, 0        # Map won't be dislocated %
00000310 : 00001317;   % 350:         call RENDER_MAP %
00000311 : 5c0300e7;   % 350:  %
00000312 : 0fc0f297;   % 352:         la t0, CURRENT_MAP # Loads CURRENT_MAP address %
00000313 : 4dc28293;   % 352:  %
00000314 : 0062c583;   % 353:         lbu a1, 6(t0)   # Loads current X on Map (starting X on Matrix (top left)) %
00000315 : 0072c603;   % 354:         lbu a2, 7(t0)   # Loads current Y on Map (starting Y on Matrix (top left))	 %
00000316 : 0082c683;   % 355:         lbu a3, 8(t0)   # Loads current X offset on Map %
00000317 : 0092c703;   % 356:         lbu a4, 9(t0)   # Loads current Y offset on Map	 %
00000318 : 00100793;   % 357:         li a5, 1		# Frame = 1 %
00000319 : 01400813;   % 358:         li a6, 20	# Screen Width = 20 %
0000031a : 00f00893;   % 359:         li a7, 15	# Screen Height = 15 %
0000031b : 00000e13;   % 360:         li t3, 0		# Starting X for rendering (top left, related to Matrix) %
0000031c : 00000393;   % 361:         li t2, 0		# Starting Y for rendering (top left, related to Matrix) %
0000031d : 00000213;   % 362:         li tp, 0        # Map won't be dislocated %
0000031e : 00001317;   % 363:         call RENDER_MAP %
0000031f : 588300e7;   % 363:  %
00000320 : 4ac0006f;   % 365:         j END_SETUP %
00000321 : 0fc10297;   % 369:         la t0, Doors4   # Doors address %
00000322 : 83b28293;   % 369:  %
00000323 : 005ea023;   % 370:         sw t0,0(t4)     # Stores Doors4 address on Doors address %
00000324 : 0fc10297;   % 372:         la t0, Frames4  # Frames address %
00000325 : 87728293;   % 372:  %
00000326 : 005f2023;   % 373:         sw t0,0(t5)     # Stores Frames4 address on Doors address %
00000327 : 0fc0f297;   % 375:         la t0,Zoomers   # Zoomers address %
00000328 : 5ac28293;   % 375:  %
00000329 : 0fc0f317;   % 376:         la t1,Zoomers4  # Loads Zoomers4 address for Map 4 %
0000032a : 6ab30313;   % 376:  %
0000032b : 0062a023;   % 377:         sw t1,0(t0)     # and stores it %
0000032c : 0fc0f297;   % 379:         la t0,Rippers   # Rippers address %
0000032d : 75828293;   % 379:  %
0000032e : 0fc0f317;   % 380:         la t1,Rippers4  # Loads Rippers4 address for Map 4 %
0000032f : 77c30313;   % 380:  %
00000330 : 0062a023;   % 381:         sw t1,0(t0)     # and stores it %
00000331 : 0fc0f297;   % 383:         la t0,Blocks    # Blocks address %
00000332 : 55428293;   % 383:  %
00000333 : 0002a023;   % 384:         sw zero,0(t0)   # Stores 0 to it (no breakable blocks) %
00000334 : 0fc14517;   % 386:         la a0, Map4 	# Map Address      %
00000335 : 8f950513;   % 386:  %
00000336 : 0fc0f297;   % 387:         la t0, CURRENT_MAP # Loads CURRENT_MAP address %
00000337 : 44c28293;   % 387:  %
00000338 : 00a2a023;   % 388:         sw a0, 0(t0)    # Stores Map4 address on CURRENT_MAP %
00000339 : 0062c583;   % 390:         lbu a1, 6(t0)   # Loads current X on Map (starting X on Matrix (top left)) %
0000033a : 0072c603;   % 391:         lbu a2, 7(t0)   # Loads current Y on Map (starting Y on Matrix (top left))	 %
0000033b : 0082c683;   % 392:         lbu a3, 8(t0)   # Loads current X offset on Map %
0000033c : 0092c703;   % 393:         lbu a4, 9(t0)   # Loads current Y offset on Map		 %
0000033d : 00400313;   % 395:         li t1, 4 %
0000033e : 06639263;   % 396:         bne t2, t1 CONTINUE_MAP4_SETUP %
0000033f : 00200393;   % 398:             li t2, 2 %
00000340 : 007282a3;   % 399:             sb t2, 5 (t0)  # Stores new rendering byte (2 - render twice)  %
00000341 : 00000593;   % 402:             li a1, 0 %
00000342 : 00b28323;   % 403:             sb a1, 6(t0)   # Stores new X on Map (starting X on Matrix (top left)) %
00000343 : 01e00613;   % 404:             li a2, 30 %
00000344 : 00c283a3;   % 405:             sb a2, 7(t0)   # Stores new Y on Map (starting Y on Matrix (top left))	 %
00000345 : 00000693;   % 406:             li a3, 0 %
00000346 : 00d28423;   % 407:             sb a3, 8(t0)   # Stores new X offset on Map %
00000347 : 00000713;   % 408:             li a4, 0 %
00000348 : 00e284a3;   % 409:             sb a4, 9(t0)   # Stores new Y offset on Map	 %
00000349 : 0fc0f297;   % 412:             la t0, PLYR_POS %
0000034a : 41a28293;   % 412:  %
0000034b : 02000313;   % 413:             li t1, 32 %
0000034c : 00629023;   % 414:             sh t1, 0(t0)   # Stores new player's X related to the screen %
0000034d : 06000313;   % 415:             li t1, 96 %
0000034e : 00628223;   % 416:             sb t1, 4(t0)   # Stores new player's Y related to the screen %
0000034f : 00000313;   % 418:             li t1, 0     %
00000350 : 00628323;   % 419:             sb t1, 6(t0)   # Stores new player's X offset %
00000351 : 00000313;   % 420:             li t1, 0 %
00000352 : 006283a3;   % 421:             sb t1, 7(t0)   # Stores new player's Y offset %
00000353 : 00200313;   % 423:             li t1, 2 %
00000354 : 00628423;   % 424:             sb t1, 8(t0)   # Stores new player's X related to the matrix %
00000355 : 02400313;   % 425:             li t1, 36 %
00000356 : 00628523;   % 426:             sb t1, 10(t0)  # Stores new player's Y related to the matrix %
00000357 : 00000793;   % 429:         li a5, 0		# Frame = 0 %
00000358 : 01400813;   % 430:         li a6, 20	# Screen Width = 20 %
00000359 : 00f00893;   % 431:         li a7, 15	# Screen Height = 15 %
0000035a : 00000e13;   % 432:         li t3, 0		# Starting X for rendering (top left, related to Matrix) %
0000035b : 00000393;   % 433:         li t2, 0		# Starting Y for rendering (top left, related to Matrix) %
0000035c : 00000213;   % 434:         li tp, 0        # Map won't be dislocated %
0000035d : 00001317;   % 436:         call RENDER_MAP %
0000035e : 48c300e7;   % 436:  %
0000035f : 0fc0f297;   % 438:         la t0, CURRENT_MAP # Loads CURRENT_MAP address %
00000360 : 3a828293;   % 438:  %
00000361 : 0062c583;   % 439:         lbu a1, 6(t0)   # Loads current X on Map (starting X on Matrix (top left)) %
00000362 : 0072c603;   % 440:         lbu a2, 7(t0)   # Loads current Y on Map (starting Y on Matrix (top left))	 %
00000363 : 0082c683;   % 441:         lbu a3, 8(t0)   # Loads current X offset on Map %
00000364 : 0092c703;   % 442:         lbu a4, 9(t0)   # Loads current Y offset on Map	 %
00000365 : 00100793;   % 443:         li a5, 1		# Frame = 1 %
00000366 : 01400813;   % 444:         li a6, 20	# Screen Width = 20 %
00000367 : 00f00893;   % 445:         li a7, 15	# Screen Height = 15 %
00000368 : 00000e13;   % 446:         li t3, 0		# Starting X for rendering (top left, related to Matrix) %
00000369 : 00000393;   % 447:         li t2, 0		# Starting Y for rendering (top left, related to Matrix) %
0000036a : 00000213;   % 448:         li tp, 0        # Map won't be dislocated %
0000036b : 00001317;   % 449:         call RENDER_MAP %
0000036c : 454300e7;   % 449:  %
0000036d : 3780006f;   % 451:         j END_SETUP %
0000036e : 0fc0f297;   % 454:         la t0, Doors5   # Doors address %
0000036f : 71028293;   % 454:  %
00000370 : 005ea023;   % 455:         sw t0,0(t4)     # Stores Doors5 address on Doors address %
00000371 : 0fc0f297;   % 457:         la t0, Frames5  # Frames address %
00000372 : 75028293;   % 457:  %
00000373 : 005f2023;   % 458:         sw t0,0(t5)     # Stores Frames5 address on Doors address %
00000374 : 0fc0f297;   % 460:         la t0,Zoomers   # Zoomers address %
00000375 : 47828293;   % 460:  %
00000376 : 0fc0f317;   % 461:         la t1,Zoomers5  # Loads Zoomers5 address for Map 5 %
00000377 : 5fc30313;   % 461:  %
00000378 : 0062a023;   % 462:         sw t1,0(t0)     # and stores it %
00000379 : 0fc0f297;   % 464:         la t0,Rippers   # Rippers address %
0000037a : 62428293;   % 464:  %
0000037b : 0002a023;   % 465:         sw zero,0(t0)   # Stores 0 to it (no rippers) %
0000037c : 0fc0f297;   % 467:         la t0,Blocks    # Blocks address %
0000037d : 42828293;   % 467:  %
0000037e : 0002a023;   % 468:         sw zero,0(t0)   # Stores 0 to it (no breakable blocks) %
0000037f : 0fc14517;   % 470:         la a0, Map5 	# Map Address      %
00000380 : b5450513;   % 470:  %
00000381 : 0fc0f297;   % 471:         la t0, CURRENT_MAP # Loads CURRENT_MAP address %
00000382 : 32028293;   % 471:  %
00000383 : 00a2a023;   % 472:         sw a0, 0(t0)    # Stores Map5 address on CURRENT_MAP %
00000384 : 0062c583;   % 474:         lbu a1, 6(t0)   # Loads current X on Map (starting X on Matrix (top left)) %
00000385 : 0072c603;   % 475:         lbu a2, 7(t0)   # Loads current Y on Map (starting Y on Matrix (top left))	 %
00000386 : 0082c683;   % 476:         lbu a3, 8(t0)   # Loads current X offset on Map %
00000387 : 0092c703;   % 477:         lbu a4, 9(t0)   # Loads current Y offset on Map		 %
00000388 : 00400313;   % 479:         li t1, 4 %
00000389 : 06639263;   % 480:         bne t2, t1 CONTINUE_MAP5_SETUP %
0000038a : 00200393;   % 482:             li t2, 2 %
0000038b : 007282a3;   % 483:             sb t2, 5 (t0)  # Stores new rendering byte (2 - render twice)  %
0000038c : 01400593;   % 486:             li a1, 20 %
0000038d : 00b28323;   % 487:             sb a1, 6(t0)   # Stores new X on Map (starting X on Matrix (top left)) %
0000038e : 00000613;   % 488:             li a2, 0 %
0000038f : 00c283a3;   % 489:             sb a2, 7(t0)   # Stores new Y on Map (starting Y on Matrix (top left))	 %
00000390 : 00000693;   % 490:             li a3, 0 %
00000391 : 00d28423;   % 491:             sb a3, 8(t0)   # Stores new X offset on Map %
00000392 : 00000713;   % 492:             li a4, 0 %
00000393 : 00e284a3;   % 493:             sb a4, 9(t0)   # Stores new Y offset on Map	 %
00000394 : 0fc0f297;   % 496:             la t0, PLYR_POS %
00000395 : 2ee28293;   % 496:  %
00000396 : 11000313;   % 497:             li t1, 272 %
00000397 : 00629023;   % 498:             sh t1, 0(t0)   # Stores new player's X related to the screen %
00000398 : 06000313;   % 499:             li t1, 96 %
00000399 : 00628223;   % 500:             sb t1, 4(t0)   # Stores new player's Y related to the screen %
0000039a : 00000313;   % 502:             li t1, 0     %
0000039b : 00628323;   % 503:             sb t1, 6(t0)   # Stores new player's X offset %
0000039c : 00000313;   % 504:             li t1, 0 %
0000039d : 006283a3;   % 505:             sb t1, 7(t0)   # Stores new player's Y offset %
0000039e : 02500313;   % 507:             li t1, 37 %
0000039f : 00628423;   % 508:             sb t1, 8(t0)   # Stores new player's X related to the matrix %
000003a0 : 00600313;   % 509:             li t1, 6 %
000003a1 : 00628523;   % 510:             sb t1, 10(t0)  # Stores new player's Y related to the matrix %
000003a2 : 00000793;   % 513:         li a5, 0		# Frame = 0 %
000003a3 : 01400813;   % 514:         li a6, 20	# Screen Width = 20 %
000003a4 : 00f00893;   % 515:         li a7, 15	# Screen Height = 15 %
000003a5 : 00000e13;   % 516:         li t3, 0		# Starting X for rendering (top left, related to Matrix) %
000003a6 : 00000393;   % 517:         li t2, 0		# Starting Y for rendering (top left, related to Matrix) %
000003a7 : 00000213;   % 518:         li tp, 0        # Map won't be dislocated %
000003a8 : 00001317;   % 520:         call RENDER_MAP %
000003a9 : 360300e7;   % 520:  %
000003aa : 0fc0f297;   % 522:         la t0, CURRENT_MAP # Loads CURRENT_MAP address %
000003ab : 27c28293;   % 522:  %
000003ac : 0062c583;   % 523:         lbu a1, 6(t0)   # Loads current X on Map (starting X on Matrix (top left)) %
000003ad : 0072c603;   % 524:         lbu a2, 7(t0)   # Loads current Y on Map (starting Y on Matrix (top left))	 %
000003ae : 0082c683;   % 525:         lbu a3, 8(t0)   # Loads current X offset on Map %
000003af : 0092c703;   % 526:         lbu a4, 9(t0)   # Loads current Y offset on Map	 %
000003b0 : 00100793;   % 527:         li a5, 1		# Frame = 1 %
000003b1 : 01400813;   % 528:         li a6, 20	# Screen Width = 20 %
000003b2 : 00f00893;   % 529:         li a7, 15	# Screen Height = 15 %
000003b3 : 00000e13;   % 530:         li t3, 0		# Starting X for rendering (top left, related to Matrix) %
000003b4 : 00000393;   % 531:         li t2, 0		# Starting Y for rendering (top left, related to Matrix) %
000003b5 : 00000213;   % 532:         li tp, 0        # Map won't be dislocated %
000003b6 : 00001317;   % 533:         call RENDER_MAP %
000003b7 : 328300e7;   % 533:  %
000003b8 : 24c0006f;   % 535:         j END_SETUP %
000003b9 : 0fc0f297;   % 538:         la t0, Doors6   # Doors address %
000003ba : 5ed28293;   % 538:  %
000003bb : 005ea023;   % 539:         sw t0,0(t4)     # Stores Doors6 address on Doors address %
000003bc : 0fc0f297;   % 541:         la t0, Frames6  # Frames address %
000003bd : 63128293;   % 541:  %
000003be : 005f2023;   % 542:         sw t0,0(t5)     # Stores Frames6 address on Doors address %
000003bf : 0fc0f297;   % 544:         la t0,Zoomers   # Zoomers address %
000003c0 : 34c28293;   % 544:  %
000003c1 : 0002a023;   % 545:         sw zero,0(t0)   # Stores 0 to it (no zoomers) %
000003c2 : 0fc0f297;   % 547:         la t0,Rippers   # Rippers address %
000003c3 : 50028293;   % 547:  %
000003c4 : 0002a023;   % 548:         sw zero,0(t0)   # Stores 0 to it (no rippers) %
000003c5 : 0fc0f297;   % 550:         la t0,Blocks    # Blocks address %
000003c6 : 30428293;   % 550:  %
000003c7 : 0002a023;   % 551:         sw zero,0(t0)   # Stores 0 to it (no breakable blocks) %
000003c8 : 0fc14517;   % 553:         la a0, Map6 	# Map Address      %
000003c9 : c8b50513;   % 553:  %
000003ca : 0fc0f297;   % 554:         la t0, CURRENT_MAP # Loads CURRENT_MAP address %
000003cb : 1fc28293;   % 554:  %
000003cc : 00a2a023;   % 555:         sw a0, 0(t0)    # Stores Map6 address on CURRENT_MAP %
000003cd : 0062c583;   % 557:         lbu a1, 6(t0)   # Loads current X on Map (starting X on Matrix (top left)) %
000003ce : 0072c603;   % 558:         lbu a2, 7(t0)   # Loads current Y on Map (starting Y on Matrix (top left))	 %
000003cf : 0082c683;   % 559:         lbu a3, 8(t0)   # Loads current X offset on Map %
000003d0 : 0092c703;   % 560:         lbu a4, 9(t0)   # Loads current Y offset on Map		 %
000003d1 : 00400313;   % 562:         li t1, 4 %
000003d2 : 06639263;   % 563:         bne t2, t1 CONTINUE_MAP6_SETUP %
000003d3 : 00200393;   % 565:             li t2, 2 %
000003d4 : 007282a3;   % 566:             sb t2, 5 (t0)  # Stores new rendering byte (2 - render twice)  %
000003d5 : 00000593;   % 569:             li a1, 0 %
000003d6 : 00b28323;   % 570:             sb a1, 6(t0)   # Stores new X on Map (starting X on Matrix (top left)) %
000003d7 : 00000613;   % 571:             li a2, 0 %
000003d8 : 00c283a3;   % 572:             sb a2, 7(t0)   # Stores new Y on Map (starting Y on Matrix (top left))	 %
000003d9 : 00000693;   % 573:             li a3, 0 %
000003da : 00d28423;   % 574:             sb a3, 8(t0)   # Stores new X offset on Map %
000003db : 00000713;   % 575:             li a4, 0 %
000003dc : 00e284a3;   % 576:             sb a4, 9(t0)   # Stores new Y offset on Map	 %
000003dd : 0fc0f297;   % 579:             la t0, PLYR_POS %
000003de : 1ca28293;   % 579:  %
000003df : 11000313;   % 580:             li t1, 272 %
000003e0 : 00629023;   % 581:             sh t1, 0(t0)   # Stores new player's X related to the screen %
000003e1 : 06000313;   % 582:             li t1, 96 %
000003e2 : 00628223;   % 583:             sb t1, 4(t0)   # Stores new player's Y related to the screen %
000003e3 : 00000313;   % 585:             li t1, 0     %
000003e4 : 00628323;   % 586:             sb t1, 6(t0)   # Stores new player's X offset %
000003e5 : 00000313;   % 587:             li t1, 0 %
000003e6 : 006283a3;   % 588:             sb t1, 7(t0)   # Stores new player's Y offset %
000003e7 : 01100313;   % 590:             li t1, 17 %
000003e8 : 00628423;   % 591:             sb t1, 8(t0)   # Stores new player's X related to the matrix %
000003e9 : 00600313;   % 592:             li t1, 6 %
000003ea : 00628523;   % 593:             sb t1, 10(t0)  # Stores new player's Y related to the matrix %
000003eb : 00000793;   % 596:         li a5, 0		# Frame = 0 %
000003ec : 01400813;   % 597:         li a6, 20	# Screen Width = 20 %
000003ed : 00f00893;   % 598:         li a7, 15	# Screen Height = 15 %
000003ee : 00000e13;   % 599:         li t3, 0		# Starting X for rendering (top left, related to Matrix) %
000003ef : 00000393;   % 600:         li t2, 0		# Starting Y for rendering (top left, related to Matrix) %
000003f0 : 00000213;   % 601:         li tp, 0        # Map won't be dislocated %
000003f1 : 00001317;   % 602:         call RENDER_MAP %
000003f2 : 23c300e7;   % 602:  %
000003f3 : 0fc0f297;   % 604:         la t0, CURRENT_MAP # Loads CURRENT_MAP address %
000003f4 : 15828293;   % 604:  %
000003f5 : 0062c583;   % 605:         lbu a1, 6(t0)   # Loads current X on Map (starting X on Matrix (top left)) %
000003f6 : 0072c603;   % 606:         lbu a2, 7(t0)   # Loads current Y on Map (starting Y on Matrix (top left))	 %
000003f7 : 0082c683;   % 607:         lbu a3, 8(t0)   # Loads current X offset on Map %
000003f8 : 0092c703;   % 608:         lbu a4, 9(t0)   # Loads current Y offset on Map	 %
000003f9 : 00100793;   % 609:         li a5, 1		# Frame = 1 %
000003fa : 01400813;   % 610:         li a6, 20	# Screen Width = 20 %
000003fb : 00f00893;   % 611:         li a7, 15	# Screen Height = 15 %
000003fc : 00000e13;   % 612:         li t3, 0		# Starting X for rendering (top left, related to Matrix) %
000003fd : 00000393;   % 613:         li t2, 0		# Starting Y for rendering (top left, related to Matrix) %
000003fe : 00000213;   % 614:         li tp, 0        # Map won't be dislocated  %
000003ff : 00001317;   % 615:         call RENDER_MAP %
00000400 : 204300e7;   % 615:  %
00000401 : 1280006f;   % 617:         j END_SETUP %
00000402 : 0fc0f297;   % 620:         la t0, Doors7   # Doors address %
00000403 : 4ce28293;   % 620:  %
00000404 : 005ea023;   % 621:         sw t0,0(t4)     # Stores Doors1 address on Doors address %
00000405 : 0fc0f297;   % 623:         la t0, Frames7  # Frames address %
00000406 : 51428293;   % 623:  %
00000407 : 005f2023;   % 624:         sw t0,0(t5)     # Stores Frames7 address on Doors address %
00000408 : 0fc0f297;   % 626:         la t0,Zoomers   # Zoomers address %
00000409 : 22828293;   % 626:  %
0000040a : 0002a023;   % 627:         sw zero,0(t0)   # Stores 0 to it (no zoomers) %
0000040b : 0fc0f297;   % 629:         la t0,Rippers   # Rippers address %
0000040c : 3dc28293;   % 629:  %
0000040d : 0002a023;   % 630:         sw zero,0(t0)   # Stores 0 to it (no rippers) %
0000040e : 0fc0f297;   % 632:         la t0,Blocks    # Blocks address %
0000040f : 1e028293;   % 632:  %
00000410 : 0002a023;   % 633:         sw zero,0(t0)   # Stores 0 to it (no breakable blocks) %
00000411 : 0fc14517;   % 635:         la a0, Map7 	# Map Address      %
00000412 : c9650513;   % 635:  %
00000413 : 0fc0f297;   % 636:         la t0, CURRENT_MAP # Loads CURRENT_MAP address %
00000414 : 0d828293;   % 636:  %
00000415 : 00a2a023;   % 637:         sw a0, 0(t0)    # Stores Map7 address on CURRENT_MAP %
00000416 : 0062c583;   % 639:         lbu a1, 6(t0)   # Loads current X on Map (starting X on Matrix (top left)) %
00000417 : 0072c603;   % 640:         lbu a2, 7(t0)   # Loads current Y on Map (starting Y on Matrix (top left))	 %
00000418 : 0082c683;   % 641:         lbu a3, 8(t0)   # Loads current X offset on Map %
00000419 : 0092c703;   % 642:         lbu a4, 9(t0)   # Loads current Y offset on Map		 %
0000041a : 00400313;   % 644:         li t1, 4 %
0000041b : 06639263;   % 645:         bne t2, t1 CONTINUE_MAP7_SETUP %
0000041c : 00200393;   % 647:             li t2, 2 %
0000041d : 007282a3;   % 648:             sb t2, 5 (t0)  # Stores new rendering byte (2 - render twice)  %
0000041e : 00000593;   % 651:             li a1, 0 %
0000041f : 00b28323;   % 652:             sb a1, 6(t0)   # Stores new X on Map (starting X on Matrix (top left)) %
00000420 : 00000613;   % 653:             li a2, 0 %
00000421 : 00c283a3;   % 654:             sb a2, 7(t0)   # Stores new Y on Map (starting Y on Matrix (top left))	 %
00000422 : 00000693;   % 655:             li a3, 0 %
00000423 : 00d28423;   % 656:             sb a3, 8(t0)   # Stores new X offset on Map %
00000424 : 00000713;   % 657:             li a4, 0 %
00000425 : 00e284a3;   % 658:             sb a4, 9(t0)   # Stores new Y offset on Map	 %
00000426 : 0fc0f297;   % 661:             la t0, PLYR_POS %
00000427 : 0a628293;   % 661:  %
00000428 : 11000313;   % 662:             li t1, 272 %
00000429 : 00629023;   % 663:             sh t1, 0(t0)   # Stores new player's X related to the screen %
0000042a : 06000313;   % 664:             li t1, 96 %
0000042b : 00628223;   % 665:             sb t1, 4(t0)   # Stores new player's Y related to the screen %
0000042c : 00000313;   % 667:             li t1, 0     %
0000042d : 00628323;   % 668:             sb t1, 6(t0)   # Stores new player's X offset %
0000042e : 00000313;   % 669:             li t1, 0 %
0000042f : 006283a3;   % 670:             sb t1, 7(t0)   # Stores new player's Y offset %
00000430 : 01100313;   % 672:             li t1, 17 %
00000431 : 00628423;   % 673:             sb t1, 8(t0)   # Stores new player's X related to the matrix %
00000432 : 00600313;   % 674:             li t1, 6 %
00000433 : 00628523;   % 675:             sb t1, 10(t0)  # Stores new player's Y related to the matrix %
00000434 : 00000793;   % 678:         li a5, 0		# Frame = 0 %
00000435 : 01400813;   % 679:         li a6, 20	# Screen Width = 20 %
00000436 : 00f00893;   % 680:         li a7, 15	# Screen Height = 15 %
00000437 : 00000e13;   % 681:         li t3, 0		# Starting X for rendering (top left, related to Matrix) %
00000438 : 00000393;   % 682:         li t2, 0		# Starting Y for rendering (top left, related to Matrix) %
00000439 : 00000213;   % 683:         li tp, 0        # Map won't be dislocated %
0000043a : 00001317;   % 684:         call RENDER_MAP %
0000043b : 118300e7;   % 684:  %
0000043c : 0fc0f297;   % 686:         la t0, CURRENT_MAP # Loads CURRENT_MAP address %
0000043d : 03428293;   % 686:  %
0000043e : 0062c583;   % 687:         lbu a1, 6(t0)   # Loads current X on Map (starting X on Matrix (top left)) %
0000043f : 0072c603;   % 688:         lbu a2, 7(t0)   # Loads current Y on Map (starting Y on Matrix (top left))	 %
00000440 : 0082c683;   % 689:         lbu a3, 8(t0)   # Loads current X offset on Map %
00000441 : 0092c703;   % 690:         lbu a4, 9(t0)   # Loads current Y offset on Map	 %
00000442 : 00100793;   % 691:         li a5, 1		# Frame = 1 %
00000443 : 01400813;   % 692:         li a6, 20	# Screen Width = 20 %
00000444 : 00f00893;   % 693:         li a7, 15	# Screen Height = 15 %
00000445 : 00000e13;   % 694:         li t3, 0		# Starting X for rendering (top left, related to Matrix) %
00000446 : 00000393;   % 695:         li t2, 0		# Starting Y for rendering (top left, related to Matrix) %
00000447 : 00000213;   % 696:         li tp, 0        # Map won't be dislocated %
00000448 : 00001317;   % 697:         call RENDER_MAP %
00000449 : 0e0300e7;   % 697:  %
0000044a : 0040006f;   % 699:         j END_SETUP %
0000044b : 0fc0f297;   % 702:     la t0, CURRENT_MAP   # Loads CURRENT_MAP address %
0000044c : ff828293;   % 702:  %
0000044d : 0052c303;   % 703:     lbu t1,5(t0)         # Loads rendering byte      %
0000044e : 00300393;   % 704:     li t2, 3             # Loads 3 (switch map through door) to be compared with %
0000044f : 00731463;   % 705:     bne t1,t2, END_SETUP_NORMAL # If rendering byte != 3, return to game loop %
00000450 : 5b80506f;   % 706:         j LEAVE_DOOR_ANIMATION_PREP # Otherwise, finish map switch %
00000451 : 00099e63;   % 710:         bnez s3,SKIP_ABILITY_RESET   # If clicking on continue, habilities will be kept %
00000452 : 0fc0f297;   % 711:             la t0,PLYR_INFO %
00000453 : ff428293;   % 711:  %
00000454 : 000280a3;   % 712:             sb zero,1(t0)     # Resets ability information %
00000455 : 0fc0f297;   % 714:             la t0, ITEM_CAPSULE_INFO %
00000456 : 01828293;   % 714:  %
00000457 : 00028023;   % 715:             sb zero,0(t0)              # Restores capsule %
00000458 : 00100993;   % 717:             li s3, 1       # If player's info was already reset %
00000459 : 0fc0f297;   % 718:             la t0,MOVE_X %
0000045a : fec28293;   % 718:  %
0000045b : 0002a023;   % 719:             sw zero,0(t0)  # Resets MOVE_X, MOVE_Y,JUMP byte and Player input byte %
0000045c : 0fc0f297;   % 721:             la t0,PLYR_INFO_2 %
0000045d : fe428293;   % 721:  %
0000045e : 0002a023;   % 722:             sw zero,0(t0) %
0000045f : 0002a223;   % 723:             sw zero,4(t0) %
00000460 : 00003317;   % 725:             call RESET_ENEMIES %
00000461 : 914300e7;   % 725:  %
00000462 : 00000317;   % 727:             call RESET_BLOCKS %
00000463 : 130300e7;   % 727:  %
00000464 : eb9fe06f;   % 729:     j GAME_LOOP %
00000465 : 0fc0f297;   % 748:     la t0, Doors # Loads Doors address %
00000466 : 30828293;   % 748:  %
00000467 : 0fc0f217;   % 749: 	la tp, CURRENT_MAP # Loads CURRENT_MAP address %
00000468 : f8820213;   % 749:  %
00000469 : 0002a503;   % 750: 	lw a0,0(t0)   # Gets current map's doors address %
0000046a : 00054283;   % 751: 	lbu t0,0(a0)  # Loads number of doors in this map %
0000046b : 00150513;   % 752: 	addi a0,a0,1  # Goes to next byte (where doors from current map start) %
0000046c : 00000313;   % 753: 	li t1,0       # Counter for doors %
0000046d : 00000593;   % 754:     li a1,0       # Default: won't render doors unless there's a change of state %
0000046e : 00350383;   % 757:         lb t2,3(a0)  # Loads C (counter) parameter %
0000046f : 0003c663;   % 758:         blt t2,zero,UPDATE_DOORS_LOOP_COUNT_UP    # If counter is negative, iterate up %
00000470 : 02704663;   % 759:         bgt t2,zero,UPDATE_DOORS_LOOP_COUNT_DOWN  # If counter is positive, iterate down %
00000471 : 0640006f;   % 760:             j NEXT_IN_UPDATE_DOORS_LOOP # Otherwise, counter is 0 and should stay this way %
00000472 : 00138393;   % 763:             addi t2,t2,1  # C++ %
00000473 : 007501a3;   % 764:             sb t2,3(a0)   # and stores updated C on door's counter byte %
00000474 : 04039c63;   % 765:             bnez t2,NEXT_IN_UPDATE_DOORS_LOOP # If C != 0, go update next door %
00000475 : 00200393;   % 767:                 li t2,2         # Loads 2 (open) %
00000476 : 00750123;   % 768:                 sb t2,2(a0)     # and stores it on door's state byte %
00000477 : 03c00393;   % 769:                 li t2,60 # Gets new counter (related to open door) %
00000478 : 007501a3;   % 770:                 sb t2,3(a0)     # and stores it on door's counter byte %
00000479 : 00100593;   % 771:                 li a1,1         # Since status was updated, should render doors   %
0000047a : 0400006f;   % 772:                 j NEXT_IN_UPDATE_DOORS_LOOP   %
0000047b : fff38393;   % 776:             addi t2,t2,-1  # C-- %
0000047c : 007501a3;   % 777:             sb t2,3(a0)    # and stores updated C on door's counter byte %
0000047d : 02039a63;   % 778:             bnez t2,NEXT_IN_UPDATE_DOORS_LOOP # If C != 0, go update next door %
0000047e : 00254383;   % 780:                 lbu t2,2(a0)  # Loads door's state byte %
0000047f : fff38393;   % 781:                 addi t2,t2,-1 # If state is 2 -> 1; if state is 1 -> 0 %
00000480 : 00038e63;   % 782:                 beqz t2, UPDATE_DOORS_LOOP_CHANGE_OPENING  # If t2 = 0, state was 1 (opening) %
00000481 : 00100393;   % 785:                     li t2,1             # Loads 1 (opening) %
00000482 : 00750123;   % 786:                     sb t2,2(a0)         # and stores it on door's state byte %
00000483 : 00400393;   % 787:                     li t2,4  # Gets new counter (related to opening door -- positive, in order to close) %
00000484 : 007501a3;   % 788:                     sb t2,3(a0)         # and stores it on door's counter byte %
00000485 : 00100593;   % 789:                     li a1,1             # Since status was updated, should render doors   %
00000486 : 0100006f;   % 790:                     j NEXT_IN_UPDATE_DOORS_LOOP  %
00000487 : 00000393;   % 793:                     li t2,0         # Loads 0 (closed) %
00000488 : 00750123;   % 794:                     sb t2,2(a0)     # and stores it on door's state byte %
00000489 : 00100593;   % 796:                     li a1,1         # Since status was updated, should render doors   %
0000048a : 00450513;   % 800:             addi a0,a0,4 # Going to the next door's address                                   %
0000048b : 00130313;   % 801:             addi t1,t1,1 # Iterating counter by 1                                    %
0000048c : 00535463;   % 802:             bge t1,t0, END_UPDATE_DOORS_LOOP # If all of the map's doors were checked, end loop                                   %
0000048d : f85ff06f;   % 803:             j UPDATE_DOORS_LOOP # otherwise, go back to the loop's beginning                      %
0000048e : 00058c63;   % 807:         beqz a1,END_UPDATE_DOORS # If a1 is 0, doors shouldn't be rendered again %
0000048f : 00300293;   % 808:         li t0, 3        # To be compared with rendering byte (3 - switch map through doors) %
00000490 : 00524303;   % 809:         lbu t1, 5(tp)   # Loads CURRENT_MAP's rendering byte on t1 %
00000491 : 00628663;   % 810:         beq t0,t1,END_UPDATE_DOORS # If rendering byte is 3, don't change it %
00000492 : 00200393;   % 812:         li t2, 2       # t2 = 2 (map will be rendered again) %
00000493 : 007202a3;   % 813:         sb t2, 5(tp)   # Stores t3 on CURRENT_MAP's rendering byte %
00000494 : 00008067;   % 817:         ret  %
00000495 : 0fc0f297;   % 840:     la t0, Doors # Loads Doors address %
00000496 : 24828293;   % 840:  %
00000497 : 0fc0f217;   % 841: 	la tp, CURRENT_MAP # Loads CURRENT_MAP address %
00000498 : ec820213;   % 841:  %
00000499 : 0002a603;   % 842: 	lw a2,0(t0)   # Gets current map's doors address %
0000049a : 00064283;   % 843: 	lbu t0,0(a2)  # Loads number of doors in this map %
0000049b : 00160613;   % 844: 	addi a2,a2,1  # Goes to next byte (where doors from current map start) %
0000049c : 00159593;   % 845:     slli a1,a1,1  # Multiplies a1 by 2  %
0000049d : 00000313;   % 847:     li t1,0       # Counter for doors      %
0000049e : 00100393;   % 850:         li t2,1       # Loads 1 (opening/closing) %
0000049f : 00760123;   % 851:         sb t2,2(a2)   # and stores it on door's state byte     %
000004a0 : 00050a63;   % 852:         beqz a0, CHANGE_DOORS_STATE_LOOP_OPEN_DOORS # If a0 = 0, open doors %
000004a1 : 00400393;   % 854:             li t2,4  # Gets new counter (related to closing door -- positive, in order to close) %
000004a2 : 40b383b3;   % 855:             sub t2,t2,a1        # t2 = 4 if a1 is 0, otherwise, t2 = 2 %
000004a3 : 007601a3;   % 856:             sb t2,3(a2)         # Stores C on door's counter byte %
000004a4 : 00c0006f;   % 857:             j NEXT_IN_CHANGE_DOORS_STATE_LOOP  %
000004a5 : ffe00393;   % 860:             li t2,-2  # Gets new counter (related to opening door -- negative, in order to open) %
000004a6 : 007601a3;   % 861:             sb t2,3(a2)         # and stores it on door's counter byte %
000004a7 : 00460613;   % 864:         addi a2,a2,4 # Going to the next door's address                                   %
000004a8 : 00130313;   % 865:         addi t1,t1,1 # Iterating counter by 1                                    %
000004a9 : 00535463;   % 866:         bge t1,t0, END_CHANGE_DOORS_STATE_LOOP # If all of the map's doors were checked, end loop                                   %
000004aa : fd1ff06f;   % 867:         j CHANGE_DOORS_STATE_LOOP # otherwise, go back to the loop's beginning                      %
000004ab : 00200393;   % 870:         li t2, 2       # t2 = 2 (map will be rendered again) %
000004ac : 007202a3;   % 871:         sb t2, 5(tp)   # Stores t3 on CURRENT_MAP's rendering byte %
000004ad : 00008067;   % 872:         ret  # End of procedure, return     %
000004ae : 0fc0f517;   % 876:     la a0, Blocks2 %
000004af : f6850513;   % 876:  %
000004b0 : 00254283;   % 877:     lbu t0,2(a0) %
000004b1 : 00354303;   % 878:     lbu t1,3(a0) %
000004b2 : 00450513;   % 879:     addi a0,a0,4 %
000004b3 : 026285b3;   % 880:     mul a1,t0,t1   # Total number of iterations %
000004b4 : 00000293;   % 881:     li t0,0 %
000004b5 : 00050303;   % 883:         lb t1,0(a0) %
000004b6 : fff00393;   % 884:         li t2,-1 %
000004b7 : 00730463;   % 885:         beq t1,t2,NEXT_IN_RESET_BLOCKS_LOOP %
000004b8 : 00050023;   % 886:             sb zero,0(a0) %
000004b9 : 00150513;   % 888:             addi a0,a0,1 %
000004ba : 00128293;   % 889:             addi t0,t0,1 %
000004bb : feb2c4e3;   % 890:             blt t0,a1,RESET_BLOCKS_LOOP %
000004bc : 00008067;   % 891:                 ret         %
000004bd : 0fc0f517;   % 22:     la a0, MOVE_X	       # Loads address of MOVE_X %
000004be : e5c50513;   % 22:  %
000004bf : 00050283;   % 23:     lb t0, 0(a0)	       # Loads information from MOVE_X %
000004c0 : 0fc0f597;   % 24:     la a1, CURRENT_MAP     # Loads CURRENT_MAP's address %
000004c1 : e2458593;   % 24:  %
000004c2 : 0005a603;   % 25:     lw a2, 0(a1) 	       # a2 has the current map's address  %
000004c3 : 0fc0f697;   % 26:     la a3, PLYR_POS        # Loads Player Position %
000004c4 : e3268693;   % 26:  %
000004c5 : 0fc0f317;   % 28:     la t1, PLYR_INFO_2	   # Loads address of the second part of PLYR_INFO %
000004c6 : e4030313;   % 28:  %
000004c7 : 00430303;   % 29:     lb t1,4(t1)            # Gets the DAMAGE_MOVE_X value %
000004c8 : 00029e63;   % 31:     bnez t0, MOVE_PLAYER_X # If there's X movement, go to MOVE_PLAYER_X %
000004c9 : 00031c63;   % 32:     bnez t1, MOVE_PLAYER_X # Otherwise, if there's damaging X movement, go to MOVE_PLAYER_X %
000004ca : 00069303;   % 35:     lh t1, 0(a3)  # Loads Player's X related to screen %
000004cb : 00669123;   % 36:     sh t1, 2(a3)  # Stores Player's X related to screen on old X %
000004cc : 0086c303;   % 37:     lbu t1, 8(a3) # Loads Player's X related to screen %
000004cd : 006684a3;   % 38:     sb t1, 9(a3)  # Stores Player's X related to screen on old X %
000004ce : 19c0006f;   % 39:     j CHECK_MOVE_Y         # Otherwise, go check Y movement %
000004cf : 00229713;   % 42:         slli a4, t0, 2  # Multiplies the value stored on MOVE_X by 4. a4 will store the movement of the player (+/- 4 pixels) %
000004d0 : 00030463;   % 44:         beqz t1,CONTINUE_MOVE_PLAYER_X  # If there's no damage knockback %
000004d1 : 00600733;   % 46:             mv a4,t1    # Adds value from DAMAGE_MOVE_X (if any) %
000004d2 : 00d6c303;   % 49:         lbu t1, 13(a3)  # Loads Player's Facing direction (0 = Right, 1 = Left) %
000004d3 : 006282b3;   % 50:         add t0,t0,t1    # Adds Facing direction with MOVE_X (if the result t0 = -1 or 2, the direction has changed) %
000004d4 : 00200393;   % 51:         li t2,2         # t1 = 2 %
000004d5 : 0072f463;   % 52:         bgeu t0,t2,CHANGE_X_DIRECTION # If t0 = -1 or 2, the direction chas changed %
000004d6 : 0100006f;   % 53:             j KEEP_X_DIRECTION  %
000004d7 : 00134313;   % 57:             xori t1,t1,1   # Inverts direction (0 -> 1; 1 -> 0) %
000004d8 : 006686a3;   % 58:             sb t1, 13(a3)  # Loads Player's Facing direction (0 = Right, 1 = Left) %
000004d9 : 1700006f;   % 59:             j CHECK_MOVE_Y %
000004da : 00668803;   % 61:             lb a6, 6(a3)	# Loads Player's X offset %
000004db : 00e80833;   % 62:             add a6,a6,a4	# Adds the X Movement to the Player's Offset %
000004dc : 0086c883;   % 64:             lbu a7, 8(a3)	# Loads Player's X on Matrix %
000004dd : 011684a3;   % 65:             sb a7, 9(a3)	# Stores Player's X on Matrix on the Old X %
000004de : 00085663;   % 67:             bge a6,zero,SKIP_LEFT_X %
000004df : fff88893;   % 70:             addi a7, a7, -1		  # Player's X on matrix -= 1 (goes to the left) %
000004e0 : 01080813;   % 71:             addi a6,a6,16  # Offset gets corrected (relative to new X on matrix coordinate) %
000004e1 : 01000e13;   % 74:             li t3, 16 %
000004e2 : 01c84663;   % 75:             blt a6,t3, SKIP_RIGHT_X %
000004e3 : 00188893;   % 77:             addi a7,a7, 1	 # Player's X on matrix += 1 (goes to the right) %
000004e4 : 41c80833;   % 78:             sub a6,a6,t3	 # Offset gets corrected (relative to new X on matrix coordinate) %
000004e5 : fe010113;   % 82:             addi sp,sp,-32 %
000004e6 : 01112e23;   % 83:             sw a7,28(sp) %
000004e7 : 01012c23;   % 84:             sw a6,24(sp) %
000004e8 : 00e12a23;   % 85:             sw a4,20(sp) %
000004e9 : 00d12823;   % 86:             sw a3,16(sp) %
000004ea : 00c12623;   % 87:             sw a2,12(sp) %
000004eb : 00b12423;   % 88:             sw a1,8(sp) %
000004ec : 00a12223;   % 89:             sw a0,4(sp) %
000004ed : 00112023;   % 90:             sw ra,0(sp) %
000004ee : 00c005b3;   % 92:             mv a1,a2 # Moves current map's address to a1  %
000004ef : 00d00633;   % 93:             mv a2,a3 # Moves PLYR_POS to a2 %
000004f0 : 00005317;   % 94:             call CHECK_HORIZONTAL_COLLISION # Checking collision %
000004f1 : 7cc300e7;   % 94:  %
000004f2 : 00a002b3;   % 96:             mv t0,a0     # Moves result of collision check to t0  %
000004f3 : 01c12883;   % 99:             lw a7,28(sp) %
000004f4 : 01812803;   % 100:             lw a6,24(sp) %
000004f5 : 01412703;   % 101:             lw a4,20(sp) %
000004f6 : 01012683;   % 102:             lw a3,16(sp) %
000004f7 : 00c12603;   % 103:             lw a2,12(sp) %
000004f8 : 00812583;   % 104:             lw a1,8(sp) %
000004f9 : 00412503;   % 105:             lw a0,4(sp) %
000004fa : 00012083;   % 106:             lw ra,0(sp) %
000004fb : 02010113;   % 107:             addi sp,sp,32 %
000004fc : 00069383;   % 110:             lh t2, 0(a3)          # Loads Player's Current X %
000004fd : 00029e63;   % 111:             bnez t0, CAN_MOVE_X   # If a0 != 0, player can move (go to CAN_MOVE_X) %
000004fe : 00700f33;   % 113:                 mv t5,t2              # store player's current X (t2) in t5 %
000004ff : 0fc0f297;   % 114:                 la t0,PLYR_INPUT      # Loads PLYR_INPUT on t0 %
00000500 : d5728293;   % 114:  %
00000501 : 00200313;   % 115:                 li t1, 2              # Sets t1 to 2 (there's player input, but can't move) %
00000502 : 00628023;   % 116:                 sb t1, 0(t0)          # and stores it in PLYR_INPUT %
00000503 : 0300006f;   % 117:                 j Fixed_X_Map %
00000504 : 0fc0f297;   % 120:         la t0,PLYR_INPUT      # Loads PLYR_INPUT on t0 %
00000505 : d4328293;   % 120:  %
00000506 : 00100313;   % 121:         li t1, 1              # Sets t1 to 1 (there's player input, and can move) %
00000507 : 00628023;   % 122:         sb t1, 0(t0)          # and stores it in PLYR_INPUT %
00000508 : 01068323;   % 124:         sb a6, 6(a3)    # Stores new X offset %
00000509 : 01168423;   % 125:         sb a7, 8(a3)    # Stores new X coordinate on matrix %
0000050a : 00770f33;   % 127:         add t5, a4, t2  # t5 = Player's current X + Movement of Player on X axis %
0000050b : 00064283;   % 129:         lbu t0, 0(a2)   # loads first byte to check what type of map it is (0 - Fixed, 1 - Horizontal, 2 - Vertical) %
0000050c : 00100e13;   % 130:         li t3, 1        # Loads 1 and  %
0000050d : 005e1463;   % 131:         bne t3, t0, Fixed_X_Map # compares with the result %
0000050e : 0100006f;   % 132:         j Horizontal_Map %
0000050f : 00769123;   % 136:           sh t2,2(a3) # Stores original X on old X related to screen %
00000510 : 01e69023;   % 137:           sh t5,0(a3) # Stores new X on current X related to screen %
00000511 : 0900006f;   % 138:           j CHECK_MOVE_Y %
00000512 : 0065c283;   % 141:             lbu t0, 6(a1)    # Loads Map's X postition on Matrix %
00000513 : 0085c303;   % 142:             lbu t1, 8(a1)    # Loads Map's X offset %
00000514 : 07700e13;   % 144:             li t3, 119      # loads left_border = 120  %
00000515 : 01ee4863;   % 145:             blt t3, t5, NOT_LEFT_BORDER_PASS  # if new player position on screen doesn't pass the left border, go to NOT_LEFT_BORDER_PASS %
00000516 : 00628eb3;   % 148:             add t4,t0,t1     # Will be 0 if Map's X offset and X position are 0 %
00000517 : fe0e80e3;   % 149:           	beqz t4, Fixed_X_Map  # If on leftmost part of the map, map won't move %
00000518 : 01c0006f;   % 150:             j MOVE_SCREEN_X     # otherwise, move the map left %
00000519 : 0b800e13;   % 153:             li t3, 184 #loads right_border = 180  %
0000051a : fdee5ae3;   % 154:             bge t3,t5,Fixed_X_Map   # if new player position on screen doesn't pass the right border, go to Fixed_X_Map %
0000051b : 00164303;   % 155:             lbu t1, 1(a2)    # Loads Map matrix width %
0000051c : 01400e13;   % 156:             li t3, 20 # Loads Map screen width related to matrix %
0000051d : 41c30333;   % 157:             sub t1,t1,t3    # t1 = Map Matrix Width - Screen Matrix Width (t1 = Map's X when it's on rightmost part of the map) %
0000051e : fc6282e3;   % 158:             beq t0,t1, Fixed_X_Map  # If on rightmost part of the map, map won't move %
0000051f : 00200e13;   % 162:             li t3, 2       # t3 = 2 (map will be rendered again) %
00000520 : 01c582a3;   % 163:             sb t3, 5(a1)   # Stores t3 on CURRENT_MAP's rendering byte %
00000521 : 00769123;   % 164:             sh t2,2(a3)    # Stores player's original X on old X related to screen %
00000522 : 0065c383;   % 167:             lbu t2, 6(a1)  # Loads Map X postition on Matrix %
00000523 : 0085c803;   % 168:             lbu a6, 8(a1)  # Loads map's X offset %
00000524 : 00e80833;   % 170:             add a6,a6,a4  # Adds the X Movement to the map's Offset %
00000525 : 00000313;   % 172:             li t1,0  # Right now, the map's X won't be updated  %
00000526 : 00085e63;   % 173:             bge a6, zero, NO_X_OFFSET_NEGATIVE_CORRECTION  %
00000527 : 00038863;   % 175:                 beqz t2 LEFTMOST_PART_OF_MAP_RESET %
00000528 : fff00313;   % 177:                     li t1, -1 %
00000529 : 01080813;   % 178:                     addi a6,a6,16 # Corrects negative offset by adding 16 %
0000052a : 01c0006f;   % 179:                     j NO_X_OFFSET_CORRECTION %
0000052b : 00000813;   % 182:                     li a6,0 %
0000052c : 0140006f;   % 183:                     j NO_X_OFFSET_CORRECTION %
0000052d : 01000293;   % 187:                 li t0, 16 %
0000052e : 00584663;   % 188:                 blt a6,t0, NO_X_OFFSET_CORRECTION %
0000052f : 00100313;   % 189:                 li t1,1 %
00000530 : 40580833;   % 190:                 sub a6,a6,t0 # Corrects values that surpass 16 by subtracting 16 from them %
00000531 : 01058423;   % 193:                 sb a6, 8(a1)   # Stores Map new X offset that is equal to player's X offset %
00000532 : 006383b3;   % 194:                 add t2,t2,t1  # adds to the X -1, 0 or 1 (moves map horizontally) %
00000533 : 00758323;   % 195:                 sb t2, 6(a1)   # Stores Map X postition on Matrix %
00000534 : 0040006f;   % 196:                 j CHECK_MOVE_Y %
00000535 : 0fc0f517;   % 200:     la a0, MOVE_Y	       # Loads address of MOVE_Y %
00000536 : c7d50513;   % 200:  %
00000537 : 00050283;   % 201:     lb t0, 0(a0)	       # Loads information from MOVE_Y %
00000538 : 0fc0f597;   % 202:     la a1, CURRENT_MAP     # Loads CURRENT_MAP's address %
00000539 : c4458593;   % 202:  %
0000053a : 0005a603;   % 203:     lw a2, 0(a1) 	       # a2 has the current map's address  %
0000053b : 0fc0f697;   % 204:     la a3, PLYR_POS        # Loads Player Position address %
0000053c : c5268693;   % 204:  %
0000053d : 06029a63;   % 206:     bnez t0, MOVE_PLAYER_Y # If there's Y movement, go to MOVE_PLAYER_Y %
0000053e : 0046c303;   % 207:         lbu t1, 4(a3)  # Loads Player's Y related to screen %
0000053f : 006682a3;   % 208:         sb t1, 5(a3)  # Stores Player's Y related to screen on old Y %
00000540 : 00a6c303;   % 209:         lbu t1, 10(a3)  # Loads Player's Y related to screen %
00000541 : 006685a3;   % 210:         sb t1, 11(a3)  # Stores Player's Y related to screen on old Y %
00000542 : fec10113;   % 212:         addi sp,sp,-20 %
00000543 : 00d12823;   % 213:         sw a3,16(sp) %
00000544 : 00c12623;   % 214:         sw a2,12(sp) %
00000545 : 00b12423;   % 215:         sw a1,8(sp) %
00000546 : 00a12223;   % 216:         sw a0,4(sp) %
00000547 : 00112023;   % 217:         sw ra,0(sp) %
00000548 : 00c005b3;   % 219:         mv a1,a2 # Moves current map's address to a1  %
00000549 : 00d00633;   % 220:         mv a2,a3 # Moves PLYR_POS to a2 %
0000054a : 00005317;   % 221:         call CHECK_VERTICAL_COLLISION # Checking collision %
0000054b : 78c300e7;   % 221:  %
0000054c : 00a002b3;   % 222:         mv t0,a0     # Moves result of collision check to t0  %
0000054d : 01012683;   % 225:         lw a3,16(sp) %
0000054e : 00c12603;   % 226:         lw a2,12(sp) %
0000054f : 00812583;   % 227:         lw a1,8(sp) %
00000550 : 00412503;   % 228:         lw a0,4(sp) %
00000551 : 00012083;   % 229:         lw ra,0(sp) %
00000552 : 01410113;   % 230:         addi sp,sp,20 %
00000553 : 00028c63;   % 232:         beqz t0, HAS_GROUND    # If t0 (holds result of collision check) != 0 go to HAS_GROUND %
00000554 : 0fc0f517;   % 234:         la a0, MOVE_Y	   # Loads address of MOVE_Y %
00000555 : c0150513;   % 234:  %
00000556 : 00100293;   % 235:         li t0, 1           # Gets number correspondent to DOWN (1) %
00000557 : 00550023;   % 236:         sb t0, 0(a0)	   # and stores it %
00000558 : 0080006f;   % 239:         j MOVE_PLAYER_Y %
00000559 : 31c0006f;   % 242:       j END_PHYSICS %
0000055a : 00150383;   % 245:         lb t2, 1(a0)   # Loads JUMP information %
0000055b : 0002c463;   % 246:         blt t0,zero, MOVE_PLAYER_UP %
0000055c : 05c0006f;   % 247:         j ITERATE_JUMP %
0000055d : 0fc0f317;   % 250:             la t1, PLYR_INFO_2	       # Loads address of the second part of PLYR_INFO %
0000055e : be030313;   % 250:  %
0000055f : 00330303;   % 251:             lb t1,3(t1)                # Gets the taking damage byte %
00000560 : 00031c63;   % 252:             bnez t1,SKIP_INPUT_CHECK   # If taking damage, only do a small hop %
00000561 : 02000313;   % 253:             li t1, 32 # minimum height of jump required for the movement  %
00000562 : 0063c863;   % 254:             blt t2, t1, SKIP_INPUT_CHECK %
00000563 : 00254303;   % 255:             lbu t1, 2(a0)   # Loads PLYR_INPUT %
00000564 : 00031463;   % 256:             bnez t1, SKIP_INPUT_CHECK # t1 != 0 ? SKIP_INPUT_CHECK : SWITCH_DOWN %
00000565 : 0140006f;   % 257:             j SWITCH_DOWN %
00000566 : c0097353;   % 260:                 fcvt.w.s t1,fs2  %
00000567 : 00035663;   % 261:                 bge t1,zero, SWITCH_DOWN %
00000568 : 05000313;   % 262:                 li t1, 80 # maximum height of jump required for the movement  %
00000569 : 0263c463;   % 263:                 blt t2, t1, ITERATE_JUMP   #  %
0000056a : 0fc0f297;   % 266:                 la t0,PLYR_INPUT      # Loads PLYR_INPUT on t0 %
0000056b : bab28293;   % 266:  %
0000056c : 00100313;   % 267:                 li t1, 1              # Sets t1 to 1 (there's player input, and can move) %
0000056d : 00628023;   % 268:                 sb t1, 0(t0)          # and stores it in PLYR_INPUT  %
0000056e : 006500a3;   % 270:                 sb t1, 1(a0)          # reset jump information %
0000056f : 00650023;   % 271:                 sb t1,0(a0)           # Switches MOVE_Y to 1 (Down)     %
00000570 : 00200313;   % 273:                 li t1, 2 %
00000571 : d0037953;   % 274:                 fcvt.s.w fs2,t1     # Sets speed to zero        %
00000572 : 2b80006f;   % 275:                 j END_PHYSICS %
00000573 : 00897953;   % 278:             fadd.s fs2,fs2,fs0    # fs2 = Player's current Y speed + gravity factor        %
00000574 : c0097753;   % 279:             fcvt.w.s a4,fs2       # Sets a4 = floor(fs2) %
00000575 : 00800293;   % 281:             li t0,8             # Loads max speed (8, when falling) %
00000576 : 00574463;   % 282:             blt a4,t0, SKIP_MAX_SPEED   # If a4 < 8, skip this part %
00000577 : 00800713;   % 284:                 li a4,8 %
00000578 : 00e002b3;   % 288:                 mv t0,a4                # moves a4 to t0 %
00000579 : 0002d463;   % 289:                 bge t0,zero, SKIP_ABS   # if t0 >= 0, skip this %
0000057a : 405002b3;   % 290:                     sub t0,zero,t0      # otherwise, t0 will be its opposite  %
0000057b : 005383b3;   % 292:                     add t2,t2,t0        # t0 to t2 (JUMP factor) %
0000057c : 007500a3;   % 293:                     sb t2, 1(a0)        # and stores it %
0000057d : 0076c803;   % 295:         lbu a6, 7(a3)	# Loads Player's Y offset %
0000057e : 00e80833;   % 296:         add a6,a6,a4	# Adds the X Movement to the Player's Offset %
0000057f : 00a6c883;   % 298:         lbu a7, 10(a3)	# Loads Player's Y on Matrix %
00000580 : 011685a3;   % 299:         sb a7, 11(a3)	# Stores Plater's Y on Matrix on the Old Y %
00000581 : 00085663;   % 301:         bge a6,zero,SKIP_UP_Y %
00000582 : fff88893;   % 303:         addi a7, a7, -1		  # Player's Y on matrix -= 1 (goes to the left) %
00000583 : 01080813;   % 304:         addi a6,a6,16  # Offset gets corrected (relative to new X on matrix coordinate) %
00000584 : 01000e13;   % 307:             li t3, 16 %
00000585 : 01c84663;   % 308:             blt a6,t3, SKIP_DOWN_Y %
00000586 : 00188893;   % 310:             addi a7,a7, 1	 # Player's Y on matrix += 1 (goes to the right) %
00000587 : 41c80833;   % 311:             sub a6,a6,t3	 # Offset gets corrected (relative to new Y on matrix coordinate) %
00000588 : fe010113;   % 315:             addi sp,sp,-32 %
00000589 : 01112e23;   % 316:             sw a7,28(sp) %
0000058a : 01012c23;   % 317:             sw a6,24(sp) %
0000058b : 00e12a23;   % 318:             sw a4,20(sp) %
0000058c : 00d12823;   % 319:             sw a3,16(sp) %
0000058d : 00c12623;   % 320:             sw a2,12(sp) %
0000058e : 00b12423;   % 321:             sw a1,8(sp) %
0000058f : 00a12223;   % 322:             sw a0,4(sp) %
00000590 : 00112023;   % 323:             sw ra,0(sp) %
00000591 : 00c005b3;   % 325:             mv a1,a2 # Moves current map's address to a1  %
00000592 : 00d00633;   % 326:             mv a2,a3 # Moves PLYR_POS to a2 %
00000593 : 00e006b3;   % 327:             mv a3,a4 # Moves offset modifier to a3 %
00000594 : 00005317;   % 328:             call CHECK_VERTICAL_COLLISION # Checking collision %
00000595 : 664300e7;   % 328:  %
00000596 : 00a002b3;   % 329:             mv t0,a0     # Moves result of collision check to t0  %
00000597 : 01c12883;   % 332:             lw a7,28(sp) %
00000598 : 01812803;   % 333:             lw a6,24(sp) %
00000599 : 01412703;   % 334:             lw a4,20(sp) %
0000059a : 01012683;   % 335:             lw a3,16(sp) %
0000059b : 00c12603;   % 336:             lw a2,12(sp) %
0000059c : 00812583;   % 337:             lw a1,8(sp) %
0000059d : 00412503;   % 338:             lw a0,4(sp) %
0000059e : 00012083;   % 339:             lw ra,0(sp) %
0000059f : 02010113;   % 340:             addi sp,sp,32 %
000005a0 : 0046c383;   % 343:             lbu t2, 4(a3)    # Loads Player's Current Y %
000005a1 : 0e029663;   % 344:             bnez t0, CAN_MOVE_Y # t0 != 0 ? CAN_MOVE_Y : Fixed_Y_Map %
000005a2 : 00700f33;   % 345:                 mv t5,t2 # storing PLYRS_current Y in t5 %
000005a3 : d0007953;   % 346:                 fcvt.s.w fs2,zero # Resets player's jump speed %
000005a4 : 00050283;   % 348:                 lb t0, 0(a0) # Gets MOVE_Y info %
000005a5 : 0602c863;   % 349:                 blt t0,zero, STOP_JUMP # If t0 <= -1 (aka, player would start jumping), reset %
000005a6 : 0fc0f317;   % 351:                     la t1, PLYR_INFO_2	   # Loads address of the second part of PLYR_INFO %
000005a7 : abc30313;   % 351:  %
000005a8 : 00030223;   % 352:                     sb zero,4(t1)          # If player hit the ground, stop damage knockback %
000005a9 : 0076c283;   % 354:                     lbu t0, 7(a3)  # Loads player's Y offset %
000005aa : 04028463;   % 355:                     beqz t0,SKIP_ADJUST_Y_DOWN # If player is on ground and Y offset = 0, don't reajust position %
000005ab : 01168523;   % 356:                         sb a7, 10(a3)   # Stores new Y coordinate on matrix %
000005ac : 00064283;   % 357:                         lbu t0, 0(a2)   # Loads first byte to check what type of map it is (0 - Fixed, 1 - Horizontal, 2 - Vertical) %
000005ad : 00200e13;   % 358:                         li t3, 2        # Loads 2 and  %
000005ae : 025e1c63;   % 359:                         bne t3, t0, SKIP_ADJUST_Y_DOWN # compares with the result %
000005af : 0095c283;   % 361:                             lbu t0, 9(a1)    # Loads map's Y offset %
000005b0 : 000584a3;   % 362:                             sb zero, 9(a1)   # Sets map's Y offset to 0 %
000005b1 : 00264e83;   % 363:                             lbu t4, 2(a2)    # Loads Map matrix height %
000005b2 : 00f00e13;   % 364:                             li t3, 15 # Loads Map screen height related to matrix %
000005b3 : 41ce8e33;   % 365:                             sub t3,t4,t3     # t4 = Map Matrix Height - Screen Matrix Height (t4 = Map's Y when it's on lowermost part of the map) %
000005b4 : 0075ce83;   % 366:                             lbu t4, 7(a1)    # Loads Map Y postition on Matrix %
000005b5 : 01cede63;   % 367:                             bge t4,t3,SKIP_ADJUST_Y_DOWN  # If on lowermost Y, don't update map's Y it %
000005b6 : 005e82b3;   % 368:                             add t0,t4,t0   # t4 will only be 4 if offset was 0 and Y is zero %
000005b7 : 00028a63;   % 369:                             beqz t0,SKIP_ADJUST_Y_DOWN    # If on topmost Y, don't update map's Y it %
000005b8 : 001e8e93;   % 370:                             addi t4,t4,1     # adds 1 to it %
000005b9 : 01d583a3;   % 371:                             sb t4, 7(a1)     # and stores it %
000005ba : 00200e13;   % 372:                             li t3, 2         # t3 = 2 (map will be rendered again) %
000005bb : 01c582a3;   % 373:                             sb t3, 5(a1)     # Stores t3 on CURRENT_MAP's rendering byte %
000005bc : 000683a3;   % 375:                     sb zero, 7(a3) # Sets player's Y offset to 0 %
000005bd : 00050023;   % 376:                     sb zero, 0(a0) # MOVE_Y = 0 %
000005be : fff00313;   % 377:                     li t1,-1 %
000005bf : 006500a3;   % 378:                     sb t1, 1(a0) # JUMP = 0 %
000005c0 : 09c0006f;   % 379:                     j Fixed_Y_Map %
000005c1 : 0fc0f317;   % 383:                     la t1, PLYR_INFO_2	   # Loads address of the second part of PLYR_INFO %
000005c2 : a5030313;   % 383:  %
000005c3 : 00634283;   % 384:                     lbu t0,6(t1)          # If player hit the ground, there's no damage knockback anymore %
000005c4 : ff628293;   % 385:                     addi t0,t0,-10 %
000005c5 : 00530323;   % 386:                     sb t0,6(t1)          # If player hit the ground, there's no damage knockback anymore %
000005c6 : 00800293;   % 389:                     li t0,8 %
000005c7 : 00154303;   % 390:                     lbu t1,1(a0) # Gets JUMP info %
000005c8 : 0062a2b3;   % 391:                     slt t0,t0,t1 # t1 > 8 ? t0 = 1 : t0 = 0 %
000005c9 : 00550023;   % 392:                     sb t0, 0(a0) # MOVE_Y = t0  %
000005ca : 000500a3;   % 393:                     sb zero,1(a0) # reseting jump byte %
000005cb : 0076c283;   % 395:                     lbu t0, 7(a3)  # Loads player's Y offset %
000005cc : 02028e63;   % 396:                     beqz t0,SKIP_ADJUST_Y_UP # If player has Y offset = 0, don't reajust position %
000005cd : 000683a3;   % 398:                         sb zero, 7(a3) # Sets player's Y offset to 0 %
000005ce : 00064283;   % 399:                         lbu t0, 0(a2)   # Loads first byte to check what type of map it is (0 - Fixed, 1 - Horizontal, 2 - Vertical) %
000005cf : 00200e13;   % 400:                         li t3, 2        # Loads 2 and  %
000005d0 : 025e1663;   % 401:                         bne t3, t0, SKIP_ADJUST_Y_UP # compares with the result %
000005d1 : 000584a3;   % 403:                             sb zero, 9(a1)   # Sets map's Y offset to 0 %
000005d2 : 00264e83;   % 404:                             lbu t4, 2(a2)    # Loads Map matrix height %
000005d3 : 00f00e13;   % 405:                             li t3, 15 # Loads Map screen height related to matrix %
000005d4 : 41ce8e33;   % 406:                             sub t3,t4,t3     # t4 = Map Matrix Height - Screen Matrix Height (t4 = Map's Y when it's on lowermost part of the map) %
000005d5 : 0075ce83;   % 407:                             lbu t4, 7(a1)    # Loads Map Y postition on Matrix %
000005d6 : 01ceda63;   % 408:                             bge t4,t3,SKIP_ADJUST_Y_UP  # If on lowermost Y, don't update map's Y it %
000005d7 : 000e8863;   % 409:                             beqz t4,SKIP_ADJUST_Y_UP    # If on topmost Y, don't update map's Y it %
000005d8 : 01d583a3;   % 410:                             sb t4, 7(a1)     # and stores it %
000005d9 : 00200e13;   % 411:                             li t3, 2         # t3 = 2 (map will be rendered again) %
000005da : 01c582a3;   % 412:                             sb t3, 5(a1)     # Stores t3 on CURRENT_MAP's rendering byte %
000005db : 0300006f;   % 414:                         j Fixed_Y_Map %
000005dc : 0fc0f297;   % 417:             la t0,PLYR_INPUT      # Loads PLYR_INPUT on t0 %
000005dd : 9e328293;   % 417:  %
000005de : 00100313;   % 418:             li t1, 1              # Sets t1 to 1 (there's player input, and can move) %
000005df : 00628023;   % 419:             sb t1, 0(t0)          # and stores it in PLYR_INPUT  %
000005e0 : 010683a3;   % 421:             sb a6, 7(a3)    # Stores new Y offset %
000005e1 : 01168523;   % 422:             sb a7, 10(a3)   # Stores new Y coordinate on matrix %
000005e2 : 00770f33;   % 424:             add t5, a4, t2  # t5 = Player's current X + Movement of Player on X axis %
000005e3 : 00064283;   % 426:             lbu t0, 0(a2)   # loads first byte to check what type of map it is (0 - Fixed, 1 - Horizontal, 2 - Vertical) %
000005e4 : 00200e13;   % 427:             li t3, 2        # Loads 2 and  %
000005e5 : 005e1463;   % 428:             bne t3, t0, Fixed_Y_Map # compares with the result %
000005e6 : 0300006f;   % 429:             j Vertical_Map %
000005e7 : 0075c383;   % 433:             lbu t2 7(a1)    # Gets map's Y related to matrix %
000005e8 : 00a6cf03;   % 434:             lbu t5, 10(a3)	# Loads Player's Y related to matrix %
000005e9 : 407f0f33;   % 435:             sub t5,t5,t2    # Gets the Y matrix related to the map's Y %
000005ea : 004f1f13;   % 436:             slli t5,t5,4 # Multiplies t5 by 16 in order to get Y related to screen %
000005eb : 0076c383;   % 437:             lbu t2, 7(a3)	# Loads Player's Y offset %
000005ec : 007f0f33;   % 438:             add t5,t5,t2    # Adds offset to position %
000005ed : 0095c383;   % 439:             lbu t2 9(a1)    # Gets map's offset %
000005ee : 407f0f33;   % 440:             sub t5,t5,t2    # and takes it from player's position %
000005ef : 01e682a3;   % 442:             sb t5,5(a3) # Stores original Y on old Y  related to screen %
000005f0 : 01e68223;   % 443:             sb t5,4(a3) # Stores new Y on current Y related to screen %
000005f1 : 0bc0006f;   % 444:             j END_PHYSICS %
000005f2 : 0075c283;   % 447:             lbu t0, 7(a1)    # Loads Map's Y postition on Matrix %
000005f3 : 0095c303;   % 448:             lbu t1, 9(a1)    # Loads Map's Y offset %
000005f4 : 05e00e13;   % 450:             li t3, 94      # loads top vertical border = 94  %
000005f5 : 01ee4863;   % 451:             blt t3, t5, NOT_TOP_BORDER_PASS  # if new player position on screen doesn't pass the upper border, go to NOT_LEFT_BORDER_PASS %
000005f6 : 00628eb3;   % 453:             add t4,t0,t1     # Will be 0 if Map's X offset and X position are 0 %
000005f7 : fc0e80e3;   % 454:             beqz t4, Fixed_Y_Map  # If on uppermost part of the map, map won't move %
000005f8 : 01c0006f;   % 455:             j MOVE_SCREEN_Y     # otherwise, move the map left %
000005f9 : 06000e13;   % 458:             li t3, 96 #loads bottom vertical border = 96  %
000005fa : fbee5ae3;   % 459:             bge t3,t5,Fixed_Y_Map   # if new player position on screen doesn't pass the lower border, go to Fixed_X_Map %
000005fb : 00264303;   % 460:             lbu t1, 2(a2)    # Loads Map matrix height %
000005fc : 00f00e13;   % 461:             li t3, 15 # Loads Map screen height related to matrix %
000005fd : 41c30333;   % 462:             sub t1,t1,t3    # t1 = Map Matrix Height - Screen Matrix Height (t1 = Map's Y when it's on lowermost part of the map) %
000005fe : fa6282e3;   % 463:             beq t0,t1, Fixed_Y_Map  # If on lowermost part of the map, map won't move %
000005ff : 00200e13;   % 466:             li t3, 2       # t3 = 2 (map will be rendered again) %
00000600 : 01c582a3;   % 467:             sb t3, 5(a1)   # Stores t3 on CURRENT_MAP's rendering byte %
00000601 : 007682a3;   % 469:             sb t2,5(a3)    # Stores player's original Y on old Y related to screen %
00000602 : 0075c383;   % 472:             lbu t2, 7(a1)  # Loads Map Y postition on Matrix %
00000603 : 0095c803;   % 473:             lbu a6, 9(a1)  # Loads map's Y offset %
00000604 : 00e80833;   % 474:             add a6,a6,a4  # Adds the Y Movement to the map's Offset %
00000605 : 00000313;   % 475:             li t1,0  # Right now, the map's Y won't be updated  %
00000606 : 00085e63;   % 476:             bge a6, zero, NO_Y_OFFSET_NEGATIVE_CORRECTION  %
00000607 : 00038863;   % 478:                 beqz t2 TOP_OF_MAP_RESET %
00000608 : fff00313;   % 480:                     li t1, -1 %
00000609 : 01080813;   % 481:                     addi a6,a6,16 # Corrects negative offset by adding 16 %
0000060a : 0340006f;   % 482:                     j NO_Y_OFFSET_CORRECTION %
0000060b : 00000813;   % 485:                     li a6,0 %
0000060c : 02c0006f;   % 486:                     j NO_Y_OFFSET_CORRECTION %
0000060d : 01000293;   % 490:                 li t0, 16 %
0000060e : 02584263;   % 491:                 blt a6,t0, NO_Y_OFFSET_CORRECTION %
0000060f : 00100313;   % 492:                 li t1,1 %
00000610 : 40580833;   % 493:                 sub a6,a6,t0 # Corrects values that surpass 16 by subtracting 16 from them %
00000611 : 00264e83;   % 495:                 lbu t4, 2(a2)    # Loads Map matrix height %
00000612 : 00f00e13;   % 496:                 li t3, 15 # Loads Map screen height related to matrix %
00000613 : 41ce8eb3;   % 497:                 sub t4,t4,t3     # t4 = Map Matrix Height - Screen Matrix Height (t1 = Map's Y when it's on lowermost part of the map) %
00000614 : 00138f13;   % 498:                 addi t5,t2,1     # Maximum Y on map %
00000615 : 01df4463;   % 500:                 blt t5,t4,NO_Y_OFFSET_CORRECTION    # If t5 != maximum Y on map, skip this next correction %
00000616 : 00000813;   % 502:                 li a6,0    # set offset to 0                %
00000617 : 010584a3;   % 505:                 sb a6, 9(a1)   # Stores Map new Y offset that is equal to player's Y offset %
00000618 : 006383b3;   % 506:                 add t2,t2,t1  # adds to the Y -1, 0 or 1 (moves map horizontally) %
00000619 : 007583a3;   % 507:                 sb t2, 7(a1)   # Stores Map Y postition on Matrix %
0000061a : 00264283;   % 509:                 lbu t0,2(a2)  # Loads map's height %
0000061b : 00f00313;   % 510:                 li t1,15 # and the screen's height %
0000061c : 406282b3;   % 511:                 sub t0,t0,t1  # Subtracts from map's height the screen height %
0000061d : 0053c663;   % 512:                 blt t2,t0,END_PHYSICS # If the new Y passes the limit of map %
0000061e : 000584a3;   % 513:                     sb zero, 9(a1) %
0000061f : 005583a3;   % 514:                     sb t0, 7(a1)   # Stores Map Y postition on Matrix %
00000620 : 00008067;   % 518:       ret %
00000621 : 00088e63;   % 38: beqz a7,NORMAL %
00000622 : 00950533;   % 40: 		add a0,a0,s1	# Image address + X on sprite  %
00000623 : 03298e33;   % 41: 		mul t3,s3,s2	# t3 = sprite width * Y on sprite %
00000624 : 01c50533;   % 42: 		add a0,a0,t3	# a0 = Image address + X on sprite + sprite widht * Y on sprite %
00000625 : 03480eb3;   % 43: 		mul t4,a6,s4	# t4 = sprite status x height of rendering area (for files that have more than one sprite) %
00000626 : 033e8eb3;   % 44: 		mul t4,t4,s3	# t4 = sprite status x height of rendering area x sprite's width %
00000627 : 00c0006f;   % 45: 		j START_RENDER %
00000628 : 02e80eb3;   % 47: 		mul t4,a6,a4	# t4 = sprite status x height of rendering area (for files that have more than one sprite) %
00000629 : 02de8eb3;   % 48: 		mul t4,t4,a3	# t4 = sprite status x height of rendering area x width of rendering area (on NORMAL_RENDER: a3 = sprite's width) %
0000062a : 01d50533;   % 51: 		add a0,a0,t4	# Adds the dislocation calculated on t4 to the sprite's address %
0000062b : 000012b7;   % 53: 	li t0,0x0FF0	#t0 = 0x0FF0 %
0000062c : ff028293;   % 53:  %
0000062d : 00f282b3;   % 54: 	add t0,t0,a5	# Rendering Address corresponds to 0x0FF0 + frame %
0000062e : 01429293;   % 55: 	slli t0,t0,20	# Shifts 20 bits, making printing adress correct (0xFF00 0000 or 0xFF10 0000) %
0000062f : 00b282b3;   % 56: 	add t0,t0,a1	# t0 = 0xFF00 0000 + X or 0xFF10 0000 + X %
00000630 : 14000313;   % 57: 	li t1,320	# t1 = 320 %
00000631 : 02c30333;   % 58: 	mul t1,t1,a2	# t1 = 320 * Y  %
00000632 : 006282b3;   % 59: 	add t0,t0,t1	# t0 = 0xFF00 0000 + X + (Y * 320) or 0xFF10 0000 + X + (Y * 320) %
00000633 : 000003b3;   % 61: 	mv t2,zero	# t2 = 0 (Resets line counter) %
00000634 : 00000e33;   % 62: 	mv t3,zero	# t3 = 0 (Resets column counter) %
00000635 : 00050e83;   % 65: 		lb t4,0(a0)	# loads byte(1 pixel) on t4 %
00000636 : 02000f13;   % 68: 		li t5,32 # Loads 32 (value of green pixel in samus) %
00000637 : 01df1c63;   % 69: 		bne t5,t4,SKIP_SWITCH %
00000638 : 0fc0ff17;   % 70: 			la t5, PLYR_INFO_2    # Loads address to PLYR_INFO_2 %
00000639 : 874f0f13;   % 70:  %
0000063a : 000f4f03;   % 71: 			lbu t5,0(t5)          # Loads missile enable byte %
0000063b : 000f0463;   % 72: 			beqz t5,SKIP_SWITCH   # If player isn't in missile mode %
0000063c : 0f000e93;   % 73: 				li t4 240        # Otherwise render cyan instead of green %
0000063d : 01d28023;   % 76: 		sb t4,0(t0)	# prints 1 pixel from t4 %
0000063e : 00128293;   % 78: 		addi t0,t0,1	# increments bitmap address %
0000063f : 00150513;   % 79: 		addi a0,a0,1	# increments image address %
00000640 : 001e0e13;   % 81: 		addi t3,t3,1		# increments column counter %
00000641 : fcde48e3;   % 82: 		blt t3,a3,PRINT_LINE	# if column counter < width, repeat %
00000642 : 14028293;   % 84: 		addi t0,t0,320	# goes to next line on bitmap display %
00000643 : 40d282b3;   % 85: 		sub t0,t0,a3	# goes to right X on bitmap display (current address - width) %
00000644 : 00088663;   % 87: 		beqz a7, NORMAL_RENDER	# If not on crop mode %
00000645 : 01350533;   % 89: 			add a0,a0,s3	# a0 += sprite width	 %
00000646 : 40d50533;   % 90: 			sub a0,a0,a3	# a0 -= rendering width %
00000647 : 00000e33;   % 93: 			mv t3,zero		# t3 = 0 (Resets column counter) %
00000648 : 00138393;   % 94: 			addi t2,t2,1		# increments line counter %
00000649 : fae3c8e3;   % 95: 			bgt a4,t2,PRINT_LINE	# if height > line counter, repeat %
0000064a : 00008067;   % 96: 			ret %
0000064b : 00088e63;   % 122: beqz a7,NORMAL_WORD %
0000064c : 00950533;   % 124: 		add a0,a0,s1	# Image address + X on sprite  %
0000064d : 03298e33;   % 125: 		mul t3,s3,s2	# t3 = sprite width * Y on sprite %
0000064e : 01c50533;   % 126: 		add a0,a0,t3	# a0 = Image address + X on sprite + sprite widht * Y on sprite %
0000064f : 03480eb3;   % 127: 		mul t4,a6,s4	# t4 = sprite status x height of rendering area (for files that have more than one sprite) %
00000650 : 033e8eb3;   % 128: 		mul t4,t4,s3	# t4 = sprite status x height of rendering area x sprite's width %
00000651 : 00c0006f;   % 129: 		j START_RENDER_WORD %
00000652 : 02e80eb3;   % 131: 		mul t4,a6,a4	# t4 = sprite status x height of rendering area (for files that have more than one sprite) %
00000653 : 02de8eb3;   % 132: 		mul t4,t4,a3	# t4 = sprite status x height of rendering area x width of rendering area (on NORMAL_RENDER: a3 = sprite's width) %
00000654 : 01d50533;   % 135: 		add a0,a0,t4	# Adds the dislocation calculated on t4 to the sprite's address %
00000655 : 000012b7;   % 137: 	li t0,0x0FF0	#t0 = 0x0FF0 %
00000656 : ff028293;   % 137:  %
00000657 : 00f282b3;   % 138: 	add t0,t0,a5	# Rendering Address corresponds to 0x0FF0 + frame %
00000658 : 01429293;   % 139: 	slli t0,t0,20	# Shifts 20 bits, making printing adress correct (0xFF00 0000 or 0xFF10 0000) %
00000659 : 00b282b3;   % 140: 	add t0,t0,a1	# t0 = 0xFF00 0000 + X or 0xFF10 0000 + X %
0000065a : 14000313;   % 141: 	li t1,320	# t1 = 320 %
0000065b : 02c30333;   % 142: 	mul t1,t1,a2	# t1 = 320 * Y  %
0000065c : 006282b3;   % 143: 	add t0,t0,t1	# t0 = 0xFF00 0000 + X + (Y * 320) or 0xFF10 0000 + X + (Y * 320) %
0000065d : 000003b3;   % 145: 	mv t2,zero	# t2 = 0 (Resets line counter) %
0000065e : 00000e33;   % 146: 	mv t3,zero	# t3 = 0 (Resets column counter) %
0000065f : 00050e83;   % 150: 		lb t4,0(a0)	# loads word(4 pixels) on t4 %
00000660 : 01d28023;   % 151: 		sb t4,0(t0)	# prints 4 pixels from t4 %
00000661 : 00128293;   % 153: 		addi t0,t0,1	# increments bitmap address %
00000662 : 00150513;   % 154: 		addi a0,a0,1	# increments image address %
00000663 : 001e0e13;   % 156: 		addi t3,t3,1		# increments column counter %
00000664 : fede46e3;   % 157: 		blt t3,a3,PRINT_LINE_WORD	# if column counter < width, repeat %
00000665 : 14028293;   % 159: 		addi t0,t0,320	# goes to next line on bitmap display %
00000666 : 40d282b3;   % 160: 		sub t0,t0,a3	# goes to right X on bitmap display (current address - width) %
00000667 : 00088663;   % 162: 		beqz a7, NORMAL_RENDER_WORD	# If not on crop mode %
00000668 : 01350533;   % 164: 			add a0,a0,s3	# a0 += sprite width	 %
00000669 : 40d50533;   % 165: 			sub a0,a0,a3	# a0 -= rendering width %
0000066a : 00000e33;   % 168: 			mv t3,zero		# t3 = 0 (Resets column counter) %
0000066b : 00138393;   % 169: 			addi t2,t2,1		# increments line counter %
0000066c : fce3c6e3;   % 170: 			bgt a4,t2,PRINT_LINE_WORD	# if height > line counter, repeat %
0000066d : 00008067;   % 171: 			ret %
0000066e : 000012b7;   % 194: 	li t0,0xFF0	# t0 = 0xFF0 %
0000066f : ff028293;   % 194:  %
00000670 : 00f282b3;   % 195: 	add t0,t0,a5	# Rendering Address corresponds to 0x0FF0 + frame %
00000671 : 01429293;   % 196: 	slli t0,t0,20	# Shifts 20 bits, making printing adress correct (0xFF00 0000 or 0xFF10 0000) %
00000672 : 00b282b3;   % 198: 	add t0,t0,a1	# t0 = 0xFF00 0000 + X or 0xFF10 0000 + X %
00000673 : 14000313;   % 200: 	li t1,320	# t1 = 320 %
00000674 : 02c30333;   % 201: 	mul t1,t1,a2	# t1 = 320 * Y  %
00000675 : 006282b3;   % 202: 	add t0,t0,t1	# t0 = 0xFF00 0000 + X + (Y * 320) or 0xFF10 0000 + X + (Y * 320) %
00000676 : 000003b3;   % 204: 	mv t2,zero	# t2 = 0 (Resets line counter) %
00000677 : 00000e33;   % 205: 	mv t3,zero	# t3 = 0 (Resets column counter) %
00000678 : 00851313;   % 207: 	slli t1,a0,8	# Shifts 8 bits on a0 %
00000679 : 00650533;   % 208: 	add a0,a0,t1	# a0 now stores two bytes of the same color (e.g.: 0x000000FF -> 0x0000FFFF) %
0000067a : 00081863;   % 210: 	bnez a6, PRINT_LINE_COLOR_HALF # If not printing 4 pixels at once %
0000067b : 01051313;   % 211: 		slli t1,a0,16	       # Shifts 16 bits on a0 %
0000067c : 00650533;   % 212: 		add a0,a0,t1	       # a0 now stores four bytes of the same color (e.g.: 0x0000FFFF -> 0xFFFFFFFF) %
0000067d : 02c0006f;   % 213: 		j PRINT_LINE_COLOR_WORD %
0000067e : 00a29023;   % 216: 		sh a0,0(t0)	# Renders two color pixels at once %
0000067f : 00228293;   % 217: 		addi t0,t0,2	# increments bitmap address by 2 bytes %
00000680 : 002e0e13;   % 219: 		addi t3,t3,2			# increments column counter %
00000681 : fede4ae3;   % 220: 		blt t3,a3,PRINT_LINE_COLOR_HALF	# if column counter < width, repeat %
00000682 : 14028293;   % 222: 		addi t0,t0,320	# goes to next line on bitmap display %
00000683 : 40d282b3;   % 223: 		sub t0,t0,a3	# goes to right X on bitmap display (current address - width) %
00000684 : 00000e33;   % 225: 		mv t3,zero			# t3 = 0 (resets column counter) %
00000685 : 00138393;   % 226: 		addi t2,t2,1			# increments line counter %
00000686 : fee3c0e3;   % 227: 		bgt a4,t2,PRINT_LINE_COLOR_HALF	# if height > line counter, repeat %
00000687 : 00008067;   % 228: 		ret			 %
00000688 : 00a2a023;   % 231: 		sw a0,0(t0)	# Renders four color pixels at once %
00000689 : 00428293;   % 232: 		addi t0,t0,4	# increments bitmap address by 4 bytes %
0000068a : 004e0e13;   % 234: 		addi t3,t3,4			# increments column counter %
0000068b : fede4ae3;   % 235: 		blt t3,a3,PRINT_LINE_COLOR_WORD	# if column counter < width, repeat %
0000068c : 14028293;   % 236: 		addi t0,t0,320	# goes to next line on bitmap display %
0000068d : 40d282b3;   % 237: 		sub t0,t0,a3	# goes to right X on bitmap display (current address - width) %
0000068e : 00000e33;   % 239: 		mv t3,zero			# t3 = 0 (resets column counter) %
0000068f : 00138393;   % 240: 		addi t2,t2,1			# increments line counter %
00000690 : fee3c0e3;   % 241: 		bgt a4,t2,PRINT_LINE_COLOR_WORD	# if height > line counter, repeat %
00000691 : 00008067;   % 242: 		ret %
00000692 : 00b00233;   % 263: 	mv tp,a1  # tp gets value from a1 %
00000693 : 0fc0e317;   % 265: 	la t1, PLYR_INFO_2	 # Loads address of the second part of PLYR_INFO %
00000694 : 70830313;   % 265:  %
00000695 : 00334283;   % 266:     lbu t0,3(t1)         # and damage cooldown %
00000696 : 00028c63;   % 267: 	beqz t0,RENDER_PLAYER_SKIP_DAMAGE %
00000697 : 00734283;   % 268: 		lbu t0,7(t1)     # Loads render byte %
00000698 : 0012c393;   % 269: 		xori t2,t0,1     # inverts it %
00000699 : 007303a3;   % 270: 		sb t2,7(t1)      # and stores it %
0000069a : 00029463;   % 271: 		bnez t0,RENDER_PLAYER_SKIP_DAMAGE # If it wasn't 0, render %
0000069b : 00008067;   % 272: 		ret	# Otherwise, finish procedure %
0000069c : 0fc0e297;   % 274: 	la t0, PLYR_STATUS # Loads PLAYER_STATUS address %
0000069d : 6da28293;   % 274:  %
0000069e : 0fc0e397;   % 275: 	la t2,PLYR_POS	# Loads PLYR_POS address %
0000069f : 6c638393;   % 275:  %
000006a0 : 00039583;   % 277: 	lh a1, 0(t2)	# Loads top left X coordinate related to sprite %
000006a1 : 0043c603;   % 278: 	lbu a2, 4(t2)	# Loads top left Y coordinate related to sprite	 %
000006a2 : 008007b3;   % 280: 	mv a5, s0		# Gets frame  %
000006a3 : 0002c803;   % 281: 	lbu a6, 0(t0)   # Loads Player's sprite status %
000006a4 : 000008b3;   % 282: 	mv a7,zero 		# Operation (0 - normal operation) %
000006a5 : 00050463;   % 284: 	beqz a0, RENDER_PLAYER_NORMAL # If a0 = 0,  then player will be rendered normally %
000006a6 : 2b80006f;   % 285: 	j RENDER_PLAYER_TRAIL         # Otherwise (a0 = 1) render player's trail %
000006a7 : fec10113;   % 288: 		addi sp,sp,-20 %
000006a8 : 00912023;   % 289: 		sw s1,0(sp) %
000006a9 : 01212223;   % 290: 		sw s2,4(sp) %
000006aa : 01312423;   % 291: 		sw s3,8(sp) %
000006ab : 01412623;   % 292: 		sw s4,12(sp) %
000006ac : 00112823;   % 293: 		sw ra,16(sp) %
000006ad : 0012c303;   % 297: 		lbu t1, 1(t0)	# Loads Player's horizontal direction (0 = Right, 1 = Left) %
000006ae : 0042c383;   % 298: 		lbu t2, 4(t0)   # Loads Player's morph ball status %
000006af : 00038463;   % 300: 		beqz t2, RENDER_PLAYER_STAND # If player isn't on morph ball, go to RENDER_PLAYER_STAND %
000006b0 : 1f80006f;   % 301: 		j RENDER_PLAYER_BALL         # Otherwise, go to RENDER_PLAYER_BALL %
000006b1 : 0062c383;   % 304: 		lbu t2, 6(t0)   # Loads Player's MOVE_X value (-1 left, 1 right, 0 not moving on X axis) %
000006b2 : 0072ce03;   % 305: 		lbu t3, 7(t0)   # Loads Player's MOVE_Y value (-1 up, 1 right, 0 not moving on Y axis) %
000006b3 : 0022ce83;   % 306: 		lbu t4, 2(t0)	# Loads Player's vertical direction (0 = Normal, 1 = Up) %
000006b4 : 0052cf03;   % 307: 		lbu t5, 5(t0)	# Loads Player's attacking status (0 - no, 1 - yes) %
000006b5 : 00030463;   % 309: 		beqz t1, RENDER_PLYR_RIGHT # Checks if player is looking right %
000006b6 : 0f00006f;   % 310: 		j RENDER_PLYR_LEFT	   # If player is looking left %
000006b7 : 01c38333;   % 313: 			add t1, t2, t3  # t1 will be 0 if t2 (MOVE_X) = 0 and t3 (MOVE_Y) = 0 %
000006b8 : 00030e63;   % 314: 			beqz t1,RENDER_IDLE_RIGHT # If t1 = 0, player isn't moving (go to RENDER_IDLE_RIGHT) %
000006b9 : 0fc0e317;   % 315: 				la t1,PLYR_INPUT # Otherwise, load PLYR_INPUT address %
000006ba : 66f30313;   % 315:  %
000006bb : 00034303;   % 316: 				lbu t1,0(t1)     # and get its value %
000006bc : ffe30313;   % 317: 				addi t1,t1,-2    # subtracts 2 from it %
000006bd : 00030463;   % 318: 				beqz t1, RENDER_IDLE_RIGHT # if the result is 0 (t1 would've been 2, so player couldn't move) go to idle %
000006be : 0340006f;   % 319: 					j NOT_IDLE_RIGHT	   # Otherwise, go to NOT_IDLE_RIGHT %
000006bf : 01400693;   % 322: 				li a3, 20   # Sprite's Widht %
000006c0 : 01e00833;   % 323: 				mv a6, t5	# Idle sprites have their status set to 1 if player is attacking %
000006c1 : 000e9a63;   % 324: 				bnez t4, RENDER_IDLE_RIGHT_UP # If player is looking up %
000006c2 : 0fc13517;   % 327: 				la a0, Samus_Right_Idle # Loads Player's Image Address  %
000006c3 : 30450513;   % 327:  %
000006c4 : 02000713;   % 328: 				li a4, 32  # Sprite's Height %
000006c5 : 1b80006f;   % 329: 				j START_RENDER_PLAYER # Start rendering player %
000006c6 : ffa60613;   % 332: 				addi a2,a2, -6 # Offseting sprite's Y so that it renders in propper place %
000006c7 : 0fc13517;   % 333: 				la a0, Samus_Right_Idle_Up # Loads Player's Image Address  %
000006c8 : 7f050513;   % 333:  %
000006c9 : 02600713;   % 334: 				li a4, 38  # Sprite's Height %
000006ca : 1a40006f;   % 335: 				j START_RENDER_PLAYER # Start rendering player %
000006cb : 000e1463;   % 338: 				bnez t3, RENDER_JUMP_RIGHT %
000006cc : 0380006f;   % 339: 				j NOT_JUMP_RIGHT %
000006cd : ffc58593;   % 348: 					addi a1,a1, -4 # Offseting sprite's X so that it renders in propper place %
000006ce : ffa60613;   % 349: 					addi a2,a2, -6 # Offseting sprite's Y so that it renders in propper place %
000006cf : 02000713;   % 350: 					li a4, 32  # Sprite's Height %
000006d0 : 01e00833;   % 351: 					mv a6, t5	# Jump sprites have their status set to 1 if player is attacking %
000006d1 : 000e9a63;   % 352: 					bnez t4, RENDER_JUMP_RIGHT_UP	# If player is looking up %
000006d2 : 01800693;   % 354: 						li a3, 24  # Sprite's Widht %
000006d3 : 0fc16517;   % 355: 						la a0, Samus_Right_Jump # Loads Player's Image Address  %
000006d4 : 18050513;   % 355:  %
000006d5 : 1780006f;   % 356: 						j START_RENDER_PLAYER   # Start rendering player %
000006d6 : 01400693;   % 359: 						li a3, 20  # Sprite's Widht %
000006d7 : 0fc16517;   % 360: 						la a0, Samus_Right_Jump_Up # Loads Player's Image Address  %
000006d8 : 77050513;   % 360:  %
000006d9 : 1680006f;   % 361: 						j START_RENDER_PLAYER      # Start rendering player %
000006da : 000e8463;   % 364: 					beqz t4, RENDER_MOVEMENT_RIGHT %
000006db : 0300006f;   % 365: 					j RENDER_MOVEMENT_RIGHT_UP %
000006dc : 02000713;   % 368: 						li a4, 32  # Sprite's Height %
000006dd : 000f0463;   % 369: 						beqz t5, RENDER_MOVEMENT_RIGHT_NORMAL %
000006de : 0140006f;   % 370: 						j RENDER_MOVEMENT_RIGHT_ATTACK %
000006df : 0fc14517;   % 373: 							la a0, Samus_Right	   # Loads Player's Image Address  %
000006e0 : d8050513;   % 373:  %
000006e1 : 01400693;   % 374: 							li a3, 20              # Sprite's Widht %
000006e2 : 1440006f;   % 375: 							j START_RENDER_PLAYER  # Start rendering player %
000006e3 : 0fc14517;   % 378: 							la a0, Samus_Right_Attack  # Loads Player's Image Address  %
000006e4 : 4f050513;   % 378:  %
000006e5 : 01c00693;   % 379: 							li a3, 28                  # Sprite's Widht %
000006e6 : 1340006f;   % 380: 							j START_RENDER_PLAYER      # Start rendering player %
000006e7 : ffa60613;   % 383: 						addi a2,a2, -6 # Offseting sprite's X so that it renders in propper place %
000006e8 : 01400693;   % 384: 						li a3, 20      # Sprite's Widht %
000006e9 : 02600713;   % 385: 						li a4, 38      # Sprite's Height %
000006ea : 000f0463;   % 386: 						beqz t5, RENDER_MOVEMENT_RIGHT_UP_NORMAL %
000006eb : 0100006f;   % 387: 						j RENDER_MOVEMENT_RIGHT_UP_ATTACK %
000006ec : 0fc15517;   % 390: 							la a0, Samus_Right_Up  # Loads Player's Image Address %
000006ed : f4c50513;   % 390:  %
000006ee : 1140006f;   % 391: 							j START_RENDER_PLAYER  # Start rendering player %
000006ef : 0fc16517;   % 394: 							la a0, Samus_Right_Up_Attack  # Loads Player's Image Address %
000006f0 : 82850513;   % 394:  %
000006f1 : 1080006f;   % 395: 							j START_RENDER_PLAYER         # Start rendering player %
000006f2 : ffc58593;   % 398: 			addi a1,a1, -4 # Offseting sprite's X so that it renders in propper place %
000006f3 : 01c38333;   % 399: 			add t1, t2, t3  # t1 will only be 0 if player isn't moving  %
000006f4 : 00030e63;   % 400: 			beqz t1,RENDER_IDLE_LEFT # Checks if player is mooving or not %
000006f5 : 0fc0e317;   % 401: 				la t1,PLYR_INPUT # Otherwise, load PLYR_INPUT address %
000006f6 : 57f30313;   % 401:  %
000006f7 : 00034303;   % 402: 				lbu t1,0(t1)     # and get its value %
000006f8 : ffe30313;   % 403: 				addi t1,t1,-2    # subtracts 2 from it %
000006f9 : 00030463;   % 404: 				beqz t1, RENDER_IDLE_LEFT # if the result is 0 (t1 would've been 2, so player couldn't move) go to idle %
000006fa : 0340006f;   % 405: 			j NOT_IDLE_LEFT	  # If player is moving or not %
000006fb : 01400693;   % 408: 				li a3, 20  # Sprite's Widht %
000006fc : 01e00833;   % 409: 				mv a6, t5	# Idle sprites have their status set to 1 if player is attacking %
000006fd : 000e9a63;   % 410: 				bnez t4, RENDER_IDLE_LEFT_UP	# If player is looking up %
000006fe : 0fc17517;   % 413: 					la a0, Samus_Left_Idle # Loads Player's Image Address  %
000006ff : 4d450513;   % 413:  %
00000700 : 02000713;   % 414: 					li a4, 32  # Sprite's Height %
00000701 : 0c80006f;   % 415: 					j START_RENDER_PLAYER # Start rendering player %
00000702 : ffa60613;   % 418: 					addi a2,a2, -6 # Offseting sprite's Y so that it renders in propper place %
00000703 : 0fc18517;   % 419: 					la a0, Samus_Left_Idle_Up # Loads Player's Image Address  %
00000704 : 9c050513;   % 419:  %
00000705 : 02600713;   % 420: 					li a4, 38  # Sprite's Height %
00000706 : 0b40006f;   % 421: 					j START_RENDER_PLAYER # Start rendering player %
00000707 : 000e1463;   % 424: 				bnez t3, RENDER_JUMP_LEFT %
00000708 : 0340006f;   % 425: 				j NOT_JUMP_LEFT %
00000709 : ffc58593;   % 434: 					addi a1,a1, -4 # Offseting sprite's X so that it renders in propper place %
0000070a : ffa60613;   % 435: 					addi a2,a2, -6 # Offseting sprite's Y so that it renders in propper place %
0000070b : 01800693;   % 436: 					li a3, 24  # Sprite's Widht %
0000070c : 02000713;   % 437: 					li a4, 32  # Sprite's Height %
0000070d : 01e00833;   % 438: 					mv a6, t5	# Jump sprites have their status set to 1 if player is attacking %
0000070e : 000e9863;   % 439: 					bnez t4, RENDER_JUMP_LEFT_UP	# If player is looking up %
0000070f : 0fc1a517;   % 444: 					la a0, Samus_Left_Jump # Loads Player's Image Address  %
00000710 : 65050513;   % 444:  %
00000711 : 0880006f;   % 445: 					j START_RENDER_PLAYER   # Start rendering player %
00000712 : 0fc1b517;   % 448: 						la a0, Samus_Left_Jump_Up # Loads Player's Image Address  %
00000713 : c4450513;   % 448:  %
00000714 : 07c0006f;   % 449: 						j START_RENDER_PLAYER      # Start rendering player %
00000715 : 000e8463;   % 452: 					beqz t4, RENDER_MOVEMENT_LEFT %
00000716 : 0340006f;   % 453: 					j RENDER_MOVEMENT_LEFT_UP %
00000717 : ff858593;   % 456: 						addi a1,a1, -8 # Offseting sprite's X so that it renders in propper place %
00000718 : 02000713;   % 457: 						li a4, 32      # Sprite's Height %
00000719 : 000f0463;   % 458: 						beqz t5, RENDER_MOVEMENT_LEFT_NORMAL %
0000071a : 0140006f;   % 459: 						j RENDER_MOVEMENT_LEFT_ATTACK %
0000071b : 0fc18517;   % 462: 							la a0, Samus_Left	   # Loads Player's Image Address  %
0000071c : f5050513;   % 462:  %
0000071d : 01c00693;   % 463: 							li a3, 28              # Sprite's Widht %
0000071e : 0540006f;   % 464: 							j START_RENDER_PLAYER  # Start rendering player %
0000071f : 0fc19517;   % 467: 							la a0, Samus_Left_Attack  # Loads Player's Image Address  %
00000720 : 9c050513;   % 467:  %
00000721 : 01c00693;   % 468: 							li a3, 28                  # Sprite's Widht %
00000722 : 0440006f;   % 469: 							j START_RENDER_PLAYER      # Start rendering player %
00000723 : ffa60613;   % 472: 						addi a2,a2, -6 # Offseting sprite's X so that it renders in propper place %
00000724 : 01400693;   % 473: 						li a3, 20      # Sprite's Widht %
00000725 : 02600713;   % 474: 						li a4, 38      # Sprite's Height %
00000726 : 000f0463;   % 475: 						beqz t5, RENDER_MOVEMENT_LEFT_UP_NORMAL %
00000727 : 0100006f;   % 476: 						j RENDER_MOVEMENT_LEFT_UP_ATTACK %
00000728 : 0fc19517;   % 479: 							la a0, Samus_Left_Up  # Loads Player's Image Address %
00000729 : 41c50513;   % 479:  %
0000072a : 0240006f;   % 480: 							j START_RENDER_PLAYER  # Start rendering player %
0000072b : 0fc1a517;   % 483: 							la a0, Samus_Left_Up_Attack  # Loads Player's Image Address %
0000072c : cf850513;   % 483:  %
0000072d : 0180006f;   % 484: 							j START_RENDER_PLAYER         # Start rendering player %
0000072e : 0fc1c517;   % 487: 			la a0, Morph_Ball # Loads morph ball image address %
0000072f : ad450513;   % 487:  %
00000730 : 01060613;   % 488: 			addi a2, a2, 16 # Adds 16 to Player's Y %
00000731 : 01000693;   % 489: 			li a3, 16 # Loads 16 to width of rendering area %
00000732 : 01000713;   % 490: 			li a4, 16 # Loads 16 to height of rendering area	 %
00000733 : 04020263;   % 494: 			beqz tp, RENDER_PLAYER_SKIP_CROP # If tp is 0, don't crop image %
00000734 : 00100293;   % 495: 				li t0,1    # To compare with tp (16 pixels to the left) %
00000735 : 02428263;   % 496: 				beq t0,tp, RENDER_PLAYER_CROP_LEFT %
00000736 : 00d009b3;   % 499: 					mv s3,a3         # Moves sprite's width to s3 %
00000737 : 00e00a33;   % 500: 					mv s4,a4         # Moves sprite's height to s4 %
00000738 : 01000693;   % 501: 					li a3,16  # New width of rendering area %
00000739 : 00100893;   % 502: 					li a7,1          # Sets to crop mode %
0000073a : 40d984b3;   % 503: 					sub s1,s3,a3     # Sets starting X to be 16 pixels before width of sprite's width %
0000073b : 00000913;   % 504: 					li s2,0          # Sets starting Y on sprite to 0 %
0000073c : 009585b3;   % 505: 					add a1,a1,s1     # Corrects player's starting X to be dislocated to the cropped X %
0000073d : 01c0006f;   % 506: 					j RENDER_PLAYER_SKIP_CROP %
0000073e : 00d009b3;   % 509: 					mv s3,a3         # Moves sprite's width to s3 %
0000073f : 00e00a33;   % 510: 					mv s4,a4         # Moves sprite's height to s4 %
00000740 : 01000693;   % 511: 					li a3,16  # New width of rendering area %
00000741 : 00100893;   % 512: 					li a7,1          # Sets to crop mode %
00000742 : 00000493;   % 513: 					li s1,0          # Sets starting X on sprite to 0  %
00000743 : 00000913;   % 514: 					li s2,0          # Sets starting Y on sprite to 0	 %
00000744 : 0fc0ef17;   % 518: 				la t5, PLYR_INFO_2    # Loads address to PLYR_INFO_2 %
00000745 : 444f0f13;   % 518:  %
00000746 : 000f4f03;   % 519: 				lbu t5,0(t5)          # Loads missile enable byte %
00000747 : 000f0863;   % 520: 				beqz t5,RENDER_PLAYER_SKIP_MISSILE   # If player isn't in missile mode %
00000748 : 00000317;   % 521: 					call RENDER    # Otherwise, render sprite byte by byte (to change color) %
00000749 : b64300e7;   % 521:  %
0000074a : 00c0006f;   % 522: 					j END_RENDER_PLAYER %
0000074b : 00000317;   % 524: 					call RENDER_WORD	# Calls RENDER_WORD procedure %
0000074c : c00300e7;   % 524:  %
0000074d : 00012483;   % 527: 					lw s1,0(sp) %
0000074e : 00412903;   % 528: 					lw s2,4(sp) %
0000074f : 00812983;   % 529: 					lw s3,8(sp) %
00000750 : 00c12a03;   % 530: 					lw s4,12(sp) %
00000751 : 01012083;   % 531: 					lw ra,16(sp) %
00000752 : 01410113;   % 532: 					addi sp,sp,20 %
00000753 : 00008067;   % 534: 					ret	   # End of procedure %
00000754 : 00144793;   % 537: 		xori a5,s0,1	# Gets oposite frame %
00000755 : 0fc0e297;   % 539: 		la t0, PLYR_MATRIX  # Loads PLYR_MATRIX address %
00000756 : 3f228293;   % 539:  %
00000757 : 0012ce03;   % 540: 		lbu t3, 1(t0) # Loads Player's old X related to matrix (Starting X for rendering (top left, related to Matrix)) %
00000758 : 0032c383;   % 541: 		lbu t2, 3(t0) # Loads Player's old Y related to matrix (Starting Y for rendering (top left, related to Matrix)) %
00000759 : 00200813;   % 543: 		li a6, 2	    # Width (Number of Tiles) = 2 %
0000075a : 00200893;   % 544: 		li a7, 2	    # Height (Number of Tiles) = 2 %
0000075b : 00b2c303;   % 546: 		lbu t1,11(t0)    # Loads player's MOVE_Y %
0000075c : 00603333;   % 547: 		sltu t1,zero,t1  # t1 != 0 ? t1 = 1 : t1 = 0 %
0000075d : 00c28e83;   % 548: 		lb t4,12(t0)     # Loads player's JUMP %
0000075e : 000ed663;   % 549: 		bge t4,zero,SKIP_JUMP_CORRECTION      # t4 < 0 ? t4 = 1 : t4 = 0 %
0000075f : 00100313;   % 550: 			li t1,1        # Will add 1 to the height %
00000760 : 00028623;   % 551: 			sb zero,12(t0) # Sets JUMP to 0 %
00000761 : 006888b3;   % 553: 		add a7,a7,t1     # If player is moving vertically (t0 != 0), the height will increase by 1  %
00000762 : 0082c283;   % 555: 		lbu t0, 8(t0)   # Loads Player's morph ball status %
00000763 : 020e0a63;   % 556: 		beqz t3,SKIP_MOVE_Y_RENDER_PLAYER_TRAIL   # If player is on leftmost side, don't increase the width %
00000764 : fffe0e13;   % 559: 			addi t3,t3,-1     # Moves X left by 1 tile %
00000765 : 0fc0e317;   % 560: 			la t1 CURRENT_MAP # Loads CURRENT_MAP address %
00000766 : 39030313;   % 560:  %
00000767 : 00032303;   % 561: 			lw t1,0(t1)       # Gets current map's address %
00000768 : 00134303;   % 562: 			lbu t1,1(t1)      # Gets current map's width %
00000769 : 41c30333;   % 563: 			sub t1,t1,t3      # t1 = Map's width - Player's old X related to matrix %
0000076a : 00400e93;   % 564: 			li t4,4           # t2 is used for comparing %
0000076b : 01d34863;   % 565: 			blt t1,t4,SET_NEW_WIDTH_RENDER_PLAYER_TRAIL # If t1 < 4, set the width to t1 %
0000076c : 0012c313;   % 567: 			xori t1,t0,1	# If player is on morph ball (t0 = 1), t1 = 0 and vice versa %
0000076d : 00330813;   % 568: 			addi a6,t1,3    # Width (Number of Tiles) = 3 (on morph ball) or 4 (not on morph ball) %
0000076e : 0080006f;   % 569: 			j SKIP_MOVE_Y_RENDER_PLAYER_TRAIL %
0000076f : 00600833;   % 571: 				mv a6,t1    # Width (Number of Tiles) = t1 (t1 < 4) %
00000770 : 00028463;   % 573: 		beqz t0, RENDER_PLAYER_TRAIL_STAND  # If player isn't on morph ball, go to RENDER_PLAYER_TRAIL_STAND %
00000771 : 0100006f;   % 574: 		j START_RENDER_PLAYER_TRAIL         # otherwise, player is on morph ball and go to START_RENDER_PLAYER_TRAIL %
00000772 : fff38393;   % 577: 			addi t2,t2,-1   # Moves Y up by 1 tile %
00000773 : 00188893;   % 578: 			addi a7,a7,1    # Height (Number of Tiles) = 3 (if not jumping) or 4 (if jumping) %
00000774 : 0040006f;   % 579: 			j START_RENDER_PLAYER_TRAIL %
00000775 : 00100db3;   % 582: 			mv s11, ra	# Moves ra to s11 -- so that we don't need to use the stack %
00000776 : 00004317;   % 583: 			call SCENE_RENDER	# Calls SCENE_RENDER procedure %
00000777 : 258300e7;   % 583:  %
00000778 : 01b000b3;   % 584: 			mv ra, s11  # Returns s11 to ra -- so that we don't need to use the stack %
00000779 : 00008067;   % 585: 			ret			# End of procedure %
0000077a : ffc10113;   % 605:     addi sp,sp,-4 %
0000077b : 00112023;   % 606:     sw ra,0(sp) %
0000077c : 0fc0e517;   % 609: 	la a0, Energy_UI    # Image address %
0000077d : 73f50513;   % 609:  %
0000077e : 01800593;   % 610: 	li a1,24            # Starting X (24) %
0000077f : 02000613;   % 611: 	li a2,32            # Starting Y (32) %
00000780 : 01800693;   % 612: 	li a3,24            # Gets width %
00000781 : 00800713;   % 613: 	li a4,8             # Gets height %
00000782 : 008007b3;   % 614: 	mv a5,s0            # Gets frame %
00000783 : 00000813;   % 615: 	li a6,0             # Only one sprite, so there's no status %
00000784 : 00000893;   % 616: 	li a7,0             # Normal render %
00000785 : 00000317;   % 617: 	call RENDER_WORD %
00000786 : b18300e7;   % 617:  %
00000787 : 0fc0e297;   % 619: 	la t0, PLYR_INFO %
00000788 : 32028293;   % 619:  %
00000789 : 00028503;   % 620: 	lb a0, 0(t0)          # Loads player's health %
0000078a : 00055463;   % 621: 	bge a0,zero,SKIP_LIFE_CORRECTION %
0000078b : 00000513;   % 622: 		li a0,0 %
0000078c : 03000593;   % 624: 	li a1,48              # a1 = column %
0000078d : 02000613;   % 625: 	li a2,32              # a2 = row  %
0000078e : 0000c6b7;   % 626: 	li a3,0xc7ff          # a3 = colors  %
0000078f : 7ff68693;   % 626:  %
00000790 : 00800733;   % 627: 	mv a4,s0              # a4 = frame %
00000791 : 00100793;   % 628: 	li a5,1               # Font %
00000792 : 06500893;   % 629: 	li a7,101 # syscal for 'print integer' %
00000793 : 00000073;   % 630: 	ecall %
00000794 : 00012083;   % 633: 	lw ra,0(sp) %
00000795 : 00410113;   % 634: 	addi sp,sp,4 %
00000796 : 00008067;   % 636: 	ret %
00000797 : 0a089863;   % 670: bnez a7,RENDER_ENTITY_TRAIL # If a0 != 0, render trail %
00000798 : 00000893;   % 671: 	li a7,0     # at the beginning, sprite doesn't need to be cropped %
00000799 : 00000493;   % 672: 	li s1,0     # Setting s1 to 0, in case needs to crop but skips horizontal crop %
0000079a : 00000913;   % 673: 	li s2,0     # Setting s2 to 0, in case needs to crop but skips vertical crop %
0000079b : 00d009b3;   % 674: 	mv s3,a3    # Storing sprite's width in (in case needs to crop but skips horizontal crop) %
0000079c : 00e00a33;   % 675: 	mv s4,a4    # Storing sprite's width in (in case needs to crop but skips horizontal crop) %
0000079d : 00d582b3;   % 678: 	add t0,a1,a3   # t0 (rightmost X + 1) = top left X related to screen + rendering area width  %
0000079e : 14505e63;   % 679: 	bge zero,t0, END_RENDER_ENTITY # If t0 <= 0, sprite's outside of screen (don't try to render >:[ ) %
0000079f : 14000313;   % 680: 	li t1,320 # t1 = 320 %
000007a0 : 1465da63;   % 681: 	bge a1,t1, END_RENDER_ENTITY # If a1 >= 320, sprite's outside of screen (don't try to render >:[ ) %
000007a1 : 0005c663;   % 684: 		blt a1,zero,CORRECT_X_LEFT # If so, crop the image %
000007a2 : 00534e63;   % 686: 		blt t1,t0,CORRECT_X_RIGHT # If so, crop the image %
000007a3 : 0240006f;   % 687: 		j RENDER_ENTITY_CHECK_VERTICAL# Otherwise, the a1 and a3 arguments are already defined correctly, go check vertical		 %
000007a4 : 00100893;   % 690: 			li a7,1         # Sprite will need to be cropped %
000007a5 : 40b004b3;   % 691: 			sub s1,zero,a1  # s1 (X in sprite where rendering starts) will be the absolute value of a1 %
000007a6 : 00b686b3;   % 693: 			add a3,a3,a1    # Since a1 will be negative, a3 will be reduced to a smaller width %
000007a7 : 00000593;   % 694: 			li a1,0         # and a1 will be set to 0 (leftmost X)   %
000007a8 : 0100006f;   % 695: 			j RENDER_ENTITY_CHECK_VERTICAL # Go check vertical arguments		 %
000007a9 : 00100893;   % 698: 			li a7,1         # Sprite will need to be cropped %
000007aa : 406282b3;   % 701: 			sub t0,t0,t1  # t0 will hold the excess width (what passes through the right border) %
000007ab : 405686b3;   % 702: 			sub a3,a3,t0  # take away from width (a3) the excess %
000007ac : 00e602b3;   % 707: 		add t0,a2,a4   # t0 (lowermost Y + 1) = top left Y related to screen + rendering area height  %
000007ad : 12505063;   % 708: 		bge zero,t0, END_RENDER_ENTITY # If t0 <= 0, sprite's outside of screen (don't try to render >:[ ) %
000007ae : 0f000313;   % 709: 		li t1,240 # t1 = 240 %
000007af : 01030313;   % 710: 		addi t1,t1,16 %
000007b0 : 10665a63;   % 711: 		bge a2,t1, END_RENDER_ENTITY # If a2 >= 240, sprite's outside of screen (don't try to render >:[ ) %
000007b1 : 00064663;   % 714: 			blt a2,zero,CORRECT_Y_TOP # If so, crop the image %
000007b2 : 00534e63;   % 716: 			blt t1,t0,CORRECT_Y_BOTTOM # If so, crop the image %
000007b3 : 0240006f;   % 717: 			j RENDER_ENTITY_START # Otherwise, the a2 and a4 arguments are already defined correctly, render	 %
000007b4 : 00100893;   % 720: 				li a7,1         # Sprite will need to be cropped %
000007b5 : 40c00933;   % 721: 				sub s2,zero,a2  # s2 (Y in sprite where rendering starts) will be the absolute value of a2 %
000007b6 : 00c70733;   % 723: 				add a4,a4,a2    # Since a2 will be negative, a4 will be reduced to a smaller height %
000007b7 : 00000613;   % 724: 				li a2,0         # and a1 will be set to 0 (topmost Y)   %
000007b8 : 0100006f;   % 725: 				j RENDER_ENTITY_START # render	 %
000007b9 : 00100893;   % 728: 				li a7,1         # Sprite will need to be cropped %
000007ba : 406282b3;   % 731: 				sub t0,t0,t1  # t0 will hold the excess height (what passes through the bottom border) %
000007bb : 40570733;   % 732: 				sub a4,a4,t0  # take away from height (a4) the excess %
000007bc : ffc10113;   % 738: 			addi sp,sp,-4 %
000007bd : 00112023;   % 739: 			sw ra,0(sp) %
000007be : 00000317;   % 741: 			call RENDER  %
000007bf : 98c300e7;   % 741:  %
000007c0 : 00012083;   % 743: 			lw ra,0(sp) %
000007c1 : 00410113;   % 744: 			addi sp,sp,4 %
000007c2 : 0cc0006f;   % 746: 			j END_RENDER_ENTITY %
000007c3 : 00000513;   % 749: 	li a0,0         # So that it renders map's trail %
000007c4 : 00144793;   % 750: 	xori a5,s0,1	# Gets oposite frame %
000007c5 : 00b00e33;   % 753: 	mv t3,a1   # column where rendering will begin (X related to Matrix) %
000007c6 : 00c003b3;   % 754: 	mv t2,a2   # line where rendering will begin (Y related to Matrix) %
000007c7 : 00d00833;   % 755: 	mv a6,a3   # width (Related to Matrix) of rendering area %
000007c8 : 00e008b3;   % 756: 	mv a7,a4   # height (Related to Matrix) of rendering area %
000007c9 : 0fc0e217;   % 758: 	la tp,CURRENT_MAP # Loads CURRENT_MAP's address %
000007ca : 20020213;   % 758:  %
000007cb : 00624283;   % 760: 	lbu t0,6(tp)   # loads map's current X   %
000007cc : 00d58333;   % 761: 	add t1,a1,a3   # t1 (rightmost X + 1) = top left X related to matrix + rendering area width  %
000007cd : 0a62d063;   % 762: 	bge t0,t1, END_RENDER_ENTITY # If t1 <= map's current X, area is outside of screen (don't try to render >:[ ) %
000007ce : 01428e93;   % 763: 	addi t4,t0,20    # t1 = map's current X + 20 %
000007cf : 09d5cc63;   % 764: 	blt a1,t4, END_RENDER_ENTITY # If a1 > map's current X + 20, area is outside of screen (don't try to render >:[ ) %
000007d0 : 0055c663;   % 779: 		blt a1,t0,CORRECT_X_LEFT_TRAIL # If so, reduce width %
000007d1 : 006ecc63;   % 781: 		blt t4,t1,CORRECT_X_RIGHT_TRAIL # If so, reduce width %
000007d2 : 02c0006f;   % 782: 		j RENDER_ENTITY_TRAIL_CHECK_VERTICAL # Otherwise, the a1 and a3 arguments are already defined correctly, go check vertical		 %
000007d3 : 40b28eb3;   % 785: 			sub t4,t0,a1    # t4 will have map's current X - Old X %
000007d4 : 41d80833;   % 786: 			sub a6,a6,t4    # Reduce width %
000007d5 : 00500e33;   % 787: 			mv t3,t0        # t3 will recieve map's current X   %
000007d6 : 01c0006f;   % 788: 			j RENDER_ENTITY_TRAIL_CHECK_VERTICAL  # Go check vertical arguments		 %
000007d7 : 406e8eb3;   % 792: 			sub t4,t4,t1    # t4 = map's current X + 20 - (top left X related to matrix + rendering area width)  %
000007d8 : 41d80833;   % 793: 			sub a6,a6,t4    # Reduce width %
000007d9 : 00824e83;   % 794: 			lbu t4,8(tp)    # loads map's X offset  %
000007da : 01d02eb3;   % 795: 			slt t4,zero,t4  # 0 < x offset ? t4 = 1 : t4 = 0 %
000007db : 01d80833;   % 796: 			add a6,a6,t4    # add 1 to width if offset != 0 %
000007dc : 06080263;   % 797: 			beqz a6, END_RENDER_ENTITY # if width is 0, end procedure %
000007dd : 00724283;   % 802: 		lbu t0,7(tp)   # loads map's current Y   %
000007de : 00e60333;   % 803: 		add t1,a2,a4   # t1 (rightmost Y + 1) = top left Y related to matrix + rendering area width  %
000007df : 0462dc63;   % 804: 		bge t0,t1, END_RENDER_ENTITY # If t1 <= map's current Y, area is outside of screen (don't try to render >:[ ) %
000007e0 : 00f28e93;   % 805: 		addi t4,t0,15   # t1 = map's current Y + 15 %
000007e1 : 05d64863;   % 806: 		blt a2,t4, END_RENDER_ENTITY # If a2 > map's current Y + 15, area is outside of screen (don't try to render >:[ ) %
000007e2 : 00564663;   % 809: 			blt a2,t0,CORRECT_Y_TOP_TRAIL # If so, reduce width %
000007e3 : 006ecc63;   % 811: 			blt t4,t1,CORRECT_Y_BOTTOM_TRAIL # If so, reduce width %
000007e4 : fe5ff06f;   % 812: 			j RENDER_ENTITY_TRAIL_CHECK_VERTICAL # Otherwise, the a2 and a4 arguments are already defined correctly, go check vertical		 %
000007e5 : 40b28eb3;   % 815: 				sub t4,t0,a1    # t4 will have map's current Y - Old Y %
000007e6 : 41d888b3;   % 816: 				sub a7,a7,t4    # Reduce height %
000007e7 : 005003b3;   % 817: 				mv t2,t0        # t2 will recieve map's current Y   %
000007e8 : 01c0006f;   % 818: 				j RENDER_ENTITY_TRAIL_START  # Render trail %
000007e9 : 406e8eb3;   % 822: 				sub t4,t4,t1    # t4 = map's current Y + 20 - (top left Y related to matrix + rendering area width)  %
000007ea : 41d888b3;   % 823: 				sub a7,a7,t4    # Reduce width %
000007eb : 00924e83;   % 824: 				lbu t4,9(tp)    # loads map's Y offset  %
000007ec : 01d02eb3;   % 825: 				slt t4,zero,t4  # 0 < Y offset ? t4 = 1 : t4 = 0 %
000007ed : 01d888b3;   % 826: 				add a7,a7,t4    # add 1 to width if offset != 0 %
000007ee : 00088e63;   % 827: 				beqz a7, END_RENDER_ENTITY # if width is 0, end procedure %
000007ef : ffc10113;   % 832: 			addi sp,sp,-4 %
000007f0 : 00112023;   % 833: 			sw ra,0(sp) %
000007f1 : 00004317;   % 835: 			call SCENE_RENDER	# Calls SCENE_RENDER procedure %
000007f2 : 06c300e7;   % 835:  %
000007f3 : 00012083;   % 837: 			lw ra,0(sp) %
000007f4 : 00410113;   % 838: 			addi sp,sp,4 %
000007f5 : 00008067;   % 842: 	ret %
000007f6 : ffc10113;   % 860: 	addi sp,sp,-4 %
000007f7 : 00112023;   % 861: 	sw ra,0(sp) %
000007f8 : 0fc0e297;   % 863: 	la t0, Doors # Loads Doors address %
000007f9 : 4bc28293;   % 863:  %
000007fa : 0fc0e217;   % 864: 	la tp, CURRENT_MAP # Loads CURRENT_MAP address %
000007fb : 13c20213;   % 864:  %
000007fc : 0002a503;   % 865: 	lw a0,0(t0)   # Gets current map's doors address %
000007fd : 00054283;   % 866: 	lbu t0,0(a0)  # Loads number of doors in this map %
000007fe : 00150513;   % 867: 	addi a0,a0,1  # Goes to next byte (where doors from current map start) %
000007ff : 00000313;   % 868: 	li t1,0       # Counter for doors %
00000800 : 00054e03;   % 873: 		lbu t3, 0(a0)        # Loads door's X on matrix %
00000801 : 00624583;   % 874: 		lbu a1, 6(tp)        # Loads map's current X on matrix %
00000802 : 40be0eb3;   % 875: 		sub t4,t3,a1         # t4 = Door's X - Map's current X %
00000803 : 01400f13;   % 876: 		li t5,20 # Loads 20 (screen's width related to matrix) %
00000804 : 01eeea63;   % 877: 		bgtu t5,t4,RENDER_DOOR_UPDATE_LOOP_Y_CHECK # If the result is between 0 and 19 (inclusive), continue on loop %
00000805 : 01df1663;   % 879: 			bne t5,t4,GO_TO_NEXT_IN_RENDER_DOOR_UPDATE_LOOP   # If t4 != 20, iterate to next door %
00000806 : 00824e83;   % 880: 				lbu t4, 8(tp)                           # Loads map's X offset %
00000807 : 000e9463;   % 881: 				bnez t4,RENDER_DOOR_UPDATE_LOOP_Y_CHECK # If X offset != 0, continue on this loop %
00000808 : 0b00006f;   % 884: 					j NEXT_IN_RENDER_DOOR_UPDATE_LOOP %
00000809 : 00154383;   % 886: 			lbu t2, 1(a0)    # Loads door's Y on matrix %
0000080a : 00724603;   % 887: 			lbu a2, 7(tp)    # Loads map's current Y on matrix %
0000080b : 40c38eb3;   % 888: 			sub t4,t2,a2     # t4 = Door's top Y - Map's current Y %
0000080c : ffe00f13;   % 889: 			li t5,-2               # Loads -2 (lower threshold) %
0000080d : 01eeafb3;   % 890: 			slt t6,t4,t5           # t6 will be 0 if t4 >= -2 %
0000080e : 00f00f13;   % 891: 			li t5,15  # Loads 15 (screen's height related to matrix) %
0000080f : 01df2f33;   % 892: 			slt t5,t5,t4           # t5 will be 0 if t4 <= 15 %
00000810 : 01ff0f33;   % 893: 			add t5,t5,t6           # t5 = 0 only if -2 <= t4 <= 15  %
00000811 : 000f0463;   % 894: 			beqz t5, RENDER_DOOR_UPDATE_LOOP_Y_CHECK_2 # If -2 <= t4 <= 15, continue loop %
00000812 : 0880006f;   % 896: 				j NEXT_IN_RENDER_DOOR_UPDATE_LOOP %
00000813 : 000ed863;   % 899: 				bge t4,zero,RENDER_DOOR_UPDATE_LOOP_MIDDLE_TOP  # If t4 >= 0, go to RENDER_DOOR_UPDATE_LOOP_MIDDLE_TOP %
00000814 : 00000393;   % 901: 					li t2,0        # starting Y will be set to 0 %
00000815 : 003e8893;   % 902: 					addi a7,t4,3   # and height will be 1 (if t4 = -2) or 2 (if t4 = -1) %
00000816 : 0300006f;   % 903: 					j START_RENDER_DOOR_UPDATE %
00000817 : 00d00f13;   % 907: 					li t5, 13                                  %
00000818 : 01eed663;   % 908: 					bge t4,t5, RENDER_DOOR_UPDATE_LOOP_TOP_1 %
00000819 : 00300893;   % 911: 						li a7, 3    # Height of rendering area will be 3 in order to render it fully %
0000081a : 0200006f;   % 912: 						j START_RENDER_DOOR_UPDATE %
0000081b : 00924703;   % 916: 						lbu a4, 9(tp)   # Loads current Y offset on Map	 %
0000081c : 00f00f13;   % 917: 						li t5,15  # Loads 15 (screen's height related to matrix) %
0000081d : 41df08b3;   % 918: 						sub a7,t5,t4    # a7 = Screen's Height (15) - (Door's Y - Map's current Y)     %
0000081e : 00e02f33;   % 919: 						slt t5,zero,a4  # a4 > 0 ? t5 = 1 : t5 = 0 (only if a4 == 0) %
0000081f : 01e888b3;   % 920: 						add a7,a7,t5    # a7 (height of rendering area) will be increased by 1 if the map's Y offset isn't 0 %
00000820 : 00089463;   % 921: 						bnez a7,START_RENDER_DOOR_UPDATE # If the result isn't equal to 0, continue to rendering this door %
00000821 : 04c0006f;   % 923: 							j NEXT_IN_RENDER_DOOR_UPDATE_LOOP		                         %
00000822 : ff010113;   % 927: 			addi sp,sp,-16 %
00000823 : 00612623;   % 928: 			sw t1,12(sp) %
00000824 : 00512423;   % 929: 			sw t0,8(sp) %
00000825 : 00412223;   % 930: 			sw tp,4(sp) %
00000826 : 00a12023;   % 931: 			sw a0,0(sp) %
00000827 : 00022503;   % 933: 			lw a0,0(tp) %
00000828 : 00824683;   % 936: 			lbu a3, 8(tp)   # Loads current X offset on Map %
00000829 : 00924703;   % 937: 			lbu a4, 9(tp)   # Loads current Y offset on Map	 %
0000082a : 008007b3;   % 938: 			mv a5, s0		# Frame = s0 %
0000082b : 00100813;   % 939: 			li a6, 1        # Width of rendering area will always be 1 %
0000082c : 00000213;   % 943: 			li tp, 0        # Map won't be dislocated		 %
0000082d : 00000317;   % 944: 			call RENDER_MAP %
0000082e : 14c300e7;   % 944:  %
0000082f : 00c12303;   % 946: 			lw t1,12(sp) %
00000830 : 00812283;   % 947: 			lw t0,8(sp) %
00000831 : 00412203;   % 948: 			lw tp,4(sp) %
00000832 : 00012503;   % 949: 			lw a0,0(sp) %
00000833 : 01010113;   % 950: 			addi sp,sp,16 %
00000834 : 00450513;   % 953: 			addi a0,a0,4 # Going to the next door's address                                   %
00000835 : 00130313;   % 954: 			addi t1,t1,1 # Iterating counter by 1                                    %
00000836 : 00535463;   % 955: 			bge t1,t0, END_RENDER_DOOR_UPDATE # If all of the map's doors were checked, end loop                                   %
00000837 : f25ff06f;   % 956: 			j RENDER_DOOR_UPDATE_LOOP # otherwise, go back to the loop's beginning                      %
00000838 : 00012083;   % 960: 			lw ra,0(sp) %
00000839 : 00410113;   % 961: 			addi sp,sp,4 %
0000083a : 00008067;   % 963: 			ret %
0000083b : ffc10113;   % 981: 	addi sp,sp,-4 %
0000083c : 00112023;   % 982: 	sw ra,0(sp) %
0000083d : 0fc0e297;   % 984: 	la t0, Frames # Loads Frames address %
0000083e : 3e828293;   % 984:  %
0000083f : 0fc0e217;   % 985: 	la tp, CURRENT_MAP # Loads CURRENT_MAP address %
00000840 : 02820213;   % 985:  %
00000841 : 0002a503;   % 986: 	lw a0,0(t0)   # Gets current map's frames address %
00000842 : 00054283;   % 987: 	lbu t0,0(a0)  # Loads number of door frames in this map %
00000843 : 00150513;   % 988: 	addi a0,a0,1  # Goes to next byte (where door frames from current map start) %
00000844 : 00000313;   % 989: 	li t1,0       # Counter for door frames %
00000845 : 00054e03;   % 994: 		lbu t3, 0(a0)        # Loads door frame's X on matrix %
00000846 : 00624583;   % 995: 		lbu a1, 6(tp)        # Loads map's current X on matrix %
00000847 : 40be0eb3;   % 996: 		sub t4,t3,a1         # t4 = Door frame's X - Map's current X %
00000848 : 01400f13;   % 997: 		li t5,20 # Loads 20 (screen's width related to matrix) %
00000849 : 01eeea63;   % 998: 		bgtu t5,t4,RENDER_DOOR_FRAMES_LOOP_Y_CHECK # If the result is between 0 and 19 (inclusive), continue on loop %
0000084a : 01df1663;   % 1000: 			bne t5,t4,GO_TO_NEXT_IN_RENDER_DOOR_FRAMES_LOOP   # If t4 != 20, iterate to next door %
0000084b : 00824e83;   % 1001: 				lbu t4, 8(tp)                           # Loads map's X offset %
0000084c : 000e9463;   % 1002: 				bnez t4,RENDER_DOOR_FRAMES_LOOP_Y_CHECK # If X offset != 0, continue on this loop %
0000084d : 0b00006f;   % 1005: 					j NEXT_IN_RENDER_DOOR_FRAMES_LOOP %
0000084e : 00154383;   % 1007: 			lbu t2, 1(a0)    # Loads door frame's Y on matrix %
0000084f : 00724603;   % 1008: 			lbu a2, 7(tp)    # Loads map's current Y on matrix %
00000850 : 40c38eb3;   % 1009: 			sub t4,t2,a2     # t4 = Door frame's top Y - Map's current Y %
00000851 : ffe00f13;   % 1010: 			li t5,-2               # Loads -2 (lower threshold) %
00000852 : 01eeafb3;   % 1011: 			slt t6,t4,t5           # t6 will be 0 if t4 >= -2 %
00000853 : 00f00f13;   % 1012: 			li t5,15  # Loads 15 (screen's height related to matrix) %
00000854 : 01df2f33;   % 1013: 			slt t5,t5,t4           # t5 will be 0 if t4 <= 15 %
00000855 : 01ff0f33;   % 1014: 			add t5,t5,t6           # t5 = 0 only if -2 <= t4 <= 15  %
00000856 : 000f0463;   % 1015: 			beqz t5, RENDER_DOOR_FRAMES_LOOP_Y_CHECK_2 # If -2 <= t4 <= 15, continue loop %
00000857 : 0880006f;   % 1017: 				j NEXT_IN_RENDER_DOOR_FRAMES_LOOP %
00000858 : 000ed863;   % 1020: 				bge t4,zero,RENDER_DOOR_FRAMES_LOOP_MIDDLE_TOP  # If t4 >= 0, go to RENDER_DOOR_FRAMES_LOOP_MIDDLE_TOP %
00000859 : 00000393;   % 1022: 					li t2,0        # starting Y will be set to 0 %
0000085a : 003e8893;   % 1023: 					addi a7,t4,3   # and height will be 1 (if t4 = -2) or 2 (if t4 = -1) %
0000085b : 0300006f;   % 1024: 					j START_RENDER_DOOR_FRAMES %
0000085c : 00d00f13;   % 1028: 					li t5, 13                                  %
0000085d : 01eed663;   % 1029: 					bge t4,t5, RENDER_DOOR_FRAMES_LOOP_TOP_1 %
0000085e : 00300893;   % 1032: 						li a7, 3    # Height of rendering area will be 3 in order to render it fully %
0000085f : 0200006f;   % 1033: 						j START_RENDER_DOOR_FRAMES %
00000860 : 00924703;   % 1037: 						lbu a4, 9(tp)   # Loads current Y offset on Map	 %
00000861 : 00f00f13;   % 1038: 						li t5,15  # Loads 15 (screen's height related to matrix) %
00000862 : 41df08b3;   % 1039: 						sub a7,t5,t4    # a7 = Screen's Height (15) - (Door frame's Y - Map's current Y)     %
00000863 : 00e02f33;   % 1040: 						slt t5,zero,a4  # a4 > 0 ? t5 = 1 : t5 = 0 (only if a4 == 0) %
00000864 : 01e888b3;   % 1041: 						add a7,a7,t5    # a7 (height of rendering area) will be increased by 1 if the map's Y offset isn't 0 %
00000865 : 00089463;   % 1042: 						bnez a7,START_RENDER_DOOR_FRAMES # If the result isn't equal to 0, continue to rendering this door frame %
00000866 : 04c0006f;   % 1044: 							j NEXT_IN_RENDER_DOOR_FRAMES_LOOP		                         %
00000867 : ff010113;   % 1048: 			addi sp,sp,-16 %
00000868 : 00612623;   % 1049: 			sw t1,12(sp) %
00000869 : 00512423;   % 1050: 			sw t0,8(sp) %
0000086a : 00412223;   % 1051: 			sw tp,4(sp) %
0000086b : 00a12023;   % 1052: 			sw a0,0(sp) %
0000086c : 00022503;   % 1054: 			lw a0,0(tp) %
0000086d : 00824683;   % 1057: 			lbu a3, 8(tp)   # Loads current X offset on Map %
0000086e : 00924703;   % 1058: 			lbu a4, 9(tp)   # Loads current Y offset on Map	 %
0000086f : 008007b3;   % 1059: 			mv a5, s0		# Frame = s0 %
00000870 : 00100813;   % 1060: 			li a6, 1        # Width of rendering area will always be 1 %
00000871 : 00000213;   % 1064: 			li tp, 0        # Map won't be dislocated		 %
00000872 : 00000317;   % 1065: 			call RENDER_MAP %
00000873 : 038300e7;   % 1065:  %
00000874 : 00c12303;   % 1067: 			lw t1,12(sp) %
00000875 : 00812283;   % 1068: 			lw t0,8(sp) %
00000876 : 00412203;   % 1069: 			lw tp,4(sp) %
00000877 : 00012503;   % 1070: 			lw a0,0(sp) %
00000878 : 01010113;   % 1071: 			addi sp,sp,16 %
00000879 : 00650513;   % 1074: 			addi a0,a0,6 # Going to the next door frame's address                                   %
0000087a : 00130313;   % 1075: 			addi t1,t1,1 # Iterating counter by 1                                    %
0000087b : 00535463;   % 1076: 			bge t1,t0, END_RENDER_DOOR_FRAMES # If all of the map's doors were checked, end loop                                   %
0000087c : f25ff06f;   % 1077: 			j RENDER_DOOR_FRAMES_LOOP # otherwise, go back to the loop's beginning                      %
0000087d : 00012083;   % 1081: 			lw ra,0(sp) %
0000087e : 00410113;   % 1082: 			addi sp,sp,4 %
0000087f : 00008067;   % 1084: 			ret %
00000880 : fec10113;   % 1125: 	addi sp,sp,-20 %
00000881 : 00112823;   % 1126: 	sw ra,16(sp) %
00000882 : 01312623;   % 1127: 	sw s3,12(sp) %
00000883 : 01212423;   % 1128: 	sw s2,8(sp) %
00000884 : 00912223;   % 1129: 	sw s1,4(sp) %
00000885 : 00812023;   % 1130: 	sw s0,0(sp) %
00000886 : 00350293;   % 1132: 	addi t0,a0,3 	# skips first 3 bytes of information (goes to the actual matrix) %
00000887 : 00b28433;   % 1133: 	add s0, t0, a1 	# s0 = Matrix Address + Starting X on Matrix %
00000888 : 00154483;   % 1134: 	lbu s1,1(a0)	# s1 = matrix width %
00000889 : 02c482b3;   % 1135: 	mul t0,s1,a2    # t0 = Matrix Width x Starting Y on Matrix %
0000088a : 00540433;   % 1136: 	add s0, s0, t0	# s0 = Address to current X and Y on Matrix %
0000088b : 010e09b3;   % 1139: 	add s3,t3,a6 	# s3 will be compared with t3 (column counter) to go to next line %
0000088c : 000e0a63;   % 1140: 	beqz t3,RENDER_MAP_NoTrailX %
0000088d : 40be0e33;   % 1142: 	sub t3,t3,a1	# t3 now is the column counter related to the screen matrix %
0000088e : 010e09b3;   % 1143: 	add s3,t3,a6 %
0000088f : 01c40433;   % 1144: 	add s0, s0, t3 	# s0 = Matrix Address + Current X on Matrix %
00000890 : 0200006f;   % 1145: 	j RENDER_MAP_GetCurrentY %
00000891 : 00068e63;   % 1148: 	beqz a3, RENDER_MAP_GetCurrentY # If there's no X offset %
00000892 : 01400293;   % 1149: 	li t0, 20 %
00000893 : 00584a63;   % 1150: 	blt a6,t0, RENDER_MAP_GetCurrentY   # If width of rendering area is smaller than the screen's width, ignore %
00000894 : 00404863;   % 1151: 	blt zero,tp, RENDER_MAP_GetCurrentY # If map is dislocated, ignore the next step %
00000895 : 01058333;   % 1152: 	add t1,a1,a6    # t1 = Starting X + Width in tiles %
00000896 : 00930463;   % 1153: 	beq t1,s1, RENDER_MAP_GetCurrentY   # If map is on furthest X to the right, don't increase width %
00000897 : 00128993;   % 1154: 	addi s3,t0,1	# if rendering a full screen (20 wide) with offset, will need to render 21 tiles %
00000898 : 01138933;   % 1157: 	add s2,t2,a7 	# s2 will be compared with t2 (column counter) to go to next line %
00000899 : 00038c63;   % 1158: 	beqz t2,RENDER_MAP_NoTrailY %
0000089a : 40c383b3;   % 1160: 	sub t2,t2,a2	# t2 now is the column counter related to the screen matrix %
0000089b : 01138933;   % 1161: 	add s2,t2,a7 %
0000089c : 027482b3;   % 1162: 	mul t0,s1,t2    # t0 = Matrix Width x Current Y on Matrix %
0000089d : 00540433;   % 1163: 	add s0, s0, t0	# s0 = Address to current X and Y on Matrix %
0000089e : 0140006f;   % 1164: 	j RENDER_MAP_LOOP %
0000089f : 00070863;   % 1167: 	beqz a4, RENDER_MAP_LOOP # If there's an X offset %
000008a0 : 00f00293;   % 1168: 	li t0, 15 %
000008a1 : 0058c463;   % 1169: 	blt a7,t0 RENDER_MAP_LOOP # If height of rendering area is smaller than the screen's height, ignore %
000008a2 : 00128913;   % 1170: 	addi s2,t0,1	# if rendering a full screen (15 wide) with offset, will need to render 16 tiles %
000008a3 : 00044303;   % 1173: 	lbu t1,0(s0)	# loads byte stored on matrix for checking what is the tile %
000008a4 : 00031463;   % 1174: 	bnez t1,NotBackground %
000008a5 : 1980006f;   % 1175: 	j CONTINUE_RENDER_MAP %
000008a6 : 02800293;   % 1178: 		li t0, 40      # Value where doors start %
000008a7 : 0e535263;   % 1179: 		bge t1, t0, RENDER_DOOR # If it's a door %
000008a8 : 00100293;   % 1180: 		li t0,1 %
000008a9 : 02628063;   % 1181: 		beq t0,t1, RENDER_BREAK_BLOCK %
000008aa : 0fc0e297;   % 1182: 		la t0, Tileset # Loads Tileset address to t0 %
000008ab : 58c28293;   % 1182:  %
000008ac : fff30313;   % 1183: 		addi t1,t1,-1  # t1 = Tile Number - 1 (so that if t1 = 1, 0 tiles will be skipped) %
000008ad : 00831313;   % 1184: 		slli t1,t1,8   # t1 = (Tile Number - 1) x 256 %
000008ae : 006282b3;   % 1185: 		add t0,t0,t1   # t0 will skip (Tile Number - 1) x 256 bytes (Tile Number - 1 tiles) %
000008af : 00000eb3;   % 1186: 		mv t4,zero     # t4 will hold the tile's sprite status (which will be zero) %
000008b0 : 16c0006f;   % 1187: 		j CONTINUE_RENDER_MAP %
000008b1 : 0fc0ee97;   % 1190: 		la t4,NEXT_MAP # Loads NEXT_MAP address %
000008b2 : e6ce8e93;   % 1190:  %
000008b3 : 00aecf03;   % 1191: 		lbu t5,10(t4)  # Gets the Render Next Map byte	 %
000008b4 : 000f0a63;   % 1192: 		beqz t5, RENDER_BREAK_BLOCK_CURRENT   # If Render Next Map Door == 0, render current map's door %
000008b5 : 0fc0e297;   % 1194: 			la t0,Blocks_Next  # Loads blocks address %
000008b6 : f4828293;   % 1194:  %
000008b7 : 0002a283;   % 1195: 			lw t0,0(t0)        # and loads the breakable block address %
000008b8 : 0100006f;   % 1196: 			j CONTINUE_RENDER_BREAK_BLOCK %
000008b9 : 0fc0e297;   % 1199: 			la t0,Blocks  # Loads blocks address %
000008ba : f3428293;   % 1199:  %
000008bb : 0002a283;   % 1200: 			lw t0,0(t0)   # and loads the breakable block address %
000008bc : 08028463;   % 1204: 			beqz t0,RENDER_BREAK_BLOCK_BACKGROUND %
000008bd : 0012cf03;   % 1207: 			lbu t5,1(t0)  # Gets Y where blocks start %
000008be : 41e38f33;   % 1208: 			sub t5,t2,t5  # Sets current Y to be related to Y where blocks start %
000008bf : 00cf0f33;   % 1209: 			add t5,t5,a2  # Corrects Y adding starting Y %
000008c0 : 0022ce83;   % 1211: 			lbu t4,2(t0)  # Loads width %
000008c1 : 03ee8eb3;   % 1212: 			mul t4,t4,t5  # and multiplies it by current Y	 %
000008c2 : 0002cf03;   % 1214: 			lbu t5,0(t0)  # Gets X where blocks start %
000008c3 : 41ee0f33;   % 1215: 			sub t5,t3,t5  # Sets current X to be related to X where blocks start %
000008c4 : 00bf0f33;   % 1216: 			add t5,t5,a1  # Corrects X adding starting X %
000008c5 : 01df0eb3;   % 1218: 			add t4,t5,t4  # adds X to it %
000008c6 : 00428293;   % 1220: 			addi t0,t0,4  # Skip first 4 information bytes %
000008c7 : 005e82b3;   % 1221: 			add t0,t4,t0  # and adds t4 to it %
000008c8 : 0002ce83;   % 1223: 			lbu t4,0(t0)  # Loads t0  %
000008c9 : 000e9a63;   % 1224: 			bnez t4, RENDER_BREAK_BLOCK_CHECK_EXPLOSION # If block isn't full, see if it's exploding %
000008ca : 0fc0e297;   % 1225: 				la t0, Tileset # Loads Tileset address to t0 %
000008cb : 50c28293;   % 1225:  %
000008cc : 00000eb3;   % 1226: 				mv t4,zero     # t4 will hold the tile's sprite status (which will be zero) %
000008cd : 0f80006f;   % 1227: 				j CONTINUE_RENDER_MAP  # Otherwise, render it %
000008ce : 00100f13;   % 1229: 			RENDER_BREAK_BLOCK_CHECK_EXPLOSION: li t5,1 %
000008cf : 01ee9e63;   % 1230: 			bne t4, t5, RENDER_BREAK_BLOCK_CHECK_EXPLOSION_2 # If block isn't in the first phase of breaking, see if it's in the second phase %
000008d0 : 001e8e93;   % 1231: 				addi t4,t4,1 # Sets block up for next phase %
000008d1 : 01d28023;   % 1232: 				sb t4,0(t0)  # and stores it %
000008d2 : 0fc0e297;   % 1233: 				la t0, BreakBlock_Break1 # Loads BreakBlock_Break1 address to t0 %
000008d3 : 2ec28293;   % 1233:  %
000008d4 : 00000eb3;   % 1234: 				mv t4,zero               # t4 will hold the tile's sprite status (which will be zero) %
000008d5 : 0d80006f;   % 1235: 				j CONTINUE_RENDER_MAP    # Otherwise, render it %
000008d6 : 00100f13;   % 1237: 			RENDER_BREAK_BLOCK_CHECK_EXPLOSION_2: li t5,1 %
000008d7 : 01ee9e63;   % 1238: 			bne t4, t5, RENDER_BREAK_BLOCK_BACKGROUND # If block is destroyed, don't render it %
000008d8 : 001e8e93;   % 1239: 				addi t4,t4,1 # Sets block up for next phase %
000008d9 : 01d28023;   % 1240: 				sb t4,0(t0)  # and stores it %
000008da : 0fc0e297;   % 1241: 				la t0, BreakBlock_Break2 # Loads BreakBlock_Break2 address to t0 %
000008db : 3cc28293;   % 1241:  %
000008dc : 00000eb3;   % 1242: 				mv t4,zero               # t4 will hold the tile's sprite status (which will be zero) %
000008dd : 0b80006f;   % 1243: 				j CONTINUE_RENDER_MAP    # Otherwise, render it %
000008de : 00000313;   % 1246: 				li t1,0   # Won't render %
000008df : 0b00006f;   % 1247: 				j CONTINUE_RENDER_MAP %
000008e0 : ffc10113;   % 1251: 		addi sp,sp,-4 %
000008e1 : 00412023;   % 1252: 		sw tp,0(sp) %
000008e2 : 00000fb3;   % 1255: 		mv t6,zero     # Resets counter %
000008e3 : 0fc0ee97;   % 1256: 		la t4,NEXT_MAP # Loads NEXT_MAP address %
000008e4 : da4e8e93;   % 1256:  %
000008e5 : 00aecf03;   % 1257: 		lbu t5,10(t4)  # Gets the Render Next Map Door byte	 %
000008e6 : 000f0e63;   % 1258: 		beqz t5, RENDER_DOOR_CURRENT   # If Render Next Map Door == 0, render current map's door %
000008e7 : 0fc0ee97;   % 1260: 			la t4, Doors_Next # Loads Doors_Next address %
000008e8 : 104e8e93;   % 1260:  %
000008e9 : 000eae83;   % 1261: 			lw t4,0(t4)	      # Gets the next map's door address %
000008ea : 000ecf03;   % 1262: 			lbu t5,0(t4)      # Gets the number of doors in this map %
000008eb : 001e8e93;   % 1263: 			addi t4,t4,1      # Starting address of the map's first door %
000008ec : 0180006f;   % 1264: 			j RENDER_DOOR_LOOP %
000008ed : 0fc0ee97;   % 1267: 			la t4, Doors # Loads Doors address %
000008ee : 0e8e8e93;   % 1267:  %
000008ef : 000eae83;   % 1268: 			lw t4,0(t4)	 # Gets the current map's door address %
000008f0 : 000ecf03;   % 1269: 			lbu t5,0(t4) # Gets the number of doors in this map %
000008f1 : 001e8e93;   % 1270: 			addi t4,t4,1 # Starting address of the map's first door %
000008f2 : 000ec203;   % 1274: 			lbu tp, 0(t4) # Loads door's X on matrix %
000008f3 : 01c582b3;   % 1275: 			add t0,a1,t3  # Gets current X on map matrix %
000008f4 : 02521e63;   % 1276: 			bne tp, t0, NEXT_IN_DOOR_LOOP # If door's X isn't the same as current X, skip this door %
000008f5 : 001ec203;   % 1277: 			lbu tp, 1(t4) # Loads door's Y on matrix %
000008f6 : 007602b3;   % 1278: 			add t0,a2,t2  # Gets current Y on map matrix %
000008f7 : 40428233;   % 1279: 			sub tp,t0,tp  # tp needs to be equal to 0, 1 or 2 in order to be a tile from this door %
000008f8 : 00200293;   % 1280: 			li t0,2 # 2 is the threshold to be compared with tp %
000008f9 : 0242e463;   % 1281: 			bgtu tp,t0, NEXT_IN_DOOR_LOOP # If current Y is above the door's uppermost Y or bellow it's downmost Y, skip this door %
000008fa : 002ec203;   % 1283: 			lbu tp, 2(t4) # Loads door's state %
000008fb : 02525863;   % 1284: 			bge tp,t0, END_RENDER_DOOR_LOOP # If door is open (state = 2 -- >= 2 for containing errors) %
000008fc : 0fc0e297;   % 1286: 				la t0, Tileset # Loads Tileset address to t0 %
000008fd : 44428293;   % 1286:  %
000008fe : fff30313;   % 1287: 				addi t1,t1,-1  # t1 = Tile Number - 1 (so that if t1 = 1, 0 tiles will be skipped) %
000008ff : 00430333;   % 1288: 				add t1,t1,tp   # t1 will change if door is opening (tp = 1) %
00000900 : 00831313;   % 1289: 				slli t1,t1,8   # t1 = (Tile Number - 1) x 256 %
00000901 : 006282b3;   % 1290: 				add t0,t0,t1   # t0 will skip (Tile Number - 1) x 256 bytes (Tile Number - 1 tiles)  %
00000902 : 0180006f;   % 1291: 				j END_RENDER_DOOR_LOOP_GLOBAL %
00000903 : 004e8e93;   % 1293: 				addi t4,t4,4 # Going to the next door's address %
00000904 : 001f8f93;   % 1294: 				addi t6,t6,1 # Iterating counter by 1 %
00000905 : 01efd463;   % 1295: 				bge t6,t5, END_RENDER_DOOR_LOOP # If all of the map's doors were checked, end loop %
00000906 : fb1ff06f;   % 1296: 				j RENDER_DOOR_LOOP # otherwise, go back to the loop's beginning %
00000907 : 00000333;   % 1299: 		mv t1,zero %
00000908 : 00000eb3;   % 1302: 		mv t4,zero    # t4 will hold the tile's sprite status (which will be zero) %
00000909 : 00012203;   % 1303: 		lw tp,0(sp) %
0000090a : 00410113;   % 1304: 		addi sp,sp,4 %
0000090b : fc810113;   % 1309: 	addi sp,sp,-56 %
0000090c : 03412a23;   % 1310: 	sw s4,52(sp) %
0000090d : 03312823;   % 1311: 	sw s3,48(sp) %
0000090e : 03212623;   % 1312: 	sw s2,44(sp) %
0000090f : 02912423;   % 1313: 	sw s1,40(sp) %
00000910 : 03112223;   % 1314: 	sw a7,36(sp) %
00000911 : 03012023;   % 1315: 	sw a6,32(sp) %
00000912 : 00e12e23;   % 1316: 	sw a4,28(sp) %
00000913 : 00d12c23;   % 1317: 	sw a3,24(sp) %
00000914 : 00c12a23;   % 1318: 	sw a2,20(sp) %
00000915 : 00b12823;   % 1319: 	sw a1,16(sp) %
00000916 : 00a12623;   % 1320: 	sw a0,12(sp) %
00000917 : 00712423;   % 1321: 	sw t2,8(sp) %
00000918 : 01c12223;   % 1322: 	sw t3,4(sp) %
00000919 : 00412023;   % 1323: 	sw tp,0(sp) %
0000091a : 00500533;   % 1326: 	mv a0, t0 # Moves t0 (storing tile address) to a0 %
0000091b : 01d00833;   % 1327: 	mv a6,t4  # Moves tmv t4 (tile's sprite status) to a6 %
0000091c : 01000293;   % 1330: 	li t0, 16 	# Tile size = 16 %
0000091d : 01c20fb3;   % 1331: 	add t6,tp,t3        # t6 gets t3 (current X) + tp (X dislocation) %
0000091e : 025f8eb3;   % 1332: 	mul t4,t6,t0		# t4 gets the X value relative to the screen ((t3 + tp) * tile size) %
0000091f : 02538f33;   % 1333: 	mul t5,t2,t0		# t5 gets the Y value relative to the screen (t2 (current Y) * tile size) %
00000920 : 00000f93;   % 1335: 	li t6,0 %
00000921 : 00069463;   % 1336: 	bnez a3, X_Offset 	# If there's a X offset %
00000922 : 02c0006f;   % 1337: 	j Check_Y_Offset %
00000923 : 004e02b3;   % 1339: 		add t0,t3,tp %
00000924 : 00029663;   % 1340: 		bnez t0, TryRightOffset  # If t3 (current colum, i.e., current X) = 0, it's on the left border %
00000925 : 00100f93;   % 1341: 		li t6,1			         # t6 = 1: Cropping leftmost tile %
00000926 : 0400006f;   % 1342: 		j START_RENDER_MAP  	 # start rendering process %
00000927 : 01400293;   % 1344: 		li t0, 20    # screen width related to matrix = 20 %
00000928 : 41c282b3;   % 1345: 		sub t0,t0,t3             # t0 = screen width - t3 (current X)  %
00000929 : 404282b3;   % 1346: 		sub t0,t0,tp             # t0 = screen width - t3 (current X) - tp (X dislocation)  %
0000092a : 00501463;   % 1347: 		bne zero, t0, NoX_Offset # If t0 <= 0 (t3 + tp >= 20), it's on the right border %
0000092b : 00200f93;   % 1348: 		li t6,2			 # t6 = 2: Cropping rightmost tile %
0000092c : 0280006f;   % 1350: 		j START_RENDER_MAP	 # start rendering process %
0000092d : 00071463;   % 1353: 	bnez a4, Y_Offset		 # Or a Y offset, go to offset operations %
0000092e : 0200006f;   % 1354: 	j START_RENDER_MAP %
0000092f : 00039663;   % 1357: 		bnez t2, TryBottomOffset # If t3 (current colum, i.e., current X) = 0, it's on the top border %
00000930 : 00100f93;   % 1358: 		li t6,1			 # t6 = 1: Cropping uppermost tile %
00000931 : 0140006f;   % 1359: 		j START_RENDER_MAP	 # start rendering process %
00000932 : 00f00293;   % 1361: 		li t0, 15   # screen height related to matrix = 15 %
00000933 : 00539463;   % 1362: 		bne t2, t0, NoY_Offset   # If t2 = 15, it's on the lower border %
00000934 : 00200f93;   % 1363: 		li t6,2			 # t6 = 2: Cropping lowermost tile %
00000935 : 0040006f;   % 1365: 		j START_RENDER_MAP	 # start rendering process %
00000936 : 06031863;   % 1368: 	bnez t1,NormalRender %
00000937 : 00000513;   % 1370: 		li a0, 0x00 		# Black %
00000938 : 01d005b3;   % 1371: 		mv a1, t4		# Top Left X %
00000939 : 01e00633;   % 1372: 		mv a2, t5		# Top Left Y	 %
0000093a : 00000833;   % 1373: 		mv a6, zero %
0000093b : 000f9463;   % 1375: 		bnez t6, CropColor  %
0000093c : 03c0006f;   % 1376: 		j NoCropColor %
0000093d : 00100813;   % 1378: 		li a6, 1 %
0000093e : ffff8f93;   % 1379: 		addi t6,t6,-1 %
0000093f : 000f9a63;   % 1380: 		bnez t6, RightBottomColorCrop %
00000940 : 01000293;   % 1382: 				li t0, 16	 %
00000941 : 40d286b3;   % 1383: 				sub a3,t0, a3		# a3 will hold rendering widht that is equal to the tile size (16) - X offset %
00000942 : 40e28733;   % 1384: 				sub a4,t0, a4		# a4 will hold rendering height that is equal to the tile size (16) - Y offset %
00000943 : 0300006f;   % 1385: 				j StartColorRender %
00000944 : 40d585b3;   % 1387: 				sub a1,a1,a3		# a1 will shift left the ammount of a3 (currently X offset)  %
00000945 : 40e60633;   % 1388: 				sub a2,a2,a4		# a2 will shift up the ammount of a4 (currently Y offset) %
00000946 : 00069463;   % 1390: 				bnez a3, CheckYColor # If X offset (a3) isn't zero, the widht for rendering the cropped tile will be the X offset %
00000947 : 01000693;   % 1391: 				li a3, 16	    # otherwise, it'll be the tile size %
00000948 : 00071463;   % 1393: 				bnez a4, EndRightBottomCropColor # If Y offset (a4) isn't zero, the widht for rendering the cropped tile will be the Y offset %
00000949 : 01000713;   % 1394: 				li a4, 16	    # otherwise, it'll be the tile size %
0000094a : 0140006f;   % 1396: 				j StartColorRender %
0000094b : 40d585b3;   % 1398: 			sub a1,a1,a3		# a1 will shift left the ammount of a3 (currently X offset)  %
0000094c : 40e60633;   % 1399: 			sub a2,a2,a4		# a2 will shift up the ammount of a4 (currently Y offset)	 %
0000094d : 01000693;   % 1400: 			li a3, 16	# Tile Width (Screen) %
0000094e : 01000713;   % 1401: 			li a4, 16	# Tile Height (Screen)	 %
0000094f : fffff317;   % 1404: 		call RENDER_COLOR %
00000950 : 47c300e7;   % 1404:  %
00000951 : 0840006f;   % 1405: 		j EndRender %
00000952 : 01d005b3;   % 1409: 		mv a1, t4		# Top Left X where tile will start rendering %
00000953 : 01e00633;   % 1410: 		mv a2, t5		# Top Left Y where tile will start rendering			 %
00000954 : 000f9463;   % 1413: 		bnez t6, Continue_Crop  %
00000955 : 0580006f;   % 1414: 		j Skip_Offset %
00000956 : 00100893;   % 1416: 		li a7,1			# Cropped Render operations %
00000957 : ffff8f93;   % 1417: 		addi t6,t6,-1		# After this, t6 = 0 or t6 = 1 %
00000958 : 020f9063;   % 1418: 		bnez t6, RightBottomCrop %
00000959 : 00d004b3;   % 1420: 			mv s1, a3		# s1 will store the X offset (where rendering will start from) %
0000095a : 00e00933;   % 1421: 			mv s2, a4		# s2 will store the Y offset (where rendering will start from) %
0000095b : 01000993;   % 1422: 			li s3, 16	# s3 = 16 %
0000095c : 01000a13;   % 1423: 			li s4, 16	# s4 = 16 %
0000095d : 409986b3;   % 1424: 			sub a3,s3, s1		# a3 will hold rendering widht that is equal to the tile size (16) - X offset %
0000095e : 41298733;   % 1425: 			sub a4,s3, s2		# a4 will hold rendering height that is equal to the tile size (16) - Y offset %
0000095f : 0440006f;   % 1426: 			j Start_NormalRender %
00000960 : 000004b3;   % 1428: 			mv s1,zero		# s1 = 0 (rendering will start from the left) %
00000961 : 00000933;   % 1429: 			mv s2,zero		# s2 = 0 (rendering will start from the top) %
00000962 : 01000993;   % 1430: 			li s3, 16	# s3 = 16 %
00000963 : 01000a13;   % 1431: 			li s4, 16	# s4 = 16 %
00000964 : 40d585b3;   % 1432: 			sub a1,a1,a3		# a1 will shift left the ammount of a3 (currently X offset)  %
00000965 : 40e60633;   % 1433: 			sub a2,a2,a4		# a2 will shift up the ammount of a4 (currently Y offset) %
00000966 : 00069463;   % 1435: 			bnez a3, CheckY # If X offset (a3) isn't zero, the widht for rendering the cropped tile will be the X offset %
00000967 : 01000693;   % 1436: 			li a3, 16	    # otherwise, it'll be the tile size %
00000968 : 00071463;   % 1438: 			bnez a4, EndRightBottomCrop # If Y offset (a4) isn't zero, the widht for rendering the cropped tile will be the Y offset %
00000969 : 01000713;   % 1439: 			li a4, 16	    # otherwise, it'll be the tile size %
0000096a : 0180006f;   % 1441: 			j Start_NormalRender %
0000096b : 40d585b3;   % 1444: 		sub a1,a1,a3		# a1 will shift left the ammount of a3 (currently X offset)  %
0000096c : 40e60633;   % 1445: 		sub a2,a2,a4		# a2 will shift up the ammount of a4 (currently Y offset)  %
0000096d : 01000693;   % 1446: 		li a3, 16	# Tile Width (Relative to Screen) %
0000096e : 01000713;   % 1447: 		li a4, 16	# Tile Height (Relative to Screen) %
0000096f : 000008b3;   % 1448: 		mv a7,zero		# Normal Render operations %
00000970 : fffff317;   % 1450: 		call RENDER_WORD %
00000971 : 36c300e7;   % 1450:  %
00000972 : 03412a03;   % 1454: 	lw s4,52(sp) %
00000973 : 03012983;   % 1455: 	lw s3,48(sp) %
00000974 : 02c12903;   % 1456: 	lw s2,44(sp) %
00000975 : 02812483;   % 1457: 	lw s1,40(sp) %
00000976 : 02412883;   % 1458: 	lw a7,36(sp) %
00000977 : 02012803;   % 1459: 	lw a6,32(sp) %
00000978 : 01c12703;   % 1460: 	lw a4,28(sp) %
00000979 : 01812683;   % 1461: 	lw a3,24(sp) %
0000097a : 01412603;   % 1462: 	lw a2,20(sp) %
0000097b : 01012583;   % 1463: 	lw a1,16(sp) %
0000097c : 00c12503;   % 1464: 	lw a0,12(sp) %
0000097d : 00812383;   % 1465: 	lw t2,8(sp) %
0000097e : 00412e03;   % 1466: 	lw t3,4(sp) %
0000097f : 00012203;   % 1467: 	lw tp,0(sp) %
00000980 : 03810113;   % 1468: 	addi sp,sp,56 %
00000981 : 001e0e13;   % 1471: 	addi t3,t3,1	# Increments column counter (current X on Matrix) %
00000982 : 00140413;   % 1472: 	addi s0,s0,1	# Goes to next byte %
00000983 : 013e5463;   % 1473: 	bge t3,s3,CONTINUE_LINE	# if column counter >= width, repeat %
00000984 : c7dff06f;   % 1474: 	j RENDER_MAP_LOOP	# if column counter < width, repeat %
00000985 : 00940433;   % 1477: 		add s0,s0,s1	# s0 = Current Address on Matrix + Matrix Width %
00000986 : 01400293;   % 1478: 		li t0, 20 %
00000987 : 00585863;   % 1479: 		bge a6,t0, MINUS_WIDTH # If width = 20, probably not on remove trail mode %
00000988 : 41040433;   % 1480: 		sub s0,s0,a6	# s0 = New Current Address on Matrix  %
00000989 : 410e0e33;   % 1481: 		sub t3,t3,a6	# t3 = 0 (resets column counter) %
0000098a : 00c0006f;   % 1482: 		j CONTINUE_LINE2 %
0000098b : 41340433;   % 1484: 		sub s0,s0,s3 %
0000098c : 00000e33;   % 1485: 		mv t3,zero	# t3 = 0 (resets column counter) %
0000098d : 00138393;   % 1488: 		addi t2,t2,1	# Increments line counter (current Y on Matrix) %
0000098e : 0123d463;   % 1489: 		bge t2,s2,CONTINUE_COLUMN # If height > line counter, repeat %
0000098f : c51ff06f;   % 1490: 		j RENDER_MAP_LOOP	  # Return to beggining of loop %
00000990 : 01012083;   % 1493: 		lw ra,16(sp)	 %
00000991 : 00c12983;   % 1494: 		lw s3,12(sp) %
00000992 : 00812903;   % 1495: 		lw s2,8(sp) %
00000993 : 00412483;   % 1496: 		lw s1,4(sp) %
00000994 : 00012403;   % 1497: 		lw s0,0(sp) %
00000995 : 01410113;   % 1498: 		addi sp,sp,20 %
00000996 : 00008067;   % 1500: 		ret %
00000997 : 0fc0e517;   % 29:     la a0, BEAMS_ARRAY      # Loads BEAMS array %
00000998 : b1450513;   % 29:  %
00000999 : 00054283;   % 30:     lbu t0,0(a0)            # Loads cooldown byte %
0000099a : 00028463;   % 31:     beqz t0,CONTINUE_BEAM_SPAWN # If on zero, spawn %
0000099b : 0e40006f;   % 32:         j END_BEAM_SPAWN_LOOP %
0000099c : 0fc0e597;   % 34:     la a1, PLYR_POS         # Loads Player Pos address %
0000099d : ace58593;   % 34:  %
0000099e : 00300613;   % 35:     li a2, 3     # Loads total number of beams %
0000099f : 00000693;   % 36:     li a3,0                 # Resets counter %
000009a0 : 00150513;   % 38:     addi a0,a0,1            # Skips cooldown byte %
000009a1 : 00054283;   % 40:         lbu t0, 0(a0)       # Loads enable byte %
000009a2 : 00028463;   % 41:         beqz t0, BEAM_SPAWN_LOOP_ACTIVATE # If current beam is disabled, activate it %
000009a3 : 0b40006f;   % 42:             j NEXT_IN_BEAM_SPAWN_LOOP     # Otherwise, go to next one in loop %
000009a4 : 0fc0e297;   % 46:             la t0, BEAMS_ARRAY            # Loads BEAMS array %
000009a5 : ae028293;   % 46:  %
000009a6 : 00200313;   % 47:             li t1, 2  # gets cooldown value %
000009a7 : 00628023;   % 48:             sb t1,0(t0)                   # stores it %
000009a8 : 0065c283;   % 51:             lbu t0, 6(a1)    # Loads player's X offset %
000009a9 : 005501a3;   % 52:             sb t0, 3(a0)     # and stores it on beam's X offset %
000009aa : 0075c283;   % 54:             lbu t0, 7(a1)    # Loads player's Y offset %
000009ab : 00550223;   % 55:             sb t0, 4(a0)     # and stores it on beam's Y offset %
000009ac : 00100293;   % 57:             li t0,1          # Loads 1 (Enabled)  %
000009ad : 00550023;   % 58:             sb t0,0(a0)      # stores in beam's enable byte %
000009ae : 00e5c283;   % 61:             lbu t0, 14(a1)   # Loads vertical direction %
000009af : 02028663;   % 62:             beqz t0, BEAM_SPAWN_LOOP_ACTIVATE_CHECK_X_AXIS # If looking foward %
000009b0 : 0085c283;   % 65:                 lbu t0, 8(a1)    # Loads player's X %
000009b1 : 005502a3;   % 66:                 sb t0, 5(a0)     # and stores it on beam's X %
000009b2 : 00550323;   % 67:                 sb t0, 6(a0)     # and on beam's old X %
000009b3 : 00a5c283;   % 70:                 lbu t0, 10(a1)   # Loads player's Y %
000009b4 : fff28293;   % 71:                 addi t0,t0,-1    # goes up 1 tile %
000009b5 : 005503a3;   % 72:                 sb t0, 7(a0)     # and stores it on beam's Y %
000009b6 : 00550423;   % 73:                 sb t0, 8(a0)     # and on beam's old Y %
000009b7 : 00000293;   % 76:                 li t0,0          # Loads 0 (Up) %
000009b8 : 005500a3;   % 77:                 sb t0,1(a0)      # and stores it on the direction byte %
000009b9 : 06c0006f;   % 78:                 j END_BEAM_SPAWN_LOOP # break loop %
000009ba : 00d5c283;   % 82:             lbu t0, 13(a1)   # Loads horizontal direction %
000009bb : 02029663;   % 83:             bnez t0,BEAM_SPAWN_LOOP_ACTIVATE_LEFT_AXIS   # If player is looking left %
000009bc : 0085c283;   % 86:                 lbu t0, 8(a1)    # Loads player's X %
000009bd : 00128293;   % 87:                 addi t0,t0,1     # goes 1 tile to the right %
000009be : 005502a3;   % 88:                 sb t0, 5(a0)     # and stores it on beam's X %
000009bf : 00550323;   % 89:                 sb t0, 6(a0)     # and on beam's old X %
000009c0 : 00a5c283;   % 92:                 lbu t0, 10(a1)   # Loads player's Y %
000009c1 : 005503a3;   % 93:                 sb t0, 7(a0)     # and stores it on beam's Y %
000009c2 : 00550423;   % 94:                 sb t0, 8(a0)     # and on beam's old Y %
000009c3 : 00100293;   % 97:                 li t0,1          # Loads 1 (Right) %
000009c4 : 005500a3;   % 98:                 sb t0,1(a0)      # and stores it on the direction byte %
000009c5 : 03c0006f;   % 99:                 j END_BEAM_SPAWN_LOOP # break loop %
000009c6 : 0085c283;   % 104:                 lbu t0, 8(a1)    # Loads player's X %
000009c7 : fff28293;   % 105:                 addi t0,t0,-1    # goes 1 tile to the left %
000009c8 : 005502a3;   % 106:                 sb t0, 5(a0)     # and stores it on beam's X %
000009c9 : 00550323;   % 107:                 sb t0, 6(a0)     # and on beam's old X %
000009ca : 00a5c283;   % 110:                 lbu t0, 10(a1)   # Loads player's Y %
000009cb : 005503a3;   % 111:                 sb t0, 7(a0)     # and stores it on beam's Y %
000009cc : 00550423;   % 112:                 sb t0, 8(a0)     # and on beam's old Y %
000009cd : fff00293;   % 115:                 li t0,-1         # Loads -1 (Left) %
000009ce : 005500a3;   % 116:                 sb t0,1(a0)      # and stores it on the direction byte %
000009cf : 0140006f;   % 117:                 j END_BEAM_SPAWN_LOOP # break loop %
000009d0 : 00950513;   % 120:             addi a0,a0,9          # Going to the next beams address                                   %
000009d1 : 00168693;   % 121:             addi a3,a3,1                   # Iterating counter by 1                                    %
000009d2 : 00c6d463;   % 122:             bge a3,a2, END_BEAM_SPAWN_LOOP # If all of the beams were checked, end loop (don't attack)                                 %
000009d3 : f39ff06f;   % 123:             j BEAM_SPAWN_LOOP # otherwise, go back to the loop's beginning  %
000009d4 : 00008067;   % 127:         ret %
000009d5 : 0fc0e517;   % 145:     la a0, BOMBS_ARRAY      # Loads BOMBS array %
000009d6 : a3850513;   % 145:  %
000009d7 : 00054283;   % 146:     lbu t0,0(a0)            # Loads cooldown byte %
000009d8 : 00028463;   % 147:     beqz t0,CONTINUE_BOMB_SPAWN # If on zero, spawn %
000009d9 : 0980006f;   % 148:         j END_BOMB_SPAWN_LOOP %
000009da : 0fc0e597;   % 150:     la a1, PLYR_POS         # Loads Player Pos address %
000009db : 9d658593;   % 150:  %
000009dc : 00300613;   % 151:     li a2, 3     # Loads total number of bombs %
000009dd : 00000693;   % 152:     li a3,0                 # Resets counter %
000009de : 00150513;   % 154:     addi a0,a0,1            # Skips cooldown byte %
000009df : 00054283;   % 156:         lbu t0, 0(a0)       # Loads enable byte %
000009e0 : 00028463;   % 157:         beqz t0, BOMB_SPAWN_LOOP_ACTIVATE # If current bomb is disabled, activate it %
000009e1 : 0680006f;   % 158:             j NEXT_IN_BOMB_SPAWN_LOOP     # Otherwise, go to next one in loop %
000009e2 : 0fc0e297;   % 162:             la t0, BOMBS_ARRAY            # Loads BOMBS array %
000009e3 : a0428293;   % 162:  %
000009e4 : 00800313;   % 163:             li t1, 8  # gets cooldown value %
000009e5 : 00628023;   % 164:             sb t1,0(t0)                   # stores it %
000009e6 : 00100293;   % 166:             li t0,1          # Loads 1 (Enabled)  %
000009e7 : 00550023;   % 167:             sb t0,0(a0)      # stores in beam's enable byte %
000009e8 : 0065c283;   % 170:             lbu t0, 6(a1)    # Loads player's X offset %
000009e9 : 005501a3;   % 171:             sb t0, 3(a0)     # and stores it on bomb's X offset %
000009ea : 0075c283;   % 173:             lbu t0, 7(a1)    # Loads player's Y offset %
000009eb : 00550223;   % 174:             sb t0, 4(a0)     # and stores it on bomb's Y offset %
000009ec : 0085c283;   % 177:             lbu t0, 8(a1)    # Loads player's X %
000009ed : 005502a3;   % 178:             sb t0, 5(a0)     # and stores it on bomb's X %
000009ee : 00550323;   % 179:             sb t0, 6(a0)     # and on bomb's old X %
000009ef : 00a5c283;   % 182:             lbu t0, 10(a1)   # Loads player's Y %
000009f0 : 00128293;   % 183:             addi t0,t0,1     # goes down 1 tile %
000009f1 : 005503a3;   % 184:             sb t0, 7(a0)     # and stores it on bomb's Y %
000009f2 : 00550423;   % 185:             sb t0, 8(a0)     # and on bomb's old Y %
000009f3 : 00069663;   % 188:             bnez a3,BOMB_SPAWN_LOOP_NOT_BOMB_0 %
000009f4 : d0007d53;   % 190:                 fcvt.s.w fs10,zero # Resets Bomb's jump speed %
000009f5 : 0280006f;   % 191:                 j END_BOMB_SPAWN_LOOP # break loop    %
000009f6 : 00100293;   % 193:             BOMB_SPAWN_LOOP_NOT_BOMB_0: li t0,1 %
000009f7 : 00569663;   % 194:             bne a3,t0,BOMB_SPAWN_LOOP_NOT_BOMB_1 %
000009f8 : d0007dd3;   % 196:                 fcvt.s.w fs11,zero # Resets Bomb's jump speed %
000009f9 : 0180006f;   % 197:                 j END_BOMB_SPAWN_LOOP # break loop    %
000009fa : d00078d3;   % 201:                 fcvt.s.w fa7,zero # Resets Bomb's jump speed %
000009fb : 00950513;   % 205:             addi a0,a0,9          # Going to the next bombs address                                   %
000009fc : 00168693;   % 206:             addi a3,a3,1                   # Iterating counter by 1                                    %
000009fd : 00c6d463;   % 207:             bge a3,a2, END_BOMB_SPAWN_LOOP # If all of the bombs were checked, end loop (don't attack)                                 %
000009fe : f85ff06f;   % 208:             j BOMB_SPAWN_LOOP # otherwise, go back to the loop's beginning  %
000009ff : 00008067;   % 212:         ret %
00000a00 : ffc10113;   % 230:     addi sp,sp,-4 %
00000a01 : 00112023;   % 231:     sw ra,0(sp) %
00000a02 : 0fc0e217;   % 233:     la tp, CURRENT_MAP  # Loads CURRENT_MAP address %
00000a03 : 91c20213;   % 233:  %
00000a04 : 0fc0e517;   % 235:     la a0,BEAMS_ARRAY   # Loads Beams array %
00000a05 : 96050513;   % 235:  %
00000a06 : 00150513;   % 236:     addi a0,a0,1        # skips cooldown byte %
00000a07 : 00000613;   % 238:     li a2,0             # resets counter %
00000a08 : 00300593;   % 239:     li a1,3  # gets number of beams in game %
00000a09 : 00000813;   % 241:         li a6,0      # Default sprite (normal beam, and not exploding) %
00000a0a : 00054383;   % 242:         lbu t2,0(a0) # Loads enable byte %
00000a0b : 00039463;   % 243:         bnez t2,BEAMS_OPERATIONS_LOOP_CONTINUE    # If enabled, %
00000a0c : 1280006f;   % 244:             j NEXT_IN_BEAMS_OPERATIONS_LOOP       # Otherwise, check other beams %
00000a0d : 00200293;   % 246:             li t0,2  # Loads "To be Disabled"  %
00000a0e : 00729663;   % 247:             bne t0,t2, BEAMS_OPERATIONS_LOOP_CONTINUE_2 # If state isn't "To be Disabled"  %
00000a0f : 00050023;   % 249:                 sb zero,0(a0) # Disables beam %
00000a10 : 1180006f;   % 250:                 j NEXT_IN_BEAMS_OPERATIONS_LOOP  # Check other beams %
00000a11 : 00300293;   % 253:             li t0,3  # Loads "Hit, to be Disabled"  %
00000a12 : 00729463;   % 254:             bne t0,t2, BEAMS_OPERATIONS_LOOP_CONTINUE_3   # If beam is trully enabled, %
00000a13 : 00100813;   % 256:                 li a6,1       # Beam will be rendered again, but exploding  %
00000a14 : fdc10113;   % 262:             addi sp,sp,-36 %
00000a15 : 00912023;   % 263:             sw s1,0(sp) %
00000a16 : 01212223;   % 264:             sw s2,4(sp) %
00000a17 : 01312423;   % 265:             sw s3,8(sp) %
00000a18 : 01412623;   % 266:             sw s4,12(sp) %
00000a19 : 00a12823;   % 267:             sw a0,16(sp) %
00000a1a : 00b12a23;   % 268:             sw a1,20(sp) %
00000a1b : 00c12c23;   % 269:             sw a2,24(sp) %
00000a1c : 00d12e23;   % 270:             sw a3,28(sp) %
00000a1d : 02412023;   % 271:             sw tp,32(sp) %
00000a1e : 00554583;   % 276:             lbu a1,5(a0) # Loads beam's current X %
00000a1f : 00624283;   % 277:             lbu t0,6(tp) # Loads map's current X %
00000a20 : 405585b3;   % 278:             sub a1,a1,t0 # Gets the X matrix related to the map's X (a1 = beam's X - map's X) %
00000a21 : 00459593;   % 279:             slli a1,a1,4 # Multiplies a5 by 16 in order to get X related to screen %
00000a22 : 00354283;   % 280:             lbu t0,3(a0) # Loads beam's X offset %
00000a23 : 005585b3;   % 281:             add a1,a1,t0 # Adds offset to position %
00000a24 : 00824283;   % 282:             lbu t0,8(tp) # Loads map's X offset %
00000a25 : 405585b3;   % 283:             sub a1,a1,t0 # and takes it from beam's position %
00000a26 : 00754603;   % 287:             lbu a2,7(a0) # Loads beam's current Y %
00000a27 : 00724303;   % 288:             lbu t1,7(tp) # Loads map's current Y %
00000a28 : 40660633;   % 289:             sub a2,a2,t1 # Gets the Y matrix related to the map's Y (a2 = beam's Y - map's Y) %
00000a29 : 00461613;   % 290:             slli a2,a2,4 # Multiplies a2 by 16 in order to get Y related to screen %
00000a2a : 00454283;   % 291:             lbu t0,4(a0) # Loads beam's Y offset %
00000a2b : 00560633;   % 292:             add a2,a2,t0 # Adds offset to position %
00000a2c : 00924303;   % 293:             lbu t1,9(tp) # Loads map's Y offset %
00000a2d : 40660633;   % 294:             sub a2,a2,t1 # and takes it from beam's position %
00000a2e : 01000693;   % 296:             li a3,16   # 16 = width of rendering area %
00000a2f : 01000713;   % 297:             li a4,16   # 16 = height of rendering area %
00000a30 : 008007b3;   % 298:             mv a5,s0          # gets frame to be rendered on %
00000a31 : 00150283;   % 300:             lb t0,1(a0)       # Loads direction byte %
00000a32 : 00028863;   % 301:             beqz t0,BEAMS_OPERATIONS_LOOP_RENDER_UP   # If beam is going up %
00000a33 : 0fc1b517;   % 302:                 la a0,Beam_Horizontal   # If beam is moving horizontally %
00000a34 : 2c050513;   % 302:  %
00000a35 : 00c0006f;   % 303:                 j BEAMS_OPERATIONS_LOOP_RENDER_START  # Render %
00000a36 : 0fc1b517;   % 306:                 la a0,Beam_Vertical     # If beam is moving vertically %
00000a37 : 4b450513;   % 306:  %
00000a38 : 00000893;   % 310:                 li a7,0             # Normal render %
00000a39 : fffff317;   % 311:                 call RENDER_ENTITY  # Renders it %
00000a3a : 578300e7;   % 311:  %
00000a3b : 01012503;   % 313:             lw a0,16(sp)    # Restores a0 %
00000a3c : 00054383;   % 314:             lbu t2,0(a0)    # Loads enable byte %
00000a3d : 00300293;   % 315:             li t0,3         # Loads "Hit, to be Disabled"  %
00000a3e : 00729663;   % 316:             bne t0,t2, BEAMS_OPERATIONS_LOOP_MOVE   # If it wasn't in the "Hit" state %
00000a3f : 00050023;   % 318:                 sb zero,0(a0) # Disables beam %
00000a40 : 0300006f;   % 319:                 j BEAMS_OPERATIONS_LOOP_AFTER_OPERATIONS  # Check other beams %
00000a41 : 00022583;   % 324:             lw a1,0(tp) %
00000a42 : 00005317;   % 325:             call MOVE_BEAM                %
00000a43 : 360300e7;   % 325:  %
00000a44 : 00254283;   % 329:             lbu t0,2(a0)    # Gets number of times that it was rendered %
00000a45 : 00128293;   % 330:             addi t0,t0,1    # iterates it %
00000a46 : 00550123;   % 331:             sb t0,2(a0)     # and stores it back %
00000a47 : 00600313;   % 332:             li t1,6  # Loads number of times beam should render/move before being disabled %
00000a48 : 0062c863;   % 333:             blt t0,t1,BEAMS_OPERATIONS_LOOP_AFTER_OPERATIONS  # If it didn't surpass the threshold, finish this part of loop %
00000a49 : 00200313;   % 335:                 li t1,2        # Loads "To be Disabled"  %
00000a4a : 00650023;   % 336:                 sb t1,0(a0)    # and stores it on enable byte %
00000a4b : 00050123;   % 337:                 sb zero,2(a0)  # Resets render counter %
00000a4c : 00012483;   % 344:             lw s1,0(sp) %
00000a4d : 00412903;   % 345:             lw s2,4(sp) %
00000a4e : 00812983;   % 346:             lw s3,8(sp) %
00000a4f : 00c12a03;   % 347:             lw s4,12(sp) %
00000a50 : 01012503;   % 348:             lw a0,16(sp) %
00000a51 : 01412583;   % 349:             lw a1,20(sp) %
00000a52 : 01812603;   % 350:             lw a2,24(sp) %
00000a53 : 01c12683;   % 351:             lw a3,28(sp) %
00000a54 : 02012203;   % 352:             lw tp,32(sp) %
00000a55 : 02410113;   % 353:             addi sp,sp,36 %
00000a56 : 00950513;   % 357:             addi a0,a0,9  # Going to the next beam's address                                   %
00000a57 : 00160613;   % 358:             addi a2,a2,1            # Iterating counter by 1                                    %
00000a58 : 00b65463;   % 359:             bge a2,a1, END_BEAMS_OPERATIONS_LOOP # If all of the beams were checked, end loop (don't attack)                                 %
00000a59 : ec1ff06f;   % 360:             j BEAMS_OPERATIONS_LOOP # otherwise, go back to the loop's beginning  %
00000a5a : 00012083;   % 364:         lw ra,0(sp) %
00000a5b : 00410113;   % 365:         addi sp,sp,4 %
00000a5c : 00008067;   % 367:         ret %
00000a5d : ffc10113;   % 384:     addi sp,sp,-4 %
00000a5e : 00112023;   % 385:     sw ra,0(sp) %
00000a5f : 0fc0d217;   % 387:     la tp, CURRENT_MAP  # Loads CURRENT_MAP address %
00000a60 : 7a820213;   % 387:  %
00000a61 : 0fc0e517;   % 389:     la a0,BOMBS_ARRAY   # Loads Bombs array %
00000a62 : 80850513;   % 389:  %
00000a63 : 00150513;   % 390:     addi a0,a0,1        # skips cooldown byte %
00000a64 : 00000613;   % 392:     li a2,0             # resets counter %
00000a65 : 00300593;   % 393:     li a1,3  # gets number of bombs in game %
00000a66 : 00054383;   % 395:         lbu t2,0(a0) # Loads enable byte %
00000a67 : 00039463;   % 396:         bnez t2,BOMBS_OPERATIONS_LOOP_CONTINUE    # If enabled, %
00000a68 : 1b00006f;   % 397:             j NEXT_IN_BOMBS_OPERATIONS_LOOP       # Otherwise, check other bombs %
00000a69 : 00200293;   % 400:             li t0,2  # Loads "To be Disabled"  %
00000a6a : 06729463;   % 401:             bne t0,t2, BOMBS_OPERATIONS_LOOP_CONTINUE_2 # If state isn't "To be Disabled"  %
00000a6b : 00050023;   % 403:                 sb zero,0(a0) # Disables bomb %
00000a6c : fec10113;   % 406:                 addi sp,sp,-20 %
00000a6d : 00a12023;   % 407:                 sw a0,0(sp) %
00000a6e : 00b12223;   % 408:                 sw a1,4(sp) %
00000a6f : 00c12423;   % 409:                 sw a2,8(sp) %
00000a70 : 00d12623;   % 410:                 sw a3,12(sp) %
00000a71 : 00412823;   % 411:                 sw tp,16(sp) %
00000a72 : 00354583;   % 414:                 lbu a1,3(a0) # Loads bomb's X offset %
00000a73 : 00454603;   % 415:                 lbu a2,4(a0) # Loads bomb's Y offset %
00000a74 : 00554683;   % 416:                 lbu a3,5(a0) # Loads bomb's current X %
00000a75 : 00754703;   % 417:                 lbu a4,7(a0) # Loads bomb's current Y %
00000a76 : 00000793;   % 418:                 li a5,0      # No delay %
00000a77 : 00100513;   % 420:                 li a0, 1   # 1 - Big   %
00000a78 : 00000317;   % 421:                 call EXPLOSION_SPAWN %
00000a79 : 604300e7;   % 421:  %
00000a7a : 00012503;   % 423:                 lw a0,0(sp)  # Restores a0 for bomb collision %
00000a7b : 00005317;   % 424:                 call BOMB_COLLISION  # Will see if bomb hit an enemy/block %
00000a7c : ef8300e7;   % 424:  %
00000a7d : 00012503;   % 426:                 lw a0,0(sp) %
00000a7e : 00412583;   % 427:                 lw a1,4(sp) %
00000a7f : 00812603;   % 428:                 lw a2,8(sp) %
00000a80 : 00c12683;   % 429:                 lw a3,12(sp) %
00000a81 : 01012203;   % 430:                 lw tp,16(sp) %
00000a82 : 01410113;   % 431:                 addi sp,sp,20 %
00000a83 : 1440006f;   % 434:                 j NEXT_IN_BOMBS_OPERATIONS_LOOP  # Check other bombs %
00000a84 : fdc10113;   % 439:             addi sp,sp,-36 %
00000a85 : 00912023;   % 440:             sw s1,0(sp) %
00000a86 : 01212223;   % 441:             sw s2,4(sp) %
00000a87 : 01312423;   % 442:             sw s3,8(sp) %
00000a88 : 01412623;   % 443:             sw s4,12(sp) %
00000a89 : 00a12823;   % 444:             sw a0,16(sp) %
00000a8a : 00b12a23;   % 445:             sw a1,20(sp) %
00000a8b : 00c12c23;   % 446:             sw a2,24(sp) %
00000a8c : 00d12e23;   % 447:             sw a3,28(sp) %
00000a8d : 02412023;   % 448:             sw tp,32(sp) %
00000a8e : 00061663;   % 452:             bnez a2,BOMBS_OPERATIONS_LOOP_NOT_BOMB_0 %
00000a8f : 21ad0553;   % 454:                 fmv.s fa0,fs10   # Moves BOMB_0's current Y speed to fa0  %
00000a90 : 0180006f;   % 455:                 j BOMBS_OPERATIONS_LOOP_MOVE  # Move %
00000a91 : 00100293;   % 457:             BOMBS_OPERATIONS_LOOP_NOT_BOMB_0: li t0,1 %
00000a92 : 00561663;   % 458:             bne a2,t0,BOMBS_OPERATIONS_LOOP_NOT_BOMB_1 %
00000a93 : 21bd8553;   % 460:                 fmv.s fa0,fs11   # Moves BOMB_1's current Y speed to fa0 %
00000a94 : 0080006f;   % 461:                 j BOMBS_OPERATIONS_LOOP_MOVE  # Move %
00000a95 : 21188553;   % 465:                 fmv.s fa0,fa7   # Moves BOMB_2's current Y speed to fa0 %
00000a96 : 00022583;   % 471:             lw a1,0(tp) %
00000a97 : 00005317;   % 472:             call MOVE_BOMB %
00000a98 : 408300e7;   % 472:  %
00000a99 : 01812603;   % 474:             lw a2,24(sp) # Getting Bomb's number back (counter) %
00000a9a : 00061663;   % 477:             bnez a2,BOMBS_OPERATIONS_AFTER_CHECK_NOT_BOMB_0 %
00000a9b : 20a50d53;   % 479:                 fmv.s fs10,fa0   # Saves BOMB_0's new Y speed from fa0  %
00000a9c : 0180006f;   % 480:                 j BOMBS_OPERATIONS_AFTER_CHECK  # Finish move %
00000a9d : 00100293;   % 482:             BOMBS_OPERATIONS_AFTER_CHECK_NOT_BOMB_0: li t0,1 %
00000a9e : 00561663;   % 483:             bne a2,t0,BOMBS_OPERATIONS_AFTER_CHECK_NOT_BOMB_1 %
00000a9f : 20a50dd3;   % 485:                 fmv.s fs11,fa0   # Saves BOMB_1's new Y speed from fa0  %
00000aa0 : 0080006f;   % 486:                 j BOMBS_OPERATIONS_AFTER_CHECK  # Finish move %
00000aa1 : 20a508d3;   % 490:                 fmv.s fa7,fa0   # Saves BOMB_2's new Y speed from fa0  %
00000aa2 : 01012503;   % 495:             lw a0,16(sp)    # Restores a0 %
00000aa3 : 02012203;   % 496:             lw tp,32(sp)    # Restores tp %
00000aa4 : 00554583;   % 500:             lbu a1,5(a0) # Loads bomb's current X %
00000aa5 : 00624283;   % 501:             lbu t0,6(tp) # Loads map's current X %
00000aa6 : 405585b3;   % 502:             sub a1,a1,t0 # Gets the X matrix related to the map's X (a1 = bomb's X - map's X) %
00000aa7 : 00459593;   % 503:             slli a1,a1,4 # Multiplies a5 by 16 in order to get X related to screen %
00000aa8 : 00354283;   % 504:             lbu t0,3(a0) # Loads bomb's X offset %
00000aa9 : 005585b3;   % 505:             add a1,a1,t0 # Adds offset to position %
00000aaa : 00824283;   % 506:             lbu t0,8(tp) # Loads map's X offset %
00000aab : 405585b3;   % 507:             sub a1,a1,t0 # and takes it from bomb's position %
00000aac : 00754603;   % 511:             lbu a2,7(a0) # Loads bomb's current Y %
00000aad : 00724303;   % 512:             lbu t1,7(tp) # Loads map's current Y %
00000aae : 40660633;   % 513:             sub a2,a2,t1 # Gets the Y matrix related to the map's Y (a2 = bomb's Y - map's Y) %
00000aaf : 00461613;   % 514:             slli a2,a2,4 # Multiplies a2 by 16 in order to get Y related to screen %
00000ab0 : 00454283;   % 515:             lbu t0,4(a0) # Loads bomb's Y offset %
00000ab1 : 00560633;   % 516:             add a2,a2,t0 # Adds offset to position %
00000ab2 : 00924303;   % 517:             lbu t1,9(tp) # Loads map's Y offset %
00000ab3 : 40660633;   % 518:             sub a2,a2,t1 # and takes it from bomb's position %
00000ab4 : 00460613;   % 519:             addi a2,a2,4 # Offsets sprite a little bit %
00000ab5 : 01000693;   % 521:             li a3,16   # 16 = width of rendering area %
00000ab6 : 01000713;   % 522:             li a4,16   # 16 = height of rendering area %
00000ab7 : 008007b3;   % 523:             mv a5,s0          # gets frame to be rendered on %
00000ab8 : 00150803;   % 525:             lb a6,1(a0)       # Loads status byte %
00000ab9 : 00184813;   % 526:             xori a6,a6,1      # Inverts it %
00000aba : 010500a3;   % 527:             sb a6,1(a0)       # and stores it %
00000abb : 0fc1b517;   % 529:             la a0,Bomb    %
00000abc : 4a050513;   % 529:  %
00000abd : 00000893;   % 530:             li a7,0             # Normal render %
00000abe : fffff317;   % 531:             call RENDER_ENTITY  # Renders it %
00000abf : 364300e7;   % 531:  %
00000ac0 : 01012503;   % 534:             lw a0,16(sp)    # Restores a0 %
00000ac1 : 00254283;   % 535:             lbu t0,2(a0)    # Gets number of times that it was rendered (counter for exploding) %
00000ac2 : 00128293;   % 536:             addi t0,t0,1    # iterates it %
00000ac3 : 00550123;   % 537:             sb t0,2(a0)     # and stores it back %
00000ac4 : 01400313;   % 538:             li t1,20  # Loads number of times bomb should render/move before being disabled %
00000ac5 : 0062ca63;   % 539:             blt t0,t1,BOMBS_OPERATIONS_LOOP_AFTER_OPERATIONS  # If it didn't surpass the threshold, finish this part of loop %
00000ac6 : 00200313;   % 541:                 li t1,2        # Loads "To be Disabled"  %
00000ac7 : 00650023;   % 542:                 sb t1,0(a0)    # and stores it on enable byte %
00000ac8 : 000500a3;   % 543:                 sb zero,1(a0)  # Sets status to 0 %
00000ac9 : 00050123;   % 544:                 sb zero,2(a0)  # Resets render counter %
00000aca : 00012483;   % 551:             lw s1,0(sp) %
00000acb : 00412903;   % 552:             lw s2,4(sp) %
00000acc : 00812983;   % 553:             lw s3,8(sp) %
00000acd : 00c12a03;   % 554:             lw s4,12(sp) %
00000ace : 01012503;   % 555:             lw a0,16(sp) %
00000acf : 01412583;   % 556:             lw a1,20(sp) %
00000ad0 : 01812603;   % 557:             lw a2,24(sp) %
00000ad1 : 01c12683;   % 558:             lw a3,28(sp) %
00000ad2 : 02012203;   % 559:             lw tp,32(sp) %
00000ad3 : 02410113;   % 560:             addi sp,sp,36 %
00000ad4 : 00950513;   % 564:             addi a0,a0,9  # Going to the next bomb's address                                   %
00000ad5 : 00160613;   % 565:             addi a2,a2,1            # Iterating counter by 1                                    %
00000ad6 : 00b65463;   % 566:             bge a2,a1, END_BOMBS_OPERATIONS_LOOP # If all of the bombs were checked, end loop (don't attack)                                 %
00000ad7 : e3dff06f;   % 567:             j BOMBS_OPERATIONS_LOOP # otherwise, go back to the loop's beginning  %
00000ad8 : 00012083;   % 571:         lw ra,0(sp) %
00000ad9 : 00410113;   % 572:         addi sp,sp,4 %
00000ada : 00008067;   % 574:         ret %
00000adb : ffc10113;   % 27:     addi sp,sp,-4 %
00000adc : 00112023;   % 28:     sw ra,0(sp) %
00000add : 0fc0d297;   % 30:     la t0,MAP_INFO  %
00000ade : 5b428293;   % 30:  %
00000adf : 0002c283;   % 31:     lbu t0,0(t0) %
00000ae0 : 00100313;   % 32:     li t1,1 %
00000ae1 : 00628463;   % 33:     beq t0,t1,CONTINUE_MARU_MARI_OPERATIONS %
00000ae2 : 0bc0006f;   % 34:         j END_MARU_MARI_OPERATIONS %
00000ae3 : 0fc0d297;   % 37:         la t0,PLYR_INFO  %
00000ae4 : 5b028293;   % 37:  %
00000ae5 : 0012c283;   % 38:         lbu t0,1(t0)                             # Loads player's number of abilities %
00000ae6 : 00028463;   % 39:         beqz t0,CONTINUE_MARU_MARI_OPERATIONS2   # Continue (ability wasn't aquired yet) %
00000ae7 : 0a80006f;   % 40:             j END_MARU_MARI_OPERATIONS           # otherwise don't render %
00000ae8 : ff010113;   % 44:             addi sp,sp,-16 %
00000ae9 : 00912023;   % 45:             sw s1,0(sp) %
00000aea : 01212223;   % 46:             sw s2,4(sp) %
00000aeb : 01312423;   % 47:             sw s3,8(sp) %
00000aec : 01412623;   % 48:             sw s4,12(sp) %
00000aed : 0fc0d217;   % 50:             la tp,CURRENT_MAP %
00000aee : 57020213;   % 50:  %
00000aef : 00f00593;   % 53:             li a1,15    # Loads maru mari's current X %
00000af0 : 00624283;   % 54:             lbu t0,6(tp) # Loads map's current X %
00000af1 : 405585b3;   % 55:             sub a1,a1,t0 # Gets the X matrix related to the map's X (a1 = maru mari's X - map's X) %
00000af2 : 00459593;   % 56:             slli a1,a1,4 # Multiplies a5 by 16 in order to get X related to screen %
00000af3 : 00824283;   % 58:             lbu t0,8(tp) # Loads map's X offset %
00000af4 : 405585b3;   % 59:             sub a1,a1,t0 # and takes it from maru mari's position %
00000af5 : 00900613;   % 62:             li a2,9 # Loads maru mari's current Y %
00000af6 : 00724303;   % 63:             lbu t1,7(tp) # Loads map's current Y %
00000af7 : 40660633;   % 64:             sub a2,a2,t1 # Gets the Y matrix related to the map's Y (a2 = maru mari's Y - map's Y) %
00000af8 : 00461613;   % 65:             slli a2,a2,4 # Multiplies a2 by 16 in order to get Y related to screen %
00000af9 : 00924303;   % 67:             lbu t1,9(tp) # Loads map's Y offset %
00000afa : 40660633;   % 68:             sub a2,a2,t1 # and takes it from loot's position %
00000afb : 01000693;   % 70:             li a3,16     # Loads width          %
00000afc : 01000713;   % 71:             li a4,16     # Loads height %
00000afd : 008007b3;   % 72:             mv a5,s0            # gets frame to be rendered on %
00000afe : 00000893;   % 73:             li a7,0             # Normal render %
00000aff : 0fc0d297;   % 76:             la t0,MARU_MARI_INFO # Loads Maru Mari's info address %
00000b00 : 56828293;   % 76:  %
00000b01 : 0002c803;   % 77:             lbu a6, 0(t0)        # Loads status sprite %
00000b02 : 00300e13;   % 78:             li t3, 3             # t3 = max_sprite %
00000b03 : 01c80863;   % 79:             beq a6,t3,RESET_MARU_MARI # If status == 3, reset it %
00000b04 : 00180813;   % 80:                 addi a6,a6,1     # Increments status  %
00000b05 : 01028023;   % 81:                 sb a6, 0(t0)     # Stores status sprite %
00000b06 : 0080006f;   % 82:                 j MARU_MARI_OPERATIONS_RENDER %
00000b07 : 00028023;   % 85:                 sb zero, 0(t0)   # Stores status sprite %
00000b08 : 0fc1c517;   % 89:                 la a0,MaruMari %
00000b09 : f6c50513;   % 89:  %
00000b0a : fffff317;   % 90:                 call RENDER_ENTITY  # Renders it %
00000b0b : 234300e7;   % 90:  %
00000b0c : 00012483;   % 93:             lw s1,0(sp) %
00000b0d : 00412903;   % 94:             lw s2,4(sp) %
00000b0e : 00812983;   % 95:             lw s3,8(sp) %
00000b0f : 00c12a03;   % 96:             lw s4,12(sp) %
00000b10 : 01010113;   % 97:             addi sp,sp,16 %
00000b11 : 00012083;   % 102:         lw ra,0(sp) %
00000b12 : 00410113;   % 103:         addi sp,sp,4 %
00000b13 : 00008067;   % 105:         ret      %
00000b14 : ffc10113;   % 133:     addi sp,sp,-4 %
00000b15 : 00112023;   % 134:     sw ra,0(sp) %
00000b16 : 0fc0d297;   % 136:     la t0,MAP_INFO  %
00000b17 : 4d028293;   % 136:  %
00000b18 : 0002c283;   % 137:     lbu t0,0(t0) %
00000b19 : 00600313;   % 138:     li t1,6 %
00000b1a : 00628463;   % 139:     beq t0,t1,CONTINUE_BOMB_POWER_OPERATIONS %
00000b1b : 0b40006f;   % 140:         j END_BOMB_POWER_OPERATIONS %
00000b1c : 0fc0d297;   % 143:         la t0,PLYR_INFO  %
00000b1d : 4cc28293;   % 143:  %
00000b1e : 0012c283;   % 144:         lbu t0,1(t0)                                # Loads player's number of abilities %
00000b1f : 00300313;   % 145:         li t1,3 %
00000b20 : 00629463;   % 146:         bne t0,t1,CONTINUE_BOMB_POWER_OPERATIONS2   # Continue (ability wasn't aquired yet) %
00000b21 : 09c0006f;   % 147:             j END_BOMB_POWER_OPERATIONS             # otherwise don't render %
00000b22 : 0fc0d297;   % 150:         la t0,BOMB_POWER_INFO  %
00000b23 : 4e028293;   % 150:  %
00000b24 : 0002c283;   % 151:         lbu t0,0(t0)                                # Loads whether capsule has been broken or not %
00000b25 : 00029463;   % 152:         bnez t0,CONTINUE_BOMB_POWER_OPERATIONS3  # Continue (capsule was broken) %
00000b26 : 0880006f;   % 153:             j END_BOMB_POWER_OPERATIONS             # otherwise don't render %
00000b27 : ff010113;   % 157:             addi sp,sp,-16 %
00000b28 : 00912023;   % 158:             sw s1,0(sp) %
00000b29 : 01212223;   % 159:             sw s2,4(sp) %
00000b2a : 01312423;   % 160:             sw s3,8(sp) %
00000b2b : 01412623;   % 161:             sw s4,12(sp) %
00000b2c : 0fc0d217;   % 163:             la tp,CURRENT_MAP %
00000b2d : 47420213;   % 163:  %
00000b2e : 00b00593;   % 166:             li a1,11    # Loads maru mari's current X %
00000b2f : 00624283;   % 167:             lbu t0,6(tp) # Loads map's current X %
00000b30 : 405585b3;   % 168:             sub a1,a1,t0 # Gets the X matrix related to the map's X (a1 = maru mari's X - map's X) %
00000b31 : 00459593;   % 169:             slli a1,a1,4 # Multiplies a5 by 16 in order to get X related to screen %
00000b32 : 00824283;   % 171:             lbu t0,8(tp) # Loads map's X offset %
00000b33 : 405585b3;   % 172:             sub a1,a1,t0 # and takes it from maru mari's position %
00000b34 : 00300613;   % 175:             li a2,3    # Loads maru mari's current Y %
00000b35 : 00724303;   % 176:             lbu t1,7(tp) # Loads map's current Y %
00000b36 : 40660633;   % 177:             sub a2,a2,t1 # Gets the Y matrix related to the map's Y (a2 = maru mari's Y - map's Y) %
00000b37 : 00461613;   % 178:             slli a2,a2,4 # Multiplies a2 by 16 in order to get Y related to screen %
00000b38 : 00924303;   % 180:             lbu t1,9(tp) # Loads map's Y offset %
00000b39 : 40660633;   % 181:             sub a2,a2,t1 # and takes it from loot's position %
00000b3a : 01000693;   % 183:             li a3,16     # Loads width          %
00000b3b : 01000713;   % 184:             li a4,16     # Loads height %
00000b3c : 008007b3;   % 185:             mv a5,s0            # Gets frame to be rendered on %
00000b3d : 00000813;   % 186:             li a6,0             # No status %
00000b3e : 00000893;   % 187:             li a7,0             # Normal render %
00000b3f : 0fc1c517;   % 189:             la a0,Bomb_Power %
00000b40 : 59050513;   % 189:  %
00000b41 : fffff317;   % 190:             call RENDER_ENTITY  # Renders it %
00000b42 : 158300e7;   % 190:  %
00000b43 : 00012483;   % 193:             lw s1,0(sp) %
00000b44 : 00412903;   % 194:             lw s2,4(sp) %
00000b45 : 00812983;   % 195:             lw s3,8(sp) %
00000b46 : 00c12a03;   % 196:             lw s4,12(sp) %
00000b47 : 01010113;   % 197:             addi sp,sp,16 %
00000b48 : 00012083;   % 202:         lw ra,0(sp) %
00000b49 : 00410113;   % 203:         addi sp,sp,4 %
00000b4a : 00008067;   % 205:         ret     %
00000b4b : ffc10113;   % 233:     addi sp,sp,-4 %
00000b4c : 00112023;   % 234:     sw ra,0(sp) %
00000b4d : 0fc0d297;   % 236:     la t0,MAP_INFO  %
00000b4e : 3f428293;   % 236:  %
00000b4f : 0002c283;   % 237:     lbu t0,0(t0) %
00000b50 : 00600313;   % 238:     li t1,6 %
00000b51 : 00628463;   % 239:     beq t0,t1,CONTINUE_ITEM_CAPSULE_OPERATIONS1 %
00000b52 : 0b80006f;   % 240:         j END_ITEM_CAPSULE_OPERATIONS %
00000b53 : 0fc0d297;   % 243:         la t0,ITEM_CAPSULE_INFO  %
00000b54 : 42028293;   % 243:  %
00000b55 : 0002c803;   % 244:         lbu a6,0(t0)                                # Loads whether capsule has been broken or not %
00000b56 : 00300313;   % 245:         li t1,3 %
00000b57 : 00681463;   % 246:         bne a6,t1,CONTINUE_ITEM_CAPSULE_OPERATIONS2   # Continue (capsule was broken) %
00000b58 : 0a00006f;   % 247:             j END_ITEM_CAPSULE_OPERATIONS             # otherwise don't render %
00000b59 : ff010113;   % 251:             addi sp,sp,-16 %
00000b5a : 00912023;   % 252:             sw s1,0(sp) %
00000b5b : 01212223;   % 253:             sw s2,4(sp) %
00000b5c : 01312423;   % 254:             sw s3,8(sp) %
00000b5d : 01412623;   % 255:             sw s4,12(sp) %
00000b5e : 0fc0d217;   % 257:             la tp,CURRENT_MAP %
00000b5f : 3ac20213;   % 257:  %
00000b60 : 00b00593;   % 260:             li a1,11    # Loads maru mari's current X %
00000b61 : 00624283;   % 261:             lbu t0,6(tp) # Loads map's current X %
00000b62 : 405585b3;   % 262:             sub a1,a1,t0 # Gets the X matrix related to the map's X (a1 = maru mari's X - map's X) %
00000b63 : 00459593;   % 263:             slli a1,a1,4 # Multiplies a5 by 16 in order to get X related to screen %
00000b64 : 00824283;   % 265:             lbu t0,8(tp) # Loads map's X offset %
00000b65 : 405585b3;   % 266:             sub a1,a1,t0 # and takes it from maru mari's position %
00000b66 : 00300613;   % 269:             li a2,3    # Loads maru mari's current Y %
00000b67 : 00724303;   % 270:             lbu t1,7(tp) # Loads map's current Y %
00000b68 : 40660633;   % 271:             sub a2,a2,t1 # Gets the Y matrix related to the map's Y (a2 = maru mari's Y - map's Y) %
00000b69 : 00461613;   % 272:             slli a2,a2,4 # Multiplies a2 by 16 in order to get Y related to screen %
00000b6a : 00924303;   % 274:             lbu t1,9(tp) # Loads map's Y offset %
00000b6b : 40660633;   % 275:             sub a2,a2,t1 # and takes it from loot's position %
00000b6c : 01000693;   % 277:             li a3,16     # Loads width          %
00000b6d : 01000713;   % 278:             li a4,16     # Loads height %
00000b6e : 008007b3;   % 279:             mv a5,s0            # Gets frame to be rendered on %
00000b6f : 00000893;   % 280:             li a7,0             # Normal render %
00000b70 : 0fc0d297;   % 282:             la t0,ITEM_CAPSULE_INFO  %
00000b71 : 3ac28293;   % 282:  %
00000b72 : 00080a63;   % 283:             beqz a6, SKIP_CAPSULE_STATUS_UPDATE %
00000b73 : 00180813;   % 284:                 addi a6,a6,1 %
00000b74 : 01028023;   % 285:                 sb a6,0(t0)    # Stores resulting status %
00000b75 : 00300293;   % 286:                 li t0,3 %
00000b76 : 01028a63;   % 287:                 beq t0,a6,AFTER_CAPSULE_RENDER %
00000b77 : 0fc1c517;   % 289:             la a0,Item_Capsule %
00000b78 : 1b050513;   % 289:  %
00000b79 : fffff317;   % 290:             call RENDER_ENTITY  # Renders it %
00000b7a : 078300e7;   % 290:  %
00000b7b : 00012483;   % 295:             lw s1,0(sp) %
00000b7c : 00412903;   % 296:             lw s2,4(sp) %
00000b7d : 00812983;   % 297:             lw s3,8(sp) %
00000b7e : 00c12a03;   % 298:             lw s4,12(sp) %
00000b7f : 01010113;   % 299:             addi sp,sp,16 %
00000b80 : 00012083;   % 304:         lw ra,0(sp) %
00000b81 : 00410113;   % 305:         addi sp,sp,4 %
00000b82 : 00008067;   % 307:         ret     %
00000b83 : 00051463;   % 334:     bnez a0,CONTINUE_LOOT_SPAWN   # If we actually want to spawn loot %
00000b84 : 09c0006f;   % 335:         j END_LOOT_SPAWN_LOOP     # Otherwise, finish procedure %
00000b85 : 00a00e33;   % 338:         mv t3, a0  # Moves explosion type to t3 %
00000b86 : 00b00eb3;   % 339:         mv t4, a1  # Moves X offset to t4 %
00000b87 : 00c00f33;   % 340:         mv t5, a2  # Moves Y offset to t5 %
00000b88 : 0fc0d517;   % 342:         la a0, LOOT_ARRAY      # Loads LOOT array %
00000b89 : 3d050513;   % 342:  %
00000b8a : 00400593;   % 344:         li a1, 4      # Loads total number of loot %
00000b8b : 00000613;   % 345:         li a2,0                 # Resets counter %
00000b8c : 00254283;   % 347:             lbu t0, 2(a0)       # Loads enable byte %
00000b8d : 00028463;   % 348:             beqz t0, LOOT_SPAWN_LOOP_ACTIVATE # If current loot is disabled, activate it %
00000b8e : 0640006f;   % 349:                 j NEXT_IN_LOOT_SPAWN_LOOP     # Otherwise, go to next one in loop %
00000b8f : 00100293;   % 352:                 li t0,1          # Loads 1 (Enabled)  %
00000b90 : 00550123;   % 353:                 sb t0,2(a0)      # stores in explosion's enable byte %
00000b91 : fffe0e13;   % 355:                 addi t3,t3,-1    # If t3 = 1 -> t3 = 0. If t3 = 2 -> t3 = 1 %
00000b92 : 020e0a63;   % 356:                 beqz t3,SKIP_RANDOM_LOOT  # If the result is 0, spawn energy %
00000b93 : ff810113;   % 358:                     addi sp,sp,-8 %
00000b94 : 00a12023;   % 359:                     sw a0,0(sp) %
00000b95 : 00b12223;   % 360:                     sw a1,4(sp) %
00000b96 : 00a00593;   % 364:                     li a1,10                  # Range %
00000b97 : 08e00893;   % 365:                     li a7,142  # random integer within range ecall %
00000b98 : 00000073;   % 366:                     ecall %
00000b99 : 00a00e33;   % 367:                     mv t3,a0 %
00000b9a : 00012503;   % 370:                     lw a0,0(sp) %
00000b9b : 00412583;   % 371:                     lw a1,4(sp) %
00000b9c : 00810113;   % 372:                     addi sp,sp,8 %
00000b9d : 000e0463;   % 375:                     beqz t3,SKIP_RANDOM_LOOT   # If result is 0 (10%), spawn energy %
00000b9e : 00100e13;   % 376:                         li t3,1                # otherwise (90%), spawn missile %
00000b9f : 01c501a3;   % 380:                 sb t3,3(a0)      # Stores explosion's type (0 - Small, 1 - Big) %
00000ba0 : 01d50223;   % 382:                 sb t4, 4(a0)     # Stores explosion's X offset %
00000ba1 : 01e502a3;   % 383:                 sb t5, 5(a0)     # Stores explosion's Y offset %
00000ba2 : 00d50323;   % 385:                 sb a3, 6(a0)     # Stores explosion's X  %
00000ba3 : 00d503a3;   % 386:                 sb a3, 7(a0)     # Stores explosion's old X  %
00000ba4 : 00e50423;   % 388:                 sb a4, 8(a0)     # Stores explosion's Y  %
00000ba5 : 00e504a3;   % 389:                 sb a4, 9(a0)     # Stores explosion's old Y    %
00000ba6 : 0140006f;   % 391:                 j END_LOOT_SPAWN_LOOP # Break Loop        %
00000ba7 : 00a50513;   % 394:                 addi a0,a0,10           # Going to the next loot address                                   %
00000ba8 : 00160613;   % 395:                 addi a2,a2,1                   # Iterating counter by 1                                    %
00000ba9 : 00b65463;   % 396:                 bge a2,a1, END_LOOT_SPAWN_LOOP # If all of the loot were checked, end loop (don't spawn loot)                                 %
00000baa : f89ff06f;   % 397:                 j LOOT_SPAWN_LOOP # otherwise, go back to the loop's beginning  %
00000bab : 00008067;   % 401:         ret         %
00000bac : ffc10113;   % 420:     addi sp,sp,-4 %
00000bad : 00112023;   % 421:     sw ra,0(sp) %
00000bae : 0fc0d217;   % 423:     la tp, CURRENT_MAP      # Loads CURRENT_MAP address %
00000baf : 26c20213;   % 423:  %
00000bb0 : 0fc0d517;   % 425:     la a0,LOOT_ARRAY   # Loads loot array %
00000bb1 : 33050513;   % 425:  %
00000bb2 : 00000613;   % 427:     li a2,0                 # resets counter %
00000bb3 : 00400593;   % 428:     li a1,4       # gets number of loot in game %
00000bb4 : 00254383;   % 430:         lbu t2,2(a0) # Loads enable byte %
00000bb5 : 00039463;   % 431:         bnez t2,LOOT_OPERATIONS_LOOP_CONTINUE    # If enabled, %
00000bb6 : 0f00006f;   % 432:             j NEXT_IN_LOOT_OPERATIONS_LOOP       # Otherwise, check other loot %
00000bb7 : fdc10113;   % 437:             addi sp,sp,-36 %
00000bb8 : 00912023;   % 438:             sw s1,0(sp) %
00000bb9 : 01212223;   % 439:             sw s2,4(sp) %
00000bba : 01312423;   % 440:             sw s3,8(sp) %
00000bbb : 01412623;   % 441:             sw s4,12(sp) %
00000bbc : 00a12823;   % 442:             sw a0,16(sp) %
00000bbd : 00b12a23;   % 443:             sw a1,20(sp) %
00000bbe : 00c12c23;   % 444:             sw a2,24(sp) %
00000bbf : 00d12e23;   % 445:             sw a3,28(sp) %
00000bc0 : 02412023;   % 446:             sw tp,32(sp) %
00000bc1 : 00654583;   % 451:             lbu a1,6(a0) # Loads loot's current X %
00000bc2 : 00624283;   % 452:             lbu t0,6(tp) # Loads map's current X %
00000bc3 : 405585b3;   % 453:             sub a1,a1,t0 # Gets the X matrix related to the map's X (a1 = loot's X - map's X) %
00000bc4 : 00459593;   % 454:             slli a1,a1,4 # Multiplies a5 by 16 in order to get X related to screen %
00000bc5 : 00454283;   % 455:             lbu t0,4(a0) # Loads loot's X offset %
00000bc6 : 005585b3;   % 456:             add a1,a1,t0 # Adds offset to position %
00000bc7 : 00824283;   % 457:             lbu t0,8(tp) # Loads map's X offset %
00000bc8 : 405585b3;   % 458:             sub a1,a1,t0 # and takes it from loot's position %
00000bc9 : 00854603;   % 461:             lbu a2,8(a0) # Loads loot's current Y %
00000bca : 00724303;   % 462:             lbu t1,7(tp) # Loads map's current Y %
00000bcb : 40660633;   % 463:             sub a2,a2,t1 # Gets the Y matrix related to the map's Y (a2 = loot's Y - map's Y) %
00000bcc : 00461613;   % 464:             slli a2,a2,4 # Multiplies a2 by 16 in order to get Y related to screen %
00000bcd : 00554283;   % 465:             lbu t0,5(a0) # Loads loot's Y offset %
00000bce : 00560633;   % 466:             add a2,a2,t0 # Adds offset to position %
00000bcf : 00924303;   % 467:             lbu t1,9(tp) # Loads map's Y offset %
00000bd0 : 40660633;   % 468:             sub a2,a2,t1 # and takes it from loot's position %
00000bd1 : 01000693;   % 470:             li a3,16             %
00000bd2 : 01000713;   % 471:             li a4,16 %
00000bd3 : 008007b3;   % 472:             mv a5,s0     # gets frame to be rendered on %
00000bd4 : 00000893;   % 473:             li a7,0      # Normal render %
00000bd5 : 00055283;   % 475:             lhu t0,0(a0)      # Gets number of times that it was rendered (counter) %
00000bd6 : 0012f813;   % 476:             andi a6,t0,1      # Will be 1 if on an odd number of times, 0, if even %
00000bd7 : 00354283;   % 478:             lbu t0,3(a0)      # Loads loot type %
00000bd8 : 00029863;   % 479:             bnez t0,LOOT_OPERATIONS_LOOP_RENDER_MISSILE # If it's a missile collectible %
00000bd9 : 0fc1c517;   % 480:                 la a0,Energy %
00000bda : 82850513;   % 480:  %
00000bdb : 00c0006f;   % 481:                 j START_LOOT_OPERATIONS_LOOP_RENDER %
00000bdc : 0fc1c517;   % 484:                 la a0,Missile_Collectable %
00000bdd : a1c50513;   % 484:  %
00000bde : fffff317;   % 488:                 call RENDER_ENTITY  # Renders it %
00000bdf : ee4300e7;   % 488:  %
00000be0 : 01012503;   % 490:                 lw a0,16(sp)     # Restores a0 %
00000be1 : 00055283;   % 491:                 lhu t0,0(a0)     # Gets number of times that it was rendered (counter) %
00000be2 : 00128293;   % 492:                 addi t0,t0,1     # iterates it %
00000be3 : 00551023;   % 493:                 sh t0,0(a0)      # and stores it back %
00000be4 : 06400313;   % 495:                 li t1,100  # Loads number of times small explosion should render before being disabled %
00000be5 : 0062c663;   % 496:                 blt t0,t1,LOOT_OPERATIONS_LOOP_AFTER_OPERATIONS  # If it didn't surpass the threshold, finish this part of loop %
00000be6 : 00051023;   % 498:                     sh zero,0(a0)  # Resets render counter %
00000be7 : 00051123;   % 499:                     sh zero,2(a0)  # Disables loot %
00000be8 : 00012483;   % 504:             lw s1,0(sp) %
00000be9 : 00412903;   % 505:             lw s2,4(sp) %
00000bea : 00812983;   % 506:             lw s3,8(sp) %
00000beb : 00c12a03;   % 507:             lw s4,12(sp) %
00000bec : 01012503;   % 508:             lw a0,16(sp) %
00000bed : 01412583;   % 509:             lw a1,20(sp) %
00000bee : 01812603;   % 510:             lw a2,24(sp) %
00000bef : 01c12683;   % 511:             lw a3,28(sp) %
00000bf0 : 02012203;   % 512:             lw tp,32(sp) %
00000bf1 : 02410113;   % 513:             addi sp,sp,36 %
00000bf2 : 00a50513;   % 517:             addi a0,a0,10  # Going to the next bomb's address                                   %
00000bf3 : 00160613;   % 518:             addi a2,a2,1               # Iterating counter by 1                                    %
00000bf4 : 00b65463;   % 519:             bge a2,a1, END_LOOT_OPERATIONS_LOOP # If all of the bombs were checked, end loop (don't attack)                                 %
00000bf5 : efdff06f;   % 520:             j LOOT_OPERATIONS_LOOP # otherwise, go back to the loop's beginning  %
00000bf6 : 00012083;   % 524:         lw ra,0(sp) %
00000bf7 : 00410113;   % 525:         addi sp,sp,4 %
00000bf8 : 00008067;   % 527:         ret %
00000bf9 : 00a00e33;   % 557:     mv t3, a0  # Moves explosion type to t3 %
00000bfa : 00b00eb3;   % 558:     mv t4, a1  # Moves X offset to t4 %
00000bfb : 00c00f33;   % 559:     mv t5, a2  # Moves Y offset to t5 %
00000bfc : 0fc0d517;   % 561:     la a0, EXPLOSION_ARRAY      # Loads EXPLOSION array %
00000bfd : 1b850513;   % 561:  %
00000bfe : 00800593;   % 563:     li a1, 8     # Loads total number of explosions %
00000bff : 00000613;   % 564:     li a2,0                     # Resets counter %
00000c00 : 00054283;   % 566:         lbu t0, 0(a0)       # Loads enable byte %
00000c01 : 00028463;   % 567:         beqz t0, EXPLOSION_SPAWN_LOOP_ACTIVATE # If current explosion is disabled, activate it %
00000c02 : 0340006f;   % 568:             j NEXT_IN_EXPLOSION_SPAWN_LOOP     # Otherwise, go to next one in loop %
00000c03 : 00100293;   % 571:             li t0,1          # Loads 1 (Enabled)  %
00000c04 : 00550023;   % 572:             sb t0,0(a0)      # stores in explosion's enable byte %
00000c05 : 01c500a3;   % 574:             sb t3,1(a0)      # Stores explosion's type (0 - Small, 1 - Big) %
00000c06 : 01d501a3;   % 576:             sb t4, 3(a0)     # Stores explosion's X offset %
00000c07 : 01e50223;   % 577:             sb t5, 4(a0)     # Stores explosion's Y offset %
00000c08 : 00d502a3;   % 579:             sb a3, 5(a0)     # Stores explosion's X  %
00000c09 : 00d50323;   % 580:             sb a3, 6(a0)     # Stores explosion's old X  %
00000c0a : 00e503a3;   % 582:             sb a4, 7(a0)     # Stores explosion's Y  %
00000c0b : 00e50423;   % 583:             sb a4, 8(a0)     # Stores explosion's old Y    %
00000c0c : 40f007b3;   % 585:             neg a5,a5        # If a5 > 0, a5 < 0 %
00000c0d : 00f50123;   % 586:             sb a5,2(a0)      # Sets counter (0 - normal / negative for delay) %
00000c0e : 0140006f;   % 587:             j END_EXPLOSION_SPAWN_LOOP # Break Loop        %
00000c0f : 00950513;   % 590:             addi a0,a0,9      # Going to the next explosion address                                   %
00000c10 : 00160613;   % 591:             addi a2,a2,1                   # Iterating counter by 1                                    %
00000c11 : 00b65463;   % 592:             bge a2,a1, END_EXPLOSION_SPAWN_LOOP # If all of the explosions were checked, end loop (don't spawn explosion)                                 %
00000c12 : fb9ff06f;   % 593:             j EXPLOSION_SPAWN_LOOP # otherwise, go back to the loop's beginning  %
00000c13 : 00008067;   % 597:         ret         %
00000c14 : ffc10113;   % 615:     addi sp,sp,-4 %
00000c15 : 00112023;   % 616:     sw ra,0(sp) %
00000c16 : 0fc0d217;   % 618:     la tp, CURRENT_MAP  # Loads CURRENT_MAP address %
00000c17 : 0cc20213;   % 618:  %
00000c18 : 0fc0d517;   % 620:     la a0,EXPLOSION_ARRAY   # Loads explosions array %
00000c19 : 14850513;   % 620:  %
00000c1a : 00000613;   % 622:     li a2,0                 # resets counter %
00000c1b : 00800593;   % 623:     li a1,8  # gets number of explosions in game %
00000c1c : 00054383;   % 625:         lbu t2,0(a0) # Loads enable byte %
00000c1d : 00039463;   % 626:         bnez t2,EXPLOSIONS_OPERATIONS_LOOP_CONTINUE    # If enabled, %
00000c1e : 1f40006f;   % 627:             j NEXT_IN_EXPLOSIONS_OPERATIONS_LOOP       # Otherwise, check other explosions %
00000c1f : fdc10113;   % 632:             addi sp,sp,-36 %
00000c20 : 00912023;   % 633:             sw s1,0(sp) %
00000c21 : 01212223;   % 634:             sw s2,4(sp) %
00000c22 : 01312423;   % 635:             sw s3,8(sp) %
00000c23 : 01412623;   % 636:             sw s4,12(sp) %
00000c24 : 00a12823;   % 637:             sw a0,16(sp) %
00000c25 : 00b12a23;   % 638:             sw a1,20(sp) %
00000c26 : 00c12c23;   % 639:             sw a2,24(sp) %
00000c27 : 00d12e23;   % 640:             sw a3,28(sp) %
00000c28 : 02412023;   % 641:             sw tp,32(sp) %
00000c29 : 00554583;   % 646:             lbu a1,5(a0) # Loads explosion's current X %
00000c2a : 00624283;   % 647:             lbu t0,6(tp) # Loads map's current X %
00000c2b : 405585b3;   % 648:             sub a1,a1,t0 # Gets the X matrix related to the map's X (a1 = explosion's X - map's X) %
00000c2c : 00459593;   % 649:             slli a1,a1,4 # Multiplies a5 by 16 in order to get X related to screen %
00000c2d : 00354283;   % 650:             lbu t0,3(a0) # Loads explosion's X offset %
00000c2e : 005585b3;   % 651:             add a1,a1,t0 # Adds offset to position %
00000c2f : 00824283;   % 652:             lbu t0,8(tp) # Loads map's X offset %
00000c30 : 405585b3;   % 653:             sub a1,a1,t0 # and takes it from explosion's position %
00000c31 : 00754603;   % 657:             lbu a2,7(a0) # Loads explosion's current Y %
00000c32 : 00724303;   % 658:             lbu t1,7(tp) # Loads map's current Y %
00000c33 : 40660633;   % 659:             sub a2,a2,t1 # Gets the Y matrix related to the map's Y (a2 = explosion's Y - map's Y) %
00000c34 : 00461613;   % 660:             slli a2,a2,4 # Multiplies a2 by 16 in order to get Y related to screen %
00000c35 : 00454283;   % 661:             lbu t0,4(a0) # Loads explosion's Y offset %
00000c36 : 00560633;   % 662:             add a2,a2,t0 # Adds offset to position %
00000c37 : 00924303;   % 663:             lbu t1,9(tp) # Loads map's Y offset %
00000c38 : 40660633;   % 664:             sub a2,a2,t1 # and takes it from explosion's position %
00000c39 : 00460613;   % 665:             addi a2,a2,4 # Offsets sprite a little bit %
00000c3a : 008007b3;   % 667:             mv a5,s0          # gets frame to be rendered on %
00000c3b : 00000893;   % 668:             li a7,0             # Normal render %
00000c3c : 00154283;   % 670:             lbu t0,1(a0)      # Loads explosion type %
00000c3d : 06029e63;   % 671:             bnez t0,EXPLOSIONS_OPERATIONS_LOOP_RENDER_BIG  # If it's a big explosion %
00000c3e : 00250283;   % 673:                 lb t0,2(a0)      # Gets number of times that it was rendered (counter) %
00000c3f : 0402c863;   % 674:                 blt t0,zero,AFTER_EXPLOSIONS_OPERATIONS_LOOP_RENDER_SMALL  # If it has a delay %
00000c40 : 00029e63;   % 675:                 bnez t0,EXPLOSIONS_OPERATIONS_LOOP_RENDER_SMALL_NOT_0  # If not on state 0 %
00000c41 : 0fc1b517;   % 677:                     la a0, Explosions_1   # Small explosion sprite %
00000c42 : 08850513;   % 677:  %
00000c43 : 01000693;   % 678:                     li a3,16      # 16 = width of rendering area %
00000c44 : 01000713;   % 679:                     li a4,16      # 16 = height of rendering area %
00000c45 : 00100813;   % 680:                     li a6, 1             # Small explosion section %
00000c46 : 02c0006f;   % 681:                     j START_EXPLOSIONS_OPERATIONS_LOOP_RENDER_SMALL # Render %
00000c47 : 00100313;   % 683:                 EXPLOSIONS_OPERATIONS_LOOP_RENDER_SMALL_NOT_0:  li t1,1 %
00000c48 : 00629463;   % 684:                 bne t0,t1,EXPLOSIONS_OPERATIONS_LOOP_RENDER_SMALL_NOT_1  # If not on state 1 %
00000c49 : 0280006f;   % 686:                     j AFTER_EXPLOSIONS_OPERATIONS_LOOP_RENDER_SMALL # Skip render %
00000c4a : 0fc1b517;   % 690:                     la a0, Explosions_2   # Big explosion sprite %
00000c4b : 26450513;   % 690:  %
00000c4c : ff858593;   % 691:                     addi a1,a1,-8        # Offsetting sprite %
00000c4d : ff860613;   % 692:                     addi a2,a2,-8        # Offsetting sprite %
00000c4e : 02000693;   % 693:                     li a3,32             # 32 = width of rendering area %
00000c4f : 02000713;   % 694:                     li a4,32             # 32 = height of rendering area %
00000c50 : 00000813;   % 695:                     li a6, 0             # There's only one sprite for it %
00000c51 : fffff317;   % 699:                     call RENDER_ENTITY  # Renders it %
00000c52 : d18300e7;   % 699:  %
00000c53 : 01012503;   % 702:                     lw a0,16(sp)    # Restores a0 %
00000c54 : 00250283;   % 703:                     lb t0,2(a0)     # Gets number of times that it was rendered (counter) %
00000c55 : 00128293;   % 704:                     addi t0,t0,1    # iterates it %
00000c56 : 00550123;   % 705:                     sb t0,2(a0)     # and stores it back %
00000c57 : 00300313;   % 706:                     li t1,3  # Loads number of times small explosion should render before being disabled %
00000c58 : 0e62c263;   % 707:                     blt t0,t1,EXPLOSIONS_OPERATIONS_LOOP_AFTER_OPERATIONS  # If it didn't surpass the threshold, finish this part of loop %
00000c59 : 00050023;   % 709:                         sb zero,0(a0)  # Disables explosion %
00000c5a : 00050123;   % 710:                         sb zero,2(a0)  # Resets render counter %
00000c5b : 0d80006f;   % 711:                         j EXPLOSIONS_OPERATIONS_LOOP_AFTER_OPERATIONS %
00000c5c : 00250283;   % 715:                 lb t0,2(a0)      # Gets number of times that it was rendered (counter) %
00000c5d : 0a02c863;   % 716:                 blt t0,zero,AFTER_EXPLOSIONS_OPERATIONS_LOOP_RENDER_BIG  # If it has a delay %
00000c5e : 00029e63;   % 717:                 bnez t0,EXPLOSIONS_OPERATIONS_LOOP_RENDER_BIG_NOT_0  # If not on state 0 %
00000c5f : 0fc1b517;   % 719:                     la a0, Explosions_1   # Small explosion sprite %
00000c60 : 01050513;   % 719:  %
00000c61 : 01000693;   % 720:                     li a3, 16     # 16 = width of rendering area %
00000c62 : 01000713;   % 721:                     li a4, 16     # 16 = height of rendering area %
00000c63 : 00000813;   % 722:                     li a6, 0             # Bomb exploding section %
00000c64 : 08c0006f;   % 723:                     j START_EXPLOSIONS_OPERATIONS_LOOP_RENDER_BIG # Render %
00000c65 : 00100313;   % 725:                 EXPLOSIONS_OPERATIONS_LOOP_RENDER_BIG_NOT_0:  li t1,1 %
00000c66 : 00629463;   % 726:                 bne t0,t1,EXPLOSIONS_OPERATIONS_LOOP_RENDER_BIG_NOT_1  # If not on state 1 %
00000c67 : 0880006f;   % 728:                     j AFTER_EXPLOSIONS_OPERATIONS_LOOP_RENDER_BIG # Skips render %
00000c68 : 00200313;   % 730:                 EXPLOSIONS_OPERATIONS_LOOP_RENDER_BIG_NOT_1: li t1,2 %
00000c69 : 00629e63;   % 731:                 bne t0,t1,EXPLOSIONS_OPERATIONS_LOOP_RENDER_BIG_NOT_2  # If not on state 2 %
00000c6a : 0fc1b517;   % 733:                     la a0, Explosions_1   # Small explosion sprite %
00000c6b : fe450513;   % 733:  %
00000c6c : 01000693;   % 734:                     li a3, 16     # 16 = width of rendering area %
00000c6d : 01000713;   % 735:                     li a4, 16     # 16 = height of rendering area %
00000c6e : 00100813;   % 736:                     li a6, 1             # Small explosion section %
00000c6f : 0600006f;   % 737:                     j START_EXPLOSIONS_OPERATIONS_LOOP_RENDER_BIG # Render %
00000c70 : 00300313;   % 739:                 EXPLOSIONS_OPERATIONS_LOOP_RENDER_BIG_NOT_2:  li t1,3 %
00000c71 : 00629463;   % 740:                 bne t0,t1,EXPLOSIONS_OPERATIONS_LOOP_RENDER_BIG_NOT_3  # If not on state 3 %
00000c72 : 05c0006f;   % 742:                     j AFTER_EXPLOSIONS_OPERATIONS_LOOP_RENDER_BIG # Skips render %
00000c73 : 00400313;   % 744:                 EXPLOSIONS_OPERATIONS_LOOP_RENDER_BIG_NOT_3: li t1,4 %
00000c74 : 02629263;   % 745:                 bne t0,t1,EXPLOSIONS_OPERATIONS_LOOP_RENDER_BIG_NOT_4  # If not on state 4 %
00000c75 : 0fc1b517;   % 747:                     la a0, Explosions_2   # Big explosion sprite %
00000c76 : 1b850513;   % 747:  %
00000c77 : ff858593;   % 748:                     addi a1,a1,-8        # Offsetting sprite %
00000c78 : ff860613;   % 749:                     addi a2,a2,-8        # Offsetting sprite %
00000c79 : 02000693;   % 750:                     li a3,32             # 32 = width of rendering area %
00000c7a : 02000713;   % 751:                     li a4,32             # 32 = height of rendering area %
00000c7b : 00000813;   % 752:                     li a6, 0             # There's only one sprite for it %
00000c7c : 02c0006f;   % 753:                     j START_EXPLOSIONS_OPERATIONS_LOOP_RENDER_BIG # Render %
00000c7d : 00500313;   % 755:                 EXPLOSIONS_OPERATIONS_LOOP_RENDER_BIG_NOT_4:  li t1,5 %
00000c7e : 00629463;   % 756:                 bne t0,t1,EXPLOSIONS_OPERATIONS_LOOP_RENDER_BIG_NOT_5  # If not on state 5 %
00000c7f : 0280006f;   % 758:                     j AFTER_EXPLOSIONS_OPERATIONS_LOOP_RENDER_BIG # Skips render %
00000c80 : 0fc1b517;   % 762:                     la a0, Explosions_2   # Big explosion sprite %
00000c81 : 18c50513;   % 762:  %
00000c82 : ff858593;   % 763:                     addi a1,a1,-8        # Offsetting sprite %
00000c83 : ff860613;   % 764:                     addi a2,a2,-8        # Offsetting sprite %
00000c84 : 02000693;   % 765:                     li a3,32             # 32 = width of rendering area %
00000c85 : 02000713;   % 766:                     li a4,32             # 32 = height of rendering area %
00000c86 : 00000813;   % 767:                     li a6, 0             # There's only one sprite for it %
00000c87 : fffff317;   % 771:                     call RENDER_ENTITY  # Renders it %
00000c88 : c40300e7;   % 771:  %
00000c89 : 01012503;   % 774:                     lw a0,16(sp)    # Restores a0 %
00000c8a : 00250283;   % 775:                     lb t0,2(a0)    # Gets number of times that it was rendered (counter) %
00000c8b : 00128293;   % 776:                     addi t0,t0,1    # iterates it %
00000c8c : 00550123;   % 777:                     sb t0,2(a0)     # and stores it back %
00000c8d : 00700313;   % 778:                     li t1,7  # Loads number of times big explosion should render before being disabled %
00000c8e : 0062c663;   % 779:                     blt t0,t1,EXPLOSIONS_OPERATIONS_LOOP_AFTER_OPERATIONS  # If it didn't surpass the threshold, finish this part of loop %
00000c8f : 00050023;   % 781:                         sb zero,0(a0)  # Disables explosion %
00000c90 : 00050123;   % 782:                         sb zero,2(a0)  # Resets render counter %
00000c91 : 00012483;   % 787:             lw s1,0(sp) %
00000c92 : 00412903;   % 788:             lw s2,4(sp) %
00000c93 : 00812983;   % 789:             lw s3,8(sp) %
00000c94 : 00c12a03;   % 790:             lw s4,12(sp) %
00000c95 : 01012503;   % 791:             lw a0,16(sp) %
00000c96 : 01412583;   % 792:             lw a1,20(sp) %
00000c97 : 01812603;   % 793:             lw a2,24(sp) %
00000c98 : 01c12683;   % 794:             lw a3,28(sp) %
00000c99 : 02012203;   % 795:             lw tp,32(sp) %
00000c9a : 02410113;   % 796:             addi sp,sp,36 %
00000c9b : 00950513;   % 800:             addi a0,a0,9  # Going to the next bomb's address                                   %
00000c9c : 00160613;   % 801:             addi a2,a2,1               # Iterating counter by 1                                    %
00000c9d : 00b65463;   % 802:             bge a2,a1, END_EXPLOSIONS_OPERATIONS_LOOP # If all of the bombs were checked, end loop (don't attack)                                 %
00000c9e : df9ff06f;   % 803:             j EXPLOSIONS_OPERATIONS_LOOP # otherwise, go back to the loop's beginning  %
00000c9f : 00012083;   % 807:         lw ra,0(sp) %
00000ca0 : 00410113;   % 808:         addi sp,sp,4 %
00000ca1 : 00008067;   % 810:         ret %
00000ca2 : ffc10113;   % 10:     addi sp,sp,-4 %
00000ca3 : 00112023;   % 11:     sw ra,0(sp) %
00000ca4 : 0fc0d297;   % 13:     la t0,CURRENT_MAP             # Loads map address %
00000ca5 : e9428293;   % 13:  %
00000ca6 : 0042c283;   % 14:     lbu t0,4(t0)                  # and from it, loads map's number %
00000ca7 : 00700313;   % 15:     li t1,7                       # Loads 7 to compare with map's number %
00000ca8 : 02629063;   % 16:     bne t0,t1,SKIP_RIDLEY         # If not on map 7, skip Ridley >:D %
00000ca9 : 00000317;   % 17:         call RIDLEY_OPERATIONS    # Checks Ridley %
00000caa : 3f0300e7;   % 17:  %
00000cab : 00000317;   % 19:         call PLASMA_BREATH_OPERATIONS  # Checks Plasma Breaths (ITS.TEDIOUS.TO.KEEP.WRITING.PLASMA.BREATH.EVERY.TIME.I.CANT.TAKE.IT.ANYMOREEEE) %
00000cac : 630300e7;   % 19:  %
00000cad : 00012083;   % 21:             lw ra,0(sp) %
00000cae : 00410113;   % 22:             addi sp,sp,4 %
00000caf : 00008067;   % 24:         ret %
00000cb0 : 00000317;   % 26:     call ZOOMER_OPERATIONS        # Checks zoomers %
00000cb1 : 01c300e7;   % 26:  %
00000cb2 : 00000317;   % 28:     call RIPPER_OPERATIONS        # Checks rippers %
00000cb3 : 270300e7;   % 28:  %
00000cb4 : 00012083;   % 30:     lw ra,0(sp) %
00000cb5 : 00410113;   % 31:     addi sp,sp,4 %
00000cb6 : 00008067;   % 33: ret %
00000cb7 : ffc10113;   % 51:     addi sp,sp,-4 %
00000cb8 : 00112023;   % 52:     sw ra,0(sp) %
00000cb9 : 0fc0d517;   % 54:     la a0,Zoomers  # Loads Zoomers address %
00000cba : f6450513;   % 54:  %
00000cbb : 0fc0d217;   % 55:     la tp, CURRENT_MAP # Loads CURRENT_MAP address %
00000cbc : e3820213;   % 55:  %
00000cbd : 00052503;   % 57:     lw a0,0(a0)    # Loads the ZoomersA address over the Zoomers address %
00000cbe : 00051463;   % 58:     bnez a0,CONTINUE_ZOOMER_OPERATIONS  # If there are zoomers in this map %
00000cbf : 2300006f;   % 59:         j END_ZOOMER_OPERATIONS_LOOP    # If a0 = 0, there are no zoomers in this map %
00000cc0 : 00054583;   % 63:     lbu a1,0(a0)   # Loads number of Zoomers in current map %
00000cc1 : 00000613;   % 65:     li a2,0        # Counter for zoomers %
00000cc2 : 00150513;   % 66:     addi a0,a0,1   # Goes to next byte (where zoomers from current map start) %
00000cc3 : 00050283;   % 68:         lb t0,0(a0) # Loads zoomer's health %
00000cc4 : 00504463;   % 69:         blt zero,t0,CONTINUE_ZOOMER_OPERATIONS_LOOP # If zoomer is alive %
00000cc5 : 2080006f;   % 71:             j NEXT_IN_ZOOMER_OPERATIONS_LOOP %
00000cc6 : 00624283;   % 74:         lbu t0,6(tp) # Loads map's current X %
00000cc7 : 00454783;   % 75:         lbu a5,4(a0) # Loads zoomer's current X %
00000cc8 : 00400393;   % 76:         li t2,4  # Loads 4 (render distance) %
00000cc9 : 40728e33;   % 77:         sub t3,t0,t2 # Gets leftmost threshold to manage zoomer %
00000cca : 1fc7ca63;   % 79:         blt a5,t3,NEXT_IN_ZOOMER_OPERATIONS_LOOP # If zoomer's X isn't inside left border, go to next %
00000ccb : 00728e33;   % 81:         add t3,t0,t2 # Calculate rightmost threshold to manage zoomer %
00000ccc : 014e0e13;   % 82:         addi t3,t3,20 # finishing calculating threshold %
00000ccd : 1fc7d463;   % 83:         bge a5,t3,NEXT_IN_ZOOMER_OPERATIONS_LOOP # If zoomer's X isn't inside right border, go to next %
00000cce : 00724303;   % 86:         lbu t1,7(tp) # Loads map's current Y %
00000ccf : 00654703;   % 87:         lbu a4,6(a0) # Loads zoomer's current Y %
00000cd0 : 40730e33;   % 89:         sub t3,t1,t2 # Gets uppermost threshold to manage zoomer %
00000cd1 : 1dc74c63;   % 90:         blt a4,t3,NEXT_IN_ZOOMER_OPERATIONS_LOOP # If zoomer's X isn't inside upper border, go to next %
00000cd2 : 00730e33;   % 92:         add t3,t1,t2 # Calculate lowermost threshold to manage zoomer %
00000cd3 : 00fe0e13;   % 93:         addi t3,t3,15 # finishing calculating threshold %
00000cd4 : 1dc75663;   % 94:         bge a4,t3,NEXT_IN_ZOOMER_OPERATIONS_LOOP # If zoomer's X isn't inside lower border, go to next %
00000cd5 : fdc10113;   % 98:             addi sp,sp,-36 %
00000cd6 : 00912023;   % 99:             sw s1,0(sp) %
00000cd7 : 01212223;   % 100:             sw s2,4(sp) %
00000cd8 : 01312423;   % 101:             sw s3,8(sp) %
00000cd9 : 01412623;   % 102:             sw s4,12(sp) %
00000cda : 00a12823;   % 103:             sw a0,16(sp) %
00000cdb : 00b12a23;   % 104:             sw a1,20(sp) %
00000cdc : 00c12c23;   % 105:             sw a2,24(sp) %
00000cdd : 00d12e23;   % 106:             sw a3,28(sp) %
00000cde : 02412023;   % 107:             sw tp,32(sp) %
00000cdf : 00022583;   % 111:             lw a1,0(tp) %
00000ce0 : 00005317;   % 112:             call MOVE_ZOOMER %
00000ce1 : c18300e7;   % 112:  %
00000ce2 : 01012503;   % 115:             lw a0,16(sp) # Gets a0 from stack again %
00000ce3 : 02012203;   % 116:             lw tp,32(sp) # Gets tp from stack again %
00000ce4 : 00454583;   % 117:             lbu a1,4(a0) # Loads zoomer's current X %
00000ce5 : 00624283;   % 118:             lbu t0,6(tp) # Loads map's current X %
00000ce6 : 405585b3;   % 119:             sub a1,a1,t0 # Gets the X matrix related to the map's X (a1 = zoomer's X - map's X) %
00000ce7 : 00459593;   % 120:             slli a1,a1,4 # Multiplies a5 by 16 in order to get X related to screen %
00000ce8 : 00254283;   % 121:             lbu t0,2(a0) # Loads zoomer's X offset %
00000ce9 : 005585b3;   % 122:             add a1,a1,t0 # Adds offset to position %
00000cea : 00824283;   % 123:             lbu t0,8(tp) # Loads map's X offset %
00000ceb : 405585b3;   % 124:             sub a1,a1,t0 # and takes it from zoomer's position %
00000cec : 00654603;   % 128:             lbu a2,6(a0) # Loads zoomer's current Y %
00000ced : 00724303;   % 129:             lbu t1,7(tp) # Loads map's current Y %
00000cee : 40660633;   % 130:             sub a2,a2,t1 # Gets the Y matrix related to the map's Y (a2 = zoomer's Y - map's Y) %
00000cef : 00461613;   % 131:             slli a2,a2,4 # Multiplies a2 by 16 in order to get Y related to screen %
00000cf0 : 00354283;   % 132:             lbu t0,3(a0) # Loads zoomer's Y offset %
00000cf1 : 00560633;   % 133:             add a2,a2,t0 # Adds offset to position %
00000cf2 : 00924303;   % 134:             lbu t1,9(tp) # Loads map's Y offset %
00000cf3 : 40660633;   % 135:             sub a2,a2,t1 # and takes it from zoomer's position %
00000cf4 : 01000693;   % 137:             li a3,16   # 16 = width of rendering area %
00000cf5 : 01000713;   % 138:             li a4,16   # 16 = height of rendering area %
00000cf6 : 008007b3;   % 139:             mv a5,s0          # gets frame to be rendered on %
00000cf7 : 00854803;   % 141:             lbu a6,8(a0)      # Loads zoomer's status is its direction %
00000cf8 : 00184813;   % 142:             xori a6,a6,1      # switches it %
00000cf9 : 01050423;   % 143:             sb a6,8(a0)       # and stores it back for using next time %
00000cfa : 00154283;   % 145:             lbu t0,1(a0)      # gets zoomer's type number %
00000cfb : 00a54303;   % 146:             lbu t1,10(a0)     # gets zoomer's platform %
00000cfc : 02031e63;   % 148:             bnez t1,ZOOMER_OPERATIONS_LOOP_TRY_LEFT %
00000cfd : 00029863;   % 150:                 bnez t0,ZOOMER_OPERATIONS_LOOP_DOWN_NOT_NORMAL %
00000cfe : 0fc1c517;   % 152:                     la a0,Zoomer_Down %
00000cff : f9450513;   % 152:  %
00000d00 : 0e40006f;   % 153:                     j ZOOMER_OPERATIONS_LOOP_RENDER %
00000d01 : 00100393;   % 154:                 ZOOMER_OPERATIONS_LOOP_DOWN_NOT_NORMAL:li t2,1 %
00000d02 : 00729863;   % 155:                 bne t0,t2,ZOOMER_OPERATIONS_LOOP_DOWN_DAMAGE %
00000d03 : 0fc1c517;   % 157:                     la a0,Zoomer_Variant_Down %
00000d04 : 78050513;   % 157:  %
00000d05 : 0d00006f;   % 158:                     j ZOOMER_OPERATIONS_LOOP_RENDER %
00000d06 : ffe28293;   % 161:                     addi t0,t0,-2 # Reverts its sprite back to normal %
00000d07 : 005500a3;   % 162:                     sb t0,1(a0)   # and stores it back %
00000d08 : 0fc1d517;   % 163:                     la a0,Zoomer_Damage_Down %
00000d09 : f6c50513;   % 163:  %
00000d0a : 0bc0006f;   % 164:                     j ZOOMER_OPERATIONS_LOOP_RENDER %
00000d0b : 00100393;   % 166:             ZOOMER_OPERATIONS_LOOP_TRY_LEFT: li t2,1 %
00000d0c : 02731e63;   % 167:             bne t1,t2,ZOOMER_OPERATIONS_LOOP_TRY_UP %
00000d0d : 00029863;   % 169:                 bnez t0,ZOOMER_OPERATIONS_LOOP_LEFT_NOT_NORMAL %
00000d0e : 0fc1c517;   % 171:                     la a0,Zoomer_Left %
00000d0f : 15450513;   % 171:  %
00000d10 : 0a40006f;   % 172:                     j ZOOMER_OPERATIONS_LOOP_RENDER %
00000d11 : 00100393;   % 173:                 ZOOMER_OPERATIONS_LOOP_LEFT_NOT_NORMAL:li t2,1 %
00000d12 : 00729863;   % 174:                 bne t0,t2,ZOOMER_OPERATIONS_LOOP_LEFT_DAMAGE %
00000d13 : 0fc1d517;   % 176:                     la a0,Zoomer_Variant_Left %
00000d14 : 94050513;   % 176:  %
00000d15 : 0900006f;   % 177:                     j ZOOMER_OPERATIONS_LOOP_RENDER %
00000d16 : ffe28293;   % 180:                     addi t0,t0,-2 # Reverts its sprite back to normal %
00000d17 : 005500a3;   % 181:                     sb t0,1(a0)   # and stores it back %
00000d18 : 0fc1d517;   % 182:                     la a0,Zoomer_Damage_Left %
00000d19 : 12c50513;   % 182:  %
00000d1a : 07c0006f;   % 183:                     j ZOOMER_OPERATIONS_LOOP_RENDER %
00000d1b : 00200393;   % 185:             ZOOMER_OPERATIONS_LOOP_TRY_UP: li t2,2 %
00000d1c : 02731e63;   % 186:             bne t1,t2,ZOOMER_OPERATIONS_LOOP_RIGHT %
00000d1d : 00029863;   % 188:                 bnez t0,ZOOMER_OPERATIONS_LOOP_UP_NOT_NORMAL %
00000d1e : 0fc1c517;   % 190:                     la a0,Zoomer_Up %
00000d1f : 31450513;   % 190:  %
00000d20 : 0640006f;   % 191:                     j ZOOMER_OPERATIONS_LOOP_RENDER %
00000d21 : 00100393;   % 192:                 ZOOMER_OPERATIONS_LOOP_UP_NOT_NORMAL:li t2,1 %
00000d22 : 00729863;   % 193:                 bne t0,t2,ZOOMER_OPERATIONS_LOOP_UP_DAMAGE %
00000d23 : 0fc1d517;   % 195:                     la a0,Zoomer_Variant_Up %
00000d24 : b0050513;   % 195:  %
00000d25 : 0500006f;   % 196:                     j ZOOMER_OPERATIONS_LOOP_RENDER %
00000d26 : ffe28293;   % 199:                     addi t0,t0,-2 # Reverts its sprite back to normal %
00000d27 : 005500a3;   % 200:                     sb t0,1(a0)   # and stores it back %
00000d28 : 0fc1d517;   % 201:                     la a0,Zoomer_Damage_Up %
00000d29 : 2ec50513;   % 201:  %
00000d2a : 03c0006f;   % 202:                     j ZOOMER_OPERATIONS_LOOP_RENDER %
00000d2b : 00029863;   % 206:                 bnez t0,ZOOMER_OPERATIONS_LOOP_RIGHT_NOT_NORMAL %
00000d2c : 0fc1c517;   % 208:                     la a0,Zoomer_Right %
00000d2d : 4dc50513;   % 208:  %
00000d2e : 02c0006f;   % 209:                     j ZOOMER_OPERATIONS_LOOP_RENDER %
00000d2f : 00100393;   % 210:                 ZOOMER_OPERATIONS_LOOP_RIGHT_NOT_NORMAL:li t2,1 %
00000d30 : 00729863;   % 211:                 bne t0,t2,ZOOMER_OPERATIONS_LOOP_RIGHT_DAMAGE %
00000d31 : 0fc1d517;   % 213:                     la a0,Zoomer_Variant_Right %
00000d32 : cc850513;   % 213:  %
00000d33 : 0180006f;   % 214:                     j ZOOMER_OPERATIONS_LOOP_RENDER %
00000d34 : ffe28293;   % 217:                     addi t0,t0,-2 # Reverts its sprite back to normal %
00000d35 : 005500a3;   % 218:                     sb t0,1(a0)   # and stores it back %
00000d36 : 0fc1d517;   % 219:                     la a0,Zoomer_Damage_Right %
00000d37 : 4b450513;   % 219:  %
00000d38 : 0040006f;   % 220:                     j ZOOMER_OPERATIONS_LOOP_RENDER %
00000d39 : 00000893;   % 223:                 li a7,0             # Normal render %
00000d3a : fffff317;   % 224:                 call RENDER_ENTITY  # Renders it %
00000d3b : 974300e7;   % 224:  %
00000d3c : 0040006f;   % 225:                 j ZOOMER_OPERATIONS_LOOP_AFTER_OPERATIONS %
00000d3d : 00012483;   % 233:             lw s1,0(sp) %
00000d3e : 00412903;   % 234:             lw s2,4(sp) %
00000d3f : 00812983;   % 235:             lw s3,8(sp) %
00000d40 : 00c12a03;   % 236:             lw s4,12(sp) %
00000d41 : 01012503;   % 237:             lw a0,16(sp) %
00000d42 : 01412583;   % 238:             lw a1,20(sp) %
00000d43 : 01812603;   % 239:             lw a2,24(sp) %
00000d44 : 01c12683;   % 240:             lw a3,28(sp) %
00000d45 : 02012203;   % 241:             lw tp,32(sp) %
00000d46 : 02410113;   % 242:             addi sp,sp,36 %
00000d47 : 00c50513;   % 246:             addi a0,a0,12  # Going to the next zoomer's address                                   %
00000d48 : 00160613;   % 247:             addi a2,a2,1            # Iterating counter by 1                                    %
00000d49 : 00b65463;   % 248:             bge a2,a1, END_ZOOMER_OPERATIONS_LOOP # If all of the zoomers were checked, end loop                                   %
00000d4a : de5ff06f;   % 249:             j ZOOMER_OPERATIONS_LOOP # otherwise, go back to the loop's beginning                      %
00000d4b : 00012083;   % 253:         lw ra,0(sp) %
00000d4c : 00410113;   % 254:         addi sp,sp,4 %
00000d4d : 00008067;   % 256:         ret %
00000d4e : ffc10113;   % 276:     addi sp,sp,-4 %
00000d4f : 00112023;   % 277:     sw ra,0(sp) %
00000d50 : 0fc0d517;   % 280:     la a0,Rippers  # Loads Rippers address %
00000d51 : ec850513;   % 280:  %
00000d52 : 0fc0d217;   % 281:     la tp, CURRENT_MAP # Loads CURRENT_MAP address %
00000d53 : bdc20213;   % 281:  %
00000d54 : 00052503;   % 283:     lw a0,0(a0)    # Loads the RippersA address over the Rippers address %
00000d55 : 00051463;   % 284:     bnez a0,CONTINUE_RIPPER_OPERATIONS    # If there are rippers in this map %
00000d56 : 1300006f;   % 285:         j END_RIPPER_OPERATIONS_LOOP      # If a0 = 0, there are no rippers in this map %
00000d57 : 00054583;   % 289:     lbu a1,0(a0)   # Loads number of Rippers in current map %
00000d58 : 00000613;   % 291:     li a2,0        # Counter for rippers %
00000d59 : 00150513;   % 292:     addi a0,a0,1   # Goes to next byte (where rippers from current map start) %
00000d5a : 00624283;   % 295:         lbu t0,6(tp) # Loads map's current X %
00000d5b : 00354783;   % 296:         lbu a5,3(a0) # Loads ripper's current X %
00000d5c : 00400393;   % 297:         li t2,4  # Loads 4 (render distance) %
00000d5d : 40728e33;   % 298:         sub t3,t0,t2 # Gets leftmost threshold to manage ripper %
00000d5e : 11c7c063;   % 299:         blt a5,t3,NEXT_IN_RIPPER_OPERATIONS_LOOP # If ripper's X isn't inside left border, go to next %
00000d5f : 00728e33;   % 301:         add t3,t0,t2 # Calculate rightmost threshold to manage ripper %
00000d60 : 014e0e13;   % 302:         addi t3,t3,20 # finishing calculating threshold %
00000d61 : 0fc7da63;   % 303:         bge a5,t3,NEXT_IN_RIPPER_OPERATIONS_LOOP # If ripper's X isn't inside right border, go to next %
00000d62 : 00724303;   % 306:         lbu t1,7(tp) # Loads map's current Y %
00000d63 : 00554703;   % 307:         lbu a4,5(a0) # Loads ripper's current Y %
00000d64 : 40730e33;   % 309:         sub t3,t1,t2 # Gets uppermost threshold to manage ripper %
00000d65 : 0fc74263;   % 310:         blt a4,t3,NEXT_IN_RIPPER_OPERATIONS_LOOP # If ripper's X isn't inside upper border, go to next %
00000d66 : 00730e33;   % 312:         add t3,t1,t2 # Calculate lowermost threshold to manage ripper %
00000d67 : 00fe0e13;   % 313:         addi t3,t3,15 # finishing calculating threshold %
00000d68 : 0dc75c63;   % 314:         bge a4,t3,NEXT_IN_RIPPER_OPERATIONS_LOOP # If ripper's X isn't inside lower border, go to next %
00000d69 : fdc10113;   % 318:             addi sp,sp,-36 %
00000d6a : 00912023;   % 319:             sw s1,0(sp) %
00000d6b : 01212223;   % 320:             sw s2,4(sp) %
00000d6c : 01312423;   % 321:             sw s3,8(sp) %
00000d6d : 01412623;   % 322:             sw s4,12(sp) %
00000d6e : 00a12823;   % 323:             sw a0,16(sp) %
00000d6f : 00b12a23;   % 324:             sw a1,20(sp) %
00000d70 : 00c12c23;   % 325:             sw a2,24(sp) %
00000d71 : 00d12e23;   % 326:             sw a3,28(sp) %
00000d72 : 02412023;   % 327:             sw tp,32(sp) %
00000d73 : 00022583;   % 331:             lw a1,0(tp) %
00000d74 : 00005317;   % 332:             call MOVE_RIPPER %
00000d75 : f28300e7;   % 332:  %
00000d76 : 01012503;   % 335:             lw a0,16(sp) # Gets a0 from stack again %
00000d77 : 02012203;   % 336:             lw tp,32(sp) # Gets tp from stack again %
00000d78 : 00354583;   % 337:             lbu a1,3(a0) # Loads ripper's current X %
00000d79 : 00624283;   % 338:             lbu t0,6(tp) # Loads map's current X %
00000d7a : 405585b3;   % 339:             sub a1,a1,t0 # Gets the X matrix related to the map's X (a1 = ripper's X - map's X) %
00000d7b : 00459593;   % 340:             slli a1,a1,4 # Multiplies a5 by 16 in order to get X related to screen %
00000d7c : 00254283;   % 341:             lbu t0,2(a0) # Loads ripper's X offset %
00000d7d : 005585b3;   % 342:             add a1,a1,t0 # Adds offset to position %
00000d7e : 00824283;   % 343:             lbu t0,8(tp) # Loads map's X offset %
00000d7f : 405585b3;   % 344:             sub a1,a1,t0 # and takes it from ripper's position %
00000d80 : 00554603;   % 348:             lbu a2,5(a0) # Loads ripper's current Y %
00000d81 : 00724303;   % 349:             lbu t1,7(tp) # Loads map's current Y %
00000d82 : 40660633;   % 350:             sub a2,a2,t1 # Gets the Y matrix related to the map's Y (a2 = ripper's Y - map's Y) %
00000d83 : 00461613;   % 351:             slli a2,a2,4 # Multiplies a2 by 16 in order to get Y related to screen %
00000d84 : 00924303;   % 353:             lbu t1,9(tp) # Loads map's Y offset %
00000d85 : 40660633;   % 354:             sub a2,a2,t1 # and takes it from ripper's position %
00000d86 : 01000693;   % 355:             li a3,16   # 16 = width of rendering area %
00000d87 : 01000713;   % 356:             li a4,16   # 16 = height of rendering area %
00000d88 : 008007b3;   % 357:             mv a5,s0          # gets frame to be rendered on %
00000d89 : 00154803;   % 358:             lbu a6,1(a0)      # ripper's status is its direction %
00000d8a : 00054503;   % 360:             lbu a0,0(a0)      # gets ripper's type number %
00000d8b : 00050863;   % 361:             beqz a0,RIPPER_OPERATIONS_LOOP_RENDER_NORMAL %
00000d8c : 0fc1d517;   % 362:                 la a0,Ripper_Variant  # loads image address of red ripper %
00000d8d : 75c50513;   % 362:  %
00000d8e : 00c0006f;   % 363:                 j RIPPER_OPERATIONS_LOOP_RENDER %
00000d8f : 0fc1d517;   % 365:                 la a0,Ripper  # loads image address of normal ripper %
00000d90 : 55050513;   % 365:  %
00000d91 : 00000893;   % 367:                 li a7,0             # Normal render %
00000d92 : fffff317;   % 368:                 call RENDER_ENTITY  # Renders it %
00000d93 : 814300e7;   % 368:  %
00000d94 : 00012483;   % 373:             lw s1,0(sp) %
00000d95 : 00412903;   % 374:             lw s2,4(sp) %
00000d96 : 00812983;   % 375:             lw s3,8(sp) %
00000d97 : 00c12a03;   % 376:             lw s4,12(sp) %
00000d98 : 01012503;   % 377:             lw a0,16(sp) %
00000d99 : 01412583;   % 378:             lw a1,20(sp) %
00000d9a : 01812603;   % 379:             lw a2,24(sp) %
00000d9b : 01c12683;   % 380:             lw a3,28(sp) %
00000d9c : 02012203;   % 381:             lw tp,32(sp) %
00000d9d : 02410113;   % 382:             addi sp,sp,36 %
00000d9e : 00750513;   % 386:             addi a0,a0,7  # Going to the next ripper's address                                   %
00000d9f : 00160613;   % 387:             addi a2,a2,1            # Iterating counter by 1                                    %
00000da0 : 00b65463;   % 388:             bge a2,a1, END_RIPPER_OPERATIONS_LOOP # If all of the rippers were checked, end loop                                   %
00000da1 : ee5ff06f;   % 389:             j RIPPER_OPERATIONS_LOOP # otherwise, go back to the loop's beginning                      %
00000da2 : 00012083;   % 393:         lw ra,0(sp) %
00000da3 : 00410113;   % 394:         addi sp,sp,4 %
00000da4 : 00008067;   % 396:         ret %
00000da5 : ffc10113;   % 414:     addi sp,sp,-4 %
00000da6 : 00112023;   % 415:     sw ra,0(sp) %
00000da7 : 0fc0d517;   % 418:     la a0,RIDLEY_INFO  # Loads Ridley's address %
00000da8 : dbc50513;   % 418:  %
00000da9 : 0fc0d217;   % 419:     la tp, CURRENT_MAP # Loads CURRENT_MAP address %
00000daa : a8020213;   % 419:  %
00000dab : 00050283;   % 421:     lb t0,0(a0) # Loads Ridley's health %
00000dac : 00504663;   % 422:     blt zero,t0,CONTINUE_RIDLEY_OPERATIONS # If Ridley is alive %
00000dad : 00050023;   % 424:         sb zero,0(a0) # Stores zero on Ridley's health %
00000dae : 2180006f;   % 425:         j END_RIDLEY_OPERATIONS %
00000daf : fdc10113;   % 429:     addi sp,sp,-36 %
00000db0 : 00912023;   % 430:     sw s1,0(sp) %
00000db1 : 01212223;   % 431:     sw s2,4(sp) %
00000db2 : 01312423;   % 432:     sw s3,8(sp) %
00000db3 : 01412623;   % 433:     sw s4,12(sp) %
00000db4 : 00a12823;   % 434:     sw a0,16(sp) %
00000db5 : 00b12a23;   % 435:     sw a1,20(sp) %
00000db6 : 00c12c23;   % 436:     sw a2,24(sp) %
00000db7 : 00d12e23;   % 437:     sw a3,28(sp) %
00000db8 : 02412023;   % 438:     sw tp,32(sp) %
00000db9 : 00022583;   % 442:     lw a1,0(tp) %
00000dba : 00005317;   % 443:     call MOVE_RIDLEY %
00000dbb : f00300e7;   % 443:  %
00000dbc : 01012503;   % 446:     lw a0,16(sp)     # Gets a0 from stack again %
00000dbd : 02012203;   % 447:     lw tp,32(sp)     # Gets tp from stack again %
00000dbe : 00900593;   % 448:     li a1,9   # Loads ridley's current X %
00000dbf : fff58593;   % 449:     addi a1,a1,-1    # subtracts 1 from it (a sort of offset for rendering sprite in proper place) %
00000dc0 : 00624283;   % 450:     lbu t0,6(tp)     # Loads map's current X   %
00000dc1 : 405585b3;   % 451:     sub a1,a1,t0     # Gets the X matrix related to the map's X (a1 = ridley's X - map's X) %
00000dc2 : 00459593;   % 452:     slli a1,a1,4 # Multiplies a5 by 16 in order to get X related to screen %
00000dc3 : 00600293;   % 453:     li t0,6 # Loads ridley's X offset %
00000dc4 : 005585b3;   % 454:     add a1,a1,t0          # Adds offset to position %
00000dc5 : 00824283;   % 455:     lbu t0,8(tp)          # Loads map's X offset %
00000dc6 : 405585b3;   % 456:     sub a1,a1,t0          # and takes it from ridley's position %
00000dc7 : 00354603;   % 460:     lbu a2,3(a0) # Loads ridley's current Y %
00000dc8 : 00724303;   % 461:     lbu t1,7(tp) # Loads map's current Y %
00000dc9 : 40660633;   % 462:     sub a2,a2,t1 # Gets the Y matrix related to the map's Y (a2 = ridley's Y - map's Y) %
00000dca : 00461613;   % 463:     slli a2,a2,4 # Multiplies a2 by 16 in order to get Y related to screen %
00000dcb : 00254283;   % 464:     lbu t0,2(a0) # Loads ridley's Y offset %
00000dcc : 00560633;   % 465:     add a2,a2,t0 # Adds offset to position %
00000dcd : 00924303;   % 466:     lbu t1,9(tp) # Loads map's Y offset %
00000dce : 40660633;   % 467:     sub a2,a2,t1 # and takes it from ridley's position %
00000dcf : 02000693;   % 469:     li a3,32   # 16 = width of rendering area %
00000dd0 : 008007b3;   % 470:     mv a5,s0          # gets frame to be rendered on %
00000dd1 : 00554803;   % 472:     lbu a6,5(a0)      # Loads ridley's status is its direction %
00000dd2 : 00184813;   % 473:     xori a6,a6,1      # switches it %
00000dd3 : 010502a3;   % 474:     sb a6,5(a0)       # and stores it back for using next time %
00000dd4 : 05000293;   % 476:     li t0, 80              # Loads screen's Y threshold where jumping animation appears %
00000dd5 : 00154303;   % 477:     lbu t1,1(a0)                              # Gets ridley's type number %
00000dd6 : 02c2d463;   % 478:     bge t0,a2,RIDLEY_OPERATIONS_RENDER_JUMP   # If Y (a2) <= 80, render jumping animation %
00000dd7 : 02800713;   % 480:         li a4,40   # 40 = height of rendering area %
00000dd8 : 00031863;   % 481:         bnez t1,RIDLEY_OPERATIONS_RENDER_DAMAGE %
00000dd9 : 0fc1e517;   % 483:             la a0,Ridley %
00000dda : 82850513;   % 483:  %
00000ddb : 0340006f;   % 484:             j RIDLEY_OPERATIONS_RENDER %
00000ddc : 000500a3;   % 488:             sb zero,1(a0)             # Reverts to normal state %
00000ddd : 0fc1f517;   % 489:             la a0,Ridley_Damage %
00000dde : e1850513;   % 489:  %
00000ddf : 0240006f;   % 490:             j RIDLEY_OPERATIONS_RENDER %
00000de0 : 03000713;   % 494:         li a4,48   # 48 = height of rendering area %
00000de1 : 00031863;   % 495:         bnez t1,RIDLEY_OPERATIONS_RENDER_JUMP_DAMAGE %
00000de2 : 0fc1e517;   % 497:             la a0,Ridley_Jump %
00000de3 : 20450513;   % 497:  %
00000de4 : 0100006f;   % 498:             j RIDLEY_OPERATIONS_RENDER %
00000de5 : 000500a3;   % 502:             sb zero,1(a0)             # Reverts to normal state %
00000de6 : 0fc1f517;   % 503:             la a0,Ridley_Damage_Jump %
00000de7 : 7f450513;   % 503:  %
00000de8 : 00000893;   % 507:         li a7,0             # Normal render %
00000de9 : ffffe317;   % 508:         call RENDER_ENTITY  # Renders it %
00000dea : 6b8300e7;   % 508:  %
00000deb : 00900593;   % 511:     li a1,9                  # Range %
00000dec : 08e00893;   % 512:     li a7,142  # random integer within range ecall %
00000ded : 00000073;   % 513:     ecall %
00000dee : 00500293;   % 514:     li t0,5                  # to compare with result (in a0) %
00000def : 00554463;   % 515:     blt a0,t0,RIDLEY_OPERATIONS_ATTACK  # 50% chance to attack %
00000df0 : 0fc0006f;   % 516:         j END_RIDLEY_OPERATIONS_PART_1  # 50% chance to not attack %
00000df1 : 01012503;   % 518:         lw a0,16(sp)      # Gets Ridley's address again %
00000df2 : 00a54283;   % 519:         lbu t0,10(a0)     # Loads attack cooldown byte %
00000df3 : 00028863;   % 520:         beqz t0,RIDLEY_OPERATIONS_ATTACK_CONTINUE  %
00000df4 : fff28293;   % 522:             addi t0,t0,-1   # Subtracs 1 from cooldown %
00000df5 : 00550523;   % 523:             sb t0,10(a0)    # and stores it back %
00000df6 : 0e40006f;   % 524:             j END_RIDLEY_OPERATIONS_PART_1 %
00000df7 : 00800293;   % 527:             li t0,8   # Resets ridley's cooldown %
00000df8 : 00550523;   % 528:             sb t0,10(a0)                   # and stores it back %
00000df9 : 0fc0d617;   % 530:             la a2,PLASMA_BREATH_ARRAY  # Loads Plasma breath array %
00000dfa : c8460613;   % 530:  %
00000dfb : 00000293;   % 531:             li t0,0 # resets counter %
00000dfc : 00500313;   % 532:             li t1,5 # gets number of plasma breaths in game %
00000dfd : 01012503;   % 536:                 lw a0,16(sp)      # Gets Ridley's address again %
00000dfe : 00064383;   % 537:                 lbu t2,0(a2) # Loads enable byte %
00000dff : 00038463;   % 538:                 beqz t2,PLASMA_SPAWN_LOOP_CONTINUE # If not enabled, enable current plasma breath %
00000e00 : 0ac0006f;   % 539:                     j NEXT_IN_PLASMA_SPAWN__LOOP   # Otherwise, check other plasma breaths %
00000e01 : 00100393;   % 543:                     li t2,1     # Enabled %
00000e02 : 00760023;   % 544:                     sb t2,0(a2) # stores enable byte %
00000e03 : 00600393;   % 547:                     li t2,6  # Loads 6 %
00000e04 : 000601a3;   % 548:                     sb zero,3(a2) # Stores 6 on X offset (since ridley's X offset is always 6) %
00000e05 : 00900393;   % 550:                     li t2,9  # Loads 10 %
00000e06 : 00138393;   % 551:                     addi t2,t2,1    # adds 1 to it %
00000e07 : 00760323;   % 552:                     sb t2,6(a2)     # Stores 11 on X (since ridley's X is always 10) %
00000e08 : 007603a3;   % 553:                     sb t2,7(a2)     # Stores 11 on old X (since ridley's X is always 10) %
00000e09 : 00254383;   % 556:                     lbu t2,2(a0)    # Loads ridley's Y offset %
00000e0a : 00760223;   % 557:                     sb t2,4(a2)     # Stores it on Y offset %
00000e0b : 00354383;   % 559:                     lbu t2,3(a0)    # Loads ridley's current Y %
00000e0c : 00760423;   % 560:                     sb t2,8(a2)     # Stores it on Y %
00000e0d : 007604a3;   % 561:                     sb t2,9(a2)     # Stores it on dol Y %
00000e0e : 00200593;   % 564:                     li a1,2                  # Range %
00000e0f : 08e00893;   % 565:                     li a7,142  # random integer within range ecall %
00000e10 : 00000073;   % 566:                     ecall %
00000e11 : 00150393;   % 568:                     addi t2,a0,1   # X movement will be between 1 and 3 (inclusive) %
00000e12 : 007600a3;   % 569:                     sb t2,1(a2)    # Stores it on X movement %
00000e13 : fff00393;   % 572:                     li t2,-1       # Loads -1 (Up) %
00000e14 : 00760123;   % 573:                     sb t2,2(a2)    # Stores it on MOVE_Y (Up) %
00000e15 : 00300593;   % 576:                     li a1,3                  # Range %
00000e16 : 08e00893;   % 577:                     li a7,142  # random integer within range ecall %
00000e17 : 00000073;   % 578:                     ecall %
00000e18 : ffa00393;   % 580:                     li t2,-6                 # Loads -8 (base speed) %
00000e19 : 00a383b3;   % 581:                     add t2,t2,a0             # Speed will be between -8 and -4 %
00000e1a : 00029663;   % 584:                     bnez t0,PLASMA_SPAWN_LOOP_NOT_PLASMA_0 %
00000e1b : d003fad3;   % 586:                         fcvt.s.w fs5,t2    # Sets PLASMA_0's Y speed  %
00000e1c : 04c0006f;   % 587:                         j END_RIDLEY_OPERATIONS_PART_1  # Break loop %
00000e1d : 00100313;   % 589:                     PLASMA_SPAWN_LOOP_NOT_PLASMA_0: li t1,1 %
00000e1e : 00629663;   % 590:                     bne t0,t1,PLASMA_SPAWN_LOOP_NOT_PLASMA_1 %
00000e1f : d003fb53;   % 592:                         fcvt.s.w fs6,t2    # Sets PLASMA_1's Y speed %
00000e20 : 03c0006f;   % 593:                         j END_RIDLEY_OPERATIONS_PART_1  # Break loop %
00000e21 : 00200313;   % 595:                     PLASMA_SPAWN_LOOP_NOT_PLASMA_1: li t1,2 %
00000e22 : 00629663;   % 596:                     bne t0,t1,PLASMA_SPAWN_LOOP_NOT_PLASMA_2 %
00000e23 : d003fbd3;   % 598:                         fcvt.s.w fs7,t2    # Sets PLASMA_2's Y speed %
00000e24 : 02c0006f;   % 599:                         j END_RIDLEY_OPERATIONS_PART_1  # Break loop %
00000e25 : 00300313;   % 601:                     PLASMA_SPAWN_LOOP_NOT_PLASMA_2: li t1,3 %
00000e26 : 00629663;   % 602:                     bne t0,t1,PLASMA_SPAWN_LOOP_NOT_PLASMA_3 %
00000e27 : d003fc53;   % 604:                         fcvt.s.w fs8,t2    # Sets PLASMA_3's Y speed %
00000e28 : 01c0006f;   % 605:                         j END_RIDLEY_OPERATIONS_PART_1  # Break loop %
00000e29 : d003fcd3;   % 609:                         fcvt.s.w fs9,t2    # Sets PLASMA_4's Y speed %
00000e2a : 0140006f;   % 610:                         j END_RIDLEY_OPERATIONS_PART_1  # Break loop %
00000e2b : 00a60613;   % 613:                     addi a2,a2,10  # Going to the next plasma breath address                                   %
00000e2c : 00128293;   % 614:                     addi t0,t0,1            # Iterating counter by 1                                    %
00000e2d : 0062d463;   % 615:                     bge t0,t1, END_RIDLEY_OPERATIONS_PART_1 # If all of the plasma breaths were checked, end loop (don't attack)                                 %
00000e2e : f3dff06f;   % 616:                     j PLASMA_SPAWN_LOOP # otherwise, go back to the loop's beginning  %
00000e2f : 00012483;   % 620:         lw s1,0(sp) %
00000e30 : 00412903;   % 621:         lw s2,4(sp) %
00000e31 : 00812983;   % 622:         lw s3,8(sp) %
00000e32 : 00c12a03;   % 623:         lw s4,12(sp) %
00000e33 : 02410113;   % 629:         addi sp,sp,36 %
00000e34 : 00012083;   % 634:         lw ra,0(sp) %
00000e35 : 00410113;   % 635:         addi sp,sp,4 %
00000e36 : 00008067;   % 637:         ret %
00000e37 : ffc10113;   % 656:     addi sp,sp,-4 %
00000e38 : 00112023;   % 657:     sw ra,0(sp) %
00000e39 : 0fc0d217;   % 659:     la tp, CURRENT_MAP         # Loads CURRENT_MAP address %
00000e3a : 84020213;   % 659:  %
00000e3b : 0fc0d517;   % 661:     la a0,PLASMA_BREATH_ARRAY  # Loads Plasma breath array %
00000e3c : b7c50513;   % 661:  %
00000e3d : 00000613;   % 663:     li a2,0 # resets counter %
00000e3e : 00500593;   % 664:     li a1,5 # gets number of plasma breaths in game %
00000e3f : 00054383;   % 666:         lbu t2,0(a0) # Loads enable byte %
00000e40 : 00039463;   % 667:         bnez t2,PLASMA_BREATH_OPERATIONS_LOOP_CONTINUE    # If enabled, %
00000e41 : 1740006f;   % 668:             j NEXT_IN_PLASMA_BREATH_OPERATIONS_LOOP       # Otherwise, check other plasma breaths %
00000e42 : 00200293;   % 670:             li t0,2  # Loads "To be Disabled"  %
00000e43 : 00729663;   % 671:             bne t0,t2, PLASMA_BREATH_OPERATIONS_LOOP_CONTINUE_2   # If plasma breath is trully enabled, %
00000e44 : 00050023;   % 673:                 sb zero,0(a0) # Disables plasma breath %
00000e45 : 1640006f;   % 674:                 j NEXT_IN_PLASMA_BREATH_OPERATIONS_LOOP  # Check other plasma breaths %
00000e46 : fdc10113;   % 679:             addi sp,sp,-36 %
00000e47 : 00912023;   % 680:             sw s1,0(sp) %
00000e48 : 01212223;   % 681:             sw s2,4(sp) %
00000e49 : 01312423;   % 682:             sw s3,8(sp) %
00000e4a : 01412623;   % 683:             sw s4,12(sp) %
00000e4b : 00a12823;   % 684:             sw a0,16(sp) %
00000e4c : 00b12a23;   % 685:             sw a1,20(sp) %
00000e4d : 00c12c23;   % 686:             sw a2,24(sp) %
00000e4e : 00d12e23;   % 687:             sw a3,28(sp) %
00000e4f : 02412023;   % 688:             sw tp,32(sp) %
00000e50 : 00061663;   % 692:             bnez a2,PLASMA_BREATH_OPERATIONS_LOOP_NOT_PLASMA_0 %
00000e51 : 215a8553;   % 694:                 fmv.s fa0,fs5   # Moves PLASMA_0's current Y speed to fa0  %
00000e52 : 0380006f;   % 695:                 j PLASMA_BREATH_OPERATIONS_LOOP_MOVE  # Move %
00000e53 : 00100293;   % 697:             PLASMA_BREATH_OPERATIONS_LOOP_NOT_PLASMA_0: li t0,1 %
00000e54 : 00561663;   % 698:             bne a2,t0,PLASMA_BREATH_OPERATIONS_LOOP_NOT_PLASMA_1 %
00000e55 : 216b0553;   % 700:                 fmv.s fa0,fs6   # Moves PLASMA_1's current Y speed to fa0 %
00000e56 : 0280006f;   % 701:                 j PLASMA_BREATH_OPERATIONS_LOOP_MOVE  # Move %
00000e57 : 00200293;   % 703:             PLASMA_BREATH_OPERATIONS_LOOP_NOT_PLASMA_1: li t0,2 %
00000e58 : 00561663;   % 704:             bne a2,t0,PLASMA_BREATH_OPERATIONS_LOOP_NOT_PLASMA_2 %
00000e59 : 217b8553;   % 706:                 fmv.s fa0,fs7   # Moves PLASMA_2's current Y speed to fa0 %
00000e5a : 0180006f;   % 707:                 j PLASMA_BREATH_OPERATIONS_LOOP_MOVE  # Move %
00000e5b : 00300293;   % 709:             PLASMA_BREATH_OPERATIONS_LOOP_NOT_PLASMA_2: li t0,3 %
00000e5c : 00561663;   % 710:             bne a2,t0,PLASMA_BREATH_OPERATIONS_LOOP_NOT_PLASMA_3 %
00000e5d : 218c0553;   % 712:                 fmv.s fa0,fs8   # Moves PLASMA_3's current Y speed to fa0 %
00000e5e : 0080006f;   % 713:                 j PLASMA_BREATH_OPERATIONS_LOOP_MOVE  # Move %
00000e5f : 219c8553;   % 717:                 fmv.s fa0,fs9   # Moves PLASMA_4's current Y speed to fa0 %
00000e60 : 00022583;   % 723:             lw a1,0(tp) %
00000e61 : 00005317;   % 724:             call MOVE_PLASMA_BREATH %
00000e62 : dd8300e7;   % 724:  %
00000e63 : 01812603;   % 726:             lw a2,24(sp) # Getting Plasma Breath's number back (counter) %
00000e64 : 00061663;   % 729:             bnez a2,PLASMA_BREATH_OPERATIONS_LOOP_AFTER_CHECK_NOT_PLASMA_0 %
00000e65 : 20a50ad3;   % 731:                 fmv.s fs5,fa0   # Saves PLASMA_0's new Y speed from fa0  %
00000e66 : 0380006f;   % 732:                 j PLASMA_BREATH_OPERATIONS_AFTER_CHECK  # Finish move %
00000e67 : 00100293;   % 734:             PLASMA_BREATH_OPERATIONS_LOOP_AFTER_CHECK_NOT_PLASMA_0: li t0,1 %
00000e68 : 00561663;   % 735:             bne a2,t0,PLASMA_BREATH_OPERATIONS_LOOP_AFTER_CHECK_NOT_PLASMA_1 %
00000e69 : 20a50b53;   % 737:                 fmv.s fs6,fa0   # Saves PLASMA_1's new Y speed from fa0  %
00000e6a : 0280006f;   % 738:                 j PLASMA_BREATH_OPERATIONS_AFTER_CHECK  # Finish move %
00000e6b : 00200293;   % 740:             PLASMA_BREATH_OPERATIONS_LOOP_AFTER_CHECK_NOT_PLASMA_1: li t0,2 %
00000e6c : 00561663;   % 741:             bne a2,t0,PLASMA_BREATH_OPERATIONS_LOOP_AFTER_CHECK_NOT_PLASMA_2 %
00000e6d : 20a50bd3;   % 743:                 fmv.s fs7,fa0   # Saves PLASMA_2's new Y speed from fa0  %
00000e6e : 0180006f;   % 744:                 j PLASMA_BREATH_OPERATIONS_AFTER_CHECK  # Finish move %
00000e6f : 00300293;   % 746:             PLASMA_BREATH_OPERATIONS_LOOP_AFTER_CHECK_NOT_PLASMA_2: li t0,3 %
00000e70 : 00561663;   % 747:             bne a2,t0,PLASMA_BREATH_OPERATIONS_LOOP_AFTER_CHECK_NOT_PLASMA_3 %
00000e71 : 20a50c53;   % 749:                 fmv.s fs8,fa0   # Saves PLASMA_3's new Y speed from fa0  %
00000e72 : 0080006f;   % 750:                 j PLASMA_BREATH_OPERATIONS_AFTER_CHECK  # Finish move %
00000e73 : 20a50cd3;   % 754:                 fmv.s fs9,fa0   # Saves PLASMA_0's new Y speed from fa0  %
00000e74 : 01012503;   % 761:             lw a0,16(sp) # Gets a0 from stack again %
00000e75 : 02012203;   % 762:             lw tp,32(sp) # Gets tp from stack again %
00000e76 : 00654583;   % 763:             lbu a1,6(a0) # Loads plasma breath's current X %
00000e77 : 00624283;   % 764:             lbu t0,6(tp) # Loads map's current X %
00000e78 : 405585b3;   % 765:             sub a1,a1,t0 # Gets the X matrix related to the map's X (a1 = plasma breath's X - map's X) %
00000e79 : 00459593;   % 766:             slli a1,a1,4 # Multiplies a5 by 16 in order to get X related to screen %
00000e7a : 00354283;   % 767:             lbu t0,3(a0) # Loads plasma breath's X offset %
00000e7b : 005585b3;   % 768:             add a1,a1,t0 # Adds offset to position %
00000e7c : 00824283;   % 769:             lbu t0,8(tp) # Loads map's X offset %
00000e7d : 405585b3;   % 770:             sub a1,a1,t0 # and takes it from plasma breath's position %
00000e7e : 00854603;   % 775:             lbu a2,8(a0) # Loads plasma breath's current Y %
00000e7f : 00724303;   % 776:             lbu t1,7(tp) # Loads map's current Y %
00000e80 : 40660633;   % 777:             sub a2,a2,t1 # Gets the Y matrix related to the map's Y (a2 = plasma breath's Y - map's Y) %
00000e81 : 00461613;   % 778:             slli a2,a2,4 # Multiplies a2 by 16 in order to get Y related to screen %
00000e82 : 00454283;   % 779:             lbu t0,4(a0) # Loads plasma breath's Y offset %
00000e83 : 00560633;   % 780:             add a2,a2,t0 # Adds offset to position %
00000e84 : 00924303;   % 781:             lbu t1,9(tp) # Loads map's Y offset %
00000e85 : 40660633;   % 782:             sub a2,a2,t1 # and takes it from plasma breath's position %
00000e86 : 01000693;   % 784:             li a3,16   # 16 = width of rendering area %
00000e87 : 01000713;   % 785:             li a4,16   # 16 = height of rendering area %
00000e88 : 008007b3;   % 786:             mv a5,s0          # gets frame to be rendered on %
00000e89 : 00554803;   % 788:             lbu a6,5(a0)      # Loads plasma breath's status %
00000e8a : 00180813;   % 789:             addi a6,a6,1      # adds 1 to it %
00000e8b : 00300293;   % 790:             li t0,3 %
00000e8c : 0102d463;   % 791:             bge t0,a6,PLASMA_BREATH_OPERATIONS_LOOP_SKIP_STATUS_CORRECTION  # If a6 <= 3, continue %
00000e8d : 00000813;   % 792:                 li a6,0       # resets a6 to 0 %
00000e8e : 010502a3;   % 794:             sb a6,5(a0)       # and stores it back for using next time %
00000e8f : 0fc20517;   % 796:             la a0,Plasma_Breath %
00000e90 : 15050513;   % 796:  %
00000e91 : 00000893;   % 797:             li a7,0             # Normal render %
00000e92 : ffffe317;   % 798:             call RENDER_ENTITY  # Renders it %
00000e93 : 414300e7;   % 798:  %
00000e94 : 00012483;   % 803:             lw s1,0(sp) %
00000e95 : 00412903;   % 804:             lw s2,4(sp) %
00000e96 : 00812983;   % 805:             lw s3,8(sp) %
00000e97 : 00c12a03;   % 806:             lw s4,12(sp) %
00000e98 : 01012503;   % 807:             lw a0,16(sp) %
00000e99 : 01412583;   % 808:             lw a1,20(sp) %
00000e9a : 01812603;   % 809:             lw a2,24(sp) %
00000e9b : 01c12683;   % 810:             lw a3,28(sp) %
00000e9c : 02012203;   % 811:             lw tp,32(sp) %
00000e9d : 02410113;   % 812:             addi sp,sp,36 %
00000e9e : 00a50513;   % 816:                     addi a0,a0,10  # Going to the next plasma breath's address                                   %
00000e9f : 00160613;   % 817:                     addi a2,a2,1            # Iterating counter by 1                                    %
00000ea0 : 00b65463;   % 818:                     bge a2,a1, END_PLASMA_BREATH_OPERATIONS_LOOP # If all of the plasma breaths were checked, end loop (don't attack)                                 %
00000ea1 : e79ff06f;   % 819:                     j PLASMA_BREATH_OPERATIONS_LOOP # otherwise, go back to the loop's beginning  %
00000ea2 : 00012083;   % 823:         lw ra,0(sp) %
00000ea3 : 00410113;   % 824:         addi sp,sp,4 %
00000ea4 : 00008067;   % 826:         ret %
00000ea5 : 0fc0c217;   % 842:     la tp,CURRENT_MAP %
00000ea6 : 69020213;   % 842:  %
00000ea7 : 00424883;   % 843:     lbu a7,4(tp)       # Loads current map's number %
00000ea8 : 0fc0c517;   % 844:     la a0 Zoomers %
00000ea9 : 7a850513;   % 844:  %
00000eaa : 0fc0c317;   % 846:     la t1,NEXT_MAP %
00000eab : 68830313;   % 846:  %
00000eac : 00a34383;   % 847: 	lbu t2,10(t1)      # Loads render Next Map's %
00000ead : 00038c63;   % 848:     beqz t2,NOT_NEXT_MAP %
00000eae : 0fc0c217;   % 849:         la tp,NEXT_MAP %
00000eaf : 67820213;   % 849:  %
00000eb0 : 00424883;   % 850:         lbu a7,4(tp)       # Loads current map's number %
00000eb1 : 0fc0c517;   % 851:         la a0,Zoomers_Next %
00000eb2 : 78850513;   % 851:  %
00000eb3 : 00700293;   % 854:     li t0,7        # Loads 7 for comparision %
00000eb4 : 01129463;   % 855:     bne t0,a7, START_ZOOMERS_RESET %
00000eb5 : 3490006f;   % 856:         j RESET_RIDLEY %
00000eb6 : 00052503;   % 859:     lw a0,0(a0)    # Loads the ZoomersA address over the Zoomers address %
00000eb7 : 00051463;   % 860:     bnez a0,CONTINUE_ZOOMER_RESET  # If there are zoomers in this map %
00000eb8 : 3310006f;   % 861:         j END_RESET_ZOOMER_LOOP    # If a0 = 0, there are no zoomers in this map %
00000eb9 : 00054583;   % 865:     lbu a1,0(a0)   # Loads number of Zoomers in current map %
00000eba : 00000613;   % 867:     li a2,0        # Counter for zoomers %
00000ebb : 00150513;   % 868:     addi a0,a0,1   # Goes to next byte (where zoomers from current map start) %
00000ebc : 00100293;   % 870:         li t0, 1  %
00000ebd : 01129463;   % 871:         bne t0, a7, SKIP_MAP1_RESET_ZOOMER_LOOP  %
00000ebe : 02c0006f;   % 872:         j RESET_ZOOMER_LOOP_MAP1 %
00000ebf : 00200293;   % 875:             li t0, 2  %
00000ec0 : 01129463;   % 876:             bne t0, a7, SKIP_MAP2_RESET_ZOOMER_LOOP  %
00000ec1 : 1f00006f;   % 877:             j RESET_ZOOMER_LOOP_MAP2 %
00000ec2 : 00300293;   % 880:             li t0, 3  %
00000ec3 : 01129463;   % 881:             bne t0, a7, SKIP_MAP3_RESET_ZOOMER_LOOP  %
00000ec4 : 4980006f;   % 882:             j RESET_ZOOMER_LOOP_MAP3 %
00000ec5 : 00400293;   % 885:             li t0, 4 %
00000ec6 : 01129463;   % 886:             bne t0, a7, SKIP_MAP4_RESET_ZOOMER_LOOP  %
00000ec7 : 65c0006f;   % 887:             j RESET_ZOOMER_LOOP_MAP4 %
00000ec8 : 1b50006f;   % 890:             j RESET_ZOOMER_LOOP_MAP5 %
00000ec9 : 04061663;   % 894:             bnez a2,RESET_ZOOMER_LOOP_MAP1_NOT_0 %
00000eca : 00600293;   % 896:                 li t0,6 %
00000ecb : 00550023;   % 897:                 sb t0,0(a0) %
00000ecc : 000500a3;   % 898:                 sb zero,1(a0) %
00000ecd : 00050123;   % 899:                 sb zero,2(a0) %
00000ece : 000501a3;   % 900:                 sb zero,3(a0) %
00000ecf : 02200293;   % 901:                 li t0,34 %
00000ed0 : 00550223;   % 902:                 sb t0,4(a0) %
00000ed1 : 000502a3;   % 903:                 sb zero,5(a0) %
00000ed2 : 00700293;   % 904:                 li t0,7 %
00000ed3 : 00550323;   % 905:                 sb t0,6(a0) %
00000ed4 : 000503a3;   % 906:                 sb zero,7(a0) %
00000ed5 : 00050423;   % 907:                 sb zero,8(a0) %
00000ed6 : 00100293;   % 908:                 li t0,1 %
00000ed7 : 005504a3;   % 909:                 sb t0,9(a0) %
00000ed8 : 00300293;   % 910:                 li t0,3 %
00000ed9 : 00550523;   % 911:                 sb t0,10(a0) %
00000eda : 000505a3;   % 912:                 sb zero,11(a0) %
00000edb : 2950006f;   % 913:                 j NEXT_IN_RESET_ZOOMER_LOOP %
00000edc : 00100293;   % 915:             RESET_ZOOMER_LOOP_MAP1_NOT_0: li t0,1 %
00000edd : 04c29463;   % 916:             bne t0,a2,RESET_ZOOMER_LOOP_MAP1_NOT_1 %
00000ede : 00600293;   % 918:                 li t0,6 %
00000edf : 00550023;   % 919:                 sb t0,0(a0) %
00000ee0 : 000500a3;   % 920:                 sb zero,1(a0) %
00000ee1 : 00050123;   % 921:                 sb zero,2(a0) %
00000ee2 : 000501a3;   % 922:                 sb zero,3(a0) %
00000ee3 : 02000293;   % 923:                 li t0,32 %
00000ee4 : 00550223;   % 924:                 sb t0,4(a0) %
00000ee5 : 000502a3;   % 925:                 sb zero,5(a0) %
00000ee6 : 00500293;   % 926:                 li t0,5 %
00000ee7 : 00550323;   % 927:                 sb t0,6(a0) %
00000ee8 : 000503a3;   % 928:                 sb zero,7(a0) %
00000ee9 : 00050423;   % 929:                 sb zero,8(a0) %
00000eea : 000504a3;   % 930:                 sb zero,9(a0) %
00000eeb : 00100293;   % 931:                 li t0,1 %
00000eec : 00550523;   % 932:                 sb t0,10(a0) %
00000eed : 005505a3;   % 933:                 sb t0,11(a0) %
00000eee : 2490006f;   % 934:                 j NEXT_IN_RESET_ZOOMER_LOOP %
00000eef : 00200293;   % 936:             RESET_ZOOMER_LOOP_MAP1_NOT_1: li t0,2 %
00000ef0 : 04c29663;   % 937:             bne t0,a2,RESET_ZOOMER_LOOP_MAP1_NOT_2 %
00000ef1 : 00600293;   % 939:                 li t0,6 %
00000ef2 : 00550023;   % 940:                 sb t0,0(a0) %
00000ef3 : 000500a3;   % 941:                 sb zero,1(a0) %
00000ef4 : 00050123;   % 942:                 sb zero,2(a0) %
00000ef5 : 000501a3;   % 943:                 sb zero,3(a0) %
00000ef6 : 00900293;   % 944:                 li t0,9 %
00000ef7 : 00550223;   % 945:                 sb t0,4(a0) %
00000ef8 : 000502a3;   % 946:                 sb zero,5(a0) %
00000ef9 : 00700293;   % 947:                 li t0,7 %
00000efa : 00550323;   % 948:                 sb t0,6(a0) %
00000efb : 000503a3;   % 949:                 sb zero,7(a0) %
00000efc : 00050423;   % 950:                 sb zero,8(a0) %
00000efd : 00100293;   % 951:                 li t0,1 %
00000efe : 005504a3;   % 952:                 sb t0,9(a0) %
00000eff : 00550523;   % 953:                 sb t0,10(a0) %
00000f00 : 00100293;   % 954:                 li t0,1 %
00000f01 : 005505a3;   % 955:                 sb t0,11(a0) %
00000f02 : 1f90006f;   % 956:                 j NEXT_IN_RESET_ZOOMER_LOOP %
00000f03 : 00300293;   % 958:             RESET_ZOOMER_LOOP_MAP1_NOT_2: li t0,3 %
00000f04 : 04c29663;   % 959:             bne t0,a2,RESET_ZOOMER_LOOP_MAP1_NOT_3 %
00000f05 : 00600293;   % 961:                 li t0,6 %
00000f06 : 00550023;   % 962:                 sb t0,0(a0) %
00000f07 : 000500a3;   % 963:                 sb zero,1(a0) %
00000f08 : 00050123;   % 964:                 sb zero,2(a0) %
00000f09 : 000501a3;   % 965:                 sb zero,3(a0) %
00000f0a : 03700293;   % 966:                 li t0,55 %
00000f0b : 00550223;   % 967:                 sb t0,4(a0) %
00000f0c : 000502a3;   % 968:                 sb zero,5(a0) %
00000f0d : 00200293;   % 969:                 li t0,2 %
00000f0e : 00550323;   % 970:                 sb t0,6(a0) %
00000f0f : 000503a3;   % 971:                 sb zero,7(a0) %
00000f10 : 00050423;   % 972:                 sb zero,8(a0) %
00000f11 : 00100293;   % 973:                 li t0,1 %
00000f12 : 005504a3;   % 974:                 sb t0,9(a0) %
00000f13 : 00200293;   % 975:                 li t0,2 %
00000f14 : 00550523;   % 976:                 sb t0,10(a0) %
00000f15 : 000505a3;   % 977:                 sb zero,11(a0) %
00000f16 : 1a90006f;   % 978:                 j NEXT_IN_RESET_ZOOMER_LOOP %
00000f17 : 00400293;   % 980:             RESET_ZOOMER_LOOP_MAP1_NOT_3: li t0,4 %
00000f18 : 04c29863;   % 981:             bne t0,a2,RESET_ZOOMER_LOOP_MAP1_NOT_4 %
00000f19 : 00600293;   % 983:                 li t0,6 %
00000f1a : 00550023;   % 984:                 sb t0,0(a0) %
00000f1b : 000500a3;   % 985:                 sb zero,1(a0) %
00000f1c : 00050123;   % 986:                 sb zero,2(a0) %
00000f1d : 000501a3;   % 987:                 sb zero,3(a0) %
00000f1e : 03700293;   % 988:                 li t0,55 %
00000f1f : 00550223;   % 989:                 sb t0,4(a0) %
00000f20 : 000502a3;   % 990:                 sb zero,5(a0) %
00000f21 : 00900293;   % 991:                 li t0,9 %
00000f22 : 00550323;   % 992:                 sb t0,6(a0) %
00000f23 : 000503a3;   % 993:                 sb zero,7(a0) %
00000f24 : 00050423;   % 994:                 sb zero,8(a0) %
00000f25 : 00100293;   % 995:                 li t0,1 %
00000f26 : 005504a3;   % 996:                 sb t0,9(a0) %
00000f27 : 00200293;   % 997:                 li t0,2 %
00000f28 : 00550523;   % 998:                 sb t0,10(a0) %
00000f29 : 00100293;   % 999:                 li t0,1 %
00000f2a : 005505a3;   % 1000:                 sb t0,11(a0) %
00000f2b : 1550006f;   % 1001:                 j NEXT_IN_RESET_ZOOMER_LOOP %
00000f2c : 00600293;   % 1005:                 li t0,6 %
00000f2d : 00550023;   % 1006:                 sb t0,0(a0) %
00000f2e : 000500a3;   % 1007:                 sb zero,1(a0) %
00000f2f : 00050123;   % 1008:                 sb zero,2(a0) %
00000f30 : 000501a3;   % 1009:                 sb zero,3(a0) %
00000f31 : 03000293;   % 1010:                 li t0,48 %
00000f32 : 00550223;   % 1011:                 sb t0,4(a0) %
00000f33 : 000502a3;   % 1012:                 sb zero,5(a0) %
00000f34 : 00c00293;   % 1013:                 li t0,12 %
00000f35 : 00550323;   % 1014:                 sb t0,6(a0) %
00000f36 : 000503a3;   % 1015:                 sb zero,7(a0) %
00000f37 : 00050423;   % 1016:                 sb zero,8(a0) %
00000f38 : 00100293;   % 1017:                 li t0,1 %
00000f39 : 005504a3;   % 1018:                 sb t0,9(a0) %
00000f3a : 00050523;   % 1019:                 sb zero,10(a0) %
00000f3b : 000505a3;   % 1020:                 sb zero,11(a0) %
00000f3c : 1110006f;   % 1021:                 j NEXT_IN_RESET_ZOOMER_LOOP %
00000f3d : 04061463;   % 1024:         bnez a2,RESET_ZOOMER_LOOP_MAP2_NOT_0 %
00000f3e : 00600293;   % 1026:                 li t0,6 %
00000f3f : 00550023;   % 1027:                 sb t0,0(a0) %
00000f40 : 000500a3;   % 1028:                 sb zero,1(a0) %
00000f41 : 00050123;   % 1029:                 sb zero,2(a0) %
00000f42 : 000501a3;   % 1030:                 sb zero,3(a0) %
00000f43 : 00f00293;   % 1031:                 li t0,15 %
00000f44 : 00550223;   % 1032:                 sb t0,4(a0) %
00000f45 : 000502a3;   % 1033:                 sb zero,5(a0) %
00000f46 : 00500293;   % 1034:                 li t0,5 %
00000f47 : 00550323;   % 1035:                 sb t0,6(a0) %
00000f48 : 000503a3;   % 1036:                 sb zero,7(a0) %
00000f49 : 00050423;   % 1037:                 sb zero,8(a0) %
00000f4a : 000504a3;   % 1038:                 sb zero,9(a0) %
00000f4b : 00050523;   % 1039:                 sb zero,10(a0) %
00000f4c : 00100293;   % 1040:                 li t0,1 %
00000f4d : 005505a3;   % 1041:                 sb t0,11(a0) %
00000f4e : 0c90006f;   % 1042:                 j NEXT_IN_RESET_ZOOMER_LOOP %
00000f4f : 00100293;   % 1044:             RESET_ZOOMER_LOOP_MAP2_NOT_0: li t0,1 %
00000f50 : 04c29463;   % 1045:             bne t0,a2,RESET_ZOOMER_LOOP_MAP2_NOT_1 %
00000f51 : 00600293;   % 1047:                 li t0,6 %
00000f52 : 00550023;   % 1048:                 sb t0,0(a0) %
00000f53 : 000500a3;   % 1049:                 sb zero,1(a0) %
00000f54 : 00050123;   % 1050:                 sb zero,2(a0) %
00000f55 : 000501a3;   % 1051:                 sb zero,3(a0) %
00000f56 : 00900293;   % 1052:                 li t0,9 %
00000f57 : 00550223;   % 1053:                 sb t0,4(a0) %
00000f58 : 000502a3;   % 1054:                 sb zero,5(a0) %
00000f59 : 00700293;   % 1055:                 li t0,7 %
00000f5a : 00550323;   % 1056:                 sb t0,6(a0) %
00000f5b : 000503a3;   % 1057:                 sb zero,7(a0) %
00000f5c : 00050423;   % 1058:                 sb zero,8(a0) %
00000f5d : 00100293;   % 1059:                 li t0,1 %
00000f5e : 005504a3;   % 1060:                 sb t0,9(a0) %
00000f5f : 00050523;   % 1061:                 sb zero,10(a0) %
00000f60 : 000505a3;   % 1062:                 sb zero,11(a0) %
00000f61 : 07d0006f;   % 1063:                 j NEXT_IN_RESET_ZOOMER_LOOP %
00000f62 : 00200293;   % 1065:             RESET_ZOOMER_LOOP_MAP2_NOT_1: li t0,2 %
00000f63 : 04c29463;   % 1066:             bne t0,a2,RESET_ZOOMER_LOOP_MAP2_NOT_2 %
00000f64 : 00600293;   % 1068:                 li t0,6 %
00000f65 : 00550023;   % 1069:                 sb t0,0(a0) %
00000f66 : 000500a3;   % 1070:                 sb zero,1(a0) %
00000f67 : 00050123;   % 1071:                 sb zero,2(a0) %
00000f68 : 000501a3;   % 1072:                 sb zero,3(a0) %
00000f69 : 00400293;   % 1073:                 li t0,4 %
00000f6a : 00550223;   % 1074:                 sb t0,4(a0) %
00000f6b : 000502a3;   % 1075:                 sb zero,5(a0) %
00000f6c : 00900293;   % 1076:                 li t0,9 %
00000f6d : 00550323;   % 1077:                 sb t0,6(a0) %
00000f6e : 000503a3;   % 1078:                 sb zero,7(a0) %
00000f6f : 00050423;   % 1079:                 sb zero,8(a0) %
00000f70 : 000504a3;   % 1080:                 sb zero,9(a0) %
00000f71 : 00100293;   % 1081:                 li t0,1 %
00000f72 : 00550523;   % 1082:                 sb t0,10(a0) %
00000f73 : 000505a3;   % 1083:                 sb zero,11(a0) %
00000f74 : 0310006f;   % 1084:                 j NEXT_IN_RESET_ZOOMER_LOOP %
00000f75 : 00300293;   % 1086:             RESET_ZOOMER_LOOP_MAP2_NOT_2: li t0,3 %
00000f76 : 04c29663;   % 1087:             bne t0,a2,RESET_ZOOMER_LOOP_MAP2_NOT_3 %
00000f77 : 00600293;   % 1089:                 li t0,6 %
00000f78 : 00550023;   % 1090:                 sb t0,0(a0) %
00000f79 : 000500a3;   % 1091:                 sb zero,1(a0) %
00000f7a : 00050123;   % 1092:                 sb zero,2(a0) %
00000f7b : 000501a3;   % 1093:                 sb zero,3(a0) %
00000f7c : 00c00293;   % 1094:                 li t0,12 %
00000f7d : 00550223;   % 1095:                 sb t0,4(a0) %
00000f7e : 000502a3;   % 1096:                 sb zero,5(a0) %
00000f7f : 00b00293;   % 1097:                 li t0,11 %
00000f80 : 00550323;   % 1098:                 sb t0,6(a0) %
00000f81 : 000503a3;   % 1099:                 sb zero,7(a0) %
00000f82 : 00050423;   % 1100:                 sb zero,8(a0) %
00000f83 : 00100293;   % 1101:                 li t0,1 %
00000f84 : 005504a3;   % 1102:                 sb t0,9(a0) %
00000f85 : 00050523;   % 1103:                 sb zero,10(a0) %
00000f86 : 00100293;   % 1104:                 li t0,1 %
00000f87 : 005505a3;   % 1105:                 sb t0,11(a0) %
00000f88 : 7e00006f;   % 1106:                 j NEXT_IN_RESET_ZOOMER_LOOP %
00000f89 : 00400293;   % 1108:             RESET_ZOOMER_LOOP_MAP2_NOT_3: li t0,4 %
00000f8a : 04c29863;   % 1109:             bne t0,a2,RESET_ZOOMER_LOOP_MAP2_NOT_4 %
00000f8b : 00c00293;   % 1111:                 li t0,12 %
00000f8c : 00550023;   % 1112:                 sb t0,0(a0) %
00000f8d : 00100293;   % 1113:                 li t0,1 %
00000f8e : 005500a3;   % 1114:                 sb t0,1(a0) %
00000f8f : 00050123;   % 1115:                 sb zero,2(a0) %
00000f90 : 000501a3;   % 1116:                 sb zero,3(a0) %
00000f91 : 00600293;   % 1117:                 li t0,6 %
00000f92 : 00550223;   % 1118:                 sb t0,4(a0) %
00000f93 : 000502a3;   % 1119:                 sb zero,5(a0) %
00000f94 : 01200293;   % 1120:                 li t0,18 %
00000f95 : 00550323;   % 1121:                 sb t0,6(a0) %
00000f96 : 000503a3;   % 1122:                 sb zero,7(a0) %
00000f97 : 00050423;   % 1123:                 sb zero,8(a0) %
00000f98 : 00100293;   % 1124:                 li t0,1 %
00000f99 : 005504a3;   % 1125:                 sb t0,9(a0) %
00000f9a : 00300293;   % 1126:                 li t0,3 %
00000f9b : 00550523;   % 1127:                 sb t0,10(a0) %
00000f9c : 000505a3;   % 1128:                 sb zero,11(a0) %
00000f9d : 78c0006f;   % 1129:                 j NEXT_IN_RESET_ZOOMER_LOOP %
00000f9e : 00500293;   % 1131:             RESET_ZOOMER_LOOP_MAP2_NOT_4: li t0,5 %
00000f9f : 04c29463;   % 1132:             bne t0,a2,RESET_ZOOMER_LOOP_MAP2_NOT_5 %
00000fa0 : 00600293;   % 1134:                 li t0,6 %
00000fa1 : 00550023;   % 1135:                 sb t0,0(a0) %
00000fa2 : 000500a3;   % 1136:                 sb zero,1(a0) %
00000fa3 : 00050123;   % 1137:                 sb zero,2(a0) %
00000fa4 : 000501a3;   % 1138:                 sb zero,3(a0) %
00000fa5 : 00c00293;   % 1139:                 li t0,12 %
00000fa6 : 00550223;   % 1140:                 sb t0,4(a0) %
00000fa7 : 000502a3;   % 1141:                 sb zero,5(a0) %
00000fa8 : 01600293;   % 1142:                 li t0,22 %
00000fa9 : 00550323;   % 1143:                 sb t0,6(a0) %
00000faa : 000503a3;   % 1144:                 sb zero,7(a0) %
00000fab : 00050423;   % 1145:                 sb zero,8(a0) %
00000fac : 000504a3;   % 1146:                 sb zero,9(a0) %
00000fad : 00050523;   % 1147:                 sb zero,10(a0) %
00000fae : 00100293;   % 1148:                 li t0,1 %
00000faf : 005505a3;   % 1149:                 sb t0,11(a0) %
00000fb0 : 7400006f;   % 1150:                 j NEXT_IN_RESET_ZOOMER_LOOP    %
00000fb1 : 00600293;   % 1152:             RESET_ZOOMER_LOOP_MAP2_NOT_5: li t0,6 %
00000fb2 : 04c29463;   % 1153:             bne t0,a2,RESET_ZOOMER_LOOP_MAP2_NOT_6 %
00000fb3 : 00c00293;   % 1155:                 li t0,12 %
00000fb4 : 00550023;   % 1156:                 sb t0,0(a0) %
00000fb5 : 00100293;   % 1157:                 li t0,1 %
00000fb6 : 005500a3;   % 1158:                 sb t0,1(a0) %
00000fb7 : 00050123;   % 1159:                 sb zero,2(a0) %
00000fb8 : 000501a3;   % 1160:                 sb zero,3(a0) %
00000fb9 : 00400293;   % 1161:                 li t0,4 %
00000fba : 00550223;   % 1162:                 sb t0,4(a0) %
00000fbb : 000502a3;   % 1163:                 sb zero,5(a0) %
00000fbc : 01c00293;   % 1164:                 li t0,28 %
00000fbd : 00550323;   % 1165:                 sb t0,6(a0) %
00000fbe : 000503a3;   % 1166:                 sb zero,7(a0) %
00000fbf : 00050423;   % 1167:                 sb zero,8(a0) %
00000fc0 : 000504a3;   % 1168:                 sb zero,9(a0) %
00000fc1 : 00050523;   % 1169:                 sb zero,10(a0) %
00000fc2 : 000505a3;   % 1170:                 sb zero,11(a0) %
00000fc3 : 6f40006f;   % 1171:                 j NEXT_IN_RESET_ZOOMER_LOOP      %
00000fc4 : 00700293;   % 1173:             RESET_ZOOMER_LOOP_MAP2_NOT_6: li t0,7 %
00000fc5 : 04c29863;   % 1174:             bne t0,a2,RESET_ZOOMER_LOOP_MAP2_NOT_7 %
00000fc6 : 00c00293;   % 1176:                 li t0,12 %
00000fc7 : 00550023;   % 1177:                 sb t0,0(a0) %
00000fc8 : 00100293;   % 1178:                 li t0,1 %
00000fc9 : 005500a3;   % 1179:                 sb t0,1(a0) %
00000fca : 00050123;   % 1180:                 sb zero,2(a0) %
00000fcb : 000501a3;   % 1181:                 sb zero,3(a0) %
00000fcc : 00700293;   % 1182:                 li t0,7 %
00000fcd : 00550223;   % 1183:                 sb t0,4(a0) %
00000fce : 000502a3;   % 1184:                 sb zero,5(a0) %
00000fcf : 02100293;   % 1185:                 li t0,33 %
00000fd0 : 00550323;   % 1186:                 sb t0,6(a0) %
00000fd1 : 000503a3;   % 1187:                 sb zero,7(a0) %
00000fd2 : 00050423;   % 1188:                 sb zero,8(a0) %
00000fd3 : 00100293;   % 1189:                 li t0,1 %
00000fd4 : 005504a3;   % 1190:                 sb t0,9(a0) %
00000fd5 : 00050523;   % 1191:                 sb zero,10(a0) %
00000fd6 : 00100293;   % 1192:                 li t0,1 %
00000fd7 : 005505a3;   % 1193:                 sb t0,11(a0) %
00000fd8 : 6a00006f;   % 1194:                 j NEXT_IN_RESET_ZOOMER_LOOP   %
00000fd9 : 00600293;   % 1198:                 li t0,6 %
00000fda : 00550023;   % 1199:                 sb t0,0(a0) %
00000fdb : 000500a3;   % 1200:                 sb zero,1(a0) %
00000fdc : 00050123;   % 1201:                 sb zero,2(a0) %
00000fdd : 000501a3;   % 1202:                 sb zero,3(a0) %
00000fde : 01100293;   % 1203:                 li t0,17 %
00000fdf : 00550223;   % 1204:                 sb t0,4(a0) %
00000fe0 : 000502a3;   % 1205:                 sb zero,5(a0) %
00000fe1 : 02200293;   % 1206:                 li t0,34 %
00000fe2 : 00550323;   % 1207:                 sb t0,6(a0) %
00000fe3 : 000503a3;   % 1208:                 sb zero,7(a0) %
00000fe4 : 00050423;   % 1209:                 sb zero,8(a0) %
00000fe5 : 000504a3;   % 1210:                 sb zero,9(a0) %
00000fe6 : 00300293;   % 1211:                 li t0,3 %
00000fe7 : 00550523;   % 1212:                 sb t0,10(a0) %
00000fe8 : 000505a3;   % 1213:                 sb zero,11(a0) %
00000fe9 : 65c0006f;   % 1214:                 j NEXT_IN_RESET_ZOOMER_LOOP         %
00000fea : 04061663;   % 1217:         bnez a2,RESET_ZOOMER_LOOP_MAP3_NOT_0 %
00000feb : 00600293;   % 1219:                 li t0,6 %
00000fec : 00550023;   % 1220:                 sb t0,0(a0) %
00000fed : 000500a3;   % 1221:                 sb zero,1(a0) %
00000fee : 00050123;   % 1222:                 sb zero,2(a0) %
00000fef : 000501a3;   % 1223:                 sb zero,3(a0) %
00000ff0 : 00200293;   % 1224:                 li t0,2 %
00000ff1 : 00550223;   % 1225:                 sb t0,4(a0) %
00000ff2 : 000502a3;   % 1226:                 sb zero,5(a0) %
00000ff3 : 00a00293;   % 1227:                 li t0,10 %
00000ff4 : 00550323;   % 1228:                 sb t0,6(a0) %
00000ff5 : 000503a3;   % 1229:                 sb zero,7(a0) %
00000ff6 : 00050423;   % 1230:                 sb zero,8(a0) %
00000ff7 : 00100293;   % 1231:                 li t0,1 %
00000ff8 : 005504a3;   % 1232:                 sb t0,9(a0) %
00000ff9 : 00100293;   % 1233:                 li t0,1 %
00000ffa : 00550523;   % 1234:                 sb t0,10(a0) %
00000ffb : 000505a3;   % 1235:                 sb zero,11(a0) %
00000ffc : 6100006f;   % 1236:                 j NEXT_IN_RESET_ZOOMER_LOOP %
00000ffd : 00100293;   % 1238:             RESET_ZOOMER_LOOP_MAP3_NOT_0: li t0,1 %
00000ffe : 04c29663;   % 1239:             bne t0,a2,RESET_ZOOMER_LOOP_MAP3_NOT_1 %
00000fff : 00600293;   % 1241:                 li t0,6 %
00001000 : 00550023;   % 1242:                 sb t0,0(a0) %
00001001 : 000500a3;   % 1243:                 sb zero,1(a0) %
00001002 : 00050123;   % 1244:                 sb zero,2(a0) %
00001003 : 000501a3;   % 1245:                 sb zero,3(a0) %
00001004 : 01200293;   % 1246:                 li t0,18 %
00001005 : 00550223;   % 1247:                 sb t0,4(a0) %
00001006 : 000502a3;   % 1248:                 sb zero,5(a0) %
00001007 : 00c00293;   % 1249:                 li t0,12 %
00001008 : 00550323;   % 1250:                 sb t0,6(a0) %
00001009 : 000503a3;   % 1251:                 sb zero,7(a0) %
0000100a : 00050423;   % 1252:                 sb zero,8(a0) %
0000100b : 00100293;   % 1253:                 li t0,1 %
0000100c : 005504a3;   % 1254:                 sb t0,9(a0) %
0000100d : 00050523;   % 1255:                 sb zero,10(a0) %
0000100e : 00100293;   % 1256:                 li t0,1 %
0000100f : 005505a3;   % 1257:                 sb t0,11(a0) %
00001010 : 5c00006f;   % 1258:                 j NEXT_IN_RESET_ZOOMER_LOOP %
00001011 : 00200293;   % 1260:             RESET_ZOOMER_LOOP_MAP3_NOT_1: li t0,2 %
00001012 : 04c29663;   % 1261:             bne t0,a2,RESET_ZOOMER_LOOP_MAP3_NOT_2 %
00001013 : 00600293;   % 1263:                 li t0,6 %
00001014 : 00550023;   % 1264:                 sb t0,0(a0) %
00001015 : 000500a3;   % 1265:                 sb zero,1(a0) %
00001016 : 00050123;   % 1266:                 sb zero,2(a0) %
00001017 : 000501a3;   % 1267:                 sb zero,3(a0) %
00001018 : 01f00293;   % 1268:                 li t0,31 %
00001019 : 00550223;   % 1269:                 sb t0,4(a0) %
0000101a : 000502a3;   % 1270:                 sb zero,5(a0) %
0000101b : 00200293;   % 1271:                 li t0,2 %
0000101c : 00550323;   % 1272:                 sb t0,6(a0) %
0000101d : 000503a3;   % 1273:                 sb zero,7(a0) %
0000101e : 00050423;   % 1274:                 sb zero,8(a0) %
0000101f : 00100293;   % 1275:                 li t0,1 %
00001020 : 005504a3;   % 1276:                 sb t0,9(a0) %
00001021 : 00300293;   % 1277:                 li t0,3 %
00001022 : 00550523;   % 1278:                 sb t0,10(a0) %
00001023 : 000505a3;   % 1279:                 sb zero,11(a0) %
00001024 : 5700006f;   % 1280:                 j NEXT_IN_RESET_ZOOMER_LOOP %
00001025 : 00300293;   % 1282:             RESET_ZOOMER_LOOP_MAP3_NOT_2: li t0,3 %
00001026 : 04c29663;   % 1283:             bne t0,a2,RESET_ZOOMER_LOOP_MAP3_NOT_3 %
00001027 : 00600293;   % 1285:                 li t0,6 %
00001028 : 00550023;   % 1286:                 sb t0,0(a0) %
00001029 : 000500a3;   % 1287:                 sb zero,1(a0) %
0000102a : 00050123;   % 1288:                 sb zero,2(a0) %
0000102b : 000501a3;   % 1289:                 sb zero,3(a0) %
0000102c : 02800293;   % 1290:                 li t0,40 %
0000102d : 00550223;   % 1291:                 sb t0,4(a0) %
0000102e : 000502a3;   % 1292:                 sb zero,5(a0) %
0000102f : 00300293;   % 1293:                 li t0,3 %
00001030 : 00550323;   % 1294:                 sb t0,6(a0) %
00001031 : 000503a3;   % 1295:                 sb zero,7(a0) %
00001032 : 00050423;   % 1296:                 sb zero,8(a0) %
00001033 : 000504a3;   % 1297:                 sb zero,9(a0) %
00001034 : 00200293;   % 1298:                 li t0,2 %
00001035 : 00550523;   % 1299:                 sb t0,10(a0) %
00001036 : 00100293;   % 1300:                 li t0,1 %
00001037 : 005505a3;   % 1301:                 sb t0,11(a0) %
00001038 : 5200006f;   % 1302:                 j NEXT_IN_RESET_ZOOMER_LOOP %
00001039 : 00400293;   % 1304:             RESET_ZOOMER_LOOP_MAP3_NOT_3: li t0,4 %
0000103a : 04c29663;   % 1305:             bne t0,a2,RESET_ZOOMER_LOOP_MAP3_NOT_4 %
0000103b : 00600293;   % 1307:                 li t0,6 %
0000103c : 00550023;   % 1308:                 sb t0,0(a0) %
0000103d : 000500a3;   % 1309:                 sb zero,1(a0) %
0000103e : 00050123;   % 1310:                 sb zero,2(a0) %
0000103f : 000501a3;   % 1311:                 sb zero,3(a0) %
00001040 : 02b00293;   % 1312:                 li t0,43 %
00001041 : 00550223;   % 1313:                 sb t0,4(a0) %
00001042 : 000502a3;   % 1314:                 sb zero,5(a0) %
00001043 : 00c00293;   % 1315:                 li t0,12 %
00001044 : 00550323;   % 1316:                 sb t0,6(a0) %
00001045 : 000503a3;   % 1317:                 sb zero,7(a0) %
00001046 : 00050423;   % 1318:                 sb zero,8(a0) %
00001047 : 00100293;   % 1319:                 li t0,1 %
00001048 : 005504a3;   % 1320:                 sb t0,9(a0) %
00001049 : 00050523;   % 1321:                 sb zero,10(a0) %
0000104a : 00100293;   % 1322:                 li t0,1 %
0000104b : 005505a3;   % 1323:                 sb t0,11(a0) %
0000104c : 4d00006f;   % 1324:                 j NEXT_IN_RESET_ZOOMER_LOOP %
0000104d : 00600293;   % 1328:                 li t0,6 %
0000104e : 00550023;   % 1329:                 sb t0,0(a0) %
0000104f : 000500a3;   % 1330:                 sb zero,1(a0) %
00001050 : 00050123;   % 1331:                 sb zero,2(a0) %
00001051 : 000501a3;   % 1332:                 sb zero,3(a0) %
00001052 : 03000293;   % 1333:                 li t0,48 %
00001053 : 00550223;   % 1334:                 sb t0,4(a0) %
00001054 : 000502a3;   % 1335:                 sb zero,5(a0) %
00001055 : 00100293;   % 1336:                 li t0,1 %
00001056 : 00550323;   % 1337:                 sb t0,6(a0) %
00001057 : 000503a3;   % 1338:                 sb zero,7(a0) %
00001058 : 00050423;   % 1339:                 sb zero,8(a0) %
00001059 : 00100293;   % 1340:                 li t0,1 %
0000105a : 005504a3;   % 1341:                 sb t0,9(a0) %
0000105b : 00550523;   % 1342:                 sb t0,10(a0) %
0000105c : 000505a3;   % 1343:                 sb zero,11(a0) %
0000105d : 48c0006f;   % 1344:                 j NEXT_IN_RESET_ZOOMER_LOOP     %
0000105e : 04061663;   % 1348:         bnez a2,RESET_ZOOMER_LOOP_MAP4_NOT_0 %
0000105f : 00600293;   % 1350:                 li t0,6 %
00001060 : 00550023;   % 1351:                 sb t0,0(a0) %
00001061 : 000500a3;   % 1352:                 sb zero,1(a0) %
00001062 : 00050123;   % 1353:                 sb zero,2(a0) %
00001063 : 000501a3;   % 1354:                 sb zero,3(a0) %
00001064 : 00500293;   % 1355:                 li t0,5 %
00001065 : 00550223;   % 1356:                 sb t0,4(a0) %
00001066 : 000502a3;   % 1357:                 sb zero,5(a0) %
00001067 : 02900293;   % 1358:                 li t0,41 %
00001068 : 00550323;   % 1359:                 sb t0,6(a0) %
00001069 : 000503a3;   % 1360:                 sb zero,7(a0) %
0000106a : 00050423;   % 1361:                 sb zero,8(a0) %
0000106b : 000504a3;   % 1362:                 sb zero,9(a0) %
0000106c : 00300293;   % 1363:                 li t0,3 %
0000106d : 00550523;   % 1364:                 sb t0,10(a0) %
0000106e : 00100293;   % 1365:                 li t0,1 %
0000106f : 005505a3;   % 1366:                 sb t0,11(a0) %
00001070 : 4400006f;   % 1367:                 j NEXT_IN_RESET_ZOOMER_LOOP %
00001071 : 00100293;   % 1369:             RESET_ZOOMER_LOOP_MAP4_NOT_0: li t0,1 %
00001072 : 04c29463;   % 1370:             bne t0,a2,RESET_ZOOMER_LOOP_MAP4_NOT_1 %
00001073 : 00c00293;   % 1372:                 li t0,12 %
00001074 : 00550023;   % 1373:                 sb t0,0(a0) %
00001075 : 00100293;   % 1374:                 li t0,1 %
00001076 : 005500a3;   % 1375:                 sb t0,1(a0) %
00001077 : 00050123;   % 1376:                 sb zero,2(a0) %
00001078 : 000501a3;   % 1377:                 sb zero,3(a0) %
00001079 : 00f00293;   % 1378:                 li t0,15 %
0000107a : 00550223;   % 1379:                 sb t0,4(a0) %
0000107b : 000502a3;   % 1380:                 sb zero,5(a0) %
0000107c : 02600293;   % 1381:                 li t0,38 %
0000107d : 00550323;   % 1382:                 sb t0,6(a0) %
0000107e : 000503a3;   % 1383:                 sb zero,7(a0) %
0000107f : 00050423;   % 1384:                 sb zero,8(a0) %
00001080 : 000504a3;   % 1385:                 sb zero,9(a0) %
00001081 : 00050523;   % 1386:                 sb zero,10(a0) %
00001082 : 000505a3;   % 1387:                 sb zero,11(a0) %
00001083 : 3f40006f;   % 1388:                 j NEXT_IN_RESET_ZOOMER_LOOP %
00001084 : 00200293;   % 1390:             RESET_ZOOMER_LOOP_MAP4_NOT_1: li t0,2 %
00001085 : 04c29663;   % 1391:             bne t0,a2,RESET_ZOOMER_LOOP_MAP4_NOT_2 %
00001086 : 00600293;   % 1393:                 li t0,6 %
00001087 : 00550023;   % 1394:                 sb t0,0(a0) %
00001088 : 000500a3;   % 1395:                 sb zero,1(a0) %
00001089 : 00050123;   % 1396:                 sb zero,2(a0) %
0000108a : 000501a3;   % 1397:                 sb zero,3(a0) %
0000108b : 00800293;   % 1398:                 li t0,8 %
0000108c : 00550223;   % 1399:                 sb t0,4(a0) %
0000108d : 000502a3;   % 1400:                 sb zero,5(a0) %
0000108e : 02100293;   % 1401:                 li t0,33 %
0000108f : 00550323;   % 1402:                 sb t0,6(a0) %
00001090 : 000503a3;   % 1403:                 sb zero,7(a0) %
00001091 : 00050423;   % 1404:                 sb zero,8(a0) %
00001092 : 00100293;   % 1405:                 li t0,1 %
00001093 : 005504a3;   % 1406:                 sb t0,9(a0) %
00001094 : 00100293;   % 1407:                 li t0,1 %
00001095 : 00050523;   % 1408:                 sb zero,10(a0) %
00001096 : 005505a3;   % 1409:                 sb t0,11(a0) %
00001097 : 3a40006f;   % 1410:                 j NEXT_IN_RESET_ZOOMER_LOOP %
00001098 : 00300293;   % 1412:             RESET_ZOOMER_LOOP_MAP4_NOT_2: li t0,3 %
00001099 : 04c29663;   % 1413:             bne t0,a2,RESET_ZOOMER_LOOP_MAP4_NOT_3 %
0000109a : 00c00293;   % 1415:                 li t0,12 %
0000109b : 00550023;   % 1416:                 sb t0,0(a0) %
0000109c : 00100293;   % 1417:                 li t0,1 %
0000109d : 005500a3;   % 1418:                 sb t0,1(a0) %
0000109e : 00050123;   % 1419:                 sb zero,2(a0) %
0000109f : 000501a3;   % 1420:                 sb zero,3(a0) %
000010a0 : 00a00293;   % 1421:                 li t0,10 %
000010a1 : 00550223;   % 1422:                 sb t0,4(a0) %
000010a2 : 000502a3;   % 1423:                 sb zero,5(a0) %
000010a3 : 01a00293;   % 1424:                 li t0,26 %
000010a4 : 00550323;   % 1425:                 sb t0,6(a0) %
000010a5 : 000503a3;   % 1426:                 sb zero,7(a0) %
000010a6 : 00050423;   % 1427:                 sb zero,8(a0) %
000010a7 : 000504a3;   % 1428:                 sb zero,9(a0) %
000010a8 : 00100293;   % 1429:                 li t0,1 %
000010a9 : 00550523;   % 1430:                 sb t0,10(a0) %
000010aa : 000505a3;   % 1431:                 sb zero,11(a0) %
000010ab : 3540006f;   % 1432:                 j NEXT_IN_RESET_ZOOMER_LOOP %
000010ac : 00400293;   % 1434:             RESET_ZOOMER_LOOP_MAP4_NOT_3: li t0,4 %
000010ad : 04c29663;   % 1435:             bne t0,a2,RESET_ZOOMER_LOOP_MAP4_NOT_4 %
000010ae : 00600293;   % 1437:                 li t0,6 %
000010af : 00550023;   % 1438:                 sb t0,0(a0) %
000010b0 : 000500a3;   % 1439:                 sb zero,1(a0) %
000010b1 : 00050123;   % 1440:                 sb zero,2(a0) %
000010b2 : 000501a3;   % 1441:                 sb zero,3(a0) %
000010b3 : 00a00293;   % 1442:                 li t0,10 %
000010b4 : 00550223;   % 1443:                 sb t0,4(a0) %
000010b5 : 000502a3;   % 1444:                 sb zero,5(a0) %
000010b6 : 01600293;   % 1445:                 li t0,22 %
000010b7 : 00550323;   % 1446:                 sb t0,6(a0) %
000010b8 : 000503a3;   % 1447:                 sb zero,7(a0) %
000010b9 : 00050423;   % 1448:                 sb zero,8(a0) %
000010ba : 00100293;   % 1449:                 li t0,1 %
000010bb : 005504a3;   % 1450:                 sb t0,9(a0) %
000010bc : 00050523;   % 1451:                 sb zero,10(a0) %
000010bd : 00100293;   % 1452:                 li t0,1 %
000010be : 005505a3;   % 1453:                 sb t0,11(a0) %
000010bf : 3040006f;   % 1454:                 j NEXT_IN_RESET_ZOOMER_LOOP %
000010c0 : 00500293;   % 1456:             RESET_ZOOMER_LOOP_MAP4_NOT_4: li t0,5 %
000010c1 : 04c29663;   % 1457:             bne t0,a2,RESET_ZOOMER_LOOP_MAP4_NOT_5 %
000010c2 : 00c00293;   % 1459:                 li t0,12 %
000010c3 : 00550023;   % 1460:                 sb t0,0(a0) %
000010c4 : 00100293;   % 1461:                 li t0,1 %
000010c5 : 005500a3;   % 1462:                 sb t0,1(a0) %
000010c6 : 00050123;   % 1463:                 sb zero,2(a0) %
000010c7 : 000501a3;   % 1464:                 sb zero,3(a0) %
000010c8 : 00400293;   % 1465:                 li t0,4 %
000010c9 : 00550223;   % 1466:                 sb t0,4(a0) %
000010ca : 000502a3;   % 1467:                 sb zero,5(a0) %
000010cb : 01500293;   % 1468:                 li t0,21 %
000010cc : 00550323;   % 1469:                 sb t0,6(a0) %
000010cd : 000503a3;   % 1470:                 sb zero,7(a0) %
000010ce : 00050423;   % 1471:                 sb zero,8(a0) %
000010cf : 000504a3;   % 1472:                 sb zero,9(a0) %
000010d0 : 00050523;   % 1473:                 sb zero,10(a0) %
000010d1 : 00100293;   % 1474:                 li t0,1 %
000010d2 : 005505a3;   % 1475:                 sb t0,11(a0) %
000010d3 : 2b40006f;   % 1476:                 j NEXT_IN_RESET_ZOOMER_LOOP    %
000010d4 : 00600293;   % 1478:             RESET_ZOOMER_LOOP_MAP4_NOT_5: li t0,6 %
000010d5 : 04c29463;   % 1479:             bne t0,a2,RESET_ZOOMER_LOOP_MAP4_NOT_6 %
000010d6 : 00600293;   % 1481:                 li t0,6 %
000010d7 : 00550023;   % 1482:                 sb t0,0(a0) %
000010d8 : 000500a3;   % 1483:                 sb zero,1(a0) %
000010d9 : 00050123;   % 1484:                 sb zero,2(a0) %
000010da : 000501a3;   % 1485:                 sb zero,3(a0) %
000010db : 01100293;   % 1486:                 li t0,17 %
000010dc : 00550223;   % 1487:                 sb t0,4(a0) %
000010dd : 000502a3;   % 1488:                 sb zero,5(a0) %
000010de : 01500293;   % 1489:                 li t0,21 %
000010df : 00550323;   % 1490:                 sb t0,6(a0) %
000010e0 : 000503a3;   % 1491:                 sb zero,7(a0) %
000010e1 : 00050423;   % 1492:                 sb zero,8(a0) %
000010e2 : 000504a3;   % 1493:                 sb zero,9(a0) %
000010e3 : 00300293;   % 1494:                 li t0,3 %
000010e4 : 00550523;   % 1495:                 sb t0,10(a0) %
000010e5 : 000505a3;   % 1496:                 sb zero,11(a0) %
000010e6 : 2680006f;   % 1497:                 j NEXT_IN_RESET_ZOOMER_LOOP      %
000010e7 : 00700293;   % 1499:             RESET_ZOOMER_LOOP_MAP4_NOT_6: li t0,7 %
000010e8 : 04c29863;   % 1500:             bne t0,a2,RESET_ZOOMER_LOOP_MAP4_NOT_7 %
000010e9 : 00c00293;   % 1502:                 li t0,12 %
000010ea : 00550023;   % 1503:                 sb t0,0(a0) %
000010eb : 00100293;   % 1504:                 li t0,1 %
000010ec : 005500a3;   % 1505:                 sb t0,1(a0) %
000010ed : 00050123;   % 1506:                 sb zero,2(a0) %
000010ee : 000501a3;   % 1507:                 sb zero,3(a0) %
000010ef : 00c00293;   % 1508:                 li t0,12 %
000010f0 : 00550223;   % 1509:                 sb t0,4(a0) %
000010f1 : 000502a3;   % 1510:                 sb zero,5(a0) %
000010f2 : 00f00293;   % 1511:                 li t0,15 %
000010f3 : 00550323;   % 1512:                 sb t0,6(a0) %
000010f4 : 000503a3;   % 1513:                 sb zero,7(a0) %
000010f5 : 00050423;   % 1514:                 sb zero,8(a0) %
000010f6 : 00100293;   % 1515:                 li t0,1 %
000010f7 : 005504a3;   % 1516:                 sb t0,9(a0) %
000010f8 : 00200293;   % 1517:                 li t0,2 %
000010f9 : 00550523;   % 1518:                 sb t0,10(a0) %
000010fa : 000505a3;   % 1519:                 sb zero,11(a0) %
000010fb : 2140006f;   % 1520:                 j NEXT_IN_RESET_ZOOMER_LOOP   %
000010fc : 00800293;   % 1522:             RESET_ZOOMER_LOOP_MAP4_NOT_7: li t0,8 %
000010fd : 04c29463;   % 1523:             bne t0,a2,RESET_ZOOMER_LOOP_MAP4_NOT_8 %
000010fe : 00600293;   % 1525:                 li t0,6 %
000010ff : 00550023;   % 1526:                 sb t0,0(a0) %
00001100 : 000500a3;   % 1527:                 sb zero,1(a0) %
00001101 : 00050123;   % 1528:                 sb zero,2(a0) %
00001102 : 000501a3;   % 1529:                 sb zero,3(a0) %
00001103 : 00700293;   % 1530:                 li t0,7 %
00001104 : 00550223;   % 1531:                 sb t0,4(a0) %
00001105 : 000502a3;   % 1532:                 sb zero,5(a0) %
00001106 : 00b00293;   % 1533:                 li t0,11 %
00001107 : 00550323;   % 1534:                 sb t0,6(a0) %
00001108 : 000503a3;   % 1535:                 sb zero,7(a0) %
00001109 : 00050423;   % 1536:                 sb zero,8(a0) %
0000110a : 000504a3;   % 1537:                 sb zero,9(a0) %
0000110b : 00050523;   % 1538:                 sb zero,10(a0) %
0000110c : 00100293;   % 1539:                 li t0,1 %
0000110d : 005505a3;   % 1540:                 sb t0,11(a0) %
0000110e : 1c80006f;   % 1541:                 j NEXT_IN_RESET_ZOOMER_LOOP     %
0000110f : 00900293;   % 1543:             RESET_ZOOMER_LOOP_MAP4_NOT_8: li t0,9 %
00001110 : 04c29463;   % 1544:             bne t0,a2,RESET_ZOOMER_LOOP_MAP4_NOT_9 %
00001111 : 00600293;   % 1546:                 li t0,6 %
00001112 : 00550023;   % 1547:                 sb t0,0(a0) %
00001113 : 000500a3;   % 1548:                 sb zero,1(a0) %
00001114 : 00050123;   % 1549:                 sb zero,2(a0) %
00001115 : 000501a3;   % 1550:                 sb zero,3(a0) %
00001116 : 00500293;   % 1551:                 li t0,5 %
00001117 : 00550223;   % 1552:                 sb t0,4(a0) %
00001118 : 000502a3;   % 1553:                 sb zero,5(a0) %
00001119 : 00800293;   % 1554:                 li t0,8 %
0000111a : 00550323;   % 1555:                 sb t0,6(a0) %
0000111b : 000503a3;   % 1556:                 sb zero,7(a0) %
0000111c : 00050423;   % 1557:                 sb zero,8(a0) %
0000111d : 000504a3;   % 1558:                 sb zero,9(a0) %
0000111e : 00100293;   % 1559:                 li t0,1 %
0000111f : 00550523;   % 1560:                 sb t0,10(a0) %
00001120 : 000505a3;   % 1561:                 sb zero,11(a0) %
00001121 : 17c0006f;   % 1562:                 j NEXT_IN_RESET_ZOOMER_LOOP  %
00001122 : 00c00293;   % 1566:                 li t0,12 %
00001123 : 00550023;   % 1567:                 sb t0,0(a0) %
00001124 : 00100293;   % 1568:                 li t0,1 %
00001125 : 005500a3;   % 1569:                 sb t0,1(a0) %
00001126 : 00050123;   % 1570:                 sb zero,2(a0) %
00001127 : 000501a3;   % 1571:                 sb zero,3(a0) %
00001128 : 00800293;   % 1572:                 li t0,8 %
00001129 : 00550223;   % 1573:                 sb t0,4(a0) %
0000112a : 000502a3;   % 1574:                 sb zero,5(a0) %
0000112b : 00300293;   % 1575:                 li t0,3 %
0000112c : 00550323;   % 1576:                 sb t0,6(a0) %
0000112d : 000503a3;   % 1577:                 sb zero,7(a0) %
0000112e : 00050423;   % 1578:                 sb zero,8(a0) %
0000112f : 00100293;   % 1579:                 li t0,1 %
00001130 : 005504a3;   % 1580:                 sb t0,9(a0) %
00001131 : 00050523;   % 1581:                 sb zero,10(a0) %
00001132 : 00100293;   % 1582:                 li t0,1 %
00001133 : 005505a3;   % 1583:                 sb t0,11(a0) %
00001134 : 1300006f;   % 1584:                 j NEXT_IN_RESET_ZOOMER_LOOP      %
00001135 : 04061663;   % 1587:         bnez a2,RESET_ZOOMER_LOOP_MAP5_NOT_0 %
00001136 : 00600293;   % 1589:                 li t0,6 %
00001137 : 00550023;   % 1590:                 sb t0,0(a0) %
00001138 : 000500a3;   % 1591:                 sb zero,1(a0) %
00001139 : 00050123;   % 1592:                 sb zero,2(a0) %
0000113a : 000501a3;   % 1593:                 sb zero,3(a0) %
0000113b : 01e00293;   % 1594:                 li t0,30 %
0000113c : 00550223;   % 1595:                 sb t0,4(a0) %
0000113d : 000502a3;   % 1596:                 sb zero,5(a0) %
0000113e : 00c00293;   % 1597:                 li t0,12 %
0000113f : 00550323;   % 1598:                 sb t0,6(a0) %
00001140 : 000503a3;   % 1599:                 sb zero,7(a0) %
00001141 : 00050423;   % 1600:                 sb zero,8(a0) %
00001142 : 00100293;   % 1601:                 li t0,1 %
00001143 : 005504a3;   % 1602:                 sb t0,9(a0) %
00001144 : 00050523;   % 1603:                 sb zero,10(a0) %
00001145 : 00100293;   % 1604:                 li t0,1 %
00001146 : 005505a3;   % 1605:                 sb t0,11(a0) %
00001147 : 0e40006f;   % 1606:                 j NEXT_IN_RESET_ZOOMER_LOOP %
00001148 : 00100293;   % 1608:             RESET_ZOOMER_LOOP_MAP5_NOT_0: li t0,1 %
00001149 : 04c29663;   % 1609:             bne t0,a2,RESET_ZOOMER_LOOP_MAP5_NOT_1 %
0000114a : 00c00293;   % 1611:                 li t0,12 %
0000114b : 00550023;   % 1612:                 sb t0,0(a0) %
0000114c : 00100293;   % 1613:                 li t0,1 %
0000114d : 005500a3;   % 1614:                 sb t0,1(a0) %
0000114e : 00050123;   % 1615:                 sb zero,2(a0) %
0000114f : 000501a3;   % 1616:                 sb zero,3(a0) %
00001150 : 01500293;   % 1617:                 li t0,21 %
00001151 : 00550223;   % 1618:                 sb t0,4(a0) %
00001152 : 000502a3;   % 1619:                 sb zero,5(a0) %
00001153 : 00c00293;   % 1620:                 li t0,12 %
00001154 : 00550323;   % 1621:                 sb t0,6(a0) %
00001155 : 000503a3;   % 1622:                 sb zero,7(a0) %
00001156 : 00050423;   % 1623:                 sb zero,8(a0) %
00001157 : 000504a3;   % 1624:                 sb zero,9(a0) %
00001158 : 00050523;   % 1625:                 sb zero,10(a0) %
00001159 : 00100293;   % 1626:                 li t0,1 %
0000115a : 005505a3;   % 1627:                 sb t0,11(a0) %
0000115b : 0940006f;   % 1628:                 j NEXT_IN_RESET_ZOOMER_LOOP %
0000115c : 00200293;   % 1630:             RESET_ZOOMER_LOOP_MAP5_NOT_1: li t0,2 %
0000115d : 04c29463;   % 1631:             bne t0,a2,RESET_ZOOMER_LOOP_MAP5_NOT_2 %
0000115e : 00600293;   % 1633:                 li t0,6 %
0000115f : 00550023;   % 1634:                 sb t0,0(a0) %
00001160 : 000500a3;   % 1635:                 sb zero,1(a0) %
00001161 : 00050123;   % 1636:                 sb zero,2(a0) %
00001162 : 000501a3;   % 1637:                 sb zero,3(a0) %
00001163 : 01300293;   % 1638:                 li t0,19 %
00001164 : 00550223;   % 1639:                 sb t0,4(a0) %
00001165 : 000502a3;   % 1640:                 sb zero,5(a0) %
00001166 : 00c00293;   % 1641:                 li t0,12 %
00001167 : 00550323;   % 1642:                 sb t0,6(a0) %
00001168 : 000503a3;   % 1643:                 sb zero,7(a0) %
00001169 : 00050423;   % 1644:                 sb zero,8(a0) %
0000116a : 00100293;   % 1645:                 li t0,1 %
0000116b : 005504a3;   % 1646:                 sb t0,9(a0) %
0000116c : 00050523;   % 1647:                 sb zero,10(a0) %
0000116d : 000505a3;   % 1648:                 sb zero,11(a0) %
0000116e : 0480006f;   % 1649:                 j NEXT_IN_RESET_ZOOMER_LOOP %
0000116f : 00600293;   % 1653:                 li t0,6 %
00001170 : 00550023;   % 1654:                 sb t0,0(a0) %
00001171 : 000500a3;   % 1655:                 sb zero,1(a0) %
00001172 : 00050123;   % 1656:                 sb zero,2(a0) %
00001173 : 000501a3;   % 1657:                 sb zero,3(a0) %
00001174 : 00900293;   % 1658:                 li t0,9 %
00001175 : 00550223;   % 1659:                 sb t0,4(a0) %
00001176 : 000502a3;   % 1660:                 sb zero,5(a0) %
00001177 : 00800293;   % 1661:                 li t0,8 %
00001178 : 00550323;   % 1662:                 sb t0,6(a0) %
00001179 : 000503a3;   % 1663:                 sb zero,7(a0) %
0000117a : 00050423;   % 1664:                 sb zero,8(a0) %
0000117b : 00100293;   % 1665:                 li t0,1 %
0000117c : 005504a3;   % 1666:                 sb t0,9(a0) %
0000117d : 00550523;   % 1667:                 sb t0,10(a0) %
0000117e : 005505a3;   % 1668:                 sb t0,11(a0) %
0000117f : 0040006f;   % 1669:                 j NEXT_IN_RESET_ZOOMER_LOOP %
00001180 : 00c50513;   % 1674:             addi a0,a0,12  # Going to the next zoomer's address                                   %
00001181 : 00160613;   % 1675:             addi a2,a2,1            # Iterating counter by 1                                    %
00001182 : 00b65463;   % 1676:             bge a2,a1, END_RESET_ZOOMER_LOOP # If all of the zoomers were checked, end loop                                   %
00001183 : ce4ff06f;   % 1677:             j RESET_ZOOMER_LOOP # otherwise, go back to the loop's beginning                      %
00001184 : 00700293;   % 1685:     li t0,7 %
00001185 : 00589463;   % 1686:     bne a7,t0,RESET_RIDLEY %
00001186 : 0680006f;   % 1687:         j END_RESET_PLASMA_BREATH_LOOP %
00001187 : 0fc0c297;   % 1690:         la t0, RIDLEY_INFO %
00001188 : e3c28293;   % 1690:  %
00001189 : 03200313;   % 1691:         li t1, 50 %
0000118a : 00628023;   % 1692:         sb t1, 0(t0)            # Restores Ridley's health points %
0000118b : 00a00313;   % 1693:         li t1,10 %
0000118c : 00628123;   % 1694:         sb t1,2(t0)             # Restores Ridley's Y offset %
0000118d : 00500313;   % 1695:         li t1,5 %
0000118e : 006281a3;   % 1696:         sb t1,3(t0)             # Restores Ridley's Y %
0000118f : 00628223;   % 1697:         sb t1,4(t0)             # Restores Ridley's old Y %
00001190 : 00028323;   % 1698:         sb zero,6(t0)           # Restores Ridley's ground position %
00001191 : 000283a3;   % 1699:         sb zero,7(t0)           # Restores Ridley's MOVE_Y %
00001192 : 00028423;   % 1700:         sb zero,8(t0)           # Restores Ridley's JUMP %
00001193 : 01400313;   % 1701:         li t1, 20 %
00001194 : 006284a3;   % 1702:         sb t1,9(t0)             # Restores Ridley's jump cooldown %
00001195 : 00800313;   % 1703:         li t1,8 %
00001196 : 00628523;   % 1704:         sb t1,10(t0)            # Restores Ridley's attack cooldown %
00001197 : 0fc0c517;   % 1706:     la a0,PLASMA_BREATH_ARRAY  # Loads Plasma breath array %
00001198 : e0c50513;   % 1706:  %
00001199 : 00000613;   % 1707:     li a2,0 # resets counter %
0000119a : 00500593;   % 1708:     li a1,5 # gets number of plasma breaths in game %
0000119b : 00050023;   % 1710:         sb zero,0(a0)   # Disables it %
0000119c : 00a50513;   % 1713:             addi a0,a0,10  # Going to the next plasma breath's address                                   %
0000119d : 00160613;   % 1714:             addi a2,a2,1            # Iterating counter by 1                                    %
0000119e : 00b65463;   % 1715:             bge a2,a1, END_RESET_PLASMA_BREATH_LOOP # If all of the plasma breaths were checked, end loop (don't attack)                                 %
0000119f : ff1ff06f;   % 1716:             j RESET_PLASMA_BREATH_LOOP # otherwise, go back to the loop's beginning  %
000011a0 : 00008067;   % 1719:     ret %
000011a1 : 0420d073;   % 137: 	csrwi ucause,1		# caso ocorra dropdown vai gerar exce��o de instru��o inv�lida %
000011a2 : ff810113;   % 139: ExceptionHandling:	addi 	sp, sp, -8 	# salva 2 registradores utilizados para comparar ucause %
000011a3 : 00512023;   % 140: 	sw 	t0, 0(sp) %
000011a4 : 01a12223;   % 141: 	sw 	s10, 4(sp) %
000011a5 : 04202d73;   % 143: 	csrr	s10,ucause     # le o ucause e salva em s10 %
000011a6 : 00800293;   % 145: 	li 	t0, 8 %
000011a7 : 01a29a63;   % 146: 	bne 	t0, s10, errorExceptions  	# N�o � ecall - nem precisa arrumar a pilha! %
000011a8 : 00012283;   % 148: 	lw 	t0, 0(sp)			# � ecall %
000011a9 : 00412d03;   % 149:     	lw 	s10, 4(sp)  			# recupera registradores usados %
000011aa : 00810113;   % 150:     	addi 	sp, sp, 8			 %
000011ab : 2080006f;   % 151: 	j 	ecallException %
000011ac : 04302df3;   % 157: errorExceptions: csrr 	s11, utval      # le o utval da exce��o e salva em s11	 %
000011ad : 0c000513;   % 158: 	addi 	a0, zero, 0xc0 		## printa tela de azul %
000011ae : 00000593;   % 159: 	addi 	a1, zero, 0 %
000011af : 09400893;   % 160: 	addi 	a7, zero, 148 %
000011b0 : 3bc010ef;   % 161: 	jal 	clsCLS %
000011b1 : 00000293;   % 164: End_Cause0:	li 	t0, 0 %
000011b2 : 03a29463;   % 165: 		bne 	t0, s10, End_Cause1 %
000011b3 : 0fc20517;   % 166: 		la 	a0, Cause0 %
000011b4 : 24450513;   % 166:  %
000011b5 : 00000593;   % 167: 		li 	a1, 0 %
000011b6 : 00100613;   % 168: 		li 	a2, 1 %
000011b7 : 0000c6b7;   % 169: 		li 	a3, 0x0000c0ff %
000011b8 : 0ff68693;   % 169:  %
000011b9 : 00000793;   % 170: 		li 	a5,0 %
000011ba : 195000ef;   % 171: 		jal	printString %
000011bb : 18c0006f;   % 172: 		j	End_uepc %
000011bc : 00100293;   % 175: End_Cause1:	li 	t0, 1 %
000011bd : 03a29463;   % 176: 		bne 	t0, s10, End_Cause2 %
000011be : 0fc20517;   % 177: 		la 	a0, Cause1 %
000011bf : 24150513;   % 177:  %
000011c0 : 00000593;   % 178: 		li 	a1, 0 %
000011c1 : 00100613;   % 179: 		li 	a2, 1 %
000011c2 : 0000c6b7;   % 180: 		li 	a3, 0x0000c0ff %
000011c3 : 0ff68693;   % 180:  %
000011c4 : 00000793;   % 181: 		li 	a5,0 %
000011c5 : 169000ef;   % 182: 		jal	printString	 %
000011c6 : 1600006f;   % 183: 		j	End_uepc %
000011c7 : 00200293;   % 186: End_Cause2:	li 	t0, 2 %
000011c8 : 03a29863;   % 187: 		bne 	t0, s10, End_Cause4 %
000011c9 : 0fc20517;   % 188: 		la 	a0, Cause2 %
000011ca : 23850513;   % 188:  %
000011cb : 00000593;   % 189: 		li 	a1, 0 %
000011cc : 00100613;   % 190: 		li 	a2, 1 %
000011cd : 0000c6b7;   % 191: 		li 	a3, 0x0000c0ff %
000011ce : 0ff68693;   % 191:  %
000011cf : 00000793;   % 192: 		li 	a5,0 %
000011d0 : 13d000ef;   % 193: 		jal	printString %
000011d1 : 0fc20517;   % 195: 		la 	a0, Instr %
000011d2 : 2de50513;   % 195:  %
000011d3 : 0fc0006f;   % 196: 		j	End_utval %
000011d4 : 00400293;   % 199: End_Cause4:	addi 	t0, zero, 4 %
000011d5 : 03a29863;   % 200: 		bne	t0, s10, End_Cause5 %
000011d6 : 0fc20517;   % 201: 		la 	a0, Cause4 %
000011d7 : 22150513;   % 201:  %
000011d8 : 00000593;   % 202: 		li 	a1, 0 %
000011d9 : 00100613;   % 203: 		li 	a2, 1 %
000011da : 0000c6b7;   % 204: 		li 	a3, 0x0000c0ff %
000011db : 0ff68693;   % 204:  %
000011dc : 00000793;   % 205: 		li 	a5,0 %
000011dd : 109000ef;   % 206: 		jal	printString %
000011de : 0fc20517;   % 208: 		la 	a0, Addrs %
000011df : 2a250513;   % 208:  %
000011e0 : 0c80006f;   % 209: 		j	End_utval %
000011e1 : 00500293;   % 212: End_Cause5:	li 	t0, 5 %
000011e2 : 03a29863;   % 213: 		bne 	t0, s10, End_Cause6 %
000011e3 : 0fc20517;   % 214: 		la 	a0, Cause5 %
000011e4 : 20f50513;   % 214:  %
000011e5 : 00000593;   % 215: 		li 	a1, 0 %
000011e6 : 00100613;   % 216: 		li 	a2, 1 %
000011e7 : 0000c6b7;   % 217: 		li 	a3, 0x0000c0ff %
000011e8 : 0ff68693;   % 217:  %
000011e9 : 00000793;   % 218: 		li 	a5,0 %
000011ea : 0d5000ef;   % 219: 		jal	printString	 %
000011eb : 0fc20517;   % 221: 		la 	a0, Addrs %
000011ec : 26e50513;   % 221:  %
000011ed : 0940006f;   % 222: 		j	End_utval %
000011ee : 00600293;   % 225: End_Cause6:	li 	t0, 6 %
000011ef : 03a29863;   % 226: 		bne 	t0, s10, End_Cause7 %
000011f0 : 0fc20517;   % 227: 		la 	a0, Cause6 %
000011f1 : 1f750513;   % 227:  %
000011f2 : 00000593;   % 228: 		li 	a1, 0 %
000011f3 : 00100613;   % 229: 		li 	a2, 1 %
000011f4 : 0000c6b7;   % 230: 		li 	a3, 0x0000c0ff %
000011f5 : 0ff68693;   % 230:  %
000011f6 : 00000793;   % 231: 		li 	a5,0 %
000011f7 : 0a1000ef;   % 232: 		jal	printString %
000011f8 : 0fc20517;   % 234: 		la 	a0, Addrs %
000011f9 : 23a50513;   % 234:  %
000011fa : 0600006f;   % 235: 		j	End_utval %
000011fb : 00700293;   % 238: End_Cause7:	li 	t0, 7 %
000011fc : 03a29863;   % 239: 		bne 	t0, s10, End_CauseD %
000011fd : 0fc20517;   % 240: 		la 	a0, Cause7 %
000011fe : 1e650513;   % 240:  %
000011ff : 00000593;   % 241: 		li 	a1, 0 %
00001200 : 00100613;   % 242: 		li 	a2, 1 %
00001201 : 0000c6b7;   % 243: 		li 	a3, 0x0000c0ff %
00001202 : 0ff68693;   % 243:  %
00001203 : 00000793;   % 244: 		li 	a5,0 %
00001204 : 06d000ef;   % 245: 		jal	printString %
00001205 : 0fc20517;   % 247: 		la 	a0, Addrs %
00001206 : 20650513;   % 247:  %
00001207 : 02c0006f;   % 248: 		j	End_utval %
00001208 : 0fc20517;   % 251: End_CauseD: 	la 	a0, CauseD %
00001209 : 1d750513;   % 251:  %
0000120a : 00000593;   % 252: 		li 	a1, 0 %
0000120b : 00100613;   % 253: 		li 	a2, 1 %
0000120c : 0000c6b7;   % 254: 		li 	a3, 0x0000c0ff %
0000120d : 0ff68693;   % 254:  %
0000120e : 00000793;   % 255: 		li 	a5,0 %
0000120f : 041000ef;   % 256: 		jal	printString %
00001210 : 0fc20517;   % 258: 		la 	a0, Addrs %
00001211 : 1da50513;   % 258:  %
00001212 : 00000593;   % 261: End_utval:	li 	a1, 0 %
00001213 : 01800613;   % 262: 		li 	a2, 24 %
00001214 : 0000c6b7;   % 263: 		li 	a3, 0x000c0ff %
00001215 : 0ff68693;   % 263:  %
00001216 : 00000793;   % 264: 		li 	a5,0 %
00001217 : 021000ef;   % 265: 		jal	printString %
00001218 : 01b00533;   % 267: 		mv 	a0, s11 %
00001219 : 03800593;   % 268: 		li 	a1, 56 %
0000121a : 01800613;   % 269: 		li 	a2, 24 %
0000121b : 0000c6b7;   % 270: 		li 	a3, 0x0000c0ff %
0000121c : 0ff68693;   % 270:  %
0000121d : 794000ef;   % 271: 		jal 	printHex %
0000121e : 0fc20517;   % 274: End_uepc: 	la 	a0, PC 		# Imprime o pc em que a exce��o ocorreu %
0000121f : 19d50513;   % 274:  %
00001220 : 00000593;   % 275: 		li 	a1, 0 %
00001221 : 00c00613;   % 276: 		li 	a2, 12 %
00001222 : 0000c6b7;   % 277: 		li 	a3, 0x000c0ff %
00001223 : 0ff68693;   % 277:  %
00001224 : 00000793;   % 278: 		li 	a5,0 %
00001225 : 7e8000ef;   % 279: 		jal	printString %
00001226 : 04102573;   % 281: 		csrr 	a0, uepc	# Le uepc	 %
00001227 : 01c00593;   % 282: 		li	a1, 28 %
00001228 : 00c00613;   % 283: 		li 	a2, 12 %
00001229 : 0000c6b7;   % 284: 		li 	a3, 0x0000c0ff %
0000122a : 0ff68693;   % 284:  %
0000122b : 75c000ef;   % 285: 		jal 	printHex	 %
0000122c : 2800006f;   % 287: 		j goToExit 		# encerra execu��o %
0000122d : ef810113;   % 294: ecallException:   addi    sp, sp, -264              # Salva todos os registradores na pilha %
0000122e : 00112023;   % 295:     sw     x1,    0(sp) %
0000122f : 00212223;   % 296:     sw     x2,    4(sp) %
00001230 : 00312423;   % 297:     sw     x3,    8(sp) %
00001231 : 00412623;   % 298:     sw     x4,   12(sp) %
00001232 : 00512823;   % 299:     sw     x5,   16(sp) %
00001233 : 00612a23;   % 300:     sw     x6,   20(sp) %
00001234 : 00712c23;   % 301:     sw     x7,   24(sp) %
00001235 : 00812e23;   % 302:     sw     x8,   28(sp) %
00001236 : 02912023;   % 303:     sw     x9,   32(sp) %
00001237 : 02a12223;   % 304:     sw     x10,  36(sp) %
00001238 : 02b12423;   % 305:     sw     x11,  40(sp) %
00001239 : 02c12623;   % 306:     sw     x12,  44(sp) %
0000123a : 02d12823;   % 307:     sw     x13,  48(sp) %
0000123b : 02e12a23;   % 308:     sw     x14,  52(sp) %
0000123c : 02f12c23;   % 309:     sw     x15,  56(sp) %
0000123d : 03012e23;   % 310:     sw     x16,  60(sp) %
0000123e : 05112023;   % 311:     sw     x17,  64(sp) %
0000123f : 05212223;   % 312:     sw     x18,  68(sp) %
00001240 : 05312423;   % 313:     sw     x19,  72(sp) %
00001241 : 05412623;   % 314:     sw     x20,  76(sp) %
00001242 : 05512823;   % 315:     sw     x21,  80(sp) %
00001243 : 05612a23;   % 316:     sw     x22,  84(sp) %
00001244 : 05712c23;   % 317:     sw     x23,  88(sp) %
00001245 : 05812e23;   % 318:     sw     x24,  92(sp) %
00001246 : 07912023;   % 319:     sw     x25,  96(sp) %
00001247 : 07a12223;   % 320:     sw     x26, 100(sp) %
00001248 : 07b12423;   % 321:     sw     x27, 104(sp) %
00001249 : 07c12623;   % 322:     sw     x28, 108(sp) %
0000124a : 07d12823;   % 323:     sw     x29, 112(sp) %
0000124b : 07e12a23;   % 324:     sw     x30, 116(sp) %
0000124c : 07f12c23;   % 325:     sw     x31, 120(sp) %
0000124d : 30102c73;   % 326: <22> csrr s8, misa %
0000124e : 020c7c13;   % 326: <23> andi s8, s8, 0x020 %
0000124f : 080c0263;   % 326: <24> beqz s8, ecallException.pula %
00001250 : 06012e27;   % 327:     fsw    f0,  124(sp) %
00001251 : 08112027;   % 328:     fsw    f1,  128(sp) %
00001252 : 08212227;   % 329:     fsw    f2,  132(sp) %
00001253 : 08312427;   % 330:     fsw    f3,  136(sp) %
00001254 : 08412627;   % 331:     fsw    f4,  140(sp) %
00001255 : 08512827;   % 332:     fsw    f5,  144(sp) %
00001256 : 08612a27;   % 333:     fsw    f6,  148(sp) %
00001257 : 08712c27;   % 334:     fsw    f7,  152(sp) %
00001258 : 08812e27;   % 335:     fsw    f8,  156(sp) %
00001259 : 0a912027;   % 336:     fsw    f9,  160(sp) %
0000125a : 0aa12227;   % 337:     fsw    f10, 164(sp) %
0000125b : 0ab12427;   % 338:     fsw    f11, 168(sp) %
0000125c : 0ac12627;   % 339:     fsw    f12, 172(sp) %
0000125d : 0ad12827;   % 340:     fsw    f13, 176(sp) %
0000125e : 0ae12a27;   % 341:     fsw    f14, 180(sp) %
0000125f : 0af12c27;   % 342:     fsw    f15, 184(sp) %
00001260 : 0b012e27;   % 343:     fsw    f16, 188(sp) %
00001261 : 0d112027;   % 344:     fsw    f17, 192(sp) %
00001262 : 0d212227;   % 345:     fsw    f18, 196(sp) %
00001263 : 0d312427;   % 346:     fsw    f19, 200(sp) %
00001264 : 0d412627;   % 347:     fsw    f20, 204(sp) %
00001265 : 0d512827;   % 348:     fsw    f21, 208(sp) %
00001266 : 0d612a27;   % 349:     fsw    f22, 212(sp) %
00001267 : 0d712c27;   % 350:     fsw    f23, 216(sp) %
00001268 : 0d812e27;   % 351:     fsw    f24, 220(sp) %
00001269 : 0f912027;   % 352:     fsw    f25, 224(sp) %
0000126a : 0fa12227;   % 353:     fsw    f26, 228(sp) %
0000126b : 0fb12427;   % 354:     fsw    f27, 232(sp) %
0000126c : 0fc12627;   % 355:     fsw    f28, 236(sp) %
0000126d : 0fd12827;   % 356:     fsw    f29, 240(sp) %
0000126e : 0fe12a27;   % 357:     fsw    f30, 244(sp) %
0000126f : 0ff12c27;   % 358:     fsw    f31, 248(sp) %
00001270 : 000002b3;   % 361:     add     t0, zero, zero %
00001271 : 00000333;   % 362:     add     t1, zero, zero %
00001272 : 000003b3;   % 363:     add     t2, zero, zero %
00001273 : 00000e33;   % 364:     add     t3, zero, zero %
00001274 : 00000eb3;   % 365:     add     t4, zero, zero %
00001275 : 00000f33;   % 366:     add     t5, zero, zero %
00001276 : 00000fb3;   % 367:     add     t6, zero, zero %
00001277 : 00a00293;   % 372:     addi    t0, zero, 10 %
00001278 : 15128863;   % 373:     beq     t0, a7, goToExit          # ecall exit %
00001279 : 06e00293;   % 374:     addi    t0, zero, 110 %
0000127a : 15128463;   % 375:     beq     t0, a7, goToExit          # ecall exit %
0000127b : 00100293;   % 377:     addi    t0, zero, 1               # ecall 1 = print int %
0000127c : 15128c63;   % 378:     beq     t0, a7, goToPrintInt %
0000127d : 06500293;   % 379:     addi    t0, zero, 101             # ecall 1 = print int %
0000127e : 15128863;   % 380:     beq     t0, a7, goToPrintInt %
0000127f : 00200293;   % 382:     addi    t0, zero, 2               # ecall 2 = print float %
00001280 : 17128063;   % 383:     beq     t0, a7, goToPrintFloat %
00001281 : 06600293;   % 384:     addi    t0, zero, 102             # ecall 2 = print float %
00001282 : 15128c63;   % 385:     beq     t0, a7, goToPrintFloat %
00001283 : 00300293;   % 387:     addi    t0, zero, 3               # ecall 3 = print double %
00001284 : 17128263;   % 388:     beq     t0, a7, goToPrintDouble %
00001285 : 06700293;   % 389:     addi    t0, zero, 103             # ecall 2 = print double %
00001286 : 15128e63;   % 390:     beq     t0, a7, goToPrintDouble %
00001287 : 00400293;   % 392:     addi    t0, zero, 4               # ecall 4 = print string %
00001288 : 13128863;   % 393:     beq     t0, a7, goToPrintString %
00001289 : 06800293;   % 394:     addi    t0, zero, 104             # ecall 4 = print string %
0000128a : 13128463;   % 395:     beq     t0, a7, goToPrintString %
0000128b : 00500293;   % 397:     addi    t0, zero, 5               # ecall 5 = read int %
0000128c : 17128063;   % 398:     beq     t0, a7, goToReadInt %
0000128d : 06900293;   % 399:     addi    t0, zero, 105             # ecall 5 = read int %
0000128e : 15128c63;   % 400:     beq     t0, a7, goToReadInt %
0000128f : 00600293;   % 402:     addi    t0, zero, 6               # ecall 6 = read float %
00001290 : 17128063;   % 403:     beq     t0, a7, goToReadFloat %
00001291 : 06a00293;   % 404:     addi    t0, zero, 106             # ecall 6 = read float %
00001292 : 15128c63;   % 405:     beq     t0, a7, goToReadFloat %
00001293 : 00700293;   % 407:     addi    t0, zero, 7               # ecall 7 = read Double %
00001294 : 17128263;   % 408:     beq     t0, a7, goToReadDouble %
00001295 : 06b00293;   % 409:     addi    t0, zero, 107             # ecall 7 = read Double %
00001296 : 15128e63;   % 410:     beq     t0, a7, goToReadDouble %
00001297 : 00800293;   % 412:     addi    t0, zero, 8               # ecall 8 = read string %
00001298 : 13128c63;   % 413:     beq     t0, a7, goToReadString %
00001299 : 06c00293;   % 414:     addi    t0, zero, 108             # ecall 8 = read string %
0000129a : 13128863;   % 415:     beq     t0, a7, goToReadString %
0000129b : 00b00293;   % 417:     addi    t0, zero, 11              # ecall 11 = print char %
0000129c : 0f128463;   % 418:     beq     t0, a7, goToPrintChar %
0000129d : 06f00293;   % 419:     addi    t0, zero, 111             # ecall 11 = print char %
0000129e : 0f128063;   % 420:     beq     t0, a7, goToPrintChar %
0000129f : 00c00293;   % 422:     addi    t0, zero, 12              # ecall 12 = read char %
000012a0 : 11128463;   % 423:     beq     t0, a7, goToReadChar %
000012a1 : 07000293;   % 424:     addi    t0, zero, 112             # ecall 12 = read char %
000012a2 : 11128063;   % 425:     beq     t0, a7, goToReadChar %
000012a3 : 01e00293;   % 428:     addi    t0, zero, 30              # ecall 30 = time %
000012a4 : 15128c63;   % 429:     beq     t0, a7, goToTime %
000012a5 : 08200293;   % 430:     addi    t0, zero, 130             # ecall 30 = time %
000012a6 : 15128863;   % 431:     beq     t0, a7, goToTime %
000012a7 : 01f00293;   % 433:     addi    t0, zero, 31              # ecall 31 = MIDI out %
000012a8 : 13128c63;   % 434:     beq     t0, a7, goToMidiOut       # Generate tone and return immediately %
000012a9 : 08300293;   % 435:     addi    t0, zero, 131             # ecall 31 = MIDI out %
000012aa : 13128863;   % 436:     beq     t0, a7, goToMidiOut %
000012ab : 02000293;   % 438:     addi    t0, zero, 32              # ecall 32 = sleep %
000012ac : 15128063;   % 439:     beq     t0, a7, goToSleep %
000012ad : 08400293;   % 440:     addi    t0, zero, 132             # ecall 32 = sleep %
000012ae : 13128c63;   % 441:     beq     t0, a7, goToSleep %
000012af : 02100293;   % 443:     addi    t0, zero, 33              # ecall 33 = MIDI out synchronous %
000012b0 : 13128063;   % 444:     beq     t0, a7, goToMidiOutSync   # Generate tone and return upon tone completion %
000012b1 : 08500293;   % 445:     addi    t0, zero, 133             # ecall 33 = MIDI out synchronous %
000012b2 : 11128c63;   % 446:     beq     t0, a7, goToMidiOutSync %
000012b3 : 02200293;   % 448:     addi    t0, zero, 34       		# ecall 34 = print hex %
000012b4 : 0f128c63;   % 449:     beq     t0, a7, goToPrintHex %
000012b5 : 08600293;   % 450:     addi    t0, zero, 134		# ecall 34 = print hex %
000012b6 : 0f128863;   % 451:     beq     t0, a7, goToPrintHex %
000012b7 : 02400293;   % 459:     addi    t0, zero, 36              # ecall 36 = PrintIntUnsigned %
000012b8 : 0f128863;   % 460:     beq     t0, a7, goToPrintIntUnsigned %
000012b9 : 08800293;   % 461:     addi    t0, zero, 136             # ecall 36 = PrintIntUnsigned %
000012ba : 0f128463;   % 462:     beq     t0, a7, goToPrintIntUnsigned %
000012bb : 02900293;   % 465:     addi    t0, zero, 41              # ecall 41 = random %
000012bc : 11128463;   % 466:     beq     t0, a7, goToRandom %
000012bd : 08d00293;   % 467:     addi    t0, zero, 141             # ecall 41 = random %
000012be : 11128063;   % 468:     beq     t0, a7, goToRandom %
000012bf : 02a00293;   % 470:     addi    t0, zero, 42              # ecall 41 = random %
000012c0 : 11128063;   % 471:     beq     t0, a7, goToRandom2 %
000012c1 : 08e00293;   % 472:     addi    t0, zero, 142             # ecall 41 = random %
000012c2 : 0f128c63;   % 473:     beq     t0, a7, goToRandom2 %
000012c3 : 02f00293;   % 476:     addi    t0, zero, 47              # ecall 47 = DrawLine %
000012c4 : 11128063;   % 477:     beq     t0, a7, goToBRES %
000012c5 : 09300293;   % 478:     addi    t0, zero, 147              # ecall 47 = DrawLine %
000012c6 : 0f128c63;   % 479:     beq     t0, a7, goToBRES     %
000012c7 : 03000293;   % 481:     addi    t0, zero, 48              # ecall 48 = CLS %
000012c8 : 0f128463;   % 482:     beq     t0, a7, goToCLS %
000012c9 : 09400293;   % 483:     addi    t0, zero, 148              # ecall 48 = CLS %
000012ca : 0f128063;   % 484:     beq     t0, a7, goToCLS %
000012cb : 1f8000ef;   % 489:     jal NaoExisteEcall  # ecall inexistente %
000012cc : 10008c37;   % 492: <9> li s8, 0x10008000	# carrega tp %
000012cd : 000c0c13;   % 492:  %
000012ce : 01819663;   % 492: <10> bne gp, s8, goToExitDE2	# Na DE1 gp = 0 ! N�o tem segmento .extern %
000012cf : 00a00893;   % 493: 			li 	a7, 10			# chama o ecall normal do Rars %
000012d0 : 00000073;   % 494: 			ecall				# exit ecall	 %
000012d1 : 0000006f;   % 495: 	goToExitDE2:	j 	goToExitDE2		# trava o processador : N�o tem sistema operacional! %
000012d2 : 244000ef;   % 497: 	goToPrintInt:	jal     printInt               	# chama printInt %
000012d3 : 0cc0006f;   % 498: 			j       endEcall %
000012d4 : 52c000ef;   % 500: 	goToPrintString: jal     printString           	# chama printString %
000012d5 : 0c40006f;   % 501: 			 j       endEcall %
000012d6 : 56c000ef;   % 503: 	goToPrintChar:	jal     printChar		# chama printChar %
000012d7 : 0bc0006f;   % 504: 			j       endEcall %
000012d8 : 30102c73;   % 506: <22> csrr s8, misa %
000012d9 : 020c7c13;   % 506: <23> andi s8, s8, 0x020 %
000012da : 1a0c0e63;   % 506: <24> beqz s8, NaoExisteEcall %
000012db : 1ed000ef;   % 507: 			jal     printFloat		# chama printFloat %
000012dc : 0a80006f;   % 508: 			j       endEcall %
000012dd : 30102c73;   % 510: <22> csrr s8, misa %
000012de : 020c7c13;   % 510: <23> andi s8, s8, 0x020 %
000012df : 1a0c0463;   % 510: <24> beqz s8, NaoExisteEcall %
000012e0 : 3dd000ef;   % 511: 			jal     printDouble		# chama printDuble %
000012e1 : 0940006f;   % 512: 			j       endEcall %
000012e2 : 688000ef;   % 515: 	goToReadChar:	jal     readChar              	# chama readChar %
000012e3 : 08c0006f;   % 516: 			j       endEcall %
000012e4 : 7b0000ef;   % 518: 	goToReadInt:   	jal     readInt                 # chama readInt %
000012e5 : 0840006f;   % 519: 			j       endEcall %
000012e6 : 718000ef;   % 521: 	goToReadString:	jal     readString              # chama readString %
000012e7 : 07c0006f;   % 522: 			j       endEcall %
000012e8 : 30102c73;   % 524: <22> csrr s8, misa %
000012e9 : 020c7c13;   % 524: <23> andi s8, s8, 0x020 %
000012ea : 160c0e63;   % 524: <24> beqz s8, NaoExisteEcall %
000012eb : 3b9000ef;   % 525: 			jal     readFloat               # chama readFloat %
000012ec : 0680006f;   % 526: 			j       endEcall %
000012ed : 30102c73;   % 528: <22> csrr s8, misa %
000012ee : 020c7c13;   % 528: <23> andi s8, s8, 0x020 %
000012ef : 160c0463;   % 528: <24> beqz s8, NaoExisteEcall %
000012f0 : 3a1000ef;   % 529: 			jal     readDouble               # chama readDouble %
000012f1 : 0540006f;   % 530: 			j       endEcall %
000012f2 : 440000ef;   % 533: 	goToPrintHex:	jal     printHex                # chama printHex %
000012f3 : 04c0006f;   % 534: 			j       endEcall %
000012f4 : 0c4010ef;   % 536: 	goToPrintIntUnsigned: 	jal	printIntUnsigned	# chama Print Unsigned Int %
000012f5 : 0440006f;   % 537: 				j	endEcall   %
000012f6 : 079000ef;   % 539: 	goToMidiOut:	jal     midiOut                 # chama MIDIout %
000012f7 : 03c0006f;   % 540: 			j       endEcall %
000012f8 : 0e9000ef;   % 542: 	goToMidiOutSync: jal     midiOutSync   		# chama MIDIoutSync %
000012f9 : 0340006f;   % 543: 			 j       endEcall %
000012fa : 5e1000ef;   % 545: 	goToTime:	jal     Time                    # chama time %
000012fb : 02c0006f;   % 546: 			j       endEcall %
000012fc : 5fd000ef;   % 548: 	goToSleep:	jal     Sleep                  	# chama sleep %
000012fd : 0240006f;   % 549: 			j       endEcall %
000012fe : 621000ef;   % 551: 	goToRandom:	jal     Random                 	# chama random %
000012ff : 01c0006f;   % 552: 			j       endEcall %
00001300 : 641000ef;   % 554: 	goToRandom2:	jal     Random2                 # chama random2 %
00001301 : 0140006f;   % 555: 			j       endEcall %
00001302 : 675000ef;   % 557: 	goToCLS:	jal     clsCLS                 	# chama CLS %
00001303 : 00c0006f;   % 558: 			j       endEcall %
00001304 : 6c9000ef;   % 560: 	goToBRES:	jal     BRESENHAM               # chama BRESENHAM %
00001305 : 0040006f;   % 561: 			j       endEcall    	 %
00001306 : 00012083;   % 565: endEcall:  	lw	x1,   0(sp)  # recupera QUASE todos os registradores na pilha %
00001307 : 00412103;   % 566: 		lw	x2,   4(sp)	 %
00001308 : 00812183;   % 567: 		lw	x3,   8(sp)	 %
00001309 : 00c12203;   % 568: 		lw	x4,  12(sp)      	 %
0000130a : 01012283;   % 569: 		lw	x5,  16(sp)      	 %
0000130b : 01412303;   % 570: 		lw	x6,  20(sp)	 %
0000130c : 01812383;   % 571: 		lw	x7,  24(sp) %
0000130d : 01c12403;   % 572: 		lw	x8,  28(sp) %
0000130e : 02012483;   % 573: 		lw	x9,  32(sp) %
0000130f : 02c12603;   % 576: 		lw     x12, 44(sp) %
00001310 : 03012683;   % 577: 		lw     x13, 48(sp) %
00001311 : 03412703;   % 578: 		lw     x14, 52(sp) %
00001312 : 03812783;   % 579: 		lw     x15, 56(sp) %
00001313 : 03c12803;   % 580: 		lw     x16, 60(sp) %
00001314 : 04012883;   % 581: 		lw     x17, 64(sp) %
00001315 : 04412903;   % 582: 		lw     x18, 68(sp) %
00001316 : 04812983;   % 583: 		lw     x19, 72(sp) %
00001317 : 04c12a03;   % 584: 		lw     x20, 76(sp) %
00001318 : 05012a83;   % 585: 		lw     x21, 80(sp) %
00001319 : 05412b03;   % 586: 		lw     x22, 84(sp) %
0000131a : 05812b83;   % 587: 		lw     x23, 88(sp) %
0000131b : 05c12c03;   % 588: 		lw     x24, 92(sp) %
0000131c : 06012c83;   % 589: 		lw     x25, 96(sp) %
0000131d : 06412d03;   % 590: 		lw     x26, 100(sp) %
0000131e : 06812d83;   % 591: 		lw     x27, 104(sp) %
0000131f : 06c12e03;   % 592: 		lw     x28, 108(sp) %
00001320 : 07012e83;   % 593: 		lw     x29, 112(sp) %
00001321 : 07412f03;   % 594: 		lw     x30, 116(sp) %
00001322 : 07812f83;   % 595: 		lw     x31, 120(sp) %
00001323 : 30102c73;   % 596: <22> csrr s8, misa %
00001324 : 020c7c13;   % 596: <23> andi s8, s8, 0x020 %
00001325 : 060c0e63;   % 596: <24> beqz s8, endEcall.pula %
00001326 : 07c12007;   % 597: 		flw    f0,  124(sp) %
00001327 : 08012087;   % 598: 		flw    f1,  128(sp) %
00001328 : 08412107;   % 599: 		flw    f2,  132(sp) %
00001329 : 08812187;   % 600: 		flw    f3,  136(sp) %
0000132a : 08c12207;   % 601: 		flw    f4,  140(sp) %
0000132b : 09012287;   % 602: 		flw    f5,  144(sp) %
0000132c : 09412307;   % 603: 		flw    f6,  148(sp) %
0000132d : 09812387;   % 604: 		flw    f7,  152(sp) %
0000132e : 09c12407;   % 605: 		flw    f8,  156(sp) %
0000132f : 0a012487;   % 606: 		flw    f9,  160(sp) %
00001330 : 0ac12607;   % 609: 		flw    f12, 172(sp) %
00001331 : 0b012687;   % 610: 		flw    f13, 176(sp) %
00001332 : 0b412707;   % 611: 		flw    f14, 180(sp) %
00001333 : 0b812787;   % 612: 		flw    f15, 184(sp) %
00001334 : 0bc12807;   % 613: 		flw    f16, 188(sp) %
00001335 : 0c012887;   % 614: 		flw    f17, 192(sp) %
00001336 : 0c412907;   % 615: 		flw    f18, 196(sp) %
00001337 : 0c812987;   % 616: 		flw    f19, 200(sp) %
00001338 : 0cc12a07;   % 617: 		flw    f20, 204(sp) %
00001339 : 0d012a87;   % 618: 		flw    f21, 208(sp) %
0000133a : 0d412b07;   % 619: 		flw    f22, 212(sp) %
0000133b : 0d812b87;   % 620: 		flw    f23, 216(sp) %
0000133c : 0dc12c07;   % 621: 		flw    f24, 220(sp) %
0000133d : 0e012c87;   % 622: 		flw    f25, 224(sp) %
0000133e : 0e412d07;   % 623: 		flw    f26, 228(sp) %
0000133f : 0e812d87;   % 624: 		flw    f27, 232(sp) %
00001340 : 0ec12e07;   % 625: 		flw    f28, 236(sp) %
00001341 : 0f012e87;   % 626: 		flw    f29, 240(sp) %
00001342 : 0f412f07;   % 627: 		flw    f30, 244(sp) %
00001343 : 0f812f87;   % 628: 		flw    f31, 248(sp) %
00001344 : 10810113;   % 630: endEcall.pula:	addi    sp, sp, 264 %
00001345 : 04102273;   % 632: 		csrr 	tp, uepc 	# le o valor de EPC salvo no registrador uepc (reg 65) %
00001346 : 00420213;   % 633: 		addi 	tp, tp, 4	# soma 4 para obter a instrucao seguinte ao ecall %
00001347 : 04121073;   % 634: 		csrw 	tp, uepc	# coloca no registrador uepc %
00001348 : 00200073;   % 635: 		uret			# retorna PC=uepc %
00001349 : 0c000513;   % 643: NaoExisteEcall: addi 	a0, zero, 0xc0 		## printa tela de azul %
0000134a : 00000593;   % 644: 		addi 	a1, zero, 0 %
0000134b : 01100833;   % 645: 		mv 	a6, a7 %
0000134c : 09400893;   % 646: 		addi 	a7, zero, 148 %
0000134d : 549000ef;   % 647: 		jal 	clsCLS %
0000134e : 0fc20517;   % 648:   		la 	a0, CauseE %
0000134f : ccf50513;   % 648:  %
00001350 : 00000593;   % 649: 		li 	a1, 0 %
00001351 : 00100613;   % 650: 		li 	a2, 1 %
00001352 : 0000c6b7;   % 651: 		li 	a3, 0x0000c0ff %
00001353 : 0ff68693;   % 651:  %
00001354 : 00000793;   % 652: 		li 	a5,0 %
00001355 : 328000ef;   % 653: 		jal	printString %
00001356 : 01000533;   % 654: 		mv 	a0, a6 %
00001357 : 06800593;   % 655: 		li 	a1, 104 %
00001358 : 00100613;   % 656: 		li 	a2, 1 %
00001359 : 0000c6b7;   % 657: 		li 	a3, 0x0000c0ff %
0000135a : 0ff68693;   % 657:  %
0000135b : 020000ef;   % 658: 		jal 	printInt %
0000135c : 04102573;   % 659: 		csrr	a0,uepc %
0000135d : 08800593;   % 660: 		li 	a1, 136 %
0000135e : 00100613;   % 661: 		li 	a2, 1 %
0000135f : 0000c6b7;   % 662: 		li 	a3, 0x0000c0ff %
00001360 : 0ff68693;   % 662:  %
00001361 : 284000ef;   % 663: 		jal 	printHex		 %
00001362 : da9ff06f;   % 664: 		j 	goToExit %
00001363 : ffc10113;   % 676: printInt:	addi 	sp, sp, -4			# Aloca espaco %
00001364 : 00112023;   % 677: 		sw 	ra, 0(sp)			# salva ra %
00001365 : 0fc20297;   % 678: 		la 	t0, TempBuffer			# carrega o Endereco do Buffer da String %
00001366 : 93428293;   % 678:  %
00001367 : 00055a63;   % 680: 		bge 	a0, zero, ehposprintInt		# Se eh positvo %
00001368 : 02d00313;   % 681: 		li 	t1, '-'				# carrega o sinal - %
00001369 : 00628023;   % 682: 		sb 	t1, 0(t0)			# coloca no buffer %
0000136a : 00128293;   % 683: 		addi 	t0, t0, 1			# incrementa endereco do buffer %
0000136b : 40a00533;   % 684: 		sub 	a0, zero, a0			# torna o numero positivo %
0000136c : 00a00393;   % 686: ehposprintInt:  li 	t2, 10				# carrega numero 10 %
0000136d : 00000313;   % 687: 		li 	t1, 0				# carrega numero de digitos com 0 %
0000136e : 30102c73;   % 689: <29> csrr s8, misa %
0000136f : 00cc5c13;   % 689: <30> srli s8, s8, 12 %
00001370 : 001c7c13;   % 689: <31> andi s8, s8, 0x001 %
00001371 : 1e0c1863;   % 689: <32> bnez s8, printInt.pula1 %
00001372 : ff410113;   % 690: <99> addi 	sp,sp,-12 %
00001373 : 00a12023;   % 690: <100> sw	a0,0(sp) %
00001374 : 00b12223;   % 690: <101> sw	a1,4(sp) %
00001375 : 00c12423;   % 690: <102> sw	a2,8(sp) %
00001376 : 00a00633;   % 690: <103> mv 	a2,a0 %
00001377 : 41f65593;   % 690: <104> srai 	a1,a2,31 %
00001378 : 00c00533;   % 690: <105> mv 	a0,a2 %
00001379 : 00058463;   % 690: <106> beqz 	a1,div10.pula1_M8 %
0000137a : 40c00533;   % 690: <107> neg 	a0,a2 %
0000137b : ff010113;   % 690: <65> addi 	sp, sp, -16 %
0000137c : 00a12023;   % 690: <66> sw	a0, 0(sp) %
0000137d : 00e12223;   % 690: <67> sw	a4, 4(sp) %
0000137e : 00f12423;   % 690: <68> sw	a5, 8(sp) %
0000137f : 00112623;   % 690: <69> sw	ra, 12(sp) %
00001380 : 00a00533;   % 690: <70> mv 	a0, a0 %
00001381 : 00155713;   % 690: <71> srli    a4,a0,1 %
00001382 : 00255793;   % 690: <72> srli    a5,a0,2 %
00001383 : 00f707b3;   % 690: <73> add     a5,a4,a5 %
00001384 : 0047d713;   % 690: <74> srli    a4,a5,4 %
00001385 : 00f70733;   % 690: <75> add     a4,a4,a5 %
00001386 : 00875793;   % 690: <76> srli    a5,a4,8 %
00001387 : 00e78733;   % 690: <77> add     a4,a5,a4 %
00001388 : 01075793;   % 690: <78> srli    a5,a4,16 %
00001389 : 00e787b3;   % 690: <79> add     a5,a5,a4 %
0000138a : 0037d793;   % 690: <80> srli    a5,a5,3 %
0000138b : 00279713;   % 690: <81> slli    a4,a5,2 %
0000138c : 00f70733;   % 690: <82> add     a4,a4,a5 %
0000138d : 00171713;   % 690: <83> slli    a4,a4,1 %
0000138e : 40e50533;   % 690: <84> sub     a0,a0,a4 %
0000138f : 00a53513;   % 690: <85> sltiu   a0,a0,10 %
00001390 : 00154513;   % 690: <86> xori    a0,a0,1 %
00001391 : 00f50533;   % 690: <87> add     a0,a0,a5 %
00001392 : 04051073;   % 690: <88> csrw	a0,uscratch %
00001393 : 00012503;   % 690: <89> lw	a0, 0(sp) %
00001394 : 00412703;   % 690: <90> lw	a4, 4(sp) %
00001395 : 00812783;   % 690: <91> lw	a5, 8(sp) %
00001396 : 00c12083;   % 690: <92> lw	ra, 12(sp) %
00001397 : 01010113;   % 690: <93> addi 	sp, sp, 16 %
00001398 : 04002ef3;   % 690: <94> csrr	t4,uscratch %
00001399 : 00058463;   % 690: <109> beqz 	a1,div10.pula2_M8 %
0000139a : 41d00eb3;   % 690: <110> neg 	t4,t4 %
0000139b : 040e9073;   % 690: <111> div10.pula2_M8:	csrw	t4,uscratch %
0000139c : 00012503;   % 690: <112> lw	a0,0(sp) %
0000139d : 00412583;   % 690: <113> lw 	a1,4(sp) %
0000139e : 00812603;   % 690: <114> lw	a2,8(sp) %
0000139f : 00c10113;   % 690: <115> addi 	sp,sp,12 %
000013a0 : 04002ef3;   % 690: <116> csrr	t4,uscratch %
000013a1 : ff010113;   % 691: <145> addi 	sp,sp,-16 %
000013a2 : 00a12023;   % 691: <146> sw	a0,0(sp) %
000013a3 : 00b12223;   % 691: <147> sw	a1,4(sp) %
000013a4 : 00c12423;   % 691: <148> sw	a2,8(sp) %
000013a5 : 00d12623;   % 691: <149> sw	a3,12(sp) %
000013a6 : 00a006b3;   % 691: <151> mv 	a3,a0 %
000013a7 : 00a00613;   % 691: <152> li 	a2,10 %
000013a8 : ff410113;   % 691: <99> addi 	sp,sp,-12 %
000013a9 : 00a12023;   % 691: <100> sw	a0,0(sp) %
000013aa : 00b12223;   % 691: <101> sw	a1,4(sp) %
000013ab : 00c12423;   % 691: <102> sw	a2,8(sp) %
000013ac : 00d00633;   % 691: <103> mv 	a2,a3 %
000013ad : 41f65593;   % 691: <104> srai 	a1,a2,31 %
000013ae : 00c00533;   % 691: <105> mv 	a0,a2 %
000013af : 00058463;   % 691: <106> beqz 	a1,div10.pula1_M11 %
000013b0 : 40c00533;   % 691: <107> neg 	a0,a2 %
000013b1 : ff010113;   % 691: <65> addi 	sp, sp, -16 %
000013b2 : 00a12023;   % 691: <66> sw	a0, 0(sp) %
000013b3 : 00e12223;   % 691: <67> sw	a4, 4(sp) %
000013b4 : 00f12423;   % 691: <68> sw	a5, 8(sp) %
000013b5 : 00112623;   % 691: <69> sw	ra, 12(sp) %
000013b6 : 00a00533;   % 691: <70> mv 	a0, a0 %
000013b7 : 00155713;   % 691: <71> srli    a4,a0,1 %
000013b8 : 00255793;   % 691: <72> srli    a5,a0,2 %
000013b9 : 00f707b3;   % 691: <73> add     a5,a4,a5 %
000013ba : 0047d713;   % 691: <74> srli    a4,a5,4 %
000013bb : 00f70733;   % 691: <75> add     a4,a4,a5 %
000013bc : 00875793;   % 691: <76> srli    a5,a4,8 %
000013bd : 00e78733;   % 691: <77> add     a4,a5,a4 %
000013be : 01075793;   % 691: <78> srli    a5,a4,16 %
000013bf : 00e787b3;   % 691: <79> add     a5,a5,a4 %
000013c0 : 0037d793;   % 691: <80> srli    a5,a5,3 %
000013c1 : 00279713;   % 691: <81> slli    a4,a5,2 %
000013c2 : 00f70733;   % 691: <82> add     a4,a4,a5 %
000013c3 : 00171713;   % 691: <83> slli    a4,a4,1 %
000013c4 : 40e50533;   % 691: <84> sub     a0,a0,a4 %
000013c5 : 00a53513;   % 691: <85> sltiu   a0,a0,10 %
000013c6 : 00154513;   % 691: <86> xori    a0,a0,1 %
000013c7 : 00f50533;   % 691: <87> add     a0,a0,a5 %
000013c8 : 04051073;   % 691: <88> csrw	a0,uscratch %
000013c9 : 00012503;   % 691: <89> lw	a0, 0(sp) %
000013ca : 00412703;   % 691: <90> lw	a4, 4(sp) %
000013cb : 00812783;   % 691: <91> lw	a5, 8(sp) %
000013cc : 00c12083;   % 691: <92> lw	ra, 12(sp) %
000013cd : 01010113;   % 691: <93> addi 	sp, sp, 16 %
000013ce : 04002573;   % 691: <94> csrr	a0,uscratch %
000013cf : 00058463;   % 691: <109> beqz 	a1,div10.pula2_M11 %
000013d0 : 40a00533;   % 691: <110> neg 	a0,a0 %
000013d1 : 04051073;   % 691: <111> div10.pula2_M11:	csrw	a0,uscratch %
000013d2 : 00012503;   % 691: <112> lw	a0,0(sp) %
000013d3 : 00412583;   % 691: <113> lw 	a1,4(sp) %
000013d4 : 00812603;   % 691: <114> lw	a2,8(sp) %
000013d5 : 00c10113;   % 691: <115> addi 	sp,sp,12 %
000013d6 : 04002573;   % 691: <116> csrr	a0,uscratch %
000013d7 : ff410113;   % 691: <45> addi 	sp, sp, -12 %
000013d8 : 00a12023;   % 691: <46> sw	a0, 0(sp) %
000013d9 : 00b12223;   % 691: <47> sw	a1, 4(sp) %
000013da : 00112423;   % 691: <48> sw	ra, 8(sp) %
000013db : 00a00533;   % 691: <50> mv 	a0, a0 %
000013dc : 00c005b3;   % 691: <51> mv 	a1, a2 %
000013dd : 701000ef;   % 691: <52> jal 	__mulsi3 %
000013de : 04051073;   % 691: <53> csrw	a0,uscratch %
000013df : 00012503;   % 691: <55> lw	a0, 0(sp) %
000013e0 : 00412583;   % 691: <56> lw	a1, 4(sp) %
000013e1 : 00812083;   % 691: <57> lw	ra, 8(sp) %
000013e2 : 00c10113;   % 691: <58> addi 	sp, sp, 12 %
000013e3 : 040025f3;   % 691: <59> csrr	a1,uscratch %
000013e4 : 40b68e33;   % 691: <155> sub 	t3,a3,a1 %
000013e5 : 040e1073;   % 691: <157> csrw	t3,uscratch %
000013e6 : 00012503;   % 691: <158> lw	a0,0(sp) %
000013e7 : 00412583;   % 691: <159> lw 	a1,4(sp) %
000013e8 : 00812603;   % 691: <160> lw	a2,8(sp) %
000013e9 : 00c12683;   % 691: <161> lw 	a3,12(sp) %
000013ea : 01010113;   % 691: <162> addi 	sp,sp,16 %
000013eb : 04002e73;   % 691: <163> csrr	t3,uscratch %
000013ec : 00c0006f;   % 692: 		j 	printInt.pula1d %
000013ed : 02754eb3;   % 693: printInt.pula1:	div 	t4, a0, t2			# divide por 10 (quociente) %
000013ee : 02756e33;   % 694: 		rem 	t3, a0, t2			# resto %
000013ef : ffc10113;   % 695: printInt.pula1d:addi 	sp, sp, -4			# aloca espaco na pilha %
000013f0 : 01c12023;   % 696: 		sw 	t3, 0(sp)			# coloca resto na pilha %
000013f1 : 01d00533;   % 697: 		mv 	a0, t4				# atualiza o numero com o quociente %
000013f2 : 00130313;   % 698: 		addi 	t1, t1, 1			# incrementa o contador de digitos %
000013f3 : de0516e3;   % 699: 		bne 	a0, zero, loop1printInt		# verifica se o numero eh zero %
000013f4 : 00012383;   % 701: loop2printInt:	lw 	t2, 0(sp)			# le digito da pilha %
000013f5 : 00410113;   % 702: 		addi 	sp, sp, 4			# libera espaco %
000013f6 : 03038393;   % 703: 		addi 	t2, t2, 48			# converte o digito para ascii %
000013f7 : 00728023;   % 704: 		sb 	t2, 0(t0)			# coloca caractere no buffer %
000013f8 : 00128293;   % 705: 		addi 	t0, t0, 1			# incrementa endereco do buffer %
000013f9 : fff30313;   % 706: 		addi 	t1, t1, -1			# decrementa contador de digitos %
000013fa : fe0314e3;   % 707: 		bne 	t1, zero, loop2printInt		# eh o ultimo? %
000013fb : 00028023;   % 708: 		sb 	zero, 0(t0)			# insere \NULL na string %
000013fc : 0fc1f517;   % 710: 		la 	a0, TempBuffer			# Endereco do buffer da srting %
000013fd : 6d850513;   % 710:  %
000013fe : 084000ef;   % 711: 		jal	printString			# chama o print string %
000013ff : 00012083;   % 713: 		lw 	ra, 0(sp)			# recupera a %
00001400 : 00410113;   % 714: 		addi 	sp, sp, 4			# libera espaco %
00001401 : 00008067;   % 715: fimprintInt:	ret					# retorna %
00001402 : ffc10113;   % 727: printHex:	addi    sp, sp, -4    		# aloca espaco %
00001403 : 00112023;   % 728:     		sw      ra, 0(sp)		# salva ra %
00001404 : 00a002b3;   % 729: 		mv 	t0, a0			# Inteiro de 32 bits a ser impresso em Hexa %
00001405 : 0fc20317;   % 730: 		la 	t1, TabelaHexASCII	# endereco da tabela HEX->ASCII %
00001406 : 8b430313;   % 730:  %
00001407 : 0fc1f397;   % 731: 		la 	t2, TempBuffer		# onde a string sera montada %
00001408 : 6ac38393;   % 731:  %
00001409 : 03000e13;   % 733: 		li 	t3,'0'			# Caractere '0' %
0000140a : 01c38023;   % 734: 		sb 	t3,0(t2)		# Escreve '0' no Buffer da String %
0000140b : 07800e13;   % 735: 		li 	t3,'x'			# Caractere 'x' %
0000140c : 01c380a3;   % 736: 		sb 	t3,1(t2)		# Escreve 'x' no Buffer da String %
0000140d : 00238393;   % 737: 		addi 	t2,t2,2			# novo endereco inicial da string %
0000140e : 01c00e13;   % 739: 		li 	t3, 28			# contador de nibble   inicio = 28 %
0000140f : 020e4263;   % 740: loopprintHex:	blt 	t3, zero, fimloopprintHex	# terminou? t3<0? %
00001410 : 01c2deb3;   % 741: 		srl 	t4, t0, t3		# desloca o nibble para direita %
00001411 : 00fefe93;   % 742: 		andi 	t4, t4, 0x000F		# mascara o nibble	 %
00001412 : 01d30eb3;   % 743: 		add 	t4, t1, t4		# endereco do ascii do nibble %
00001413 : 000e8e83;   % 744: 		lb 	t4, 0(t4)		# le ascii do nibble %
00001414 : 01d38023;   % 745: 		sb 	t4, 0(t2)		# armazena o ascii do nibble no buffer da string %
00001415 : 00138393;   % 746: 		addi 	t2, t2, 1		# incrementa o endereco do buffer %
00001416 : ffce0e13;   % 747: 		addi 	t3, t3, -4		# decrementa o numero do nibble %
00001417 : fe1ff06f;   % 748: 		j 	loopprintHex %
00001418 : 00038023;   % 750: fimloopprintHex: sb 	zero,0(t2)		# grava \null na string %
00001419 : 0fc1f517;   % 751: 		la 	a0, TempBuffer		# Argumento do print String %
0000141a : 66450513;   % 751:  %
0000141b : 010000ef;   % 752: 		jal	printString		# Chama o print string %
0000141c : 00012083;   % 754: 		lw 	ra, 0(sp)		# recupera ra %
0000141d : 00410113;   % 755: 		addi 	sp, sp, 4		# libera espaco %
0000141e : 00008067;   % 756: fimprintHex:	ret				# retorna %
0000141f : ff810113;   % 767: printString:	addi	sp, sp, -8			# aloca espaco %
00001420 : 00112023;   % 768:     		sw	ra, 0(sp)			# salva ra %
00001421 : 00812223;   % 769:     		sw	s0, 4(sp)			# salva s0 %
00001422 : 00a00433;   % 770:     		mv	s0, a0              		# s0 = endereco do caractere na string %
00001423 : 00040503;   % 772: loopprintString:lb	a0, 0(s0)                 	# le em a0 o caracter a ser impresso %
00001424 : 02050263;   % 774:     		beq     a0, zero, fimloopprintString	# string ASCIIZ termina com NULL %
00001425 : 030000ef;   % 776:     		jal     printChar       		# imprime char %
00001426 : 00858593;   % 778: 		addi    a1, a1, 8                 	# incrementa a coluna %
00001427 : 13900f93;   % 779: 		li 	t6, 313		 %
00001428 : 01f5c663;   % 780: 		blt	a1, t6, NaoPulaLinha	    	# se ainda tiver lugar na linha %
00001429 : 00860613;   % 781:     		addi    a2, a2, 8                 	# incrementa a linha %
0000142a : 000005b3;   % 782:     		mv    	a1, zero			# volta a coluna zero %
0000142b : 00140413;   % 784: NaoPulaLinha:	addi    s0, s0, 1			# proximo caractere %
0000142c : fddff06f;   % 785:     		j       loopprintString       		# volta ao loop %
0000142d : 00012083;   % 787: fimloopprintString:	lw      ra, 0(sp)    		# recupera ra %
0000142e : 00012403;   % 788: 			lw 	s0, 0(sp)		# recupera s0 original %
0000142f : 00810113;   % 789:     			addi    sp, sp, 8		# libera espaco %
00001430 : 00008067;   % 790: fimprintString:	ret      	    			# retorna %
00001431 : 0ff00e93;   % 813: printChar:	li 	t4, 0xFF	# t4 temporario %
00001432 : 008e9e93;   % 814: 		slli 	t4, t4, 8	# t4 = 0x0000FF00 (no RARS, nao podemos fazer diretamente "andi rd, rs1, 0xFF00") %
00001433 : 01d6ff33;   % 815: 		and    	t5, a3, t4   	# t5 obtem cor de fundo %
00001434 : 008f5f13;   % 816:     		srli	t5, t5, 8	# numero da cor de fundo %
00001435 : 0ff6ff93;   % 817: 		andi   	t6, a3, 0xFF    # t6 obtem cor de frente %
00001436 : 02000213;   % 819: 		li 	tp, ' ' %
00001437 : 00454863;   % 820: 		blt 	a0, tp, printChar.NAOIMPRIMIVEL	# ascii menor que 32 nao eh imprimivel %
00001438 : 07e00213;   % 821: 		li 	tp, '~' %
00001439 : 00a24463;   % 822: 		bgt	a0, tp, printChar.NAOIMPRIMIVEL	# ascii Maior que 126  nao eh imprimivel %
0000143a : 0080006f;   % 823:     		j       printChar.IMPRIMIVEL %
0000143b : 02000513;   % 825: printChar.NAOIMPRIMIVEL: li      a0, 32		# Imprime espaco %
0000143c : 14000213;   % 827: printChar.IMPRIMIVEL:	li	tp, 320		# Num colunas 320 %
0000143d : 30102c73;   % 828: <29> csrr s8, misa %
0000143e : 00cc5c13;   % 828: <30> srli s8, s8, 12 %
0000143f : 001c7c13;   % 828: <31> andi s8, s8, 0x001 %
00001440 : 020c1e63;   % 828: <32> bnez s8, printChar.mul1 %
00001441 : ff410113;   % 829: <45> addi 	sp, sp, -12 %
00001442 : 00a12023;   % 829: <46> sw	a0, 0(sp) %
00001443 : 00b12223;   % 829: <47> sw	a1, 4(sp) %
00001444 : 00112423;   % 829: <48> sw	ra, 8(sp) %
00001445 : 00400533;   % 829: <50> mv 	a0, tp %
00001446 : 00c005b3;   % 829: <51> mv 	a1, a2 %
00001447 : 559000ef;   % 829: <52> jal 	__mulsi3 %
00001448 : 04051073;   % 829: <53> csrw	a0,uscratch %
00001449 : 00012503;   % 829: <55> lw	a0, 0(sp) %
0000144a : 00412583;   % 829: <56> lw	a1, 4(sp) %
0000144b : 00812083;   % 829: <57> lw	ra, 8(sp) %
0000144c : 00c10113;   % 829: <58> addi 	sp, sp, 12 %
0000144d : 04002ef3;   % 829: <59> csrr	t4,uscratch %
0000144e : 0080006f;   % 830: 			j printChar.mul1d %
0000144f : 02c20eb3;   % 831: printChar.mul1:		mul     t4, tp, a2			# multiplica a2x320  t4 = coordenada y %
00001450 : 00be8eb3;   % 832: printChar.mul1d:	add     t4, t4, a1               	# t4 = 320*y + x %
00001451 : 007e8e93;   % 833: 			addi    t4, t4, 7                 	# t4 = 320*y + (x+7) %
00001452 : ff000237;   % 834: 			li      tp, 0xFF000000          	# Endereco de inicio da memoria VGA0 %
00001453 : 00020213;   % 834:  %
00001454 : 00070663;   % 835: 			beq 	a4, zero, printChar.PULAFRAME		# Verifica qual o frame a ser usado em a4 %
00001455 : ff100237;   % 836: 			li      tp, 0xFF100000          	# Endereco de inicio da memoria VGA1 %
00001456 : 00020213;   % 836:  %
00001457 : 004e8eb3;   % 837: printChar.PULAFRAME:	add     t4, t4, tp               	# t4 = endereco de impressao do ultimo pixel da primeira linha do char %
00001458 : fe050393;   % 838: 			addi    t2, a0, -32               	# indice do char na memoria %
00001459 : 00339393;   % 839: 			slli    t2, t2, 3                 	# offset em bytes em relacao ao endereco inicial %
0000145a : 00079863;   % 840: 			bnez    a5, printChar.PS2P      # se a5 != 0, usar outra fonte   ---> pode fazer outros beqs caso queira adicionar fontes %
0000145b : 0fc1fe17;   % 841: 			la      t3, LabelTabChar		# endereco dos caracteres na memoria %
0000145c : e40e0e13;   % 841:  %
0000145d : 00c0006f;   % 842: 			j printChar.endereco            # ir para calculo final do endereco %
0000145e : 0fc1fe17;   % 845: 			la      t3, LabelTabCharPS2P     # Fonte alternativa %
0000145f : 14ce0e13;   % 845:  %
00001460 : 01c383b3;   % 848: 			add     t2, t2, t3               	# endereco do caractere na memoria %
00001461 : 0003ae03;   % 849: 			lw      t3, 0(t2)                 	# carrega a primeira word do char %
00001462 : 00400293;   % 850: 			li 	t0, 4				# i=4 %
00001463 : 02028e63;   % 852: printChar.forChar1I:	beq     t0, zero, printChar.endForChar1I # if(i == 0) end for i %
00001464 : 00800313;   % 853:     			addi    t1, zero, 8               	# j = 8 %
00001465 : 02030463;   % 855: printChar.forChar1J:	beq     t1, zero, printChar.endForChar1J # if(j == 0) end for j %
00001466 : 001e7c93;   % 856:         		andi    s9, t3, 0x001			# primeiro bit do caracter %
00001467 : 001e5e13;   % 857:         		srli    t3, t3, 1             		# retira o primeiro bit %
00001468 : 000c8663;   % 858:         		beq     s9, zero, printChar.printCharPixelbg1	# pixel eh fundo? %
00001469 : 01fe8023;   % 859:         		sb      t6, 0(t4)             		# imprime pixel com cor de frente %
0000146a : 0080006f;   % 860:         		j       printChar.endCharPixel1 %
0000146b : 01ee8023;   % 861: printChar.printCharPixelbg1:	sb      t5, 0(t4)                # imprime pixel com cor de fundo %
0000146c : fff30313;   % 862: printChar.endCharPixel1: addi    t1, t1, -1                	# j-- %
0000146d : fffe8e93;   % 863:     			addi    t4, t4, -1                	# t4 aponta um pixel para a esquerda %
0000146e : fddff06f;   % 864:     			j       printChar.forChar1J		# vollta novo pixel %
0000146f : fff28293;   % 866: printChar.endForChar1J: addi    t0, t0, -1 		# i-- %
00001470 : 148e8e93;   % 867:     			addi    t4, t4, 328           	# 2**12 + 8 %
00001471 : fc9ff06f;   % 868:     			j       printChar.forChar1I	# volta ao loop %
00001472 : 0043ae03;   % 870: printChar.endForChar1I:	lw      t3, 4(t2)           	# carrega a segunda word do char %
00001473 : 00400293;   % 871: 			li 	t0, 4			# i = 4 %
00001474 : 02028e63;   % 872: printChar.forChar2I:    beq     t0, zero, printChar.endForChar2I  # if(i == 0) end for i %
00001475 : 00800313;   % 873:     			addi    t1, zero, 8             # j = 8 %
00001476 : 02030463;   % 875: printChar.forChar2J:	beq	t1, zero, printChar.endForChar2J # if(j == 0) end for j %
00001477 : 001e7c93;   % 876:         		andi    s9, t3, 0x001	    		# pixel a ser impresso %
00001478 : 001e5e13;   % 877:         		srli    t3, t3, 1                 	# desloca para o proximo %
00001479 : 000c8663;   % 878:         		beq     s9, zero, printChar.printCharPixelbg2 # pixel eh fundo? %
0000147a : 01fe8023;   % 879:         		sb      t6, 0(t4)			# imprime cor frente %
0000147b : 0080006f;   % 880:         		j       printChar.endCharPixel2		# volta ao loop %
0000147c : 01ee8023;   % 882: printChar.printCharPixelbg2:	sb      t5, 0(t4)		# imprime cor de fundo %
0000147d : fff30313;   % 884: printChar.endCharPixel2:	addi    t1, t1, -1		# j-- %
0000147e : fffe8e93;   % 885:     				addi    t4, t4, -1              # t4 aponta um pixel para a esquerda %
0000147f : fddff06f;   % 886:     				j       printChar.forChar2J %
00001480 : fff28293;   % 888: printChar.endForChar2J:	addi	t0, t0, -1 		# i-- %
00001481 : 148e8e93;   % 889:     			addi    t4, t4, 328		# %
00001482 : fc9ff06f;   % 890:     			j       printChar.forChar2I	# volta ao loop %
00001483 : 00008067;   % 892: printChar.endForChar2I:	ret				# retorna %
00001484 : 00000013;   % 901: readChar: 		nop %
00001485 : ff2002b7;   % 905: readCharKDMMIO:		li 	t0, 0xFF200000			# Execucao com Polling do KD MMIO %
00001486 : 00028293;   % 905:  %
00001487 : 0002a503;   % 907: loopReadCharKDMMIO:  	lw     	a0, 0(t0)   			# le o bit de flag do teclado %
00001488 : 00157513;   % 908: 			andi 	a0, a0, 0x0001			# mascara bit 0 %
00001489 : fe050ce3;   % 909: 			beqz    a0, loopReadCharKDMMIO  	# testa se uma tecla foi pressionada %
0000148a : 0042a503;   % 910:    			lw 	a0, 4(t0)			# le o ascii da tecla pressionada %
0000148b : 0800006f;   % 911: 			j fimreadChar				# fim Read Char %
0000148c : ff2002b7;   % 917: readCharDE2:  	li      t0, 0xFF200100 			# Endereco buffer0 %
0000148d : 10028293;   % 917:  %
0000148e : 0002a303;   % 918:     		lw     	t1, 0(t0)				# conteudo inicial do buffer %
0000148f : 0002a383;   % 920: loopReadChar:  	lw     	t2, 0(t0)   				# le buffer teclado %
00001490 : 00639663;   % 921: 		bne     t2, t1, buffermodificadoChar    	# testa se o buffer foi modificado %
00001491 : 00700333;   % 923: atualizaBufferChar:  mv t1, t2			# atualiza o buffer com o novo valor %
00001492 : ff5ff06f;   % 924:     		j       loopReadChar		# loop de principal de leitura  %
00001493 : 0ff00f13;   % 926: buffermodificadoChar:	li t5, 0xFF %
00001494 : 008f1f13;   % 927: 	slli 	t5, t5, 8			# t5 = 0x0000FF00 %
00001495 : 01e3fe33;   % 928: 	and    	t3, t2, t5 			# mascara o 2o scancode %
00001496 : 0000f237;   % 929: 	li 	tp, 0x0000F000 %
00001497 : 00020213;   % 929:  %
00001498 : 024e0063;   % 930: 	beq     t3, tp, teclasoltaChar		# eh 0xF0 no 2o scancode? tecla foi solta %
00001499 : 0ff00213;   % 931: 	li	tp, 0x000000FF %
0000149a : 0043fe33;   % 932: 	and	t3, t2, tp			# mascara 1o scancode	(essa podemos fazer diretamente) %
0000149b : 01200213;   % 933: 	li	tp, 0x00000012 %
0000149c : fc4e1ae3;   % 934:     	bne 	t3, tp, atualizaBufferChar	# nao eh o SHIFT que esta pressionado ? volta a ler  %
0000149d : 0fc1f417;   % 935: 	la      s0, LabelScanCodeShift		# se for SHIFT que esta pressionado atualiza o endereco da tabel %
0000149e : 3ce40413;   % 935:  %
0000149f : fc9ff06f;   % 936:     	j       atualizaBufferChar		# volta a ler %
000014a0 : 0ff3fe13;   % 938: teclasoltaChar:		andi t3, t2, 0x00FF		# mascara o 1o scancode %
000014a1 : 08000213;   % 939: 	li	tp, 0x00000080 %
000014a2 : fbc24ee3;   % 940:   	bgt	t3, tp, atualizaBufferChar		# se o scancode for > 0x80 entao nao eh imprimivel! %
000014a3 : 01200213;   % 941:   	li	tp, 0x00000012 %
000014a4 : 004e1863;   % 942: 	bne 	t3, tp, naoehshiftChar			# nao foi o shift que foi solto? entao processa %
000014a5 : 0fc1f417;   % 943: 	la 	s0, LabelScanCode			# shift foi solto atualiza o endereco da tabela %
000014a6 : 32840413;   % 943:  %
000014a7 : fa9ff06f;   % 944: 	j 	atualizaBufferChar			# volta a ler %
000014a8 : 01c40e33;   % 946: naoehshiftChar:	   	add     t3, s0, t3              # endereco na tabela de scancode da tecla com ou sem shift %
000014a9 : 000e0503;   % 947:     	lb      a0, 0(t3)				# le o ascii do caracter para a0 %
000014aa : f8050ee3;   % 948:     	beq     a0, zero, atualizaBufferChar		# se for caractere nao imprimivel volta a ler %
000014ab : 00008067;   % 950: fimreadChar: 	ret			# retorna %
000014ac : ff810113;   % 962: readString: 	addi 	sp, sp, -8			# reserva espaco na pilha %
000014ad : 00812223;   % 963: 		sw 	s0, 4(sp)			# salva s0 %
000014ae : 00112023;   % 964: 		sw 	ra, 0(sp)			# salva ra %
000014af : 00000693;   % 965: 		li 	a3, 0				# zera o contador de caracteres digitados %
000014b0 : 00a00933;   % 966: 		mv 	s2, a0				# salva o endereco inicial %
000014b1 : 0fc1f417;   % 967:     		la      s0, LabelScanCode      		# Endereco da tabela de scancode inicial para readChar %
000014b2 : 2f840413;   % 967:  %
000014b3 : 04d58c63;   % 969: loopreadString: beq 	a1, a3, fimreadString   	# buffer cheio fim %
000014b4 : ff810113;   % 971: 		addi 	sp, sp, -8 %
000014b5 : 00112023;   % 972: 		sw 	ra, 0(sp)			# salva ra %
000014b6 : 00a12223;   % 973: 		sw 	a0, 4(sp)			# salva a0 pois ele sera reescrito em readChar %
000014b7 : f35ff0ef;   % 974: 		jal 	readChar			# le um caracter do teclado (retorno em a0) %
000014b8 : 00a00fb3;   % 975: 		mv 	t6, a0				# t6 eh a letra lida em readChar %
000014b9 : 00012083;   % 976: 		lw 	ra, 0(sp) %
000014ba : 00412503;   % 977: 		lw 	a0, 4(sp) %
000014bb : 00810113;   % 978: 		addi 	sp, sp, 8 %
000014bc : 00800213;   % 980: 		li 	tp, 0x08			 %
000014bd : 004f9c63;   % 981: 		bne	t6, tp, PulaBackSpace		# Se nao for BACKSPACE %
000014be : fcd00ae3;   % 982: 		beq	zero, a3, loopreadString	# Se n�o tem nenhum caractere no buffer apenas volta a ler %
000014bf : fff68693;   % 983: 		addi	a3, a3, -1			# diminui contador %
000014c0 : fff50513;   % 984: 		addi 	a0, a0, -1			# diminui endereco do buffer %
000014c1 : 00050023;   % 985: 		sb 	zero, 0(a0)			# coloca zero no caractere anterior %
000014c2 : fc5ff06f;   % 986: 		j loopreadString %
000014c3 : 00a00213;   % 988: PulaBackSpace:	li	tp, 0x0A %
000014c4 : 004f8a63;   % 989: 		beq 	t6, tp, fimreadString		# se for tecla ENTER fim %
000014c5 : 01f50023;   % 990: 		sb 	t6, 0(a0)			# grava no buffer %
000014c6 : 00168693;   % 991: 		addi 	a3, a3, 1			# incrementa contador %
000014c7 : 00150513;   % 992: 		addi 	a0, a0, 1			# incrementa endereco no buffer %
000014c8 : fadff06f;   % 993: 		j loopreadString			# volta a ler outro caractere %
000014c9 : 00050023;   % 995: fimreadString: 	sb 	zero, 0(a0)			# grava NULL no buffer %
000014ca : fff50613;   % 996: 		addi 	a2, a0, -1			# Para que a2 tenha o endereco do ultimo caractere digitado %
000014cb : 01200533;   % 997: 		mv	a0, s2				# a0 volta a ter o endereco inicial da string %
000014cc : 00012083;   % 998: 		lw 	ra, 0(sp)			# recupera ra %
000014cd : 00412403;   % 999: 		lw	s0, 4(sp)			# recupera s0 %
000014ce : 00810113;   % 1000: 		addi 	sp, sp, 8			# libera espaco %
000014cf : 00008067;   % 1001: 		ret					# retorna %
000014d0 : ffc10113;   % 1010: readInt: 	addi 	sp,sp,-4		# reserva espaco na pilha %
000014d1 : 00112023;   % 1011: 	sw 	ra, 0(sp)			# salva ra %
000014d2 : 0fc1f517;   % 1012: 	la 	a0, TempBuffer			# Endereco do buffer de string %
000014d3 : 38050513;   % 1012:  %
000014d4 : 00a00593;   % 1013: 	li 	a1, 10				# numero maximo de digitos %
000014d5 : f5dff0ef;   % 1014: 	jal 	readString			# le uma string de ate 10 digitos, a3 numero de digitos %
000014d6 : 00c002b3;   % 1015: 	mv 	t0, a2				# copia endereco do ultimo digito %
000014d7 : 00a00393;   % 1016: 	li 	t2, 10				# dez %
000014d8 : 00100e13;   % 1017: 	li 	t3, 1				# dezenas, centenas, etc %
000014d9 : 00000533;   % 1018: 	mv 	a0, zero			# zera o numero %
000014da : 0c068e63;   % 1020: loopReadInt: 	beq	a3,zero, fimReadInt	# Leu todos os digitos %
000014db : 00028303;   % 1021: 	lb 	t1, (t0)			# le um digito %
000014dc : 02d00213;   % 1022: 	li	tp, 0x0000002D %
000014dd : 0c430663;   % 1023: 	beq 	t1, tp, ehnegReadInt		# = '-' %
000014de : 02b00213;   % 1024: 	li	tp, 0x0000002B %
000014df : 0c430463;   % 1025: 	beq 	t1, tp, ehposReadInt		# = '+' %
000014e0 : 03000213;   % 1026: 	li	tp, 0x00000030 %
000014e1 : 0a434c63;   % 1027: 	blt 	t1, tp, naoehReadInt		# <'0' %
000014e2 : 03900213;   % 1028: 	li	tp, 0x00000039 %
000014e3 : 0a624863;   % 1029: 	bgt 	t1, tp, naoehReadInt		# >'9' %
000014e4 : fd030313;   % 1030: 	addi 	t1, t1, -48			# transforma ascii em numero %
000014e5 : 30102c73;   % 1031: <29> csrr s8, misa %
000014e6 : 00cc5c13;   % 1031: <30> srli s8, s8, 12 %
000014e7 : 001c7c13;   % 1031: <31> andi s8, s8, 0x001 %
000014e8 : 020c1e63;   % 1031: <32> bnez s8, readInt.mul1 %
000014e9 : ff410113;   % 1032: <45> addi 	sp, sp, -12 %
000014ea : 00a12023;   % 1032: <46> sw	a0, 0(sp) %
000014eb : 00b12223;   % 1032: <47> sw	a1, 4(sp) %
000014ec : 00112423;   % 1032: <48> sw	ra, 8(sp) %
000014ed : 00600533;   % 1032: <50> mv 	a0, t1 %
000014ee : 01c005b3;   % 1032: <51> mv 	a1, t3 %
000014ef : 2b9000ef;   % 1032: <52> jal 	__mulsi3 %
000014f0 : 04051073;   % 1032: <53> csrw	a0,uscratch %
000014f1 : 00012503;   % 1032: <55> lw	a0, 0(sp) %
000014f2 : 00412583;   % 1032: <56> lw	a1, 4(sp) %
000014f3 : 00812083;   % 1032: <57> lw	ra, 8(sp) %
000014f4 : 00c10113;   % 1032: <58> addi 	sp, sp, 12 %
000014f5 : 04002373;   % 1032: <59> csrr	t1,uscratch %
000014f6 : 0080006f;   % 1033: 	j readInt.mul1d %
000014f7 : 03c30333;   % 1034: readInt.mul1: 	mul 	t1, t1, t3			# multiplica por dezenas/centenas %
000014f8 : 00650533;   % 1035: readInt.mul1d:	add 	a0, a0, t1			# soma no numero %
000014f9 : 30102c73;   % 1036: <29> csrr s8, misa %
000014fa : 00cc5c13;   % 1036: <30> srli s8, s8, 12 %
000014fb : 001c7c13;   % 1036: <31> andi s8, s8, 0x001 %
000014fc : 020c1e63;   % 1036: <32> bnez s8, readInt.mul2 %
000014fd : ff410113;   % 1037: <45> addi 	sp, sp, -12 %
000014fe : 00a12023;   % 1037: <46> sw	a0, 0(sp) %
000014ff : 00b12223;   % 1037: <47> sw	a1, 4(sp) %
00001500 : 00112423;   % 1037: <48> sw	ra, 8(sp) %
00001501 : 01c00533;   % 1037: <50> mv 	a0, t3 %
00001502 : 007005b3;   % 1037: <51> mv 	a1, t2 %
00001503 : 269000ef;   % 1037: <52> jal 	__mulsi3 %
00001504 : 04051073;   % 1037: <53> csrw	a0,uscratch %
00001505 : 00012503;   % 1037: <55> lw	a0, 0(sp) %
00001506 : 00412583;   % 1037: <56> lw	a1, 4(sp) %
00001507 : 00812083;   % 1037: <57> lw	ra, 8(sp) %
00001508 : 00c10113;   % 1037: <58> addi 	sp, sp, 12 %
00001509 : 04002e73;   % 1037: <59> csrr	t3,uscratch %
0000150a : 0080006f;   % 1038: 	j readInt.mul2d %
0000150b : 027e0e33;   % 1039: readInt.mul2: 	mul 	t3, t3, t2			# proxima dezena/centena %
0000150c : fff28293;   % 1040: readInt.mul2d:	addi 	t0, t0, -1			# busca o digito anterior %
0000150d : fff68693;   % 1041: 	addi	a3, a3, -1			# reduz o contador de digitos  %
0000150e : f31ff06f;   % 1042: 	j 	loopReadInt			# volta para buscar proximo digito %
0000150f : 0080006f;   % 1045: 		j fimReadInt			# como nao esta implmentado apenas retorna %
00001510 : 40a00533;   % 1047: ehnegReadInt:	sub a0,zero,a0			# se for negativo %
00001511 : 00012083;   % 1051: fimReadInt:	lw 	ra, 0(sp)		# recupera ra %
00001512 : 00410113;   % 1052: 		addi 	sp, sp, 4		# libera espaco %
00001513 : 00008067;   % 1053: 		ret				# fim ReadInt %
00001514 : 10008c37;   % 1073: <9> li s8, 0x10008000	# carrega tp %
00001515 : 000c0c13;   % 1073:  %
00001516 : 01819863;   % 1073: <10> bne gp, s8, midiOutDE2	# Na DE1 gp = 0 ! N�o tem segmento .extern %
00001517 : 01f00893;   % 1075: 	li a7,31		# Chama o ecall normal %
00001518 : 00000073;   % 1076: 	ecall %
00001519 : 0600006f;   % 1077: 	j fimmidiOut %
0000151a : ff2002b7;   % 1079: midiOutDE2:	li      t0, 0xFF200178 %
0000151b : 17828293;   % 1079:  %
0000151c : 00000333;   % 1080:     		add     t1, zero, zero %
0000151d : 00f67393;   % 1085:    	 	andi    t2, a2, 0x0000000F %
0000151e : 01b39393;   % 1086:     		slli    t2, t2, 27 %
0000151f : 00736333;   % 1087:     		or      t1, t1, t2 %
00001520 : 07f6f393;   % 1090:     		andi    t2, a3, 0x0000007F %
00001521 : 01439393;   % 1091:     		slli    t2, t2, 20 %
00001522 : 00736333;   % 1092:     		or      t1, t1, t2 %
00001523 : 07f57393;   % 1095:     		andi    t2, a0, 0x0000007F %
00001524 : 00d39393;   % 1096:     		slli    t2, t2, 13 %
00001525 : 00736333;   % 1097:     		or      t1, t1, t2 %
00001526 : 1ff00e93;   % 1100: 		li 	t4, 0x1FF %
00001527 : 004e9e93;   % 1101: 		slli 	t4, t4, 4 %
00001528 : 00fe8e93;   % 1102: 		addi 	t4, t4, 0x00F			# t4 = 0x00001FFF %
00001529 : 01d5f3b3;   % 1103:     		and    	t2, a1, t4 %
0000152a : 00736333;   % 1104:     		or      t1, t1, t2 %
0000152b : 0040006f;   % 1107:     		j       SintMidOut %
0000152c : 0062a023;   % 1109: SintMidOut:	sw	t1, 0(t0) %
0000152d : ff2003b7;   % 1112: 	    		li      t2, 0xFF20017C %
0000152e : 17c38393;   % 1112:  %
0000152f : 0003ae03;   % 1113: Check_AUD_DACLRCK:     	lw      t3, 0(t2) %
00001530 : fe0e0ee3;   % 1114:     			beq     t3, zero, Check_AUD_DACLRCK %
00001531 : 00008067;   % 1116: fimmidiOut:    		ret %
00001532 : 10008c37;   % 1134: <9> li s8, 0x10008000	# carrega tp %
00001533 : 000c0c13;   % 1134:  %
00001534 : 01819863;   % 1134: <10> bne gp, s8, midiOutSyncDE2	# Na DE1 gp = 0 ! N�o tem segmento .extern %
00001535 : 02100893;   % 1136: 	li a7,33		# Chama o ecall normal %
00001536 : 00000073;   % 1137: 	ecall %
00001537 : 0780006f;   % 1138: 	j fimmidiOutSync %
00001538 : ff2002b7;   % 1140: midiOutSyncDE2:	li      t0, 0xFF200178 %
00001539 : 17828293;   % 1140:  %
0000153a : 00000333;   % 1141:     		add     t1, zero, zero %
0000153b : 08000337;   % 1144:     		lui    	t1, 0x08000 %
0000153c : 00431313;   % 1145: 		slli	t1,t1,4 %
0000153d : 00f67393;   % 1148:     		andi    t2, a2, 0x00F %
0000153e : 01b39393;   % 1149:     		slli    t2, t2, 27 %
0000153f : 00736333;   % 1150:     		or      t1, t1, t2 %
00001540 : 07f6f393;   % 1153:     		andi    t2, a3, 0x07F %
00001541 : 01439393;   % 1154:     		slli    t2, t2, 20 %
00001542 : 00736333;   % 1155:     		or      t1, t1, t2 %
00001543 : 07f57393;   % 1158:     		andi    t2, a0, 0x07F %
00001544 : 00d39393;   % 1159:     		slli    t2, t2, 13 %
00001545 : 00736333;   % 1160:     		or      t1, t1, t2 %
00001546 : 1ff00e93;   % 1163: 		li 	t4, 0x1FF %
00001547 : 004e9e93;   % 1164: 		slli 	t4, t4, 4 %
00001548 : 00fe8e93;   % 1165: 		addi 	t4, t4, 0x00F			# t4 = 0x00001FFF %
00001549 : 01d5f3b3;   % 1166:     		and    	t2, a1, t4 %
0000154a : 00736333;   % 1167:     		or      t1, t1, t2 %
0000154b : 0040006f;   % 1170:     		j       SintMidOutSync %
0000154c : 0062a023;   % 1172: SintMidOutSync:	sw	t1, 0(t0) %
0000154d : ff2003b7;   % 1175:     		li      t2, 0xFF20017C %
0000154e : 17c38393;   % 1175:  %
0000154f : ff200eb7;   % 1176:     		li      t4, 0xFF200180 %
00001550 : 180e8e93;   % 1176:  %
00001551 : 0003ae03;   % 1178: Check_AUD_DACLRCKSync:	lw      t3, 0(t2) %
00001552 : fe0e0ee3;   % 1179:     			beq     t3, zero, Check_AUD_DACLRCKSync %
00001553 : 000eaf03;   % 1181: Melody:     	lw      t5, 0(t4) %
00001554 : fe0f1ee3;   % 1182:     		bne     t5, zero, Melody %
00001555 : 00008067;   % 1184: fimmidiOutSync:	ret %
00001556 : ffc10113;   % 1194: printFloat:	addi 	sp, sp, -4 %
00001557 : 00112023;   % 1195: 		sw 	ra, 0(sp)				# salva ra %
00001558 : 0fc1f417;   % 1196: 		la 	s0, TempBuffer %
00001559 : 16840413;   % 1196:  %
0000155a : 02b00293;   % 1199: 		li 	t0, '+'			# define sinal '+' %
0000155b : e00504d3;   % 1200: 		fmv.x.s s1, fa0			# recupera o numero float sem conversao %
0000155c : 01f4d493;   % 1201: 		srli	s1, s1, 31		# bit 31(sinal) em bit 0, numero eh negativo s1=1 %
0000155d : 00048463;   % 1202: 		beq 	s1, zero, ehposprintFloat	# eh positivo s1=0 %
0000155e : 02d00293;   % 1203: 		li 	t0, '-'				# define sinal '-' %
0000155f : 00540023;   % 1204: ehposprintFloat: sb 	t0, 0(s0)			# coloca sinal no buffer %
00001560 : 00140413;   % 1205: 		addi 	s0, s0, 1			# incrementa o endereco do buffer %
00001561 : e00502d3;   % 1208: 		 fmv.x.s t0, fa0			# recupera o numero float sem conversao %
00001562 : 7f800337;   % 1209: 		 lui	t1, 0x7F800 %
00001563 : 0062f2b3;   % 1210: 		 and 	t0, t0, t1   			# mascara com 0111 1111 1000 0000 0000 0000... %
00001564 : 00129293;   % 1211: 		 slli 	t0, t0, 1			# tira o sinal do numero %
00001565 : 0182d293;   % 1212: 		 srli 	t0, t0, 24			# recupera o expoente %
00001566 : e0050353;   % 1215: 		fmv.x.s t1, fa0				# recupera o numero float sem conversao %
00001567 : 008003b7;   % 1216: 		li 	t2, 0x007FFFFF			# t2 = 0x007FFFFF %
00001568 : fff38393;   % 1216:  %
00001569 : 00737333;   % 1217: 		and 	t1, t1, t2			# mascara com 0000 0000 0111 1111 1111... 		  %
0000156a : 14028c63;   % 1219: 		beq 	t0, zero, ehExp0printFloat	# Expoente = 0 %
0000156b : 0ff00213;   % 1220: 		li	tp, 0x000000FF			# TP = 255 %
0000156c : 16428c63;   % 1221: 		beq 	t0, tp, ehExp255printFloat	# Expoente = 255 %
0000156d : 20a52053;   % 1225: 		fabs.s 		ft0, fa0		# ft0 recebe o modulo  de x %
0000156e : 00100213;   % 1226: 		li		tp, 1 %
0000156f : d00270d3;   % 1227: 		fcvt.s.w 	ft1, tp			# ft1 recebe o numero 1.0 %
00001570 : 00a00213;   % 1228: 		li		tp, 10 %
00001571 : d0027353;   % 1229: 		fcvt.s.w 	ft6, tp			# ft6 recebe o numero 10.0 %
00001572 : 00200213;   % 1230: 		li		tp, 2 %
00001573 : d0027e53;   % 1231: 		fcvt.s.w 	ft8, tp %
00001574 : 19c0f3d3;   % 1232: 		fdiv.s		ft7, ft1, ft8		# ft7 recebe o numero 0.5 %
00001575 : a0101ed3;   % 1234: 		flt.s 	t4, ft0, ft1		# ft0 < 1.0 ? Se sim, E deve ser negativo %
00001576 : 000e9663;   % 1235: 		bnez	t4, menor1printFloat	# se a comparacao deu true (1), pula %
00001577 : 20630153;   % 1236: 		fmv.s 	ft2, ft6		# ft2  fator de multiplicacao = 10 %
00001578 : 02c0006f;   % 1237: 		j 	cont2printFloat		# vai para expoente positivo %
00001579 : 1860f153;   % 1238: menor1printFloat: fdiv.s ft2,ft1,ft6		# ft2 fator multiplicativo = 0.1 %
0000157a : 20000253;   % 1241: cont1printFloat: 	fmv.s 	ft4, ft0			# inicia com o numero x  %
0000157b : 201081d3;   % 1242: 		 	fmv.s 	ft3, ft1			# contador comeca em 1 %
0000157c : 18227253;   % 1243: loop1printFloat: 	fdiv.s 	ft4, ft4, ft2			# divide o numero pelo fator multiplicativo %
0000157d : a0120e53;   % 1244: 		 	fle.s 	t3, ft4, ft1			# o numero eh > que 1? entao fim %
0000157e : 000e0663;   % 1245: 		 	beq 	t3,zero, fimloop1printFloat %
0000157f : 0011f1d3;   % 1246: 		 	fadd.s 	ft3, ft3, ft1			# incrementa o contador %
00001580 : ff1ff06f;   % 1247: 		 	j 	loop1printFloat			# volta ao loop %
00001581 : 18227253;   % 1249: fimloop1printFloat: 	fdiv.s 	ft4, ft4, ft2			# ajusta o numero %
00001582 : 0200006f;   % 1250: 		 	j 	intprintFloat			# vai para imprimir a parte inteira %
00001583 : 20000253;   % 1253: cont2printFloat:	fmv.s 	 ft4, ft0			# inicia com o numero x  %
00001584 : d00071d3;   % 1254: 		 	fcvt.s.w ft3, zero			# contador comeca em 0 %
00001585 : a0621e53;   % 1255: loop2printFloat:  	flt.s 	 t3, ft4, ft6			# resultado eh < que 10? entao fim %
00001586 : 18227253;   % 1256: 			fdiv.s 	 ft4, ft4, ft2			# divide o numero pelo fator multiplicativo %
00001587 : 000e1663;   % 1257: 			bne 	 t3, zero, intprintFloat %
00001588 : 0011f1d3;   % 1258: 		 	fadd.s 	 ft3, ft3, ft1			# incrementa o contador %
00001589 : ff1ff06f;   % 1259: 		 	j 	 loop2printFloat %
0000158a : 10227253;   % 1265: intprintFloat:		fmul.s 		ft4, ft4, ft2		# ajusta o numero %
0000158b : 08727253;   % 1266: 			fsub.s		ft4, ft4, ft7		# tira 0.5, dessa forma sempre ao converter estaremos fazendo floor %
0000158c : c00272d3;   % 1267: 		  	fcvt.w.s	t0, ft4			# coloca floor de ft4 em t0 %
0000158d : 00727253;   % 1268: 			fadd.s		ft4, ft4, ft7		# readiciona 0.5 %
0000158e : 00029463;   % 1269: 			bnez		t0, pulaeh1print	# para corrigir multiplos inteiros de 10! %
0000158f : 00100293;   % 1270: 			li 		t0, 1 %
00001590 : 03028293;   % 1271: pulaeh1print:		addi 		t0, t0, 48		# converte para ascii			 %
00001591 : 00540023;   % 1272: 			sb 		t0, 0(s0)		# coloca no buffer %
00001592 : 00140413;   % 1273: 		  	addi 		s0, s0, 1		# incrementta o buffer %
00001593 : 02e00293;   % 1276: 		  	li 	t0, '.'				# carrega o '.' %
00001594 : 00540023;   % 1277: 		  	sb 	t0, 0(s0)			# coloca no buffer %
00001595 : 00140413;   % 1278: 		  	addi 	s0, s0, 1			# incrementa o buffer %
00001596 : 00800313;   % 1281: 		  	li 		t1, 8				# contador de digitos  -  8 casas decimais %
00001597 : 04030a63;   % 1282: loopfracprintFloat:  	beq 		t1, zero, fimfracprintFloat	# fim dos digitos? %
00001598 : 08727253;   % 1283: 			fsub.s		ft4, ft4, ft7			# tira 0.5 %
00001599 : c0027f53;   % 1284: 			fcvt.w.s 	t5, ft4				# floor de ft4 %
0000159a : 00727253;   % 1285: 			fadd.s		ft4, ft4, ft7			# readiciona 0.5 %
0000159b : d00f72d3;   % 1286: 			fcvt.s.w	ft5, t5				# reconverte em float so com a parte inteira %
0000159c : 085272d3;   % 1287: 		  	fsub.s 		ft5, ft4, ft5			# parte fracionaria %
0000159d : 1062f2d3;   % 1288: 		  	fmul.s 		ft5, ft5, ft6			# mult x 10 %
0000159e : 0872f2d3;   % 1289: 			fsub.s		ft5, ft5, ft7			# tira 0.5 %
0000159f : c002f2d3;   % 1290: 			fcvt.w.s	t0, ft5				# coloca floor de ft5 em 10 %
000015a0 : 03028293;   % 1291: 		  	addi 		t0, t0, 48			# converte para ascii %
000015a1 : 03000213;   % 1293: 			li 		tp, 48 %
000015a2 : 0042c663;   % 1294: 			blt		t0, tp, pulaprtFloat1	# testa se eh menor que '0' %
000015a3 : 03900213;   % 1295: 			li		tp, 57 %
000015a4 : 00525463;   % 1296: 			ble		t0, tp, pulaprtFloat2	# testa se eh menor ou igual que '9' %
000015a5 : 03000293;   % 1297: pulaprtFloat1:		li		t0, 48			# define como '0'		  			  	 %
000015a6 : 00540023;   % 1299: pulaprtFloat2:	  	sb 		t0, 0(s0)			# coloca no buffer %
000015a7 : 00140413;   % 1300: 		  	addi 		s0, s0, 1			# incrementa endereco %
000015a8 : fff30313;   % 1301: 		  	addi 		t1, t1, -1			# decrementa contador %
000015a9 : 0072f2d3;   % 1302: 			fadd.s		ft5, ft5, ft7			# reincrementa 0.5 %
000015aa : 20528253;   % 1303: 		  	fmv.s 		ft4, ft5			# coloca o numero em ft4 %
000015ab : fb1ff06f;   % 1304: 		  	j 		loopfracprintFloat		# volta ao loop %
000015ac : 04500293;   % 1307: fimfracprintFloat: 	li 	t0,'E'			# carrega 'E' %
000015ad : 00540023;   % 1308: 			sb 	t0, 0(s0)		# coloca no buffer %
000015ae : 00140413;   % 1309: 			addi 	s0, s0, 1		# incrementa endereco %
000015af : 02b00293;   % 1312: 		  	li 	t0, '+'				# carrega '+' %
000015b0 : 000e8463;   % 1313: 		  	beqz 	t4, expposprintFloat		# nao eh negativo? %
000015b1 : 02d00293;   % 1314: 		  	li 	t0, '-'				# carrega '-' %
000015b2 : 00540023;   % 1315: expposprintFloat: 	sb 	t0, 0(s0)			# coloca no buffer %
000015b3 : 00140413;   % 1316: 		  	addi 	s0, s0, 1			#incrementa endereco %
000015b4 : 00a00313;   % 1319: 			li 	t1, 10				# carrega 10	 %
000015b5 : c001f253;   % 1320: 			fcvt.w.s  tp, ft3			# passa ft3 para t0 %
000015b6 : 026242b3;   % 1321: 			div 	t0, tp, t1			# divide por 10 (dezena) %
000015b7 : 026263b3;   % 1322: 			rem	t2, tp, t1			# t0 = quociente, t2 = resto %
000015b8 : 03028293;   % 1323: 			addi 	t0, t0, 48			# converte para ascii %
000015b9 : 00540023;   % 1324: 			sb 	t0, 0(s0)			# coloca no buffer %
000015ba : 03038393;   % 1325: 			addi 	t2, t2, 48			# converte para ascii %
000015bb : 007400a3;   % 1326: 			sb 	t2, 1(s0)			# coloca no buffer %
000015bc : 00040123;   % 1327: 			sb 	zero, 2(s0)			# insere \NULL da string %
000015bd : 0fc1f517;   % 1328: 			la 	a0, TempBuffer			# endereco do Buffer										 %
000015be : fd450513;   % 1328:  %
000015bf : 0500006f;   % 1329: 	  		j 	fimprintFloat			# imprime a string %
000015c0 : 00030e63;   % 1331: ehExp0printFloat: 	beq 	t1, zero, eh0printFloat		# Verifica se eh zero %
000015c1 : 0fc1f517;   % 1333: ehDesnormprintFloat: 	la 	a0, NumDesnormP			# string numero desnormalizado positivo %
000015c2 : 1d750513;   % 1333:  %
000015c3 : 04048063;   % 1334: 			beq 	s1, zero, fimprintFloat		# o sinal eh 1? entao eh negativo %
000015c4 : 0fc1f517;   % 1335: 		 	la 	a0, NumDesnormN			# string numero desnormalizado negativo %
000015c5 : 1d450513;   % 1335:  %
000015c6 : 0340006f;   % 1336: 			j 	fimprintFloat			# imprime a string %
000015c7 : 0fc1f517;   % 1338: eh0printFloat:		la 	a0, NumZero			# string do zero %
000015c8 : 1d150513;   % 1338:  %
000015c9 : 0280006f;   % 1339: 			j 	fimprintFloat 	 		# imprime a string %
000015ca : 00030863;   % 1341: ehExp255printFloat: 	beq 	t1, zero, ehInfprintFloat	# se mantissa eh zero entao eh Infinito %
000015cb : 0fc1f517;   % 1343: ehNaNprintfFloat:	la 	a0, NumNaN			# string do NaN %
000015cc : 1e050513;   % 1343:  %
000015cd : 0180006f;   % 1344: 			j 	fimprintFloat			# imprime string %
000015ce : 0fc1f517;   % 1346: ehInfprintFloat:	la 	a0, NumInfP			# string do infinito positivo %
000015cf : 1c050513;   % 1346:  %
000015d0 : 00048663;   % 1347: 			beq 	s1, zero, fimprintFloat		# o sinal eh 1? entao eh negativo %
000015d1 : 0fc1f517;   % 1348: 			la 	a0, NumInfN			# string do infinito negativo %
000015d2 : 1be50513;   % 1348:  %
000015d3 : 931ff0ef;   % 1352: 			jal	printString			# imprime a string em a0 %
000015d4 : 00012083;   % 1353: 			lw 	ra, 0(sp)			# recupera ra %
000015d5 : 00410113;   % 1354: 			addi 	sp, sp, 4			# libera espaco %
000015d6 : 00008067;   % 1355: 			ret					# retorna %
000015d7 : 00008067;   % 1373: 			ret %
000015d8 : 00008067;   % 1391: 			ret %
000015d9 : ffc10113;   % 1402: readFloat: addi sp, sp, -4			# aloca espaco %
000015da : 00112023;   % 1403: 	sw 	ra, 0(sp)			# salva ra %
000015db : 0fc1f517;   % 1404: 	la 	a0, TempBuffer			# endereco do FloatBuffer %
000015dc : f5c50513;   % 1404:  %
000015dd : 02000593;   % 1405: 	li 	a1, 32				# numero maximo de caracteres %
000015de : b39ff0ef;   % 1406: 	jal	readString			# le string, retorna a2 ultimo endereco e a3 numero de caracteres %
000015df : 00c00433;   % 1407: 	mv 	s0, a2				# ultimo endereco da string (antes do \0) %
000015e0 : 00d004b3;   % 1408: 	mv 	s1, a3				# numero de caracteres digitados %
000015e1 : 0fc1fb97;   % 1409: 	la	s7, TempBuffer			# Endereco do primeiro caractere %
000015e2 : f44b8b93;   % 1409:  %
000015e3 : 017002b3;   % 1411: lePrimeiroreadFloat:	mv 	t0, s7		# Endereco de Inicio %
000015e4 : 00028303;   % 1412: 	lb 	t1, 0(t0)				# le primeiro caractere %
000015e5 : 06500213;   % 1413: 	li	tp, 'e'					# TP = 101 = 'e' %
000015e6 : 02430863;   % 1414: 	beq 	t1, tp, insere0AreadFloat		# insere '0' antes %
000015e7 : 04500213;   % 1415: 	li 	tp, 'E'					# TP = 69 = 'E' %
000015e8 : 02430463;   % 1416: 	beq 	t1, tp, insere0AreadFloat		# insere '0' antes %
000015e9 : 02e00213;   % 1417: 	li	tp, '.'					# TP = 46 = '.' %
000015ea : 02430063;   % 1418: 	beq 	t1, tp, insere0AreadFloat		#  insere '0' antes %
000015eb : 02b00213;   % 1419: 	li	tp, '+'					# TP = 43 = '+' %
000015ec : 00430863;   % 1420: 	beq 	t1, tp, pulaPrimreadChar		# pula o primeiro caractere %
000015ed : 02d00213;   % 1421: 	li	tp, '-'					# TP = 45 = '-' %
000015ee : 00430463;   % 1422: 	beq 	t1, tp, pulaPrimreadChar %
000015ef : 03c0006f;   % 1423: 	j leUltimoreadFloat %
000015f0 : 001b8b93;   % 1425: pulaPrimreadChar: addi s7,s7,1			# incrementa o endereco inicial %
000015f1 : fc9ff06f;   % 1426: 		  j lePrimeiroreadFloat		# volta a testar o novo primeiro caractere %
000015f2 : 008002b3;   % 1428: insere0AreadFloat: mv t0, s0			# endereco do ultimo caractere %
000015f3 : 00140413;   % 1429: 		   addi s0, s0, 1		# desloca o ultimo endereco para o proximo %
000015f4 : 00148493;   % 1430: 	   	   addi s1, s1, 1		# incrementa o num. caracteres %
000015f5 : 000400a3;   % 1431: 	   	   sb 	zero, 1(s0)		# \NULL do final de string %
000015f6 : 01700f33;   % 1432: 	   	   mv t5, s7			# primeiro caractere %
000015f7 : 01e28a63;   % 1433: insere0Aloop:	   beq 	t0, t5, saiinsere0AreadFloat	# chegou no inicio entao fim %
000015f8 : 00028303;   % 1434: 		   lb 	t1, 0(t0)		# le caractere %
000015f9 : 006280a3;   % 1435: 		   sb 	t1, 1(t0)		# escreve no proximo %
000015fa : fff28293;   % 1436: 		   addi t0, t0, -1		# decrementa endereco %
000015fb : ff1ff06f;   % 1437: 		   j insere0Aloop		# volta ao loop %
000015fc : 03000313;   % 1438: saiinsere0AreadFloat: li t1, '0'		# ascii '0' %
000015fd : 00628023;   % 1439: 		   sb t1, 0(t0)			# escreve '0' no primeiro caractere %
000015fe : 00040303;   % 1441: leUltimoreadFloat: lb  	t1, 0(s0)			# le ultimo caractere %
000015ff : 06500213;   % 1442: 		li	tp, 'e'				# TP = 101 = 'e' %
00001600 : 00430c63;   % 1443: 		beq 	t1, tp, insere0PreadFloat	# insere '0' depois %
00001601 : 04500213;   % 1444: 		li 	tp, 'E'				# TP = 69 = 'E' %
00001602 : 00430863;   % 1445: 		beq 	t1, tp, insere0PreadFloat	# insere '0' depois %
00001603 : 02e00213;   % 1446: 		li	tp, '.'				# TP = 46 = '.' %
00001604 : 00430463;   % 1447: 		beq 	t1, tp, insere0PreadFloat	# insere '0' depois %
00001605 : 0180006f;   % 1448: 		j 	inicioreadFloat %
00001606 : 00140413;   % 1450: insere0PreadFloat: addi	s0, s0, 1		# desloca o ultimo endereco para o proximo %
00001607 : 00148493;   % 1451: 	   	   addi	s1, s1, 1		# incrementa o num. caracteres %
00001608 : 03000313;   % 1452: 		   li 	t1,'0'			# ascii '0' %
00001609 : 00640023;   % 1453: 		   sb 	t1,0(s0)		# escreve '0' no ultimo %
0000160a : 000400a3;   % 1454: 		   sb 	zero,1(s0)		# \null do final de string %
0000160b : d0007553;   % 1456: inicioreadFloat:  fcvt.s.w 	fa0, zero	# fa0 Resultado inicialmente zero %
0000160c : 00a00293;   % 1457: 		li 	t0, 10			# inteiro 10	 %
0000160d : d002f353;   % 1458: 		fcvt.s.w 	ft6, t0		# ft6 contem sempre o numero cte 10.0000 %
0000160e : 00100293;   % 1459: 		li 	t0, 1			# inteiro 1 %
0000160f : d002f0d3;   % 1460: 		fcvt.s.w 	ft1, t0		# ft1 contem sempre o numero cte 1.0000	 %
00001610 : 00140993;   % 1463: procuraEreadFloat:	addi 	s3, s0, 1			# inicialmente nao tem 'e' ou 'E' na string (fora da string) %
00001611 : 017002b3;   % 1464: 			mv 	t0, s7				# endereco inicial %
00001612 : 02828263;   % 1465: loopEreadFloat: 	beq 	t0, s0, naotemEreadFloat	# sai se nao encontrou 'e' %
00001613 : 00028303;   % 1466: 			lb 	t1, 0(t0)			# le o caractere %
00001614 : 06500213;   % 1467: 			li	tp, 'e'				# TP = 101 = 'e' %
00001615 : 00430a63;   % 1468: 			beq 	t1, tp, ehEreadFloat		# tem 'e' %
00001616 : 04500213;   % 1469: 			li 	tp, 'E'				# TP = 69 = 'E' %
00001617 : 00430663;   % 1470: 			beq	t1, tp, ehEreadFloat		# tem 'E' %
00001618 : 00128293;   % 1471: 			addi 	t0, t0, 1			# incrementa endereco %
00001619 : fe5ff06f;   % 1472: 			j 	loopEreadFloat			# volta ao loop %
0000161a : 005009b3;   % 1473: ehEreadFloat: 		mv 	s3, t0				# endereco do 'e' ou 'E' na string %
0000161b : 01300933;   % 1477: procuraPontoreadFloat:	mv 	s2, s3				# local inicial do ponto na string (='e' se existir) ou fora da string	 %
0000161c : 017002b3;   % 1478: 			mv 	t0, s7				# endereco inicial %
0000161d : 00828e63;   % 1479: loopPontoreadFloat: 	beq 	t0, s0, naotemPontoreadFloat	# sai se nao encontrou '.' %
0000161e : 00028303;   % 1480: 			lb 	t1, 0(t0)			# le o caractere %
0000161f : 02e00213;   % 1481: 			li	tp, '.'				# TP = 46 = '.' %
00001620 : 00430663;   % 1482: 			beq 	t1, tp, ehPontoreadFloat	# tem '.' %
00001621 : 00128293;   % 1483: 			addi 	t0, t0, 1			# incrementa endereco %
00001622 : fedff06f;   % 1484: 			j 	loopPontoreadFloat		# volta ao loop %
00001623 : 00500933;   % 1485: ehPontoreadFloat: 	mv 	s2, t0				# endereco do '.' na string %
00001624 : d0007153;   % 1489: intreadFloat:		fcvt.s.w 	ft2, zero		# zera parte inteira %
00001625 : fff90293;   % 1490: 			addi 	t0, s2, -1			# endereco do caractere antes do ponto %
00001626 : 201081d3;   % 1491: 			fmv.s 	ft3, ft1			# ft3 contem unidade/dezenas/centenas		 %
00001627 : 01700f33;   % 1492: 			mv 	t5, s7				# Primeiro Endereco %
00001628 : 03e2ca63;   % 1493: loopintreadFloat: 	blt 	t0, t5, fimintreadFloat		# sai se o endereco for < inicio da string %
00001629 : 00028303;   % 1494: 			lb 	t1, 0(t0)			# le o caracter %
0000162a : 03000213;   % 1495: 			li	tp, '0'				# TP = 48 = '0' %
0000162b : 10434863;   % 1496: 			blt 	t1, tp, erroreadFloat		# nao eh caractere valido para numero %
0000162c : 03900213;   % 1497: 			li	tp, '9'				# TP = 57 = '9' %
0000162d : 10624463;   % 1498: 			bgt 	t1, tp, erroreadFloat		# nao eh caractere valido para numero %
0000162e : fd030313;   % 1499: 			addi 	t1, t1, -48			# converte ascii para decimal %
0000162f : d0037153;   % 1500: 			fcvt.s.w  ft2, t1			# digito lido em float %
00001630 : 10317153;   % 1502: 			fmul.s 	ft2,ft2,ft3			# multiplica por un/dezena/centena %
00001631 : 00257553;   % 1503: 			fadd.s 	fa0,fa0,ft2			# soma no resultado %
00001632 : 1061f1d3;   % 1504: 			fmul.s 	ft3,ft3,ft6			# proxima dezena/centena %
00001633 : fff28293;   % 1506: 			addi 	t0,t0,-1			# endereco anterior %
00001634 : fd1ff06f;   % 1507: 			j 	loopintreadFloat		# volta ao loop %
00001635 : d0007153;   % 1511: fracreadFloat:		fcvt.s.w 	ft2, zero		# zera parte fracionaria %
00001636 : 00190293;   % 1512: 			addi 	t0, s2, 1			# endereco depois do ponto %
00001637 : 1860f1d3;   % 1513: 			fdiv.s 	ft3, ft1, ft6			# ft3 inicial 0.1 %
00001638 : 0332da63;   % 1515: loopfracreadFloat: 	bge 	t0, s3, fimfracreadFloat	# endereco eh 'e' 'E' ou >ultimo %
00001639 : 00028303;   % 1516: 			lb 	t1, 0(t0)			# le o caracter %
0000163a : 03000213;   % 1517: 			li	tp, '0'				# TP = 48 = '0' %
0000163b : 0c434863;   % 1518: 			blt 	t1, tp, erroreadFloat		# nao eh valido %
0000163c : 03900213;   % 1519: 			li	tp, '9'				# TP = 57 = '9' %
0000163d : 0c624463;   % 1520: 			bgt 	t1, tp, erroreadFloat		# nao eh valido %
0000163e : fd030313;   % 1521: 			addi 	t1, t1, -48			# converte ascii para decimal %
0000163f : d0037153;   % 1522: 			fcvt.s.w 	ft2, t1			# digito lido em float		 %
00001640 : 10317153;   % 1524: 			fmul.s 	ft2, ft2, ft3			# multiplica por ezena/centena %
00001641 : 00257553;   % 1525: 			fadd.s 	fa0, fa0, ft2			# soma no resultado %
00001642 : 1861f1d3;   % 1526: 			fdiv.s 	ft3, ft3, ft6			# proxima frac un/dezena/centena %
00001643 : 00128293;   % 1528: 			addi 	t0, t0, 1			# proximo endereco %
00001644 : fd1ff06f;   % 1529: 			j 	loopfracreadFloat		# volta ao loop		 %
00001645 : d0007153;   % 1534: potreadFloat:		fcvt.s.w 	ft2, zero		# zera potencia %
00001646 : 00198293;   % 1535: 			addi 	t0, s3, 1			# endereco seguinte ao 'e' %
00001647 : 00000a13;   % 1536: 			li 	s4, 0				# sinal do expoente positivo %
00001648 : 00028303;   % 1537: 			lb 	t1, 0(t0)			# le o caractere seguinte ao 'e' %
00001649 : 02d00213;   % 1538: 			li	tp, '-'				# TP = 45 = '-' %
0000164a : 00430863;   % 1539: 			beq	t1, tp, potsinalnegreadFloat	# sinal do expoente esta escrito e eh positivo %
0000164b : 02b00213;   % 1540: 			li	tp, '+'				# TP = 43 = '+' %
0000164c : 00430663;   % 1541: 			beq 	t1, tp, potsinalposreadFloat	# sinal do expoente eh negativo %
0000164d : 00c0006f;   % 1542: 			j 	pulapotsinalreadFloat		# nao esta escrito o sinal do expoente %
0000164e : 00100a13;   % 1543: potsinalnegreadFloat:	li 	s4, 1				# s4=1 expoente negativo %
0000164f : 00128293;   % 1544: potsinalposreadFloat:	addi 	t0, t0, 1			# se tiver '-' ou '+' avanca para o proximo endereco %
00001650 : 00500ab3;   % 1545: pulapotsinalreadFloat:	mv 	s5, t0 				# Neste ponto s5 contem o endereco do primeiro digito da pot e s4 o sinal do expoente		 %
00001651 : 201081d3;   % 1547: 			fmv.s 	ft3, ft1			# ft3 un/dez/cen = 1 %
00001652 : 00000393;   % 1550: expreadFloat:		li 	t2, 0				# zera expoente %
00001653 : 008002b3;   % 1551: 			mv 	t0, s0				# endereco do ultimo caractere da string %
00001654 : 00a00e13;   % 1552: 			li 	t3, 10				# numero dez %
00001655 : 00100e93;   % 1553: 			li 	t4, 1				# und/dez/cent %
00001656 : 0352c063;   % 1555: loopexpreadFloat:	blt 	t0, s5, fimexpreadFloat		# ainda nao eh o endereco do primeiro digito? %
00001657 : 00028303;   % 1556: 			lb 	t1, 0(t0)			# le o caracter %
00001658 : fd030313;   % 1557: 			addi 	t1, t1, -48			# converte ascii para decimal %
00001659 : 03d30333;   % 1558: 			mul 	t1, t1, t4			# mul digito %
0000165a : 006383b3;   % 1559: 			add 	t2, t2, t1			# soma ao exp %
0000165b : 03ce8eb3;   % 1560: 			mul 	t4, t4, t3			# proxima casa decimal %
0000165c : fff28293;   % 1561: 			addi 	t0, t0, -1			# endereco anterior %
0000165d : fe5ff06f;   % 1562: 			j loopexpreadFloat			# volta ao loop %
0000165e : 20108153;   % 1566: 			fmv.s 	ft2, ft1			# numero 10^exp  inicial=1 %
0000165f : 206301d3;   % 1567: 			fmv.s 	ft3, ft6			# se o sinal for + ft3 eh 10 %
00001660 : 00000213;   % 1568: 			li	tp, 0x00000000			# TP = ZERO %
00001661 : 004a0463;   % 1569: 			beq 	s4, tp, sinalexpPosreadFloat	# se sinal exp positivo %
00001662 : 1860f1d3;   % 1570: 			fdiv.s 	ft3, ft1, ft6			# se o final for - ft3 eh 0.1 %
00001663 : 00000293;   % 1571: sinalexpPosreadFloat:	li 	t0, 0				# contador  %
00001664 : 00728863;   % 1572: sinalexpreadFloat: 	beq 	t0, t2, fimsinalexpreadFloat	# se chegou ao fim %
00001665 : 10317153;   % 1573: 			fmul.s 	ft2, ft2, ft3			# multiplica pelo fator 10 ou 0.1 %
00001666 : 00128293;   % 1574: 			addi 	t0, t0, 1			# incrementa o contador %
00001667 : ff5ff06f;   % 1575: 			j 	sinalexpreadFloat %
00001668 : 10257553;   % 1578: 		fmul.s 	fa0, fa0, ft2		# multiplicacao final! %
00001669 : 0fc1f297;   % 1580: 		la 	t0, TempBuffer		# ajuste final do sinal do numero %
0000166a : d2428293;   % 1580:  %
0000166b : 00028303;   % 1581: 		lb 	t1, 0(t0)		# le primeiro caractere %
0000166c : 02d00213;   % 1582: 		li	tp, '-'			# TP = 45 = '-' %
0000166d : 00431463;   % 1583: 		bne 	t1, tp, fimreadFloat	# nao eh '-' entao fim %
0000166e : 20a51553;   % 1584: 		fneg.s 	fa0, fa0		# nega o numero float %
0000166f : 00012083;   % 1587: fimreadFloat: 	lw 	ra, 0(sp)		# recupera ra %
00001670 : 00410113;   % 1588: 		addi 	sp, sp, 4		# libera espaco %
00001671 : 00008067;   % 1589: 		ret				# retorna %
00001672 : 10008c37;   % 1597: <9> li s8, 0x10008000	# carrega tp %
00001673 : 000c0c13;   % 1597:  %
00001674 : 01819863;   % 1597: <10> bne gp, s8, Time.DE1	# Na DE1 gp = 0 ! N�o tem segmento .extern %
00001675 : 01e00893;   % 1598: 	li 	a7, 30				# Chama o ecall do Rars %
00001676 : 00000073;   % 1599: 	ecall %
00001677 : 00008067;   % 1600: 	ret					# saida %
00001678 : c0102573;   % 1602: Time.DE1:	csrr a0, time			#  Le time LOW %
00001679 : c81025f3;   % 1603: 		csrr a1, timeh 			#  Le time HIGH %
0000167a : 00008067;   % 1604: 		ret %
0000167b : 10008c37;   % 1611: <9> li s8, 0x10008000	# carrega tp %
0000167c : 000c0c13;   % 1611:  %
0000167d : 01819863;   % 1611: <10> bne gp, s8, Sleep.DE1	# Na DE1 gp = 0 ! N�o tem segmento .extern %
0000167e : 02000893;   % 1612: 	li 	a7, 32				# Chama o ecall do Rars %
0000167f : 00000073;   % 1613: 	ecall %
00001680 : 00008067;   % 1614: 	ret					#Saida %
00001681 : c01022f3;   % 1616: Sleep.DE1:	csrr 	t0, time		# Le o tempo do sistema %
00001682 : 00a28333;   % 1617: 		add 	t1, t0, a0		# soma com o tempo solicitado %
00001683 : c01022f3;   % 1618: Sleep.Loop:	csrr	t0, time		# Le o tempo do sistema %
00001684 : fe62eee3;   % 1619: 		bltu	t0, t1, Sleep.Loop	# t0<t1 ? %
00001685 : 00008067;   % 1620: 		ret %
00001686 : 10008c37;   % 1628: <9> li s8, 0x10008000	# carrega tp %
00001687 : 000c0c13;   % 1628:  %
00001688 : 01819863;   % 1628: <10> bne gp, s8, Random.DE1	# Na DE1 gp = 0 ! N�o tem segmento .extern %
00001689 : 02900893;   % 1629: 	li 	a7,41			# Chama o ecall do Rars %
0000168a : 00000073;   % 1630: 	ecall	 %
0000168b : 00008067;   % 1631: 	ret				# saida %
0000168c : ff2002b7;   % 1633: Random.DE1: 	li 	t0, 0xFF200514	# carrega endereco do LFSR %
0000168d : 51428293;   % 1633:  %
0000168e : 0002a503;   % 1634: 		lw 	a0, 0(t0)	# le a word em a0 %
0000168f : 00008067;   % 1635: 		ret			# retorna %
00001690 : 10008c37;   % 1645: <9> li s8, 0x10008000	# carrega tp %
00001691 : 000c0c13;   % 1645:  %
00001692 : 01819863;   % 1645: <10> bne gp, s8, Random2.DE1	# Na DE1 gp = 0 ! N�o tem segmento .extern %
00001693 : 02a00893;   % 1646: 		li 	a7,42			# Chama o ecall do Rars %
00001694 : 00000073;   % 1647: 		ecall	 %
00001695 : 00008067;   % 1648: 		ret				# saida %
00001696 : ff2002b7;   % 1650: Random2.DE1: 	li 	t0, 0xFF200514	# carrega endereco do LFSR %
00001697 : 51428293;   % 1650:  %
00001698 : 0002a503;   % 1651: 		lw 	a0, 0(t0)	# le a word em a0 %
00001699 : ffc10113;   % 1652: 		addi sp,sp,-4 %
0000169a : 00112023;   % 1653: 		sw ra,0(sp) %
0000169b : 4b8000ef;   % 1654: 		jal 	__umodsi3 %
0000169c : 00012083;   % 1656: 		lw ra,0(sp) %
0000169d : 00410113;   % 1657: 		addi sp,sp,4 %
0000169e : 00008067;   % 1658: 		ret			# retorna %
0000169f : 00058c63;   % 1669: clsCLS:	beq 	a1, zero, CLS.frame0 %
000016a0 : ff100337;   % 1670: 	li      t1, 0xFF100000              # Memoria VGA 1 %
000016a1 : 00030313;   % 1670:  %
000016a2 : ff1133b7;   % 1671:    	li      t2, 0xFF112C00 %
000016a3 : c0038393;   % 1671:  %
000016a4 : 0140006f;   % 1672:    	j 	CLS.pula %
000016a5 : ff000337;   % 1673: CLS.frame0: 	li      t1, 0xFF000000           # Memoria VGA 0 %
000016a6 : 00030313;   % 1673:  %
000016a7 : ff0133b7;   % 1674:    	    	li      t2, 0xFF012C00   	 %
000016a8 : c0038393;   % 1674:  %
000016a9 : 0ff57513;   % 1675: CLS.pula:	andi    a0, a0, 0x00FF %
000016aa : 00a002b3;   % 1678:  		mv 	t0, a0 %
000016ab : 00851513;   % 1679:  		slli 	a0, a0, 8 %
000016ac : 00a2e2b3;   % 1680:  		or 	t0, t0, a0 %
000016ad : 00851513;   % 1681:  		slli 	a0, a0, 8 %
000016ae : 00a2e2b3;   % 1682:  		or 	t0, t0, a0 %
000016af : 00851513;   % 1683:  		slli 	a0, a0, 8 %
000016b0 : 00a2e2b3;   % 1684:  		or 	t0, t0, a0 %
000016b1 : 00730863;   % 1686: CLS.for:	beq     t1, t2, CLS.fim %
000016b2 : 00532023;   % 1687: 		sw      t0, 0(t1) %
000016b3 : 00430313;   % 1688:     		addi    t1, t1, 4 %
000016b4 : ff5ff06f;   % 1689:     		j       CLS.for %
000016b5 : 00008067;   % 1690: CLS.fim:	ret %
000016b6 : ff000837;   % 1699: BRESENHAM: 	li	a6, 0xFF000000           	# Memoria VGA 0 %
000016b7 : 00080813;   % 1699:  %
000016b8 : 00078663;   % 1700: 	   	beq	a5, zero, pulaBRES %
000016b9 : ff100837;   % 1701: 	   	li 	a6, 0xFF100000              # Memoria VGA 1 %
000016ba : 00080813;   % 1701:  %
000016bb : 14000893;   % 1703: pulaBRES: 	li 	a7, 320 %
000016bc : 40b682b3;   % 1704: 	  	sub 	t0, a3, a1 %
000016bd : 0002d463;   % 1705: 	  	bge 	t0, zero, PULAABRES %
000016be : 405002b3;   % 1706: 	  	sub 	t0, zero, t0 %
000016bf : 40a60333;   % 1707: PULAABRES:	sub 	t1, a2, a0 %
000016c0 : 00035463;   % 1708: 	   	bge  	t1, zero, PULABBRES %
000016c1 : 40600333;   % 1709: 	   	sub  	t1, zero, t1	 %
000016c2 : 0262d263;   % 1710: PULABBRES: 	bge  	t0, t1, PULACBRES %
000016c3 : 00a65e63;   % 1711: 	   	ble  	a0, a2, PULAC1BRES %
000016c4 : 00a007b3;   % 1712: 	   	mv 	a5, a0 %
000016c5 : 00c00533;   % 1713: 	   	mv 	a0, a2 %
000016c6 : 00f00633;   % 1714: 	   	mv 	a2, a5 %
000016c7 : 00b007b3;   % 1715: 	   	mv	a5, a1 %
000016c8 : 00d005b3;   % 1716: 	   	mv 	a1, a3 %
000016c9 : 00f006b3;   % 1717: 	   	mv 	a3, a5 %
000016ca : 0240006f;   % 1718: PULAC1BRES:	j PLOTLOWBRES %
000016cb : 00b6de63;   % 1720: PULACBRES: 	ble  	a1, a3, PULAC2BRES %
000016cc : 00a007b3;   % 1721: 	   	mv 	a5, a0 %
000016cd : 00c00533;   % 1722: 	   	mv 	a0, a2 %
000016ce : 00f00633;   % 1723: 	   	mv 	a2, a5 %
000016cf : 00b007b3;   % 1724: 	   	mv 	a5, a1 %
000016d0 : 00d005b3;   % 1725: 	   	mv 	a1, a3 %
000016d1 : 00f006b3;   % 1726: 	   	mv 	a3, a5 %
000016d2 : 0a80006f;   % 1727: PULAC2BRES:	j PLOTHIGHBRES %
000016d3 : 40a602b3;   % 1729: PLOTLOWBRES:	sub 	t0, a2, a0		# dx=x1-x0 %
000016d4 : 40b68333;   % 1730: 	 	sub 	t1, a3, a1		# dy y1-y0 %
000016d5 : 00100393;   % 1731: 	 	li  	t2, 1			# yi=1 %
000016d6 : 00035663;   % 1732: 	 	bge 	t1, zero, PULA1BRES	# dy>=0 PULA %
000016d7 : fff00393;   % 1733: 	 	li  	t2, -1			# yi=-1 %
000016d8 : 40600333;   % 1734: 	 	sub 	t1, zero, t1		# dy=-dy %
000016d9 : 00131e13;   % 1735: PULA1BRES:	slli 	t3, t1, 1		# 2*dy %
000016da : 405e0e33;   % 1736: 		sub 	t3, t3, t0		# D=2*dy-dx %
000016db : 00b00eb3;   % 1737: 		mv 	t4, a1			# y=y0 %
000016dc : 00a00f33;   % 1738: 		mv 	t5, a0			# x=x0 %
000016dd : 30102c73;   % 1740: <29> csrr s8, misa %
000016de : 00cc5c13;   % 1740: <30> srli s8, s8, 12 %
000016df : 001c7c13;   % 1740: <31> andi s8, s8, 0x001 %
000016e0 : 020c1e63;   % 1740: <32> bnez s8, BRESENHAM.mul1 %
000016e1 : ff410113;   % 1741: <45> addi 	sp, sp, -12 %
000016e2 : 00a12023;   % 1741: <46> sw	a0, 0(sp) %
000016e3 : 00b12223;   % 1741: <47> sw	a1, 4(sp) %
000016e4 : 00112423;   % 1741: <48> sw	ra, 8(sp) %
000016e5 : 01d00533;   % 1741: <50> mv 	a0, t4 %
000016e6 : 011005b3;   % 1741: <51> mv 	a1, a7 %
000016e7 : 2d8000ef;   % 1741: <52> jal 	__mulsi3 %
000016e8 : 04051073;   % 1741: <53> csrw	a0,uscratch %
000016e9 : 00012503;   % 1741: <55> lw	a0, 0(sp) %
000016ea : 00412583;   % 1741: <56> lw	a1, 4(sp) %
000016eb : 00812083;   % 1741: <57> lw	ra, 8(sp) %
000016ec : 00c10113;   % 1741: <58> addi 	sp, sp, 12 %
000016ed : 04002ff3;   % 1741: <59> csrr	t6,uscratch %
000016ee : 0080006f;   % 1742: 		j BRESENHAM.mul1d %
000016ef : 031e8fb3;   % 1743: BRESENHAM.mul1:	mul 	t6, t4, a7		# y*320 %
000016f0 : 01ef8fb3;   % 1744: BRESENHAM.mul1d:add 	t6, t6, t5		# y*320+x %
000016f1 : 010f8fb3;   % 1745: 		add 	t6, t6, a6		# 0xFF000000+y*320+x %
000016f2 : 00ef8023;   % 1746: 		sb 	a4, 0(t6)		# plot com cor a4 %
000016f3 : 01c05863;   % 1748: 		ble 	t3, zero, PULA2BRES	# D<=0 %
000016f4 : 007e8eb3;   % 1749: 		add 	t4, t4, t2		# y=y+yi %
000016f5 : 00129f93;   % 1750: 		slli 	t6, t0, 1		# 2*dx %
000016f6 : 41fe0e33;   % 1751: 		sub 	t3, t3, t6		# D=D-2dx %
000016f7 : 00131f93;   % 1752: PULA2BRES:	slli 	t6, t1, 1		# 2*dy %
000016f8 : 01fe0e33;   % 1753: 		add 	t3, t3, t6		# D=D+2dx %
000016f9 : 001f0f13;   % 1754: 		addi	t5, t5, 1 %
000016fa : f8cf16e3;   % 1755: 		bne 	t5, a2, LOOPx1BRES %
000016fb : 00008067;   % 1756: 		ret %
000016fc : 40a602b3;   % 1758: PLOTHIGHBRES: 	sub 	t0, a2, a0		# dx=x1-x0 %
000016fd : 40b68333;   % 1759: 	 	sub 	t1, a3, a1		# dy y1-y0 %
000016fe : 00100393;   % 1760: 	 	li 	t2, 1			# xi=1 %
000016ff : 0002d663;   % 1761: 	 	bge 	t0, zero, PULA3BRES	# dy>=0 PULA %
00001700 : fff00393;   % 1762: 	 	li 	t2, -1			# xi=-1 %
00001701 : 405002b3;   % 1763: 	 	sub 	t0, zero, t0		# dx=-dx %
00001702 : 00129e13;   % 1764: PULA3BRES:	slli 	t3, t0, 1		# 2*dx %
00001703 : 406e0e33;   % 1765: 		sub 	t3, t3, t1		# D=2*dx-d1 %
00001704 : 00a00eb3;   % 1766: 		mv 	t4, a0			# x=x0 %
00001705 : 00b00f33;   % 1767: 		mv 	t5, a1			# y=y0 %
00001706 : 30102c73;   % 1769: <29> csrr s8, misa %
00001707 : 00cc5c13;   % 1769: <30> srli s8, s8, 12 %
00001708 : 001c7c13;   % 1769: <31> andi s8, s8, 0x001 %
00001709 : 020c1e63;   % 1769: <32> bnez s8, BRESENHAM.mul2 %
0000170a : ff410113;   % 1770: <45> addi 	sp, sp, -12 %
0000170b : 00a12023;   % 1770: <46> sw	a0, 0(sp) %
0000170c : 00b12223;   % 1770: <47> sw	a1, 4(sp) %
0000170d : 00112423;   % 1770: <48> sw	ra, 8(sp) %
0000170e : 01e00533;   % 1770: <50> mv 	a0, t5 %
0000170f : 011005b3;   % 1770: <51> mv 	a1, a7 %
00001710 : 234000ef;   % 1770: <52> jal 	__mulsi3 %
00001711 : 04051073;   % 1770: <53> csrw	a0,uscratch %
00001712 : 00012503;   % 1770: <55> lw	a0, 0(sp) %
00001713 : 00412583;   % 1770: <56> lw	a1, 4(sp) %
00001714 : 00812083;   % 1770: <57> lw	ra, 8(sp) %
00001715 : 00c10113;   % 1770: <58> addi 	sp, sp, 12 %
00001716 : 04002ff3;   % 1770: <59> csrr	t6,uscratch %
00001717 : 0080006f;   % 1771: 		j BRESENHAM.mul2d %
00001718 : 031f0fb3;   % 1772: BRESENHAM.mul2:	mul 	t6, t5, a7		# y*320 %
00001719 : 01df8fb3;   % 1773: BRESENHAM.mul2d:add 	t6, t6, t4		# y*320+x %
0000171a : 010f8fb3;   % 1774: 		add 	t6, t6, a6		# 0xFF000000+y*320+x %
0000171b : 00ef8023;   % 1775: 		sb 	a4, 0(t6)		# plot com cor a4 %
0000171c : 01c05863;   % 1777: 		ble 	t3, zero, PULA4BRES	# D<=0 %
0000171d : 007e8eb3;   % 1778: 		add 	t4, t4, t2		# x=x+xi %
0000171e : 00131f93;   % 1779: 		slli 	t6, t1, 1		# 2*dy %
0000171f : 41fe0e33;   % 1780: 		sub 	t3, t3, t6		# D=D-2dy %
00001720 : 00129f93;   % 1781: PULA4BRES: 	slli 	t6, t0, 1		# 2*dy %
00001721 : 01fe0e33;   % 1782: 		add 	t3, t3, t6		# D=D+2dx %
00001722 : 001f0f13;   % 1783: 		addi 	t5, t5, 1 %
00001723 : f8df16e3;   % 1784: 		bne 	t5, a3, LOOPx2BRES %
00001724 : 00008067;   % 1785: 		ret		 %
00001725 : ffc10113;   % 1800: printIntUnsigned:	addi 	sp, sp, -4		# Aloca espaco %
00001726 : 00112023;   % 1801: 		sw 	ra, 0(sp)			# salva ra %
00001727 : 0fc1f297;   % 1802: 		la 	t0, TempBuffer			# carrega o Endereco do Buffer da String %
00001728 : a2c28293;   % 1802:  %
00001729 : 00a00393;   % 1804: 		li 	t2, 10				# carrega numero 10 %
0000172a : 00000313;   % 1805: 		li 	t1, 0				# carrega numero de digitos com 0 %
0000172b : 30102c73;   % 1807: <29> csrr s8, misa %
0000172c : 00cc5c13;   % 1807: <30> srli s8, s8, 12 %
0000172d : 001c7c13;   % 1807: <31> andi s8, s8, 0x001 %
0000172e : 160c1463;   % 1807: <32> bnez s8, printIntUnsigned.pula1 %
0000172f : ff010113;   % 1808: <65> addi 	sp, sp, -16 %
00001730 : 00a12023;   % 1808: <66> sw	a0, 0(sp) %
00001731 : 00e12223;   % 1808: <67> sw	a4, 4(sp) %
00001732 : 00f12423;   % 1808: <68> sw	a5, 8(sp) %
00001733 : 00112623;   % 1808: <69> sw	ra, 12(sp) %
00001734 : 00a00533;   % 1808: <70> mv 	a0, a0 %
00001735 : 00155713;   % 1808: <71> srli    a4,a0,1 %
00001736 : 00255793;   % 1808: <72> srli    a5,a0,2 %
00001737 : 00f707b3;   % 1808: <73> add     a5,a4,a5 %
00001738 : 0047d713;   % 1808: <74> srli    a4,a5,4 %
00001739 : 00f70733;   % 1808: <75> add     a4,a4,a5 %
0000173a : 00875793;   % 1808: <76> srli    a5,a4,8 %
0000173b : 00e78733;   % 1808: <77> add     a4,a5,a4 %
0000173c : 01075793;   % 1808: <78> srli    a5,a4,16 %
0000173d : 00e787b3;   % 1808: <79> add     a5,a5,a4 %
0000173e : 0037d793;   % 1808: <80> srli    a5,a5,3 %
0000173f : 00279713;   % 1808: <81> slli    a4,a5,2 %
00001740 : 00f70733;   % 1808: <82> add     a4,a4,a5 %
00001741 : 00171713;   % 1808: <83> slli    a4,a4,1 %
00001742 : 40e50533;   % 1808: <84> sub     a0,a0,a4 %
00001743 : 00a53513;   % 1808: <85> sltiu   a0,a0,10 %
00001744 : 00154513;   % 1808: <86> xori    a0,a0,1 %
00001745 : 00f50533;   % 1808: <87> add     a0,a0,a5 %
00001746 : 04051073;   % 1808: <88> csrw	a0,uscratch %
00001747 : 00012503;   % 1808: <89> lw	a0, 0(sp) %
00001748 : 00412703;   % 1808: <90> lw	a4, 4(sp) %
00001749 : 00812783;   % 1808: <91> lw	a5, 8(sp) %
0000174a : 00c12083;   % 1808: <92> lw	ra, 12(sp) %
0000174b : 01010113;   % 1808: <93> addi 	sp, sp, 16 %
0000174c : 04002ef3;   % 1808: <94> csrr	t4,uscratch %
0000174d : ff010113;   % 1809: <122> addi 	sp,sp,-16 %
0000174e : 00a12023;   % 1809: <123> sw	a0,0(sp) %
0000174f : 00b12223;   % 1809: <124> sw	a1,4(sp) %
00001750 : 00c12423;   % 1809: <125> sw	a2,8(sp) %
00001751 : 00d12623;   % 1809: <126> sw	a3,12(sp) %
00001752 : 00a006b3;   % 1809: <128> mv 	a3,a0 %
00001753 : 00a00613;   % 1809: <129> li 	a2,10 %
00001754 : ff010113;   % 1809: <65> addi 	sp, sp, -16 %
00001755 : 00a12023;   % 1809: <66> sw	a0, 0(sp) %
00001756 : 00e12223;   % 1809: <67> sw	a4, 4(sp) %
00001757 : 00f12423;   % 1809: <68> sw	a5, 8(sp) %
00001758 : 00112623;   % 1809: <69> sw	ra, 12(sp) %
00001759 : 00d00533;   % 1809: <70> mv 	a0, a3 %
0000175a : 00155713;   % 1809: <71> srli    a4,a0,1 %
0000175b : 00255793;   % 1809: <72> srli    a5,a0,2 %
0000175c : 00f707b3;   % 1809: <73> add     a5,a4,a5 %
0000175d : 0047d713;   % 1809: <74> srli    a4,a5,4 %
0000175e : 00f70733;   % 1809: <75> add     a4,a4,a5 %
0000175f : 00875793;   % 1809: <76> srli    a5,a4,8 %
00001760 : 00e78733;   % 1809: <77> add     a4,a5,a4 %
00001761 : 01075793;   % 1809: <78> srli    a5,a4,16 %
00001762 : 00e787b3;   % 1809: <79> add     a5,a5,a4 %
00001763 : 0037d793;   % 1809: <80> srli    a5,a5,3 %
00001764 : 00279713;   % 1809: <81> slli    a4,a5,2 %
00001765 : 00f70733;   % 1809: <82> add     a4,a4,a5 %
00001766 : 00171713;   % 1809: <83> slli    a4,a4,1 %
00001767 : 40e50533;   % 1809: <84> sub     a0,a0,a4 %
00001768 : 00a53513;   % 1809: <85> sltiu   a0,a0,10 %
00001769 : 00154513;   % 1809: <86> xori    a0,a0,1 %
0000176a : 00f50533;   % 1809: <87> add     a0,a0,a5 %
0000176b : 04051073;   % 1809: <88> csrw	a0,uscratch %
0000176c : 00012503;   % 1809: <89> lw	a0, 0(sp) %
0000176d : 00412703;   % 1809: <90> lw	a4, 4(sp) %
0000176e : 00812783;   % 1809: <91> lw	a5, 8(sp) %
0000176f : 00c12083;   % 1809: <92> lw	ra, 12(sp) %
00001770 : 01010113;   % 1809: <93> addi 	sp, sp, 16 %
00001771 : 04002573;   % 1809: <94> csrr	a0,uscratch %
00001772 : ff410113;   % 1809: <45> addi 	sp, sp, -12 %
00001773 : 00a12023;   % 1809: <46> sw	a0, 0(sp) %
00001774 : 00b12223;   % 1809: <47> sw	a1, 4(sp) %
00001775 : 00112423;   % 1809: <48> sw	ra, 8(sp) %
00001776 : 00a00533;   % 1809: <50> mv 	a0, a0 %
00001777 : 00c005b3;   % 1809: <51> mv 	a1, a2 %
00001778 : 094000ef;   % 1809: <52> jal 	__mulsi3 %
00001779 : 04051073;   % 1809: <53> csrw	a0,uscratch %
0000177a : 00012503;   % 1809: <55> lw	a0, 0(sp) %
0000177b : 00412583;   % 1809: <56> lw	a1, 4(sp) %
0000177c : 00812083;   % 1809: <57> lw	ra, 8(sp) %
0000177d : 00c10113;   % 1809: <58> addi 	sp, sp, 12 %
0000177e : 040025f3;   % 1809: <59> csrr	a1,uscratch %
0000177f : 40b68e33;   % 1809: <132> sub 	t3,a3,a1 %
00001780 : 040e1073;   % 1809: <134> csrw	t3,uscratch %
00001781 : 00012503;   % 1809: <135> lw	a0,0(sp) %
00001782 : 00412583;   % 1809: <136> lw 	a1,4(sp) %
00001783 : 00812603;   % 1809: <137> lw	a2,8(sp) %
00001784 : 00c12683;   % 1809: <138> lw	a3,12(sp) %
00001785 : 01010113;   % 1809: <139> addi 	sp,sp,16 %
00001786 : 04002e73;   % 1809: <140> csrr	t3,uscratch %
00001787 : 00c0006f;   % 1810: 			j	printIntUnsigned.pula1d %
00001788 : 02755eb3;   % 1811: printIntUnsigned.pula1:	divu 	t4, a0, t2			# divide por 10 (quociente) %
00001789 : 02757e33;   % 1812: 			remu 	t3, a0, t2			# resto %
0000178a : ffc10113;   % 1813: printIntUnsigned.pula1d:addi 	sp, sp, -4			# aloca espaco na pilha %
0000178b : 01c12023;   % 1814: 		sw 	t3, 0(sp)			# coloca resto na pilha %
0000178c : 01d00533;   % 1815: 		mv 	a0, t4				# atualiza o numero com o quociente %
0000178d : 00130313;   % 1816: 		addi 	t1, t1, 1			# incrementa o contador de digitos %
0000178e : e6051ae3;   % 1817: 		bne 	a0, zero, printIntUnsigned.loop1# verifica se o numero eh zero %
0000178f : 00012383;   % 1819: printIntUnsigned.loop2:	lw 	t2, 0(sp)		# le digito da pilha %
00001790 : 00410113;   % 1820: 		addi 	sp, sp, 4			# libera espaco %
00001791 : 03038393;   % 1821: 		addi 	t2, t2, 48			# converte o digito para ascii %
00001792 : 00728023;   % 1822: 		sb 	t2, 0(t0)			# coloca caractere no buffer %
00001793 : 00128293;   % 1823: 		addi 	t0, t0, 1			# incrementa endereco do buffer %
00001794 : fff30313;   % 1824: 		addi 	t1, t1, -1			# decrementa contador de digitos %
00001795 : fe0314e3;   % 1825: 		bne 	t1, zero, printIntUnsigned.loop2# eh o ultimo? %
00001796 : 00028023;   % 1826: 		sb 	zero, 0(t0)			# insere \NULL na string %
00001797 : 0fc1f517;   % 1828: 		la 	a0, TempBuffer			# Endereco do buffer da srting %
00001798 : 86c50513;   % 1828:  %
00001799 : a18ff0ef;   % 1829: 		jal	printString			# chama o print string %
0000179a : 00012083;   % 1831: 		lw 	ra, 0(sp)			# recupera a %
0000179b : 00410113;   % 1832: 		addi 	sp, sp, 4			# libera espaco %
0000179c : 00008067;   % 1833: printIntUnsigned.fim:	ret %
0000179d : ff410113;   % 1845: __mulsi3:	addi 	sp,sp,-12 %
0000179e : 00b12023;   % 1846: 		sw 	a1,0(sp) %
0000179f : 00e12223;   % 1847: 		sw 	a4,4(sp) %
000017a0 : 00f12423;   % 1848: 		sw	a5,8(sp) %
000017a1 : 00a007b3;   % 1850: 	 	mv      a5,a0 %
000017a2 : 00000513;   % 1851:         	li      a0,0 %
000017a3 : 00078e63;   % 1852: mulsi3.L4: 	beqz    a5,mulsi3.L1 %
000017a4 : 0017f713;   % 1853:         	andi    a4,a5,1 %
000017a5 : 00070463;   % 1854:         	beqz    a4,mulsi3.L3 %
000017a6 : 00b50533;   % 1855:         	add     a0,a0,a1 %
000017a7 : 0017d793;   % 1856: mulsi3.L3: 	srli    a5,a5,1 %
000017a8 : 00159593;   % 1857:         	slli    a1,a1,1 %
000017a9 : fe9ff06f;   % 1858:         	j       mulsi3.L4 %
000017aa : 00012583;   % 1860: mulsi3.L1: 	lw 	a1,0(sp) %
000017ab : 00412703;   % 1861: 		lw	a4,4(sp) %
000017ac : 00812783;   % 1862: 		lw	a5,8(sp) %
000017ad : 00c10113;   % 1863: 		addi 	sp,sp,12 %
000017ae : 00008067;   % 1864: 		ret %
000017af : ff010113;   % 1868: __udivsi3:	addi 	sp,sp,-16 %
000017b0 : 00b12023;   % 1869: 		sw 	a1,0(sp) %
000017b1 : 00d12223;   % 1870: 		sw	a3,4(sp) %
000017b2 : 00e12423;   % 1871: 		sw 	a4,8(sp) %
000017b3 : 00f12623;   % 1872: 		sw	a5,12(sp) %
000017b4 : 00a00733;   % 1874:  		mv      a4,a0 %
000017b5 : 00155693;   % 1875:         	srli    a3,a0,1 %
000017b6 : 00100793;   % 1876:         	li      a5,1 %
000017b7 : 00b6e863;   % 1877: udivsi3.L3:    	bltu    a3,a1,udivsi3.L6 %
000017b8 : 00179793;   % 1878:         	slli    a5,a5,1 %
000017b9 : 00159593;   % 1879:         	slli    a1,a1,1 %
000017ba : ff5ff06f;   % 1880:         	j       udivsi3.L3 %
000017bb : 00000513;   % 1881: udivsi3.L6:    	li      a0,0 %
000017bc : 00078e63;   % 1882: udivsi3.L2:   	beqz    a5,udivsi3.L1 %
000017bd : 00b76663;   % 1883:         	bltu    a4,a1,udivsi3.L5 %
000017be : 40b70733;   % 1884:         	sub     a4,a4,a1 %
000017bf : 00f50533;   % 1885:         	add     a0,a0,a5 %
000017c0 : 0017d793;   % 1886: udivsi3.L5:    	srli    a5,a5,1 %
000017c1 : 0015d593;   % 1887:         	srli    a1,a1,1 %
000017c2 : fe9ff06f;   % 1888:         	j       udivsi3.L2 %
000017c3 : 00012583;   % 1890: udivsi3.L1: 	lw 	a1,0(sp) %
000017c4 : 00412683;   % 1891: 		lw	a3,4(sp) %
000017c5 : 00812703;   % 1892: 		lw	a4,8(sp) %
000017c6 : 00c12783;   % 1893: 		lw	a5,12(sp) %
000017c7 : 01010113;   % 1894: 		addi 	sp,sp,16 %
000017c8 : 00008067;   % 1895:     		ret %
000017c9 : ff410113;   % 1898: __umodsi3:	addi	sp, sp, -12 %
000017ca : 00512023;   % 1899: 		sw 	t0, 0(sp) %
000017cb : 00612223;   % 1900: 		sw 	t1, 4(sp) %
000017cc : 00112423;   % 1901: 		sw 	ra, 8(sp) %
000017cd : 00a002b3;   % 1902: 	 	mv 	t0, a0		# dividendo %
000017ce : 00b00333;   % 1903: 		mv 	t1, a1		# divisor %
000017cf : f81ff0ef;   % 1904: 		jal 	__udivsi3 %
000017d0 : 006005b3;   % 1905: 		mv 	a1, t1		# quociente * divisor %
000017d1 : f31ff0ef;   % 1906: 		jal 	__mulsi3 %
000017d2 : 40a28533;   % 1907: 		sub 	a0, t0, a0	# dividendo-quociente*divisor %
000017d3 : 00012283;   % 1908: 		lw 	t0, 0(sp) %
000017d4 : 00412303;   % 1909: 		lw 	t1, 4(sp) %
000017d5 : 00812083;   % 1910: 		lw 	ra, 8(sp) %
000017d6 : 00c10113;   % 1911: 		addi 	sp, sp, 12 %
000017d7 : 00008067;   % 1912: 		ret %
000017d8 : ff010113;   % 1915: __divsi3:	addi	sp, sp, -16 %
000017d9 : 00512023;   % 1916: 		sw 	t0, 0(sp) %
000017da : 00612223;   % 1917: 		sw 	t1, 4(sp) %
000017db : 00712423;   % 1918: 		sw 	t2, 8(sp) %
000017dc : 00112623;   % 1919: 		sw 	ra, 12(sp) %
000017dd : 41f55293;   % 1920: 		srai	t0,a0,31	# indica se a0 � pos(0) ou neg (2^32-1) %
000017de : 41f5d313;   % 1921: 		srai 	t1,a1,31	# indica se a1 � pos(0) ou neg (2^32-1) %
000017df : 0062c3b3;   % 1922: 		xor	t2,t0,t1	# indica se deve(!=0) ou n�o(==0) inverter o sinal do resultado %
000017e0 : 00028463;   % 1923: 		beqz 	t0,divsi3.pula1 %
000017e1 : 40a00533;   % 1924: 		neg	a0,a0		# nega %
000017e2 : 00030463;   % 1925: divsi3.pula1:	beqz 	t1,divsi3.pula2 %
000017e3 : 40b005b3;   % 1926: 		neg	a1,a1		# nega %
000017e4 : f2dff0ef;   % 1927: divsi3.pula2:	jal 	__udivsi3	# divis�o unsigned %
000017e5 : 00038463;   % 1928: 		beqz	t2, divsi3.pula3	 %
000017e6 : 40a00533;   % 1929: 		neg	a0,a0		# nega %
000017e7 : 00012283;   % 1930: divsi3.pula3:	lw 	t0, 0(sp) %
000017e8 : 00412303;   % 1931: 		lw 	t1, 4(sp) %
000017e9 : 00812383;   % 1932: 		lw 	t2, 8(sp) %
000017ea : 00c12083;   % 1933: 		lw 	ra, 12(sp) %
000017eb : 01010113;   % 1934: 		addi 	sp, sp, 16 %
000017ec : 00008067;   % 1935: 		ret %
000017ed : ff410113;   % 1938: __modsi3:	addi	sp, sp, -12 %
000017ee : 00512023;   % 1939: 		sw 	t0, 0(sp) %
000017ef : 00612223;   % 1940: 		sw 	t1, 4(sp) %
000017f0 : 00112423;   % 1941: 		sw 	ra, 8(sp) %
000017f1 : 41f55293;   % 1942: 		srai	t0,a0,31	# indica se a0 � pos(0) ou neg (2^32-1) %
000017f2 : 41f5d313;   % 1943: 		srai 	t1,a1,31	# indica se a1 � pos(0) ou neg (2^32-1) %
000017f3 : 00028463;   % 1944: 		beqz 	t0,modsi3.pula1 %
000017f4 : 40a00533;   % 1945: 		neg	a0,a0		# nega %
000017f5 : 00030463;   % 1946: modsi3.pula1:	beqz 	t1,modsi3.pula2 %
000017f6 : 40b005b3;   % 1947: 		neg	a1,a1		# nega %
000017f7 : f49ff0ef;   % 1948: modsi3.pula2:	jal 	__umodsi3	# resto unsigned %
000017f8 : 00028463;   % 1949: 		beqz	t0, modsi3.pula3	# sinal do dividendo	 %
000017f9 : 40a00533;   % 1950: 		neg	a0,a0		# nega %
000017fa : 00012283;   % 1951: modsi3.pula3:	lw 	t0, 0(sp) %
000017fb : 00412303;   % 1952: 		lw 	t1, 4(sp) %
000017fc : 00812083;   % 1953: 		lw 	ra, 8(sp) %
000017fd : 00c10113;   % 1954: 		addi 	sp, sp, 12 %
000017fe : 00008067;   % 1955: 		ret																				 %
000017ff : 0fc0a297;   % 12: 	la t0, CURRENT_MAP  # Loads CURRENT_MAP's address %
00001800 : 12828293;   % 12:  %
00001801 : 0052c303;   % 13: 	lbu t1, 5(t0)       # Loads on t1 the CURRENT_MAP's rendering byte %
00001802 : 00200313;   % 14: 	li t1,2 %
00001803 : 00300393;   % 15: 	li t2,3				# Loads number 3 -- related to "switch map" operation %
00001804 : 00734463;   % 16: 	blt t1,t2 CHECK_MAP_MOVE_RENDER_1 # If the rendering byte is 0, 1 or 2 %
00001805 : 00008067;   % 17: 		ret				# If the rendering byte isn't <= 2 %
00001806 : 00030a63;   % 19: 		beqz t1, END_MAP_MOVE_RENDER # If the rendering byte is 0 %
00001807 : 00000513;   % 21: 			li a0, 0	   # in order to render map normally %
00001808 : fff30313;   % 22: 			addi t1,t1,-1  # subtracting 1 from t1 so that if t1 = 2 -> t1 = 1 (will be rendered  %
00001809 : 006282a3;   % 24: 			sb t1,5(t0)	   # Stores the new CURRENT_MAP's rendering byte %
0000180a : 0080006f;   % 25: 			j SCENE_RENDER # Starts scene rendering procedure %
0000180b : 00008067;   % 28: 		ret                %
0000180c : ffc10113;   % 48:     addi sp,sp,-4 %
0000180d : 00112023;   % 49:     sw ra, 0(sp) %
0000180e : 00051c63;   % 51: 	bnez a0, SKIP_SCENE_RENDER_ARGUMENTS # If a0 = 1, the arguments bellow have already been set %
0000180f : 008007b3;   % 53: 		mv a5,s0	# Current frame %
00001810 : 01400813;   % 54: 		li a6, 20	# Screen Width = 20 %
00001811 : 00f00893;   % 55: 		li a7, 15	# Screen Height = 15 %
00001812 : 00000e13;   % 56: 		li t3, 0	# Starting X for rendering (top left, related to Matrix) %
00001813 : 00000393;   % 57: 		li t2, 0	# Starting Y for rendering (top left, related to Matrix) %
00001814 : 0fc0a297;   % 60:     la t0, CURRENT_MAP  # Loads CURRENT_MAP's address %
00001815 : 0d428293;   % 60:  %
00001816 : 0002a503;   % 61:     lw a0, 0(t0) 	# a0 now has the Map Address %
00001817 : 0062c583;   % 63:     lbu a1, 6(t0)   # Loads current X on Map (starting X on Matrix (top left)) %
00001818 : 0072c603;   % 64:     lbu a2, 7(t0)   # Loads current Y on Map (starting Y on Matrix (top left))	 %
00001819 : 0082c683;   % 65:     lbu a3, 8(t0)   # Loads current X offset on Map %
0000181a : 0092c703;   % 66:     lbu a4, 9(t0)   # Loads current Y offset on Map %
0000181b : 00000213;   % 67: 	li tp, 0        # Map won't be dislocated %
0000181c : ffffc317;   % 69: 	call RENDER_MAP %
0000181d : 190300e7;   % 69:  %
0000181e : 00012083;   % 72: 	lw ra, 0(sp) %
0000181f : 00410113;   % 73:     addi sp,sp,4 %
00001820 : 00008067;   % 75:     ret %
00001821 : 0fc0a317;   % 91: 	la t1, NEXT_MAP  # Gets NEXT_MAP address %
00001822 : 0ac30313;   % 91:  %
00001823 : 0fc0af17;   % 92: 	la t5, CURRENT_MAP  # Gets CURRENT_MAP address %
00001824 : 098f0f13;   % 92:  %
00001825 : 00254383;   % 93: 	lbu t2,2(a0)     # Gets next map's number %
00001826 : 00730223;   % 94: 	sb t2,4(t1)      # and stores it in NEXT_MAP %
00001827 : 00354e03;   % 95: 	lbu t3,3(a0)     # Gets next map's door number %
00001828 : 01c304a3;   % 96: 	sb t3,9(t1)      # and stores it in NEXT_MAP %
00001829 : 002e1e13;   % 97: 	slli t3,t3,2     # t3 has the number of bytes to be skipped after finding door address %
0000182a : 001e0e13;   % 98: 	addi t3,t3,1     # t3 has the number of bytes to be skipped after finding door address and skiping number of doors byte %
0000182b : 00100293;   % 101: 	li t0, 1  %
0000182c : 04729463;   % 102:     bne t0, t2, SKIP_NEXT_MAP1  %
0000182d : 0fc0e297;   % 103: 		la t0, Map1   # If next map is Map1 %
0000182e : a8028293;   % 103:  %
0000182f : 00532023;   % 104: 		sw t0,0(t1)   # Store it into NEXT_MAP %
00001830 : 0fc0a397;   % 105: 		la t2,Doors1  # Gets Doors1 address  %
00001831 : 3e438393;   % 105:  %
00001832 : 0fc0ae97;   % 107: 		la t4,Zoomers_Next   # Zoomers address %
00001833 : 184e8e93;   % 107:  %
00001834 : 0fc0a217;   % 108: 		la tp,Zoomers1       # Loads Zoomers1 address for Map 1 %
00001835 : 18020213;   % 108:  %
00001836 : 004ea023;   % 109: 		sw tp,0(t4)          # and stores it %
00001837 : 0fc0ae97;   % 111: 		la t4,Rippers_Next   # Rippers address %
00001838 : 330e8e93;   % 111:  %
00001839 : 000ea023;   % 112: 		sw zero,0(t4)   # Stores 0 to it (no rippers) %
0000183a : 0fc0ae97;   % 114: 		la t4,Blocks_Next    # Blocks address %
0000183b : 134e8e93;   % 114:  %
0000183c : 000ea023;   % 115: 		sw zero,0(t4)        # there are no blocks in this map %
0000183d : 1e00006f;   % 117:     	j CONTINUE_CHANGE_MAP %
0000183e : 00200293;   % 119:         li t0, 2  %
0000183f : 04729c63;   % 120:         bne t0, t2, SKIP_NEXT_MAP2  %
00001840 : 0fc0e297;   % 121: 			la t0, Map2   # If next map is Map2 %
00001841 : dbb28293;   % 121:  %
00001842 : 00532023;   % 122: 			sw t0,0(t1)   # Store it into NEXT_MAP %
00001843 : 0fc0ae97;   % 124: 			la t4,Zoomers_Next   # Zoomers address %
00001844 : 140e8e93;   % 124:  %
00001845 : 0fc0a217;   % 125: 			la tp,Zoomers2       # Loads Zoomers2 address for Map 2 %
00001846 : 18520213;   % 125:  %
00001847 : 004ea023;   % 126: 			sw tp,0(t4)          # and stores it %
00001848 : 0fc0ae97;   % 128: 			la t4,Rippers_Next   # Rippers address %
00001849 : 2ece8e93;   % 128:  %
0000184a : 0fc0a217;   % 129: 			la tp,Rippers2       # Loads Rippers2 address for Map 2 %
0000184b : 2e820213;   % 129:  %
0000184c : 004ea023;   % 130: 			sw tp,0(t4)          # and stores it %
0000184d : 0fc0ae97;   % 132: 			la t4,Blocks_Next    # Blocks address %
0000184e : 0e8e8e93;   % 132:  %
0000184f : 0fc0a217;   % 133: 			la tp,Blocks2   # Loads Blocks2 address for Map 2 %
00001850 : 0e420213;   % 133:  %
00001851 : 004ea023;   % 134: 			sw tp,0(t4)     # and stores it %
00001852 : 0fc0a397;   % 136: 			la t2,Doors2  # Gets Doors2 address  %
00001853 : 36138393;   % 136:  %
00001854 : 1840006f;   % 137: 			j CONTINUE_CHANGE_MAP %
00001855 : 00300293;   % 140:         li t0, 3  %
00001856 : 04729463;   % 141:         bne t0, t2, SKIP_NEXT_MAP3  %
00001857 : 0fc0e297;   % 142: 			la t0, Map3   # If next map is Map3 %
00001858 : 0e628293;   % 142:  %
00001859 : 00532023;   % 143: 			sw t0,0(t1)   # Store it into NEXT_MAP %
0000185a : 0fc0a397;   % 144: 			la t2,Doors3  # Gets Doors3 address  %
0000185b : 34e38393;   % 144:  %
0000185c : 0fc0ae97;   % 146: 			la t4,Zoomers_Next   # Zoomers address %
0000185d : 0dce8e93;   % 146:  %
0000185e : 0fc0a217;   % 147: 			la tp,Zoomers3       # Loads Zoomers3 address for Map 3 %
0000185f : 18e20213;   % 147:  %
00001860 : 004ea023;   % 148: 			sw tp,0(t4)          # and stores it %
00001861 : 0fc0ae97;   % 150: 			la t4,Rippers_Next   # Rippers address %
00001862 : 288e8e93;   % 150:  %
00001863 : 000ea023;   % 151: 			sw zero,0(t4)   # Stores 0 to it (no rippers) %
00001864 : 0fc0ae97;   % 153: 			la t4,Blocks_Next    # Blocks address %
00001865 : 08ce8e93;   % 153:  %
00001866 : 000ea023;   % 154: 			sw zero,0(t4)        # there are no blocks in this map %
00001867 : 1380006f;   % 156: 			j CONTINUE_CHANGE_MAP %
00001868 : 00400293;   % 159:         li t0, 4   %
00001869 : 04729863;   % 160:         bne t0, t2, SKIP_NEXT_MAP4  %
0000186a : 0fc0e297;   % 161: 			la t0, Map4   # If next map is Map4 %
0000186b : 42128293;   % 161:  %
0000186c : 00532023;   % 162: 			sw t0,0(t1)   # Store it into NEXT_MAP %
0000186d : 0fc0a397;   % 163: 			la t2,Doors4  # Gets Doors4 address   %
0000186e : 30b38393;   % 163:  %
0000186f : 0fc0ae97;   % 165: 			la t4,Zoomers_Next   # Zoomers address %
00001870 : 090e8e93;   % 165:  %
00001871 : 0fc0a217;   % 166: 			la tp,Zoomers4       # Loads Zoomers4 address for Map 4 %
00001872 : 18b20213;   % 166:  %
00001873 : 004ea023;   % 167: 			sw tp,0(t4)          # and stores it %
00001874 : 0fc0ae97;   % 169: 			la t4,Rippers_Next   # Rippers address %
00001875 : 23ce8e93;   % 169:  %
00001876 : 0fc0a217;   % 170: 			la tp,Rippers4       # Loads Rippers4 address for Map 4 %
00001877 : 25c20213;   % 170:  %
00001878 : 004ea023;   % 171: 			sw tp,0(t4)          # and stores it %
00001879 : 0fc0ae97;   % 173: 			la t4,Blocks_Next    # Blocks address %
0000187a : 038e8e93;   % 173:  %
0000187b : 000ea023;   % 174: 			sw zero,0(t4)        # there are no blocks in this map %
0000187c : 0e40006f;   % 176: 			j CONTINUE_CHANGE_MAP %
0000187d : 00500293;   % 179:         li t0, 5  %
0000187e : 04729463;   % 180:         bne t0, t2, SKIP_NEXT_MAP5  %
0000187f : 0fc0e297;   % 181: 			la t0, Map5   # If next map is Map5 %
00001880 : 75428293;   % 181:  %
00001881 : 00532023;   % 182: 			sw t0,0(t1)   # Store it into NEXT_MAP %
00001882 : 0fc0a397;   % 183: 			la t2,Doors5  # Gets Doors5 address   %
00001883 : 2c038393;   % 183:  %
00001884 : 0fc0ae97;   % 185: 			la t4,Zoomers_Next   # Zoomers address %
00001885 : 03ce8e93;   % 185:  %
00001886 : 0fc0a217;   % 186: 			la tp,Zoomers5       # Loads Zoomers5 address for Map 5 %
00001887 : 1bc20213;   % 186:  %
00001888 : 004ea023;   % 187: 			sw tp,0(t4)          # and stores it %
00001889 : 0fc0ae97;   % 189: 			la t4,Rippers_Next   # Rippers address %
0000188a : 1e8e8e93;   % 189:  %
0000188b : 000ea023;   % 190: 			sw zero,0(t4)   # Stores 0 to it (no rippers) %
0000188c : 0fc0ae97;   % 192: 			la t4,Blocks_Next    # Blocks address %
0000188d : fece8e93;   % 192:  %
0000188e : 000ea023;   % 193: 			sw zero,0(t4)        # there are no blocks in this map %
0000188f : 0980006f;   % 195: 			j CONTINUE_CHANGE_MAP %
00001890 : 00600293;   % 198:         li t0, 6 %
00001891 : 04729063;   % 199:         bne t0, t2, SKIP_NEXT_MAP6 %
00001892 : 0fc0f297;   % 200: 			la t0, Map6   # If next map is Map6 %
00001893 : 96328293;   % 200:  %
00001894 : 00532023;   % 201: 			sw t0,0(t1)   # Store it into NEXT_MAP %
00001895 : 0fc0a397;   % 202: 			la t2,Doors6  # Gets Doors6 address   %
00001896 : 27d38393;   % 202:  %
00001897 : 0fc0ae97;   % 204: 			la t4,Zoomers_Next   # Zoomers address %
00001898 : ff0e8e93;   % 204:  %
00001899 : 000ea023;   % 205: 			sw zero,0(t4)          # and stores it %
0000189a : 0fc0ae97;   % 207: 			la t4,Rippers_Next   # Rippers address %
0000189b : 1a4e8e93;   % 207:  %
0000189c : 000ea023;   % 208: 			sw zero,0(t4)   # Stores 0 to it (no rippers) %
0000189d : 0fc0ae97;   % 210: 			la t4,Blocks_Next    # Blocks address %
0000189e : fa8e8e93;   % 210:  %
0000189f : 000ea023;   % 211: 			sw zero,0(t4)        # there are no blocks in this map %
000018a0 : 0540006f;   % 213: 			j CONTINUE_CHANGE_MAP %
000018a1 : 00700293;   % 216: 		li t0, 7  %
000018a2 : 04729063;   % 217: 		bne t0, t2, SKIP_NEXT_MAP7  %
000018a3 : 0fc0f297;   % 218: 			la t0, Map7   # If next map is Map7 %
000018a4 : a4e28293;   % 218:  %
000018a5 : 00532023;   % 219: 			sw t0,0(t1)   # Store it into NEXT_MAP %
000018a6 : 0fc0a397;   % 220: 			la t2,Doors7  # Gets Doors7 address  %
000018a7 : 23e38393;   % 220:  %
000018a8 : 0fc0ae97;   % 222: 			la t4,Zoomers_Next   # Zoomers address %
000018a9 : face8e93;   % 222:  %
000018aa : 000ea023;   % 223: 			sw zero,0(t4)          # and stores it %
000018ab : 0fc0ae97;   % 225: 			la t4,Rippers_Next   # Rippers address %
000018ac : 160e8e93;   % 225:  %
000018ad : 000ea023;   % 226: 			sw zero,0(t4)   # Stores 0 to it (no rippers) %
000018ae : 0fc0ae97;   % 228: 			la t4,Blocks_Next    # Blocks address %
000018af : f64e8e93;   % 228:  %
000018b0 : 000ea023;   % 229: 			sw zero,0(t4)        # there are no blocks in this map %
000018b1 : 0100006f;   % 231: 			j CONTINUE_CHANGE_MAP %
000018b2 : fe010113;   % 235: 		addi sp,sp,-32  # Restoring unchanged %
000018b3 : 00000513;   % 236: 		li a0,0         # Player won't be able to move %
000018b4 : 8f8fb06f;   % 237: 		j ERROR_ON_SWITCH %
000018b5 : 02010113;   % 240: 	addi sp,sp,32    # Freeing stack since it won't return to Physics %
000018b6 : 0012ce83;   % 242: 	lbu t4,1(t0)     # Gets next map's width %
000018b7 : 0fc0a297;   % 244: 	la t0, Doors_Next # Gets Next Doors	address %
000018b8 : 1c428293;   % 244:  %
000018b9 : 0072a023;   % 245: 	sw t2,0(t0)       # and stores t2 (the DoorsA address) in it %
000018ba : 007e03b3;   % 247: 	add t2,t3,t2     # t2 has the address of destination door (DoorsA) %
000018bb : 0013c283;   % 248: 	lbu t0,1(t2)     # Gets door's Y %
000018bc : ffb28293;   % 249: 	addi t0,t0,-5    # Gets screen's matrix top left Y %
000018bd : 005303a3;   % 250: 	sb t0,7(t1)      # Stores Y on NEXT_MAP %
000018be : 000302a3;   % 252: 	sb zero,5(t1)    # Number of iterations %
000018bf : 00054e03;   % 253: 	lbu t3,0(a0)     # Loads door frame's current X position %
000018c0 : 000e0e63;   % 254: 	beqz t3, SWITCH_TOWARDS_LEFT  # If door frame is on the left (t3 = 0), next map is on the left %
000018c1 : 000f0523;   % 256: 		sb zero,10(t5)    # Stores 0 in the X dislocation for current map %
000018c2 : 000f05a3;   % 257: 		sb zero,11(t5)    # Stores switch direction (next map is on the right) %
000018c3 : 00030323;   % 258: 		sb zero,6(t1)     # Stores furthest X to the left of next map (0) on NEXT_MAP %
000018c4 : 01400293;   % 259: 		li t0, 20 # Gets screen width in tiles (20) %
000018c5 : 00530423;   % 260: 		sb t0,8(t1)           # and stores it in X dislocation for the next map  %
000018c6 : 01c0006f;   % 261: 		j ENTER_DOOR_ANIMATION_PREP %
000018c7 : 00100293;   % 263: 		li t0 1        # Direction is loaded by t0 %
000018c8 : 005f05a3;   % 264: 		sb t0,11(t5)   # and stored (next map is on the left) %
000018c9 : 005f0523;   % 265: 		sb t0,10(t5)   # Stores 1 in the X dislocation for current map %
000018ca : fffe8e93;   % 266: 		addi t4,t4,-1  # Subtracts 1 from map's width %
000018cb : 01d30323;   % 267: 		sb t4,6(t1)    # and stores the result as the X on NEXT_MAP %
000018cc : 00030423;   % 268: 		sb zero,8(t1)  # Stores 0 in the X dislocation for next map  %
000018cd : 0fc0a297;   % 285: 	la t0, PLYR_INPUT %
000018ce : e1f28293;   % 285:  %
000018cf : 00000393;   % 286: 	li t2, 0   # There isn't input %
000018d0 : 00728023;   % 287: 	sb t2, 0(t0)  %
000018d1 : 0fc0a297;   % 289: 	la t0, PLYR_STATUS      # Loads Player Status %
000018d2 : e0628293;   % 289:  %
000018d3 : 00000313;   % 290: 	li t1, 0        # Loads vertical direction (0 = normal) %
000018d4 : 00628123;   % 291: 	sb t1, 2(t0)    # Stores new direction on PLYR_STATUS %
000018d5 : 006282a3;   % 293: 	sb t1, 5(t0)                   %
000018d6 : 00028323;   % 294: 	sb zero, 6(t0)  # Stores new direction on MOVE_X %
000018d7 : 00144413;   % 296: 	xori s0,s0,1   # Switches frame value (register)										 %
000018d8 : 00100513;   % 297: 	li a0, 1       # Rendering player's trail operation %
000018d9 : 00000593;   % 298: 	li a1, 0       # Rendering full player (a1 doesn't really matter when a0 = 1) %
000018da : ffffb317;   % 299: 	call RENDER_PLAYER %
000018db : 6e0300e7;   % 299:  %
000018dc : c01022f3;   % 303: 	csrr t0,3073                       # Gets current time %
000018dd : 409282b3;   % 304:     sub t0, t0, s1                     # t0 = current time - last frame's time %
000018de : 03200313;   % 305:     li t1, 50                  # Loads frame rate (time (in ms) per frame) %
000018df : fe62eae3;   % 306:     bltu t0,t1, ENTER_DOOR_ANIMATION  # While t0 < minimum time for a frame, keep looping  %
000018e0 : 00144413;   % 308: 	xori s0,s0,1		    # Switches frame value (register) %
000018e1 : 0fc0a297;   % 310: 	la t0, MOVE_Y  # Loads MOVE_Y %
000018e2 : dcd28293;   % 310:  %
000018e3 : 00028283;   % 311: 	lb t0,0(t0)    # and gets its value  %
000018e4 : 02028463;   % 312: 	beqz t0,ENTER_DOOR_ANIMATION_MOVE_PLAYER # If player is on the ground, go to ENTER_DOOR_ANIMATION_MOVE_PLAYER %
000018e5 : ffffb317;   % 314: 		call PHYSICS            # Physics operations %
000018e6 : f60300e7;   % 314:  %
000018e7 : 00000317;   % 315: 		call UPDATE_STATUS      # Updates player's sprite status %
000018e8 : 5a0300e7;   % 315:  %
000018e9 : 00000513;   % 317: 		li a0, 0     # Rendering player operation %
000018ea : 00000593;   % 318: 		li a1, 0     # Rendering full player %
000018eb : ffffb317;   % 319: 		call RENDER_PLAYER %
000018ec : 69c300e7;   % 319:  %
000018ed : 0900006f;   % 320: 		j CONTINUE_ENTER_DOOR_ANIMATION %
000018ee : 0fc0a297;   % 322: 		la t0, CURRENT_MAP   # Loads CURRENT_MAP's address %
000018ef : d6c28293;   % 322:  %
000018f0 : 0fc0a317;   % 323: 		la t1, PLYR_POS   # Loads PLYR_POS's address %
000018f1 : d7e30313;   % 323:  %
000018f2 : 00b2c383;   % 324: 		lbu t2,11(t0)        # Loads switch direction %
000018f3 : 04038063;   % 325: 		beqz t2, ENTER_DOOR_ANIMATION_NEXT_ON_RIGHT # If next map is on the right, go to ENTER_DOOR_ANIMATION_NEXT_ON_RIGHT %
000018f4 : 00031283;   % 327: 			lh t0,0(t1)   # Gets player's current X related to screen %
000018f5 : 00531123;   % 328: 			sh t0,2(t1)   # Stores it on old X %
000018f6 : ffc28293;   % 330: 			addi t0,t0,-4  # Adds 4 to player's X %
000018f7 : 00531023;   % 331: 			sh t0,0(t1)   # Stores new X %
000018f8 : 0fc0a297;   % 333: 			la t0, MOVE_X  # Loads MOVE_X %
000018f9 : d7028293;   % 333:  %
000018fa : fff00313;   % 334: 			li t1,-1       # Loads direction (left) %
000018fb : 00628023;   % 335: 			sb t1,0(t0)    # Stores on MOVE_X %
000018fc : 00000317;   % 336: 			call UPDATE_STATUS      # Updates player's sprite status %
000018fd : 54c300e7;   % 336:  %
000018fe : 00000513;   % 338: 			li a0, 0     # Rendering player operation %
000018ff : 00200593;   % 339: 			li a1, 2     # Rendering player's 16 rightmost pixels %
00001900 : ffffb317;   % 340: 			call RENDER_PLAYER %
00001901 : 648300e7;   % 340:  %
00001902 : 03c0006f;   % 341: 			j CONTINUE_ENTER_DOOR_ANIMATION %
00001903 : 00031283;   % 344: 			lh t0,0(t1)   # Gets player's current X related to screen %
00001904 : 00531123;   % 345: 			sh t0,2(t1)   # Stores it on old X %
00001905 : 00428293;   % 347: 			addi t0,t0,4  # Adds 4 to player's X %
00001906 : 00531023;   % 348: 			sh t0,0(t1)   # Stores new X %
00001907 : 0fc0a297;   % 350: 			la t0, MOVE_X  # Loads MOVE_X %
00001908 : d3428293;   % 350:  %
00001909 : 00100313;   % 351: 			li t1,1        # Loads direction (right) %
0000190a : 00628023;   % 352: 			sb t1,0(t0)    # Stores on MOVE_X %
0000190b : 00000317;   % 353: 			call UPDATE_STATUS      # Updates player's sprite status %
0000190c : 510300e7;   % 353:  %
0000190d : 00000513;   % 355: 			li a0, 0     # Rendering player operation %
0000190e : 00100593;   % 356: 			li a1, 1     # Rendering player's 16 leftmost pixels %
0000190f : ffffb317;   % 357: 			call RENDER_PLAYER %
00001910 : 60c300e7;   % 357:  %
00001911 : ffffc317;   % 360: 	call RENDER_DOOR_FRAMES	 %
00001912 : ca8300e7;   % 360:  %
00001913 : ff2002b7;   % 363: 	li t0,0xFF200604	# Loads Bitmap Display address %
00001914 : 60428293;   % 363:  %
00001915 : 0082a023;   % 364: 	sw s0,0(t0)         # Stores new frame value (from s0) on Bitmap Display %
00001916 : 00100513;   % 366: 	li a0, 1     # Rendering player's trail operation %
00001917 : 00000593;   % 367: 	li a1, 0     # Rendering full player (a1 doesn't really matter when a0 = 1) %
00001918 : ffffb317;   % 368: 	call RENDER_PLAYER %
00001919 : 5e8300e7;   % 368:  %
0000191a : ffffc317;   % 370: 	call RENDER_UI %
0000191b : 980300e7;   % 370:  %
0000191c : 0fc0a297;   % 374: 	la t0, MOVE_Y  # Loads MOVE_Y %
0000191d : ce128293;   % 374:  %
0000191e : 00028283;   % 375: 	lb t0,0(t0)    # and gets its value  %
0000191f : 04029c63;   % 376: 	bnez t0,CONTINUE_ENTER_DOOR_ANIMATION_2 # If player is on the ground, go to CONTINUE_ENTER_DOOR_ANIMATION_2 %
00001920 : 0fc0a297;   % 377: 		la t0, CURRENT_MAP   # Loads CURRENT_MAP's address %
00001921 : ca428293;   % 377:  %
00001922 : 0fc0a317;   % 378: 		la t1, PLYR_POS      # Loads PLYR_POS's address		 %
00001923 : cb630313;   % 378:  %
00001924 : 00a30383;   % 379: 		lb t2,10(t1)         # Gets player's current Y related to matrix %
00001925 : 007305a3;   % 380: 		sb t2,11(t1)         # Stores it on old Y related to matrix %
00001926 : 00b2c383;   % 381: 		lbu t2,11(t0)        # Loads switch direction %
00001927 : 00038c63;   % 382: 		beqz t2, ENTER_DOOR_ANIMATION_NEXT_ON_RIGHT_2 # If next map is on the right, go to ENTER_DOOR_ANIMATION_NEXT_ON_RIGHT_2 %
00001928 : 00031383;   % 384: 			lh t2,0(t1)           # Gets player's current X related to screen %
00001929 : 02039863;   % 385: 			bnez,t2,CONTINUE_ENTER_DOOR_ANIMATION_2  # If player's current X = !0, continue loop %
0000192a : 00400313;   % 387: 				li t1,4           # X Offset for map %
0000192b : 00628423;   % 388: 				sb t1,8(t0)       # storing X offset for map %
0000192c : 02c0006f;   % 389: 				j SWITCH_MAP_PREP  %
0000192d : 00031e03;   % 392: 			lh t3,0(t1)           # Gets player's current X related to screen %
0000192e : 14000313;   % 393: 			li t1,320    # Loads 320 %
0000192f : 01000393;   % 394: 			li t2,16       # Loads 16 %
00001930 : 40730333;   % 395: 			sub t1,t1,t2          # t1 = 304	 %
00001931 : 01c31863;   % 396: 			bne t1,t3,CONTINUE_ENTER_DOOR_ANIMATION_2  # If player's current X != 304, continue loop %
00001932 : 00c00313;   % 398: 				li t1,12          # X Offset for map %
00001933 : 00628423;   % 399: 				sb t1,8(t0)       # storing X offset for map %
00001934 : 00c0006f;   % 400: 				j SWITCH_MAP_PREP   %
00001935 : c01024f3;   % 402: 		csrr s1,3073    # new time is stored in s1, in order to be compared later		 %
00001936 : e99ff06f;   % 404: 		j ENTER_DOOR_ANIMATION	# Returns to beginning of loop %
00001937 : 00100513;   % 420: 	li a0,1   # Close doors %
00001938 : 00100593;   % 421: 	li a1,1   # Close them fast    :) %
00001939 : ffffb317;   % 422: 	call CHANGE_DOORS_STATE %
0000193a : d70300e7;   % 422:  %
0000193b : 0fc0a317;   % 424: 	la t1,NEXT_MAP %
0000193c : c4430313;   % 424:  %
0000193d : 00100393;   % 425: 	li t2,1 %
0000193e : 00730523;   % 426: 	sb t2,10(t1)      # Loads render Next Map's %
0000193f : ffffd317;   % 428: 	call RESET_ENEMIES %
00001940 : 598300e7;   % 428:  %
00001941 : 0fc0a317;   % 430: 	la t1,NEXT_MAP %
00001942 : c2c30313;   % 430:  %
00001943 : 00030523;   % 431: 	sb zero,10(t1)      # Loads render Next Map's %
00001944 : 0fc0a297;   % 434: 	la t0,CURRENT_MAP %
00001945 : c1428293;   % 434:  %
00001946 : 00300393;   % 435: 	li t2,3 %
00001947 : 007282a3;   % 436: 	sb t2,5(t0) %
00001948 : c01022f3;   % 440: 	csrr t0,3073 %
00001949 : 409282b3;   % 441:     sub t0, t0, s1 #  # a0 = current time - last frame's time %
0000194a : 03200313;   % 442:     li t1, 50       # Loads frame rate (time (in ms) per frame) %
0000194b : fe62eae3;   % 443:     bltu t0,t1, SWITCH_MAP  # While a0 < minimum time for a frame, keep looping  %
0000194c : 00144413;   % 446: 	xori s0,s0,1			# inverts frame value %
0000194d : 0fc0a317;   % 449: 	la t1, NEXT_MAP         # Gets NEXT_MAP address %
0000194e : bfc30313;   % 449:  %
0000194f : 00030523;   % 450: 	sb zero,10(t1)          # Stores 0 on Render Next Map Door (in order to render doors properly) %
00001950 : 00534303;   % 451: 	lbu t1,5(t1)            # Gets number of iterations so far %
00001951 : 01400813;   % 452: 	li a6, 20 	# Screen Width = 20     # width (Related to Matrix) of rendering area %
00001952 : 15035c63;   % 453: 	bge t1,a6,END_OF_SWITCH_MAP %
00001953 : 0fc0a297;   % 457: 		la t0, CURRENT_MAP      # Gets CURRENT_MAP address %
00001954 : bd828293;   % 457:  %
00001955 : 0002a503;   % 458: 		lw a0,0(t0)	            # Loads Current Map's address %
00001956 : 0072c603;   % 459: 		lbu a2, 7(t0)           # Loads current Y on Map (starting Y on Matrix (top left))	 %
00001957 : 0082c683;   % 460: 		lbu a3, 8(t0)           # Loads current X offset on Map %
00001958 : 00000713;   % 461: 		li a4,0                 # Y offset will always be 0 during transition %
00001959 : 008007b3;   % 462: 		mv a5,s0	            # Current frame %
0000195a : 00f00893;   % 463: 		li a7, 15	# Screen Height = 15    # height (Related to Matrix) of rendering area %
0000195b : 00000e13;   % 464: 		li t3, 0	            # Starting X for rendering (top left, related to Matrix) %
0000195c : 00000393;   % 465: 		li t2, 0	            # Starting Y for rendering (top left, related to Matrix) %
0000195d : 0062c583;   % 467: 		lbu a1, 6(t0)           # Loads current X on Map (starting X on Matrix (top left)) %
0000195e : 00a2c203;   % 468: 		lbu tp,10(t0)           # X dislocation related to CURRENT_MAP %
0000195f : 00b2ce83;   % 469: 		lbu t4,11(t0)           # Loads switch direction %
00001960 : 020e8063;   % 470: 		beqz t4, SWITCH_MAP_CURRENT_ON_LEFT  # If next map is on the right, current map is on the left %
00001961 : 00300e93;   % 472: 			li t4,3             # Loads 3 for holding comparision %
00001962 : 00deaeb3;   % 473: 			slt t4,t4,a3        # Sets t4 to 1 if X offset isn't 0 (in this case, if X offset < 4, X offset = 0) %
00001963 : 40680833;   % 474: 			sub a6,a6,t1       # Screen Width = Number of iterations (X offset = 0) or Number of iterations + 1 (X offset != 0) %
00001964 : 00620233;   % 475: 			add tp,tp,t1        # Gets dislocation by adding the number of iterations from it %
00001965 : ffffc317;   % 476: 			call RENDER_MAP %
00001966 : c6c300e7;   % 476:  %
00001967 : 0100006f;   % 477: 			j SWITCH_MAP_NEXT %
00001968 : 006585b3;   % 479: 			add a1,a1,t1            # Changes X %
00001969 : ffffc317;   % 481: 			call RENDER_MAP %
0000196a : c5c300e7;   % 481:  %
0000196b : 0fc0a297;   % 485: 		la t0, CURRENT_MAP      # Gets CURRENT_MAP address %
0000196c : b7828293;   % 485:  %
0000196d : 0fc0a317;   % 486: 		la t1, NEXT_MAP         # Gets NEXT_MAP address %
0000196e : b7c30313;   % 486:  %
0000196f : 00100393;   % 487: 		li t2,1                 # Loads 1 in order to render Next Map's Door %
00001970 : 00730523;   % 488: 		sb t2,10(t1)            # Stores 1 on Render Next Map Door %
00001971 : 00032503;   % 490: 		lw a0,0(t1)	            # Loads Next Map's address %
00001972 : 00734603;   % 491: 		lbu a2, 7(t1)           # Loads current Y on Map (starting Y on Matrix (top left))	 %
00001973 : 0082c683;   % 492: 		lbu a3, 8(t0)           # Loads current X offset on Map %
00001974 : 00000713;   % 493: 		li a4,0                 # Y offset will always be 0 during transition %
00001975 : 008007b3;   % 494: 		mv a5,s0	            # Current frame %
00001976 : 00f00893;   % 495: 		li a7, 15	# Screen Height = 15    # height (Related to Matrix) of rendering area %
00001977 : 00000e13;   % 496: 		li t3, 0	            # Starting X for rendering (top left, related to Matrix) %
00001978 : 00000393;   % 497: 		li t2, 0	            # Starting Y for rendering (top left, related to Matrix) %
00001979 : 00634583;   % 500: 		lbu a1, 6(t1)           # Loads current X on Map (starting X on Matrix (top left)) %
0000197a : 00834203;   % 501: 		lbu tp,8(t1)            # X dislocation related to CURRENT_MAP %
0000197b : 00b2ce83;   % 502: 		lbu t4,11(t0)           # Loads switch direction %
0000197c : 00534f03;   % 503: 		lbu t5,5(t1)            # Gets number of iterations so far		 %
0000197d : 020e8063;   % 504: 		beqz t4, SWITCH_MAP_NEXT_ON_RIGHT  # If next map is on the right %
0000197e : 41e585b3;   % 506: 			sub a1,a1,t5        # Changes X %
0000197f : 01400e93;   % 507: 			li t4,20            # Loads 3 for holding comparision %
00001980 : 01df2eb3;   % 508: 			slt t4,t5,t4        # Sets t4 to 1 if number of iterations is less than 19 %
00001981 : 01df0833;   % 509: 			add a6,t5,t4        # Screen Width = Number of iterations (if it's equal to 19) or Number of iterations + 1 (if it's < 19) %
00001982 : ffffc317;   % 511: 			call RENDER_MAP %
00001983 : bf8300e7;   % 511:  %
00001984 : 0200006f;   % 512: 			j SWITCH_MAP_CONTINUE %
00001985 : 00300e93;   % 514: 			li t4,3             # Loads 3 for holding comparision %
00001986 : 00deaeb3;   % 515: 			slt t4,t4,a3        # Sets t4 to 1 if X offset isn't 0 (in this case, if X offset < 4, X offset = 0) %
00001987 : 01df0833;   % 516: 			add a6,t5,t4        # Screen Width = Number of iterations (X offset = 0) or Number of iterations + 1 (X offset != 0) %
00001988 : 00834203;   % 517: 			lbu tp,8(t1)        # X dislocation related to CURRENT_MAP %
00001989 : 41e20233;   % 518: 			sub tp,tp,t5        # Gets dislocation by subtracting the number of iterations from it %
0000198a : ffffc317;   % 519: 			call RENDER_MAP %
0000198b : bd8300e7;   % 519:  %
0000198c : ffffb317;   % 523: 	call UPDATE_DOORS       # Updates doors %
0000198d : b64300e7;   % 523:  %
0000198e : ff2002b7;   % 526: 	li t0,0xFF200604		# carrega em t0 o endereco de troca de frame %
0000198f : 60428293;   % 526:  %
00001990 : 0082a023;   % 527: 	sw s0,0(t0) %
00001991 : ffffb317;   % 529: 	call RENDER_UI %
00001992 : 7a4300e7;   % 529:  %
00001993 : 0fc0a297;   % 533: 	la t0, CURRENT_MAP      # Gets CURRENT_MAP address	 %
00001994 : ad828293;   % 533:  %
00001995 : 0fc0a317;   % 534: 	la t1, NEXT_MAP         # Gets NEXT_MAP address %
00001996 : adc30313;   % 534:  %
00001997 : 00b2ce03;   % 535: 	lbu t3,11(t0)           # Loads switch direction %
00001998 : 0082c383;   % 536: 	lbu t2, 8(t0)           # Loads current X offset  %
00001999 : 000e0a63;   % 538: 	beqz t3, SWITCH_MAP_OFFSET_RIGHT # If next map is on the right %
0000199a : ffc38393;   % 540: 		addi t2,t2,-4   # decrease offset by 4  %
0000199b : 0203d463;   % 542: 		bge t2, zero, SWITCH_MAP_AFTER_OFFSET_OPERATION %
0000199c : 01038393;   % 544: 			addi t2,t2,16 # Corrects negative offset by adding 16 %
0000199d : 0140006f;   % 545: 			j SWITCH_MAP_ITERATE # iterates procedure  %
0000199e : 00438393;   % 547: 		addi t2,t2,4      # increase offset by 4  %
0000199f : 01000e13;   % 548: 		li t3,16   # loads 16 for operations %
000019a0 : 01c3ca63;   % 550: 		blt t2, t3, SWITCH_MAP_AFTER_OFFSET_OPERATION  %
000019a1 : 41c383b3;   % 552: 			sub t2,t2,t3           # Corrects offset by subtracting 16 %
000019a2 : 00534e03;   % 555: 		lbu t3,5(t1)    # Gets number of iterations so far %
000019a3 : 001e0e13;   % 556: 		addi t3,t3,1    # t2++ %
000019a4 : 01c302a3;   % 557: 		sb t3,5(t1)     # Stores new iteration %
000019a5 : 00728423;   % 559: 		sb t2, 8(t0)    # Stores new X offset %
000019a6 : c01024f3;   % 560: 		csrr s1,3073    # new time is stored in s1, in order to be compared later %
000019a7 : e85ff06f;   % 561: 		j SWITCH_MAP %
000019a8 : 0fc0a297;   % 564: 	la t0,CURRENT_MAP %
000019a9 : a8428293;   % 564:  %
000019aa : 0fc0a317;   % 565: 	la t1,NEXT_MAP %
000019ab : a8830313;   % 565:  %
000019ac : 00032383;   % 566: 	lw t2,0(t1)        # Loads next map's address %
000019ad : 0072a023;   % 567: 	sw t2,0(t0)        # and stores it on CURRENT_MAP %
000019ae : 00434383;   % 568: 	lbu t2,4(t1)       # Loads next map's number %
000019af : 00728223;   % 569: 	sb t2,4(t0)        # and stores it on CURRENT_MAP %
000019b0 : 00634383;   % 570: 	lbu t2,6(t1)       # Loads next map's X %
000019b1 : 00728323;   % 571: 	sb t2,6(t0)        # and stores it on CURRENT_MAP %
000019b2 : 00734383;   % 572: 	lbu t2,7(t1)       # Loads next map's Y %
000019b3 : 007283a3;   % 573: 	sb t2,7(t0)        # and stores it on CURRENT_MAP %
000019b4 : 00028423;   % 574: 	sb zero,8(t0)      # Sets CURRENT_MAP's X offset to 0 %
000019b5 : 000284a3;   % 575: 	sb zero,9(t0)      # Sets CURRENT_MAP's Y offset to 0 %
000019b6 : 00b2ce03;   % 577: 	lbu t3,11(t0)  # Loads switch direction %
000019b7 : 000e0c63;   % 578: 	beqz t3,END_OF_SWITCH_MAP_SKIP_CHANGE_MAP_POSITION # If next map was on the right, player will be on the left door %
000019b8 : 0002ae03;   % 580: 		lw t3,0(t0)    # Gets current map's address %
000019b9 : 001e4e03;   % 581: 		lbu t3,1(t3)   # and takes its width %
000019ba : 01400e93;   % 582: 		li t4,20  # t4 = 20 %
000019bb : 41de0eb3;   % 583: 		sub t4,t3,t4          # t4 = Current Map's X position %
000019bc : 01d28323;   % 584: 		sb t4,6(t0)           # Stores map's X %
000019bd : 8f4fa06f;   % 586: 		j SETUP %
000019be : 0fc0a297;   % 600: 	la t0,CURRENT_MAP %
000019bf : a2c28293;   % 600:  %
000019c0 : 00200393;   % 601: 	li t2,2            # Loads 3 (switch map through door) %
000019c1 : 007282a3;   % 602: 	sb t2,5(t0) %
000019c2 : 0fc0a317;   % 605: 	la t1,NEXT_MAP %
000019c3 : a2830313;   % 605:  %
000019c4 : 00934303;   % 606: 	lbu t1,9(t1)     # loads "next door"'s number %
000019c5 : 00231313;   % 607: 	slli t1,t1,2     # multiplies it by 4 %
000019c6 : 0fc0a517;   % 608: 	la a0, Doors     # Gets Doors address %
000019c7 : d8450513;   % 608:  %
000019c8 : 00052503;   % 609: 	lw a0,0(a0)      # gets current map's doors address %
000019c9 : 00150513;   % 610: 	addi a0,a0,1     # skips number of doors %
000019ca : 00650533;   % 611: 	add a0,a0,t1     # and adds t1 to get the correct door's address %
000019cb : 00100393;   % 612: 	li t2,1             # Loads 1 (opening/closing) %
000019cc : 00750123;   % 613:     sb t2,2(a0)         # and stores it on door's state byte     %
000019cd : ffe00393;   % 614:     li t2,-2  # Gets new counter (related to opening door -- negative, in order to open) %
000019ce : 007501a3;   % 615:     sb t2,3(a0)         # and stores it on door's counter byte %
000019cf : 0fc0a397;   % 618: 	la t2, PLYR_POS %
000019d0 : a0238393;   % 618:  %
000019d1 : 0072ce83;   % 620: 	lbu t4,7(t0)                # Loads map's Y %
000019d2 : 006e8e13;   % 621: 	addi t3,t4,6  # adds 6 to it to get Player's new Y related to matrix %
000019d3 : 01c38523;   % 622: 	sb t3, 10(t2)               # and stores it  %
000019d4 : 01c385a3;   % 623: 	sb t3, 11(t2)               # as well as on old Y %
000019d5 : 41de0e33;   % 625: 	sub t3,t3,t4                # Gets player's matrix Y related to map's matrix Y  %
000019d6 : 004e1e13;   % 626: 	slli t3,t3,4  # Multiplies t3 by 16 to get Player's new Y related to screen %
000019d7 : 01c38223;   % 627: 	sb t3, 4(t2)                # and stores it %
000019d8 : 00b2ce03;   % 630: 	lbu t3,11(t0)  # Loads switch direction %
000019d9 : 000e0a63;   % 631: 	beqz t3,LEAVE_DOOR_ANIMATION_PREP_PLAYER_LEFT_DOOR # If next map was on the right, player will be on the left door %
000019da : 0002ae03;   % 633: 		lw t3,0(t0)    # Gets current map's address %
000019db : 001e4e03;   % 634: 		lbu t3,1(t3)   # and takes its width %
000019dc : fffe0e13;   % 635: 		addi t3,t3,-1         # Subtracts 1 from width to get Player's new X related to matrix (because coordinate starts on 0) %
000019dd : 0080006f;   % 636: 		j LEAVE_DOOR_ANIMATION_PREP_PLAYER_POS %
000019de : 00000e13;   % 638: 		li t3,0               # Player's new X related to matrix %
000019df : 01c38423;   % 640: 		sb t3, 8(t2)      # Stores new player's X related to the matrix %
000019e0 : 01c384a3;   % 641: 		sb t3, 9(t2)      # as well as on player's old X related to the matrix %
000019e1 : 0062ce83;   % 643: 		lbu t4,6(t0)                # Loads map's X %
000019e2 : 41de0e33;   % 644: 		sub t3,t3,t4                # Gets player's matrix X related to map's matrix X  %
000019e3 : 004e1e13;   % 645: 		slli t3,t3,4  # Multiplies t3 by 16 to get Player's new X related to screen %
000019e4 : 01c39023;   % 646: 		sh t3, 0(t2)   # Stores new player's X related to the screen %
000019e5 : 00000e13;   % 648: 		li t3, 0       # For player's offset %
000019e6 : 01c38323;   % 649: 		sb t3, 6(t2)   # Stores new player's X offset %
000019e7 : 01c383a3;   % 650: 		sb t3, 7(t2)   # Stores new player's Y offset %
000019e8 : c01022f3;   % 655: 	csrr t0,3073                       # Gets current time %
000019e9 : 409282b3;   % 656:     sub t0, t0, s1                     # t0 = current time - last frame's time %
000019ea : 03200313;   % 657:     li t1, 50                  # Loads frame rate (time (in ms) per frame) %
000019eb : fe62eae3;   % 658:     bltu t0,t1, LEAVE_DOOR_ANIMATION   # While t0 < minimum time for a frame, keep looping  %
000019ec : 00144413;   % 660: 	xori s0,s0,1		    # Switches frame value (register) %
000019ed : ffffb317;   % 662: 	call UPDATE_DOORS       # Updates doors %
000019ee : 9e0300e7;   % 662:  %
000019ef : 00000317;   % 663: 	call MAP_MOVE_RENDER    # Renders map when necessary %
000019f0 : 840300e7;   % 663:  %
000019f1 : 0fc0a297;   % 666: 	la t0, CURRENT_MAP   # Loads CURRENT_MAP's address %
000019f2 : 96028293;   % 666:  %
000019f3 : 0fc0a317;   % 667: 	la t1, PLYR_POS      # Loads PLYR_POS's address %
000019f4 : 97230313;   % 667:  %
000019f5 : 00b2c383;   % 668: 	lbu t2,11(t0)        # Loads switch direction %
000019f6 : 04038063;   % 669: 	beqz t2, LEAVE_DOOR_ANIMATION_NEXT_ON_RIGHT # If next map is on the right, go to LEAVE_DOOR_ANIMATION_NEXT_ON_RIGHT %
000019f7 : 00031283;   % 671: 		lh t0,0(t1)   # Gets player's current X related to screen %
000019f8 : 00531123;   % 672: 		sh t0,2(t1)   # Stores it on old X %
000019f9 : ffc28293;   % 674: 		addi t0,t0,-4  # Adds 4 to player's X %
000019fa : 00531023;   % 675: 		sh t0,0(t1)    # Stores new X %
000019fb : 0fc0a297;   % 677: 		la t0, MOVE_X  # Loads MOVE_X %
000019fc : 96428293;   % 677:  %
000019fd : fff00313;   % 678: 		li t1,-1       # Loads direction (left) %
000019fe : 00628023;   % 679: 		sb t1,0(t0)    # Stores on MOVE_X %
000019ff : 00000317;   % 680: 		call UPDATE_STATUS      # Updates player's sprite status %
00001a00 : 140300e7;   % 680:  %
00001a01 : 00000513;   % 682: 		li a0, 0     # Rendering player operation %
00001a02 : 00000593;   % 683: 		li a1,0     # Rendering full player %
00001a03 : ffffb317;   % 684: 		call RENDER_PLAYER %
00001a04 : 23c300e7;   % 684:  %
00001a05 : 03c0006f;   % 685: 		j CONTINUE_LEAVE_DOOR_ANIMATION %
00001a06 : 00031283;   % 688: 		lh t0,0(t1)   # Gets player's current X related to screen %
00001a07 : 00531123;   % 689: 		sh t0,2(t1)   # Stores it on old X %
00001a08 : 00428293;   % 691: 		addi t0,t0,4  # Adds 4 to player's X %
00001a09 : 00531023;   % 692: 		sh t0,0(t1)   # Stores new X %
00001a0a : 0fc0a297;   % 694: 		la t0, MOVE_X  # Loads MOVE_X %
00001a0b : 92828293;   % 694:  %
00001a0c : 00100313;   % 695: 		li t1,1        # Loads direction (right) %
00001a0d : 00628023;   % 696: 		sb t1,0(t0)    # Stores on MOVE_X %
00001a0e : 00000317;   % 697: 		call UPDATE_STATUS      # Updates player's sprite status %
00001a0f : 104300e7;   % 697:  %
00001a10 : 00000513;   % 699: 		li a0, 0     # Rendering player operation %
00001a11 : 00000593;   % 700: 		li a1, 0     # Rendering full player %
00001a12 : ffffb317;   % 701: 		call RENDER_PLAYER %
00001a13 : 200300e7;   % 701:  %
00001a14 : ffffc317;   % 704: 	call RENDER_DOOR_FRAMES %
00001a15 : 89c300e7;   % 704:  %
00001a16 : ff2002b7;   % 707: 	li t0,0xFF200604	# Loads Bitmap Display address %
00001a17 : 60428293;   % 707:  %
00001a18 : 0082a023;   % 708: 	sw s0,0(t0)         # Stores new frame value (from s0) on Bitmap Display %
00001a19 : 00100513;   % 710: 	li a0, 1     # Rendering player's trail operation %
00001a1a : 00000593;   % 711: 	li a1, 0     # Rendering full player (a1 doesn't really matter when a0 = 1) %
00001a1b : ffffb317;   % 712: 	call RENDER_PLAYER %
00001a1c : 1dc300e7;   % 712:  %
00001a1d : ffffb317;   % 714: 	call RENDER_UI %
00001a1e : 574300e7;   % 714:  %
00001a1f : 0fc0a297;   % 719: 	la t0, CURRENT_MAP   # Loads CURRENT_MAP's address %
00001a20 : 8a828293;   % 719:  %
00001a21 : 0fc0a317;   % 720: 	la t1, PLYR_POS   # Loads PLYR_POS's address	 %
00001a22 : 8ba30313;   % 720:  %
00001a23 : 00b2c383;   % 721: 	lbu t2,11(t0)        # Loads switch direction %
00001a24 : 02038e63;   % 722: 	beqz t2, LEAVE_DOOR_ANIMATION_NEXT_ON_RIGHT_2 # If next map is on the right, go to LEAVE_DOOR_ANIMATION_NEXT_ON_RIGHT_2 %
00001a25 : 00031e03;   % 724: 		lh t3,0(t1)           # Gets player's current X related to screen %
00001a26 : 14000293;   % 725: 		li t0,320    # Loads 320 (screen width in pixels) %
00001a27 : 01000393;   % 726: 		li t2,16       # Loads 16 (tile size) %
00001a28 : 407282b3;   % 727: 		sub t0,t0,t2          # t0 = 304 %
00001a29 : 407282b3;   % 728: 		sub t0,t0,t2          # t0 = 288 %
00001a2a : ff828293;   % 729: 		addi t0,t0,-8	      # Player should have an offset of 8 %
00001a2b : 05c29663;   % 730: 		bne t0,t3,CONTINUE_LEAVE_DOOR_ANIMATION_2  # If player's current X != 280, continue loop %
00001a2c : 00800393;   % 732: 			li t2,8           # Loads 8 for player's X offset %
00001a2d : 00730323;   % 733: 			sb t2,6(t1)       # and stores it %
00001a2e : 00834383;   % 734: 			lbu t2,8(t1)      # Gets player's current X related to matrix %
00001a2f : ffe38393;   % 735: 			addi t2,t2,-2     # subtracts 1 from it %
00001a30 : 00730423;   % 736: 			sb t2,8(t1)       # and stores it back %
00001a31 : 007304a3;   % 737: 			sb t2,9(t1)       # as well as storing on old X %
00001a32 : 0380006f;   % 738: 			j END_LEAVE_DOOR_ANIMATION  # Finish procedure  %
00001a33 : 00031383;   % 742: 		lh t2,0(t1)           # Gets player's current X related to screen %
00001a34 : 01000e13;   % 743: 		li t3,16       # Loads 16 (tile size) %
00001a35 : 008e0e13;   % 744: 		addi t3,t3,8          # Player should have an offset of 8 %
00001a36 : 027e1063;   % 745: 		bne t3,t2,CONTINUE_LEAVE_DOOR_ANIMATION_2  # If player's current X != 16, continue loop %
00001a37 : 00800293;   % 747: 			li t0,8           # Loads 8 for player's X offset %
00001a38 : 00530323;   % 748: 			sb t0,6(t1)       # and stores it %
00001a39 : 00834383;   % 749: 			lbu t2,8(t1)      # Gets player's current X related to matrix %
00001a3a : 00138393;   % 750: 			addi t2,t2,1      # adds 1 to it %
00001a3b : 00730423;   % 751: 			sb t2,8(t1)       # and stores it back %
00001a3c : 007304a3;   % 752: 			sb t2,9(t1)       # as well as storing on old X %
00001a3d : 00c0006f;   % 753: 			j END_LEAVE_DOOR_ANIMATION  # Finish procedure  %
00001a3e : c01024f3;   % 756: 		csrr s1,3073    # new time is stored in s1, in order to be compared later		 %
00001a3f : ea5ff06f;   % 757: 		j LEAVE_DOOR_ANIMATION	# Returns to beginning of loop %
00001a40 : 0fc0a317;   % 761: 		la t1,NEXT_MAP %
00001a41 : 83030313;   % 761:  %
00001a42 : 00934303;   % 762: 		lbu t1,9(t1)     # loads "next door"'s number %
00001a43 : 00231313;   % 763: 		slli t1,t1,2     # multiplies it by 4 %
00001a44 : 0fc0a517;   % 764: 		la a0, Doors     # Gets Doors address %
00001a45 : b8c50513;   % 764:  %
00001a46 : 00052503;   % 765: 		lw a0,0(a0)      # gets current map's doors address %
00001a47 : 00150513;   % 766: 		addi a0,a0,1     # skips number of doors %
00001a48 : 00650533;   % 767: 		add a0,a0,t1     # and adds t1 to get the correct door's address %
00001a49 : 00100393;   % 768: 		li t2,1             # Loads 1 (opening/closing) %
00001a4a : 00750123;   % 769: 		sb t2,2(a0)         # and stores it on door's state byte     %
00001a4b : 00400393;   % 770: 		li t2,4  # Gets new counter (related to closing door -- positive, in order to close) %
00001a4c : 007501a3;   % 771: 		sb t2,3(a0)         # and stores it on door's counter byte %
00001a4d : c01024f3;   % 773: 		csrr s1,3073      # new time is stored in s1, in order to be compared later		 %
00001a4e : f10f906f;   % 774: 		j GAME_LOOP       # go to GAME_LOOP   %
00001a4f : 0fc0a297;   % 11:     la t0,PLYR_INFO %
00001a50 : 80028293;   % 11:  %
00001a51 : 00028283;   % 12:     lb t0,0(t0) %
00001a52 : 00504863;   % 13:     blt zero,t0,END_CHECK_LIFE   # If player is alive %
00001a53 : 00300913;   % 15:         li s2,3 %
00001a54 : c01024f3;   % 16:         csrr s1,3073 %
00001a55 : e95f906f;   % 17:         j SETUP %
00001a56 : 0fc09297;   % 24:     la t0,PLYR_STATUS  # Loads Player Status %
00001a57 : 7f228293;   % 24:  %
00001a58 : 00428303;   % 25:     lb t1, 4(t0)       # Loads Ball Byte  %
00001a59 : 00031463;   % 26:     bnez t1, UPDATE_PLAYER_SPRITE_BALL # If player is on morph ball (t1 != 0), go to UPDATE_BALL_SPRITE %
00001a5a : 0500006f;   % 27:     j UPDATE_PLAYER_SPRITE_STANDING    # Otherwise, go to CHECK_VERTICAL_MOV %
00001a5b : 0012c303;   % 31:         lbu t1, 1(t0)                    # Loads player's facing direction into t1 %
00001a5c : 00031463;   % 32:         bnez t1, UPDATE_PLAYER_SPRITE_BALL_LEFT # If player is looking left, go to UPDATE_PLAYER_SPRITE_BALL_LEFT %
00001a5d : 0240006f;   % 33:         j UPDATE_PLAYER_SPRITE_BALL_RIGHT       # otherwise, go to UPDATE_PLAYER_SPRITE_BALL_RIGHT %
00001a5e : 0002c303;   % 37:             lbu t1, 0(t0)  # Loads sprite number %
00001a5f : 00030863;   % 38:             beqz t1, UPDATE_PLAYER_SPRITE_BALL_LEFT_RESET   # If sprite arrived at 0 %
00001a60 : fff30313;   % 40:                 addi t1,t1,-1  # Decrements sprite number %
00001a61 : 00628023;   % 41:                 sb t1, 0(t0)   # and stores it %
00001a62 : 0700006f;   % 42:                 j END_UPDATE_PLAYER_SPRITE %
00001a63 : 00300313;   % 45:                 li t1,3        # Loads new sprite status %
00001a64 : 00628023;   % 46:                 sb t1, 0(t0)  # and stores it %
00001a65 : 0640006f;   % 47:                 j END_UPDATE_PLAYER_SPRITE %
00001a66 : 0002c303;   % 51:             lbu t1, 0(t0)  # Loads sprite number %
00001a67 : 00300393;   % 52:             li t2,3        # loads upper threshold %
00001a68 : 00730863;   % 53:             beq t1,t2, UPDATE_PLAYER_SPRITE_BALL_RIGHT_RESET   # If sprite arrived at 3 %
00001a69 : 00130313;   % 55:                 addi t1,t1,1   # Increments sprite number %
00001a6a : 00628023;   % 56:                 sb t1, 0(t0)   # and stores it %
00001a6b : 04c0006f;   % 57:                 j END_UPDATE_PLAYER_SPRITE %
00001a6c : 00028023;   % 60:                 sb zero, 0(t0)  # Stores 0 on sprite status %
00001a6d : 0440006f;   % 61:                 j END_UPDATE_PLAYER_SPRITE %
00001a6e : 0072c303;   % 64:         lbu t1, 7(t0) # Loads MOVE_Y to t1 %
00001a6f : 00030663;   % 65:         beqz t1, UPDATE_PLAYER_SPRITE_STANDING_CHECK_HORIZONTAL_MOV  %
00001a70 : 00028023;   % 67:             sb zero, 0(t0)  # Stores 0 on sprite status %
00001a71 : 0340006f;   % 68:             j END_UPDATE_PLAYER_SPRITE %
00001a72 : 0062c303;   % 71:             lbu t1,6(t0)  # Loads Move X to t1 %
00001a73 : 00031663;   % 72:             bnez t1, UPDATE_PLAYER_SPRITE_STANDING_HORIZONTAL_MOV %
00001a74 : 00028023;   % 74:                 sb zero, 0(t0)  # Stores 0 on sprite status %
00001a75 : 0240006f;   % 75:                 j END_UPDATE_PLAYER_SPRITE %
00001a76 : 0002c303;   % 79:             lbu t1, 0(t0)  # Loads sprite number %
00001a77 : 00200393;   % 80:             li t2,2        # loads upper threshold %
00001a78 : 00730863;   % 81:             beq t1,t2, UPDATE_PLAYER_SPRITE_STANDING_HORIZONTAL_MOV_RESET   # If sprite arrived at 2 %
00001a79 : 00130313;   % 83:                 addi t1,t1,1   # Increments sprite number %
00001a7a : 00628023;   % 84:                 sb t1, 0(t0)   # and stores it %
00001a7b : 00c0006f;   % 85:                 j END_UPDATE_PLAYER_SPRITE %
00001a7c : 00028023;   % 88:                 sb zero, 0(t0)  # Stores 0 on sprite status %
00001a7d : 0040006f;   % 89:                 j END_UPDATE_PLAYER_SPRITE %
00001a7e : 0fc09317;   % 97:         la t1, PLYR_INFO_2	 # Loads address of the second part of PLYR_INFO %
00001a7f : 75c30313;   % 97:  %
00001a80 : 00534283;   % 98:         lbu t0,5(t1)         # and damage cooldown %
00001a81 : 00028a63;   % 99:         beqz t0,UPDATE_PLAYER_STATUS_DAMAGE_MOVE_X  # If it's on 0, don't update it %
00001a82 : fff28293;   % 101:             addi t0,t0,-1    # decrements it %
00001a83 : 005302a3;   % 102:             sb t0,5(t1)      # and stores it back %
00001a84 : 00029463;   % 103:             bnez t0,UPDATE_PLAYER_STATUS_DAMAGE_MOVE_X # If it didn't reach 0,  %
00001a85 : 000301a3;   % 105:                 sb zero,3(t1) %
00001a86 : 00634283;   % 109:         lbu t0,6(t1)   # Loads knockback cooldown %
00001a87 : 00028a63;   % 110:         beqz t0,UPDATE_PLAYER_STATUS_ATTACK_COOLDOWN  # If it's on 0, don't update it %
00001a88 : fff28293;   % 112:             addi t0,t0,-1    # decrements it %
00001a89 : 00530323;   % 113:             sb t0,6(t1)      # and stores it back %
00001a8a : 00504463;   % 114:             bgt t0,zero,UPDATE_PLAYER_STATUS_ATTACK_COOLDOWN # If it didn't reach 0,  %
00001a8b : 00030223;   % 116:                 sb zero,4(t1)    %
00001a8c : 0fc09317;   % 119:         la t1, BEAMS_ARRAY     # Loads BEAMS array %
00001a8d : 74030313;   % 119:  %
00001a8e : 00034283;   % 120:         lbu t0,0(t1)           # And the attack cooldown byte %
00001a8f : 00028663;   % 121:         beqz t0,UPDATE_PLAYER_STATUS_BOMB_COOLDOWN  # If it's on 0, don't update it %
00001a90 : fff28293;   % 123:             addi t0,t0,-1    # decrements it %
00001a91 : 00530023;   % 124:             sb t0,0(t1)      # and stores it back %
00001a92 : 0fc09317;   % 127:         la t1, BOMBS_ARRAY     # Loads BOMBS array %
00001a93 : 74430313;   % 127:  %
00001a94 : 00034283;   % 128:         lbu t0,0(t1)           # And the attack cooldown byte %
00001a95 : 00028663;   % 129:         beqz t0,END_UPDATE_PLAYER_STATUS  # If it's on 0, don't update it %
00001a96 : fff28293;   % 131:             addi t0,t0,-1    # decrements it %
00001a97 : 00530023;   % 132:             sb t0,0(t1)      # and stores it back %
00001a98 : 00008067;   % 141:     ret     %
00001a99 : 00100313;   % 147:         li t1, 1      # Loads morph ball mode (1 = enabled) %
00001a9a : 00650223;   % 148:         sb t1, 4(a0)  # Stores new direction on PLYR_STATUS %
00001a9b : 00008067;   % 149:         ret %
00001a9c : fff00313;   % 152:     li t1, -1     # Loads direction for MOVE_Y (-1 = up) %
00001a9d : 006503a3;   % 153:     sb t1, 7(a0)  # Stores new direction on MOVE_Y %
00001a9e : 0fc09517;   % 156:     la a0, MOVE_Y %
00001a9f : 6d950513;   % 156:  %
00001aa0 : 0fc09597;   % 157:     la a1, CURRENT_MAP %
00001aa1 : 6a458593;   % 157:  %
00001aa2 : 0005a583;   % 158:     lw a1, 0(a1) %
00001aa3 : 0fc09617;   % 159:     la a2, PLYR_POS %
00001aa4 : 6b260613;   % 159:  %
00001aa5 : 00000693;   % 160:     li a3, 0 %
00001aa6 : 00100db3;   % 163:     mv s11, ra # storing return address in s11 %
00001aa7 : 00000317;   % 164:     call CHECK_VERTICAL_COLLISION %
00001aa8 : 218300e7;   % 164:  %
00001aa9 : 01b000b3;   % 165:     mv ra, s11 # loading return address from s11 %
00001aaa : 0fc09297;   % 167:     la t0, PLYR_STATUS      # Loads Player Status %
00001aab : 6a228293;   % 167:  %
00001aac : 00050463;   % 168:     beqz a0, END_OUT_OF_MORPH_BALL %
00001aad : 00028223;   % 169:         sb zero, 4(t0) # key = up ? ball = 0  %
00001aae : 00100313;   % 171:         li t1,1       # Sets MOVE_Y to 1 (falling) so that player is placed on the ground correctly %
00001aaf : 005283a3;   % 172:         sb t0, 7(t0)  # Stores new direction on MOVE_Y %
00001ab0 : 00008067;   % 173:         ret %
00001ab1 : 00a00233;   % 195:     mv tp, a0 # Moves whether it was damage from input (1 - Cheat) or from enemy (0) %
00001ab2 : 00b00f33;   % 196:     mv t5, a1 %
00001ab3 : 0fc09517;   % 198:     la a0, PLYR_INFO_2	 # Loads address of the second part of PLYR_INFO %
00001ab4 : 68850513;   % 198:  %
00001ab5 : 00354283;   % 199:     lbu t0,3(a0)         # Loads taking damage byte %
00001ab6 : 00028463;   % 200:     beqz t0,DAMAGE_PLAYER_START   # If not taking damage, do it %
00001ab7 : 0ac0006f;   % 201:         j END_DAMAGE_PLAYER       # Otherwise, player is invincible, end procedure %
00001ab8 : 00100293;   % 204:         li t0,1        # Taking damage == True %
00001ab9 : 005501a3;   % 205:         sb t0,3(a0)    # stores taking damage byte %
00001aba : 01400293;   % 207:         li t0,20  # Loads number of invincibility frames %
00001abb : 005502a3;   % 208:         sb t0,5(a0)           # and stores it %
00001abc : 01400293;   % 210:         li t0,20  # Loads number of invincibility frames %
00001abd : 00550323;   % 211:         sb t0,6(a0)           # and stores it %
00001abe : 0fc09317;   % 213:         la t1, MOVE_Y	# Loads address of the second part of PLYR_INFO %
00001abf : 65930313;   % 213:  %
00001ac0 : fff00293;   % 214:         li t0, -1       # Loads direction for MOVE_Y (-1 = up) %
00001ac1 : 00530023;   % 215:         sb t0, 0(t1)    # Stores new direction on MOVE_Y %
00001ac2 : 000300a3;   % 216:         sb zero,1(t1)   # Resets jump counter %
00001ac3 : ffd00293;   % 219:         li t0,-3 # Jumping value for damage %
00001ac4 : d002f953;   % 220:         fcvt.s.w fs2,t0   # Sets fs2 (player's Y speed) to -3 %
00001ac5 : 00300293;   % 222:         li t0,3 %
00001ac6 : 00560663;   % 223:         beq a2,t0,DAMAGE_PLAYER_RANDOMIZE %
00001ac7 : 00200293;   % 224:         li t0,2 %
00001ac8 : 00429a63;   % 225:         bne t0,tp,DAMAGE_PLAYER_CHECK_DIRECTION %
00001ac9 : 00200593;   % 228:             li a1,2                  # Range %
00001aca : 08e00893;   % 229:             li a7,142  # random integer within range ecall %
00001acb : 00000073;   % 230:             ecall %
00001acc : 00a00633;   % 231:             mv a2,a0   # Moves result to a2 and starts checking direction %
00001acd : 00061663;   % 233:             bnez a2,DAMAGE_PLAYER_CHECK_LEFT %
00001ace : ffc00293;   % 235:                 li t0,-4 %
00001acf : 01c0006f;   % 236:                 j DAMAGE_PLAYER_DIRECTION %
00001ad0 : 00100293;   % 238:             DAMAGE_PLAYER_CHECK_LEFT: li t0,1 %
00001ad1 : 00c29663;   % 239:             bne t0,a2,DAMAGE_PLAYER_SAME_X %
00001ad2 : 00400293;   % 241:                 li t0,4 %
00001ad3 : 00c0006f;   % 242:                 j DAMAGE_PLAYER_DIRECTION %
00001ad4 : 00000293;   % 246:                 li t0,0 %
00001ad5 : 0040006f;   % 247:                 j DAMAGE_PLAYER_DIRECTION %
00001ad6 : 0fc09517;   % 250:                 la a0, PLYR_INFO_2	 # Loads address of the second part of PLYR_INFO  %
00001ad7 : 5fc50513;   % 250:  %
00001ad8 : 00550223;   % 251:                 sb t0, 4(a0)    # Stores new direction on DAMAGE_MOVE_X %
00001ad9 : 0fc09297;   % 253:         la t0,PLYR_INFO_2 %
00001ada : 5f028293;   % 253:  %
00001adb : 0002c283;   % 254:         lbu t0,0(t0) %
00001adc : 00029c63;   % 255:         bnez t0,END_DAMAGE_PLAYER %
00001add : 0fc09297;   % 259:         la t0,PLYR_INFO  # Loads PLYR_INFO %
00001ade : 5c828293;   % 259:  %
00001adf : 0002c303;   % 260:         lbu t1,0(t0)     # and player's health %
00001ae0 : 41e30333;   % 261:         sub t1,t1,t5     # takes away hp %
00001ae1 : 00628023;   % 262:         sb t1,0(t0)      # and stores it back %
00001ae2 : 00008067;   % 265:     ret %
00001ae3 : 00000213;   % 48:     li tp, 0  # Player check %
00001ae4 : 00c003b3;   % 49:     mv t2,a2  # Moves a2 to t2 %
00001ae5 : 00200613;   % 50:     li a2, 2  # Base case: check 2 tiles horizontally (or 1 if on morph ball) %
00001ae6 : 00000693;   % 51:     li a3,0   # Sets for horizontal check  %
00001ae7 : 00000713;   % 52:     li a4,0   # Base case: ignore door %
00001ae8 : 0015c783;   % 53:     lbu a5,1(a1)   # Loads Map Matrix's width %
00001ae9 : 0083c803;   % 54:     lbu a6, 8(t2)  # a6 = Player's X related to matrix %
00001aea : 00a3c883;   % 55:     lbu a7, 10(t2) # a7 = Player's Y related to matrix %
00001aeb : 00358593;   % 57:     addi a1,a1,3   # Adds 3 to the Matrix's address so that it goes to the beginning of matrix %
00001aec : 02f882b3;   % 58:     mul t0,a7,a5   # Player's Y related to matrix * Map Matrix's width %
00001aed : 005802b3;   % 59:     add t0,a6,t0   # t0 = Player's X related to matrix +  Player's Y related to matrix * Map Matrix's width   %
00001aee : 005585b3;   % 60:     add a1,a1,t0   # a1 = Map Matrix's address adjusted for Player's X and Y related to matrix %
00001aef : 0063ce03;   % 62:     lbu t3, 6(t2)  # t3 = Player's X offset %
00001af0 : 00050283;   % 63:     lb t0, 0(a0)   # Loads MOVE_X information to t0 %
00001af1 : 00200513;   % 65:     li a0,2        # Sets a0 to 2 (check any type of door) %
00001af2 : 00029c63;   % 66:     bnez t0, CHECK_X_DIRECTION  # If player's not moving, end procedure  %
00001af3 : 0fc09317;   % 67:     la t1, PLYR_INFO_2	   # Loads address of the second part of PLYR_INFO %
00001af4 : 58830313;   % 67:  %
00001af5 : 00430303;   % 68:     lb t1,4(t1)            # Gets the DAMAGE_MOVE_X value %
00001af6 : 00031463;   % 69:     bnez t1, CHECK_X_DIRECTION  # If player's not moving, end procedure  %
00001af7 : 0d00006f;   % 70:     j END_HORIZONTAL_COLLISION  %
00001af8 : 0fc09317;   % 74:         la t1, MOVE_Y # Loads MOVE_Y address %
00001af9 : 57130313;   % 74:  %
00001afa : 00030303;   % 75:         lb t1,0(t1)   # Loads MOVE_Y content %
00001afb : 04030663;   % 76:         beqz t1, CONTINUE_CHECK_X_DIRECTION  # If MOVE_Y = 0, skip %
00001afc : 02605863;   % 77:             bge zero,t1, UPWARDS_THIRD_CHECK # If MOVE_Y = 1 (down) continue %
00001afd : 0fc09317;   % 78:                 la t1, PLYR_POS    # Loads PLYR_POS address %
00001afe : 54a30313;   % 78:  %
00001aff : 00730303;   % 79:                 lb t1, 7(t1)       # Loads Y offset %
00001b00 : 02030c63;   % 80:                 beqz t1 CONTINUE_CHECK_X_DIRECTION # If Y offset is zero, there's no need to check 3 tiles %
00001b01 : 00e00e93;   % 81:                 li t4,14 %
00001b02 : 01d35663;   % 82:                 bge t1,t4,DONWARDS_CHECK_2_BELLOW  # Instead of checking the two in front of samus, check two, but 1 tile bellow %
00001b03 : 00160613;   % 83:                     addi a2,a2, 1  # Checks 3 tiles horizontally (or 2 if on morph ball) %
00001b04 : 0280006f;   % 84:                     j CONTINUE_CHECK_X_DIRECTION %
00001b05 : 00188893;   % 86:                     addi a7,a7,1 %
00001b06 : 00b785b3;   % 87:                     add a1,a5, a1 %
00001b07 : 01c0006f;   % 88:                     j CONTINUE_CHECK_X_DIRECTION %
00001b08 : 0fc09317;   % 90:                 la t1, PLYR_POS # Loads PLYR_POS address %
00001b09 : 51e30313;   % 90:  %
00001b0a : 00730303;   % 91:                 lb t1, 7(t1)    # Loads Y offset %
00001b0b : 00200f13;   % 92:                 li t5, 2        # Represents the desired offset %
00001b0c : 006f5463;   % 93:                 bge t5, t1 CONTINUE_CHECK_X_DIRECTION # If Y offset is zero, there's no need to check 3 tiles %
00001b0d : 00160613;   % 94:                     addi a2,a2, 1  # Checks 3 tiles horizontally (or 2 if on morph ball) %
00001b0e : 0103c303;   % 97:         lbu t1,16(t2) # Loads Player's morph ball byte %
00001b0f : 00030863;   % 98:         beqz t1,CONTINUE_CHECK_X_DIRECTION_2 # If player's not on morph ball %
00001b10 : fff60613;   % 99:         addi a2,a2,-1 # Morph ball requires one less iteration on horizontal check %
00001b11 : 00b785b3;   % 100:         add a1,a5,a1  # Increments width to player's y on matrix (checks only one tile in front of them) %
00001b12 : 00188893;   % 101:         addi a7,a7,1  # Increments current Y on matrix(+1 Y) %
00001b13 : 0002cc63;   % 104:         blt t0, zero, CHECK_X_LEFT # If player is moving left (t0 < 0), go to CHECK_X_LEFT %
00001b14 : 0fc09297;   % 105:         la t0, PLYR_INFO_2	   # Loads address of the second part of PLYR_INFO %
00001b15 : 50428293;   % 105:  %
00001b16 : 00428283;   % 106:         lb t0,4(t0)            # Gets the DAMAGE_MOVE_X value %
00001b17 : 0002c463;   % 107:         blt t0, zero, CHECK_X_LEFT # If player is moving left (t0 < 0), go to CHECK_X_LEFT %
00001b18 : 0240006f;   % 108:         j CHECK_X_RIGHT            # otherwise, go to CHECK_X_RIGHT %
00001b19 : 00c00293;   % 111:             li t0, 12    # Loads number 12 for comparing with X offset  %
00001b1a : 005e0a63;   % 112:             beq t3, t0, CONTINUE_CHECK_X_LEFT # If X offset is 12, continue checking %
00001b1b : ff828293;   % 113:             addi t0,t0, -8                    # Otherwise, compare with offset 4 %
00001b1c : 00200713;   % 114:             li a4,2      # Sets to check for only doors (if the next condition isn't met, it doesn' matter the value of a4) %
00001b1d : 005e0663;   % 115:             beq t3, t0, CONTINUE_CHECK_X_LEFT_DOOR # If X offset is 4, check for doors %
00001b1e : 0340006f;   % 116:             j END_HORIZONTAL_COLLISION             # Otherwise, stop %
00001b1f : 00000713;   % 119:                 li a4,0 # Sets to ignore doors %
00001b20 : 47d0106f;   % 121:                 j CHECK_MAP_COLLISION %
00001b21 : 00158593;   % 124:             addi a1,a1, 1 # Looks to the tile on the right of player's current tile %
00001b22 : 00180813;   % 125:             addi a6,a6,1  # Increments current X on matrix(+1 X) %
00001b23 : 00400293;   % 126:             li t0, 4      # Loads number 4 for comparing with X offset  %
00001b24 : 005e0a63;   % 127:             beq t3, t0, CONTINUE_CHECK_X_RIGHT # If X offset is 4, continue checking %
00001b25 : 00828293;   % 128:             addi t0,t0, 8                      # Otherwise, compare with offset 12 %
00001b26 : 00200713;   % 129:             li a4,2       # Sets to check for only doors (if the next condition isn't met, it doesn' matter the value of a4) %
00001b27 : 005e0663;   % 130:             beq t3, t0, CONTINUE_CHECK_X_RIGHT_DOOR # If X offset is 12, check for doors %
00001b28 : 00c0006f;   % 131:                 j END_HORIZONTAL_COLLISION  %
00001b29 : 00000713;   % 134:                 li a4,0 # Sets to ignore doors %
00001b2a : 4550106f;   % 136:                 j CHECK_MAP_COLLISION %
00001b2b : 00100513;   % 140:         li a0,1   %
00001b2c : 00008067;   % 141:         ret  %
00001b2d : 00c003b3;   % 173:     mv t2,a2  # Moves a2 to t2 %
00001b2e : 00d00233;   % 174:     mv tp,a3  # Moves a3 to tp %
00001b2f : 00100613;   % 175:     li a2,1   # Base case: check 1 tiles vertically %
00001b30 : 00100693;   % 176:     li a3,1   # Sets for horizontal check  %
00001b31 : 00000713;   % 177:     li a4,0   # Base case: ignore door %
00001b32 : 0015c783;   % 178:     lbu a5,1(a1)   # Loads Map Matrix's width %
00001b33 : 0083c803;   % 179:     lbu a6, 8(t2)  # a6 = Player's X related to matrix %
00001b34 : 00a3c883;   % 180:     lbu a7, 10(t2) # a7 = Player's Y related to matrix %
00001b35 : 00358593;   % 182:     addi a1,a1,3   # Adds 3 to the Matrix's address so that it goes to the beginning of matrix %
00001b36 : 02f882b3;   % 183:     mul t0,a7,a5   # Player's Y related to matrix * Map Matrix's width %
00001b37 : 005802b3;   % 184:     add t0,a6,t0   # t0 = Player's X related to matrix +  Player's Y related to matrix * Map Matrix's width   %
00001b38 : 005585b3;   % 185:     add a1,a1,t0   # a1 = Map Matrix's address adjusted for Player's X and Y related to matrix %
00001b39 : 0073ce03;   % 187:     lbu t3, 7(t2)  # t3 = Player's Y offset %
00001b3a : 00050283;   % 188:     lb t0, 0(a0) # Loads MOVE_Y to t0  %
00001b3b : 0002c463;   % 189:     blt t0,zero, CHECK_Y_UP # If t0 < 0, check up,  %
00001b3c : 0500006f;   % 190:     j CHECK_Y_DOWN          # otherwise check down %
00001b3d : 004e0e33;   % 194:         add t3,t3,tp     # current offset + offset modifier %
00001b3e : 01c05463;   % 195:         bge zero,t3 CONTINUE_CHECK_Y_UP # If current offset + offset modifier <= 0, continue checking %
00001b3f : 0d00006f;   % 196:         j END_VERTICAL_COLLISION    # otherwise, end procedure %
00001b40 : 0103c303;   % 200:             lbu t1,16(t2)  # Loads Player's morph ball byte %
00001b41 : 00031663;   % 201:             bnez t1, CONTINUE_CHECK_Y_UP2 # If player is on morph ball, don't update Y to be checked %
00001b42 : 40f585b3;   % 202:             sub a1,a1,a5   # If player isn't on morph ball, update Y one tile up (-1 matrix Y)  %
00001b43 : fff88893;   % 203:             addi a7,a7,-1  # Increments current Y on matrix(-1 Y) %
00001b44 : 0063ce03;   % 207:             lbu t3, 6(t2)  # t3 = Player's X offset %
00001b45 : 00800293;   % 208:             li t0, 8   # Loads number 8 for comparing with X offset  %
00001b46 : 005e4863;   % 209:             blt t3,t0, CHECK_Y_UP_ABOVE # If X offset < 8, just check one tile above %
00001b47 : 00c00293;   % 210:             li t0,12   # Loads number 12 for comparing with X offset  %
00001b48 : 005e5863;   % 211:             bge t3,t0, CHECK_Y_UP_TO_THE_RIGHT # If X offset >= 12, check one tile above to the right  %
00001b49 : 00200613;   % 212:             li a2,2    # If player's X offset = 8, check 2 tiles above the player (one above, the other above to the right) %
00001b4a : 00000213;   % 215:                 li tp, 0  # Player check %
00001b4b : 3d10106f;   % 216:                 j CHECK_MAP_COLLISION %
00001b4c : 00158593;   % 219:                 addi a1,a1, 1 # Looks to the tile on the right of player's current tile %
00001b4d : 00180813;   % 220:                 addi a6,a6,1  # Increments current X on matrix (+1 X) %
00001b4e : 00000213;   % 221:                 li tp, 0  # Player check %
00001b4f : 3c10106f;   % 222:                 j CHECK_MAP_COLLISION            %
00001b50 : 00000e93;   % 225:         li t4,0   # If Y offset = 0 %
00001b51 : 00000f13;   % 226:         li t5,0   # If Y offset = 0 %
00001b52 : 000e0e63;   % 227:         beqz t3 CONTINUE_CHECK_Y_DOWN    # If player's Y offset = 0, continue checking %
00001b53 : 00f00eb3;   % 230:         mv t4,a5   %
00001b54 : 00100f13;   % 231:         li t5,1    %
00001b55 : 01000313;   % 233:         li t1,16  # Loads 16 %
00001b56 : 004e0e33;   % 234:         add t3,t3,tp     # current offset + offset modifier %
00001b57 : 006e5463;   % 235:         bge t3,t1 CONTINUE_CHECK_Y_DOWN  # If current offset + offset modifier >= 16, continue checking (but check one tile bellow) %
00001b58 : 06c0006f;   % 237:         j END_VERTICAL_COLLISION         # otherwise, end procedure %
00001b59 : 00100713;   % 240:             li a4, 1  # Base case: Consider doors %
00001b5a : 00179293;   % 242:             slli t0,a5,1     # t0 = 2 x Matrix width %
00001b5b : 005585b3;   % 243:             add a1,a1,t0     # Updates Y 2 tiles down (+2 matrix Y)  %
00001b5c : 00288893;   % 244:             addi a7,a7,2     # Increments current Y on matrix (+2 Y) %
00001b5d : 01d585b3;   % 246:             add a1,a1,t4     # If current offset + offset modifier >= 16, update Y another tile down (+1 matrix Y) %
00001b5e : 01e888b3;   % 247:             add a7,a7,t5    # If Y current offset + offset modifier >= 16, increment current Y on matrix once more (+1 Y) %
00001b5f : 0063ce03;   % 249:             lbu t3, 6(t2)    # t3 = Player's X offset %
00001b60 : 020e0063;   % 250:             beqz t3 CHECK_Y_DOWN_BOTH_DOORS # If X offset = 0, just check one tile bellow, and consider both doors %
00001b61 : 00800293;   % 251:             li t0, 8   # Loads number 8 for comparing with X offset  %
00001b62 : 025e4263;   % 252:             blt t3,t0, CHECK_Y_DOWN_RIGHT_DOOR # If X offset < 8, just check one tile bellow, and consider right doors %
00001b63 : 03c2c663;   % 253:             blt t0,t3, CHECK_Y_DOWN_LEFT_DOOR # If X offset > 8, check one tile bellow to the right , and consider left doors %
00001b64 : 00200613;   % 255:                 li a2,2  # Check 2 tiles above the player (one bellow, the other bellow to the right)   %
00001b65 : 00000713;   % 256:                 li a4,0  # Ignore doors %
00001b66 : 00000213;   % 257:                 li tp, 0  # Player check %
00001b67 : 3610106f;   % 258:                 j CHECK_MAP_COLLISION %
00001b68 : 00200513;   % 261:                 li a0, 2 # Consider both doors on the left and on the right sides of the map %
00001b69 : 00000213;   % 262:                 li tp, 0  # Player check %
00001b6a : 3550106f;   % 263:                 j CHECK_MAP_COLLISION %
00001b6b : 00000513;   % 266:                 li a0, 0 # Only consider doors on the right side of the map %
00001b6c : 00000213;   % 267:                 li tp, 0  # Player check %
00001b6d : 3490106f;   % 268:                 j CHECK_MAP_COLLISION %
00001b6e : 00100513;   % 271:                 li a0, 1 # Only consider doors on the left side of the map %
00001b6f : 00158593;   % 272:                 addi a1,a1, 1 # Looks to the tile on the right of player's current tile %
00001b70 : 00180813;   % 273:                 addi a6,a6,1  # Increments current X on matrix (+1 X) %
00001b71 : 00000213;   % 274:                 li tp, 0  # Player check %
00001b72 : 3350106f;   % 275:                 j CHECK_MAP_COLLISION  %
00001b73 : 00100513;   % 279:         li a0,1   %
00001b74 : 00008067;   % 280:         ret  %
00001b75 : ffc10113;   % 304:     addi sp,sp,-4 %
00001b76 : 00112023;   % 305:     sw ra,0(sp) %
00001b77 : 0fc09297;   % 307:     la t0, PLYR_POS  # Loads PLAYER_POS address %
00001b78 : 36228293;   % 307:  %
00001b79 : 0082c503;   % 308:     lbu a0, 8(t0)      # Loads Player's current X (matrix) %
00001b7a : 00a2c583;   % 309:     lbu a1, 10(t0)     # Loads Player's current Y (matrix)   %
00001b7b : 0062c603;   % 310:     lbu a2, 6(t0)      # Loads Player's current X offset %
00001b7c : 0072c683;   % 311:     lbu a3, 7(t0)      # Loads Player's current Y offset %
00001b7d : 0102c703;   % 312:     lbu a4, 16(t0)     # Loads Player's ball mode (0 - Disabled, 1 - Enabled) %
00001b7e : 0fc09297;   % 316:     la t0,CURRENT_MAP             # Loads map address %
00001b7f : 32c28293;   % 316:  %
00001b80 : 0042c283;   % 317:     lbu t0,4(t0)                  # and from it, loads map's number %
00001b81 : 00600313;   % 318:     li t1,6                       # Loads 6 to compare with map's number %
00001b82 : 00628463;   % 319:     beq t0,t1,PLAYER_COLLISION_BOMB_POWER      # If on map 6, continue checking for Bomb Power %
00001b83 : 0880006f;   % 320:         j PLAYER_COLLISION_MARU_MARI   # Otherwise, skip this check %
00001b84 : 0fc09e17;   % 323:         la t3,PLYR_INFO  # Loads Bomb Power's info address %
00001b85 : 32ce0e13;   % 323:  %
00001b86 : 001e4e83;   % 324:         lbu t4,1(t3)     # Loads player's abilities %
00001b87 : 00300e13;   % 325:         li t3,3 %
00001b88 : 01de1463;   % 326:         bne t3,t4, CONTINUE_PLAYER_COLLISION_BOMB_POWER %
00001b89 : 0700006f;   % 327:             j PLAYER_COLLISION_MARU_MARI   # Otherwise, skip this check %
00001b8a : 00b00e13;   % 330:         li t3,11   # Loads Bomb Power's current X %
00001b8b : 00ae0863;   % 331:         beq t3,a0,PLAYER_COLLISION_BOMB_POWER_SAME_X   # If Bomb Power's X is the same as the player's %
00001b8c : 00150e93;   % 332:         addi t4,a0,1   # Checks player's tile to the right %
00001b8d : 01de0a63;   % 333:         beq t3,t4,PLAYER_COLLISION_BOMB_POWER_RIGHT_X  # If Bomb Power's X is to the right of player %
00001b8e : 05c0006f;   % 334:             j PLAYER_COLLISION_MARU_MARI   # Otherwise, Bomb Power isn't near player enough to be collected, check next %
00001b8f : 00c00e93;   % 337:             li t4,12 %
00001b90 : 01d64a63;   % 338:             blt a2,t4,PLAYER_COLLISION_BOMB_POWER_CHECK_Y # If player's X offset < 12, continue %
00001b91 : 0500006f;   % 339:                 j PLAYER_COLLISION_MARU_MARI # Otherwise, Bomb Power isn't near player enough to be collected, check next %
00001b92 : 00400e13;   % 342:             li t3,4  %
00001b93 : 00ce4463;   % 343:             blt t3,a2,PLAYER_COLLISION_BOMB_POWER_CHECK_Y # If t3 < player offset, continue %
00001b94 : 0440006f;   % 344:                 j PLAYER_COLLISION_MARU_MARI     # Otherwise, Bomb Power isn't near player enough to be collected, check next %
00001b95 : 00300e13;   % 347:             li t3,3   # Loads Bomb Power's current Y %
00001b96 : 00158e93;   % 348:             addi t4,a1,1        # Checks player's base tile (Y + 1) %
00001b97 : 01de0a63;   % 349:             beq t3,t4,PLAYER_COLLISION_BOMB_POWER_HIT  # If Bomb Power's Y on player's base, it's collected %
00001b98 : 0340006f;   % 351:                 j PLAYER_COLLISION_MARU_MARI     # Otherwise, Bomb Power isn't near player enough to be collected, check next %
00001b99 : 00200e13;   % 354:                 li t3,2 %
00001b9a : 00de4463;   % 355:                 blt t3,a3,PLAYER_COLLISION_BOMB_POWER_HIT # If Bomb Power's "Y offset" is less than the player's Y offset deal damage %
00001b9b : 0280006f;   % 356:                     j PLAYER_COLLISION_MARU_MARI     # Otherwise, Bomb Power isn't near player enough to be collected, check next %
00001b9c : 0fc09e17;   % 360:                 la t3,PLYR_INFO  # Loads Maru Bomb Power's info address %
00001b9d : 2cce0e13;   % 360:  %
00001b9e : 00300e93;   % 361:                 li t4,3          # Loads 1 (1 - ball) %
00001b9f : 01de00a3;   % 362:                 sb t4,1(t3)      # Loads player's abilities %
00001ba0 : c0102373;   % 364:                 csrr t1,3073                       # Gets current time for loop %
00001ba1 : c01022f3;   % 366:                     csrr t0,3073                                      # Gets current time %
00001ba2 : 406282b3;   % 367:                     sub t0, t0, t1                                    # t0 = current time - last frame's time %
00001ba3 : 7d000393;   % 368:                     li t2, 2000                             # Loads power_up_delay %
00001ba4 : fe72eae3;   % 369:                     bltu t0,t2, PLAYER_COLLISION_BOMB_POWER_HIT_LOOP  # While t0 < minimum time for a frame, keep looping %
00001ba5 : 0fc09297;   % 374:     la t0,CURRENT_MAP             # Loads map address %
00001ba6 : 29028293;   % 374:  %
00001ba7 : 0042c283;   % 375:     lbu t0,4(t0)                  # and from it, loads map's number %
00001ba8 : 00100313;   % 376:     li t1,1                       # Loads 1 to compare with map's number %
00001ba9 : 00628463;   % 377:     beq t0,t1,CONTINUE_PLAYER_COLLISION_MARU_MARI1      # If on map 1, continue checking for MARU MARI %
00001baa : 0840006f;   % 378:         j PLAYER_COLLISION_LOOT   # Otherwise, skip this check %
00001bab : 0fc09e17;   % 381:         la t3,PLYR_INFO  # Loads Maru Mari's info address %
00001bac : 290e0e13;   % 381:  %
00001bad : 001e4e83;   % 382:         lbu t4,1(t3)     # Loads player's abilities %
00001bae : 000e8463;   % 383:         beqz t4, CONTINUE_PLAYER_COLLISION_MARU_MARI2 %
00001baf : 0700006f;   % 384:             j PLAYER_COLLISION_LOOT   # Otherwise, skip this check %
00001bb0 : 00f00e13;   % 387:         li t3,15   # Loads MaruMari's current X %
00001bb1 : 00ae0863;   % 388:         beq t3,a0,PLAYER_COLLISION_MARU_MARI_SAME_X   # If MaruMari's X is the same as the player's %
00001bb2 : 00150e93;   % 389:         addi t4,a0,1   # Checks player's tile to the right %
00001bb3 : 01de0a63;   % 390:         beq t3,t4,PLAYER_COLLISION_MARU_MARI_RIGHT_X  # If MaruMari's X is to the right of player %
00001bb4 : 05c0006f;   % 391:             j PLAYER_COLLISION_LOOT   # Otherwise, MaruMari isn't near player enough to be collected, check next %
00001bb5 : 00c00e93;   % 394:             li t4,12 %
00001bb6 : 01d64a63;   % 395:             blt a2,t4,PLAYER_COLLISION_MARU_MARI_CHECK_Y # If player's X offset < 12, continue %
00001bb7 : 0500006f;   % 396:                 j PLAYER_COLLISION_LOOT # Otherwise, MaruMari isn't near player enough to be collected, check next %
00001bb8 : 00400e13;   % 399:             li t3,4  %
00001bb9 : 00ce4463;   % 400:             blt t3,a2,PLAYER_COLLISION_MARU_MARI_CHECK_Y # If t3 < player offset, continue %
00001bba : 0440006f;   % 401:                 j PLAYER_COLLISION_LOOT     # Otherwise, MaruMari isn't near player enough to be collected, check next %
00001bbb : 00900e13;   % 404:             li t3,9   # Loads MaruMari's current Y %
00001bbc : 00158e93;   % 405:             addi t4,a1,1        # Checks player's base tile (Y + 1) %
00001bbd : 01de0a63;   % 406:             beq t3,t4,PLAYER_COLLISION_MARU_MARI_HIT  # If MaruMari's Y on player's base, it's collected %
00001bbe : 0340006f;   % 408:                 j PLAYER_COLLISION_LOOT     # Otherwise, MaruMari isn't near player enough to be collected, check next %
00001bbf : 00200e13;   % 411:                 li t3,2 %
00001bc0 : 00de4463;   % 412:                 blt t3,a3,PLAYER_COLLISION_MARU_MARI_HIT # If MaruMari's "Y offset" is less than the player's Y offset deal damage %
00001bc1 : 0280006f;   % 413:                     j PLAYER_COLLISION_LOOT     # Otherwise, MaruMari isn't near player enough to be collected, check next %
00001bc2 : 0fc09e17;   % 417:                 la t3,PLYR_INFO  # Loads Maru Mari's info address %
00001bc3 : 234e0e13;   % 417:  %
00001bc4 : 00100e93;   % 418:                 li t4,1          # Loads 1 (1 - ball) %
00001bc5 : 01de00a3;   % 419:                 sb t4,1(t3)      # Loads player's abilities %
00001bc6 : c0102373;   % 421:                 csrr t1,3073                       # Gets current time for loop %
00001bc7 : c01022f3;   % 423:                     csrr t0,3073                                     # Gets current time %
00001bc8 : 406282b3;   % 424:                     sub t0, t0, t1                                   # t0 = current time - last frame's time %
00001bc9 : 7d000393;   % 425:                     li t2, 2000                            # Loads power_up_delay %
00001bca : fe72eae3;   % 426:                     bltu t0,t2, PLAYER_COLLISION_MARU_MARI_HIT_LOOP  # While t0 < minimum time for a frame, keep looping %
00001bcb : 0fc09297;   % 431:     la t0,LOOT_ARRAY   # Loads loot array %
00001bcc : 2c428293;   % 431:  %
00001bcd : 00000393;   % 433:     li t2,0                 # resets counter %
00001bce : 00400313;   % 434:     li t1,4       # gets number of loot in game %
00001bcf : 0022ce03;   % 436:         lbu t3,2(t0) # Loads enable byte %
00001bd0 : 000e1463;   % 437:         bnez t3,PLAYER_COLLISION_LOOT_LOOP_CONTINUE    # If enabled, %
00001bd1 : 0e80006f;   % 438:             j NEXT_IN_PLAYER_COLLISION_LOOT_LOOP       # Otherwise, check other loot %
00001bd2 : 0062ce03;   % 441:         lbu t3,6(t0)   # Loads loot's current X %
00001bd3 : 00ae0c63;   % 442:         beq t3,a0,PLAYER_COLLISION_LOOT_LOOP_SAME_X   # If loot's X is the same as the player's %
00001bd4 : 00150e93;   % 443:         addi t4,a0,1   # Checks player's tile to the right %
00001bd5 : 03de0863;   % 444:         beq t3,t4,PLAYER_COLLISION_LOOT_LOOP_RIGHT_X  # If loot's X is to the right of player %
00001bd6 : fff50e93;   % 445:         addi t4,a0,-1  # Checks player's tile to the left %
00001bd7 : 01de0c63;   % 446:         beq t3,t4,PLAYER_COLLISION_LOOT_LOOP_LEFT_X   # If loot's X is to the left of player %
00001bd8 : 0cc0006f;   % 447:         j NEXT_IN_PLAYER_COLLISION_LOOT_LOOP # Otherwise, loot isn't near player enough to be collected, check next %
00001bd9 : 0042ce03;   % 450:             lbu t3,4(t0)   # Loads loot's X offset %
00001bda : 00c00e93;   % 451:             li t4,12 %
00001bdb : 03ced463;   % 452:             ble t3,t4,PLAYER_COLLISION_LOOT_LOOP_CHECK_Y # If t3 <= 12, continue %
00001bdc : 0bc0006f;   % 453:                 j NEXT_IN_PLAYER_COLLISION_LOOT_LOOP # Otherwise, loot isn't near player enough to be collected, check next %
00001bdd : 0042ce03;   % 456:             lbu t3,4(t0)   # Loads loot's X offset %
00001bde : ffce0e13;   % 457:             addi t3,t3,-4  # subtracts 4 from it %
00001bdf : 00ce4c63;   % 458:             blt t3,a2,PLAYER_COLLISION_LOOT_LOOP_CHECK_Y # If t3 < player offset, continue %
00001be0 : 0ac0006f;   % 459:                 j NEXT_IN_PLAYER_COLLISION_LOOT_LOOP     # Otherwise, loot isn't near player enough to be collected, check next %
00001be1 : 0042ce03;   % 462:             lbu t3,4(t0)   # Loads loot's X offset %
00001be2 : 004e0e13;   % 463:             addi t3,t3,4   # adds 4 to it %
00001be3 : 00ce4463;   % 464:             blt t3,a2,PLAYER_COLLISION_LOOT_LOOP_CHECK_Y # If t3 < player offset, continue %
00001be4 : 09c0006f;   % 465:                 j NEXT_IN_PLAYER_COLLISION_LOOT_LOOP     # Otherwise, loot isn't near player enough to be collected, check next %
00001be5 : 0082ce03;   % 468:             lbu t3,8(t0)   # Loads loot's current Y %
00001be6 : 02be0463;   % 469:             beq t3,a1,PLAYER_COLLISION_LOOT_LOOP_SAME_Y    # If loot's Y is the same as the player's %
00001be7 : 00158e93;   % 470:             addi t4,a1,1   # Checks player's base tile (Y + 1) %
00001be8 : 03de0c63;   % 471:             beq t3,t4,PLAYER_COLLISION_LOOT_LOOP_HIT  # If loot's Y on player's base %
00001be9 : 00258e93;   % 472:             addi t4,a1,2   # Checks bellow player's base tile (Y + 2) %
00001bea : 01de0463;   % 473:             beq t3,t4,PLAYER_COLLISION_LOOT_LOOP_BELLOW  # If loot's X is bellow player %
00001beb : 0800006f;   % 475:             j NEXT_IN_PLAYER_COLLISION_LOOT_LOOP     # Otherwise, loot isn't near player enough to be collected, check next %
00001bec : 0042ce03;   % 478:                 lbu t3,4(t0)  # Loads loot's Y offset %
00001bed : 007e0e93;   % 479:                 addi t4,t3,7  %
00001bee : 02de4063;   % 480:                 blt t3,a3,PLAYER_COLLISION_LOOT_LOOP_HIT # If loot's "Y offset" is less than the player's Y offset deal damage %
00001bef : 0700006f;   % 481:                     j NEXT_IN_PLAYER_COLLISION_LOOT_LOOP     # Otherwise, loot isn't near player enough to be collected, check next %
00001bf0 : 00070463;   % 484:                 beqz a4,CONTINUE_PLAYER_COLLISION_LOOT_LOOP_SAME_Y  # If not on morph ball, check it was a hit %
00001bf1 : 0680006f;   % 486:                     j NEXT_IN_PLAYER_COLLISION_LOOT_LOOP     # Otherwise, loot isn't near player enough to be collected, check next %
00001bf2 : 0042ce03;   % 489:                     lbu t3,4(t0)      # Loads loot's Y offset %
00001bf3 : 00ce0e13;   % 490:                     addi t3,t3, 12  %
00001bf4 : 01c6c463;   % 491:                     bgt t3,a3,PLAYER_COLLISION_LOOT_LOOP_HIT # If loot's "Y offset" is greater than the player's Y offset deal damage %
00001bf5 : 0580006f;   % 492:                         j NEXT_IN_PLAYER_COLLISION_LOOT_LOOP # Otherwise, loot isn't near player enough to be collected, check next %
00001bf6 : 00028123;   % 496:                 sb zero,2(t0)     # Disables loot %
00001bf7 : 0032ce03;   % 497:                 lbu t3,3(t0)      # Loads loot's type %
00001bf8 : 020e0463;   % 498:                 beqz t3, PLAYER_COLLISION_LOOT_LOOP_HIT_ENERGY  # If it's energy %
00001bf9 : 0fc09e17;   % 500:                     la t3,PLYR_INFO_2 %
00001bfa : 170e0e13;   % 500:  %
00001bfb : 002e4e83;   % 501:                     lbu t4,2(t3)       # Loads number of missiles %
00001bfc : 005e8e93;   % 502:                     addi t4,t4,5 %
00001bfd : 06400f13;   % 503:                     li t5,100 %
00001bfe : 01eec463;   % 504:                     blt t4,t5,STORE_NEW_MISSILE %
00001bff : 06400e93;   % 505:                         li t4,100      # Sets missile number to maximum %
00001c00 : 01de0123;   % 507:                         sb t4,2(t3)    # Stores updated number of missiles %
00001c01 : 0280006f;   % 508:                         j NEXT_IN_PLAYER_COLLISION_LOOT_LOOP # Go to next loot        %
00001c02 : 0fc09e17;   % 512:                     la t3,PLYR_INFO %
00001c03 : 134e0e13;   % 512:  %
00001c04 : 000e4e83;   % 513:                     lbu t4,0(t3)       # Loads health %
00001c05 : 005e8e93;   % 514:                     addi t4,t4,5 %
00001c06 : 06300f13;   % 515:                     li t5,99 %
00001c07 : 01eec463;   % 516:                     blt t4,t5,STORE_NEW_ENERGY %
00001c08 : 06300e93;   % 517:                         li t4,99       # Sets missile number to maximum %
00001c09 : 01de0023;   % 519:                         sb t4,0(t3)    # Stores updated number of missiles %
00001c0a : 0040006f;   % 520:                         j NEXT_IN_PLAYER_COLLISION_LOOT_LOOP # Go to next loot            %
00001c0b : 00728293;   % 523:             addi t0,t0,7   # Going to the next ripper's address                                   %
00001c0c : 00138393;   % 524:             addi t2,t2,1             # Iterating counter by 1                                    %
00001c0d : 0063d463;   % 525:             bge t2,t1, PLAYER_COLLISION_ENEMIES # If all of the rippers were checked, end loop                                   %
00001c0e : f05ff06f;   % 526:             j PLAYER_COLLISION_LOOT_LOOP # otherwise, go back to the loop's beginning          %
00001c0f : 0fc09297;   % 529:     la t0,CURRENT_MAP             # Loads map address %
00001c10 : 0e828293;   % 529:  %
00001c11 : 0042c283;   % 530:     lbu t0,4(t0)                  # and from it, loads map's number %
00001c12 : 00700313;   % 531:     li t1,7                       # Loads 7 to compare with map's number %
00001c13 : 00629463;   % 532:     bne t0,t1,PLAYER_COLLISION_SKIP_RIDLEY         # If not on map 7, skip Ridley and Plasma Breath >:D %
00001c14 : 20c0006f;   % 533:         j PLAYER_COLLISION_RIDLEY # Otherwise, skip the rest of the checks %
00001c15 : 0fc09297;   % 538:     la t0,Zoomers  # Loads Zoomers address %
00001c16 : 1f428293;   % 538:  %
00001c17 : 0002a283;   % 540:     lw t0,0(t0)    # Loads the ZoomersA address over the Zoomers address %
00001c18 : 00029463;   % 541:     bnez t0,CONTINUE_PLAYER_COLLISION_ZOOMER  # If there are zoomers in this map %
00001c19 : 1040006f;   % 542:         j PLAYER_COLLISION_RIPPER             # If t0 = 0, there are no zoomers in this map %
00001c1a : 0002c303;   % 546:     lbu t1,0(t0)   # Loads number of Zoomers in current map %
00001c1b : 00000393;   % 547:     li t2,0        # Counter for zoomers %
00001c1c : 00128293;   % 548:     addi t0,t0,1   # Goes to next byte (where zoomers from current map start) %
00001c1d : 00028e03;   % 551:         lb t3,0(t0) # Loads zoomer's health %
00001c1e : 01c04463;   % 552:         blt zero,t3,CONTINUE_PLAYER_COLLISION_ZOOMER_LOOP # If zoomer is alive %
00001c1f : 0dc0006f;   % 554:             j NEXT_IN_PLAYER_COLLISION_ZOOMER_LOOP   # Zoomer is dead %
00001c20 : 00300213;   % 557:         li tp, 3 # tp will start as 3 (random direction)  %
00001c21 : 0042ce03;   % 558:         lbu t3,4(t0)   # Loads zoomer's current X %
00001c22 : 00ae0c63;   % 559:         beq t3,a0,PLAYER_COLLISION_ZOOMER_LOOP_SAME_X   # If zoomer's X is the same as the player's %
00001c23 : 00150e93;   % 560:         addi t4,a0,1   # Checks player's tile to the right %
00001c24 : 05de0263;   % 561:         beq t3,t4,PLAYER_COLLISION_ZOOMER_LOOP_RIGHT_X  # If zoomer's X is to the right of player %
00001c25 : fff50e93;   % 562:         addi t4,a0,-1  # Checks player's tile to the left %
00001c26 : 03de0263;   % 563:         beq t3,t4,PLAYER_COLLISION_ZOOMER_LOOP_LEFT_X   # If zoomer's X is to the left of player %
00001c27 : 0bc0006f;   % 564:         j NEXT_IN_PLAYER_COLLISION_ZOOMER_LOOP # Otherwise, zoomer isn't near player enough to deal damage, check next %
00001c28 : 0022ce03;   % 567:             lbu t3,2(t0)   # Loads zoomer's X offset %
00001c29 : 00ce0463;   % 568:             beq t3,a2,PLAYER_COLLISION_ZOOMER_LOOP_SAME_X_RANDOM # If offsets are the same, randomize direction %
00001c2a : 00ce2233;   % 570:                 slt tp,t3,a2   # If t3 < a2, damage is from the left, otherwise, it is from the right  %
00001c2b : 00c00e93;   % 572:                 li t4,12       # to be compared with  %
00001c2c : 41c60e33;   % 573:                 sub t3,a2,t3   # t3 = zoomer's x offset - player's x offset %
00001c2d : 03de4c63;   % 574:                 blt t3,t4,PLAYER_COLLISION_ZOOMER_LOOP_CHECK_Y # If t3 < 12, continue %
00001c2e : 0a00006f;   % 575:                     j NEXT_IN_PLAYER_COLLISION_ZOOMER_LOOP # Otherwise, zoomer isn't near player enough to deal damage, check next %
00001c2f : 0022ce03;   % 578:             lbu t3,2(t0)   # Loads zoomer's X offset %
00001c30 : ffce0e13;   % 579:             addi t3,t3,-4  # subtracts 4 from it %
00001c31 : 01c65663;   % 580:             bge a2,t3,STOP_PLAYER_COLLISION_ZOOMER_LOOP_LEFT_X # If t3 <= player offset, there wasn't a hit %
00001c32 : 00100213;   % 581:                 li tp,1    # Damage from the left %
00001c33 : 0200006f;   % 582:                 j PLAYER_COLLISION_ZOOMER_LOOP_CHECK_Y %
00001c34 : 0880006f;   % 584:                 j NEXT_IN_PLAYER_COLLISION_ZOOMER_LOOP # Zoomer isn't near player enough to deal damage, check next %
00001c35 : 0022ce03;   % 587:             lbu t3,2(t0)   # Loads zoomer's X offset %
00001c36 : 004e0e13;   % 588:             addi t3,t3,4   # adds 4 to it %
00001c37 : 00ce5663;   % 589:             bge t3,a2,STOP_PLAYER_COLLISION_ZOOMER_LOOP_RIGHT_X # If t3 >= player offset, there wasn't a hit %
00001c38 : 00000213;   % 590:                 li tp,0    # Damage from the right %
00001c39 : 0080006f;   % 591:                 j PLAYER_COLLISION_ZOOMER_LOOP_CHECK_Y %
00001c3a : 0700006f;   % 593:                 j NEXT_IN_PLAYER_COLLISION_ZOOMER_LOOP # Zoomer isn't near player enough to deal damage, check next %
00001c3b : 0062ce03;   % 596:             lbu t3,6(t0)   # Loads zoomer's current Y %
00001c3c : 04be0063;   % 597:             beq t3,a1,PLAYER_COLLISION_ZOOMER_LOOP_SAME_Y    # If zoomer's Y is the same as the player's %
00001c3d : 00158e93;   % 598:             addi t4,a1,1   # Checks player's base tile (Y + 1) %
00001c3e : 05de0463;   % 599:             beq t3,t4,PLAYER_COLLISION_ZOOMER_LOOP_HIT  # If zoomer's Y on player's base %
00001c3f : 00258e93;   % 600:             addi t4,a1,2   # Checks bellow player's base tile (Y + 2) %
00001c40 : 01de0863;   % 601:             beq t3,t4,PLAYER_COLLISION_ZOOMER_LOOP_BELLOW  # If zoomer's X is bellow player %
00001c41 : fff58e93;   % 602:             addi t4,a1,-1  # Checks 1 tile above player's Y %
00001c42 : 01de0a63;   % 603:             beq t3,t4,PLAYER_COLLISION_ZOOMER_LOOP_ABOVE     # If zoomer's X is above the player %
00001c43 : 04c0006f;   % 604:             j NEXT_IN_PLAYER_COLLISION_ZOOMER_LOOP # Otherwise, zoomer isn't near player enough to deal damage, check next %
00001c44 : 0032ce03;   % 607:                 lbu t3,3(t0)   # Loads zoomer's Y offset %
00001c45 : 02de4663;   % 608:                 blt t3,a3,PLAYER_COLLISION_ZOOMER_LOOP_HIT # If zoomer's Y offset is less than the player's Y offset deal damage %
00001c46 : 0400006f;   % 609:                     j NEXT_IN_PLAYER_COLLISION_ZOOMER_LOOP # Otherwise, zoomer isn't near player enough to deal damage, check next %
00001c47 : 00070463;   % 612:                 beqz a4,CONTINUE_PLAYER_COLLISION_ZOOMER_LOOP_ABOVE  # If not on morph ball, check if it was a hit %
00001c48 : 0380006f;   % 613:                     j NEXT_IN_PLAYER_COLLISION_ZOOMER_LOOP # Otherwise, zoomer isn't near player enough to deal damage, check next %
00001c49 : 0032ce03;   % 616:                 lbu t3,3(t0)   # Loads zoomer's Y offset %
00001c4a : 01c6cc63;   % 617:                 bgt t3,a3,PLAYER_COLLISION_ZOOMER_LOOP_HIT # If zoomer's Y offset is greater than the player's Y offset deal damage %
00001c4b : 02c0006f;   % 618:                     j NEXT_IN_PLAYER_COLLISION_ZOOMER_LOOP # Otherwise, zoomer isn't near player enough to deal damage, check next %
00001c4c : 00070863;   % 621:                 beqz a4,PLAYER_COLLISION_ZOOMER_LOOP_HIT  # If not on morph ball, it was a hit %
00001c4d : 0032ce03;   % 623:                 lbu t3,3(t0)   # Loads zoomer's Y offset %
00001c4e : 01c6c463;   % 624:                 bgt t3,a3,PLAYER_COLLISION_ZOOMER_LOOP_HIT # If zoomer's Y offset is greater than the player's Y offset deal damage %
00001c4f : 01c0006f;   % 625:                     j NEXT_IN_PLAYER_COLLISION_ZOOMER_LOOP # Otherwise, zoomer isn't near player enough to deal damage, check next %
00001c50 : 00000513;   % 629:                 li a0,0  # Hit was from same X %
00001c51 : 00800593;   % 630:                 li a1,8  # Damage dealt %
00001c52 : 00400633;   % 631:                 mv a2,tp # Gets direction %
00001c53 : 00000317;   % 632:                 call DAMAGE_PLAYER %
00001c54 : 978300e7;   % 632:  %
00001c55 : 2e40006f;   % 633:                 j END_PLAYER_COLLISION  # Player already took damage, end procedure here                %
00001c56 : 00c28293;   % 636:             addi t0,t0,12   # Going to the next zoomer's address                                   %
00001c57 : 00138393;   % 637:             addi t2,t2,1             # Iterating counter by 1                                    %
00001c58 : 0063d463;   % 638:             bge t2,t1, PLAYER_COLLISION_RIPPER # If all of the zoomers were checked, end loop                                   %
00001c59 : f11ff06f;   % 639:             j PLAYER_COLLISION_ZOOMER_LOOP # otherwise, go back to the loop's beginning                      %
00001c5a : 0fc09297;   % 642:     la t0,Rippers  # Loads Rippers address %
00001c5b : 2a028293;   % 642:  %
00001c5c : 0002a283;   % 644:     lw t0,0(t0)    # Loads the RippersA address over the Rippers address %
00001c5d : 00029463;   % 645:     bnez t0,CONTINUE_PLAYER_COLLISION_RIPPER  # If there are rippers in this map %
00001c5e : 2c00006f;   % 646:         j END_PLAYER_COLLISION             # If t0 = 0, there are no rippers in this map %
00001c5f : 0002c303;   % 650:     lbu t1,0(t0)   # Loads number of Rippers in current map %
00001c60 : 00000393;   % 651:     li t2,0        # Counter for rippers %
00001c61 : 00128293;   % 652:     addi t0,t0,1   # Goes to next byte (where rippers from current map start) %
00001c62 : 00300213;   % 655:         li tp, 3 # tp will start as 3 (random direction)  %
00001c63 : 0032ce03;   % 656:         lbu t3,3(t0)   # Loads ripper's current X %
00001c64 : 00ae0c63;   % 657:         beq t3,a0,PLAYER_COLLISION_RIPPER_LOOP_SAME_X   # If ripper's X is the same as the player's %
00001c65 : 00150e93;   % 658:         addi t4,a0,1   # Checks player's tile to the right %
00001c66 : 05de0263;   % 659:         beq t3,t4,PLAYER_COLLISION_RIPPER_LOOP_RIGHT_X  # If ripper's X is to the right of player %
00001c67 : fff50e93;   % 660:         addi t4,a0,-1  # Checks player's tile to the left %
00001c68 : 03de0263;   % 661:         beq t3,t4,PLAYER_COLLISION_RIPPER_LOOP_LEFT_X   # If ripper's X is to the left of player %
00001c69 : 0a40006f;   % 662:         j NEXT_IN_PLAYER_COLLISION_RIPPER_LOOP # Otherwise, ripper isn't near player enough to deal damage, check next %
00001c6a : 0022ce03;   % 665:             lbu t3,2(t0)   # Loads ripper's X offset %
00001c6b : 00ce0463;   % 666:             beq t3,a2,PLAYER_COLLISION_RIPPER_LOOP_SAME_X_RANDOM # If offsets are the same, randomize direction %
00001c6c : 00ce2233;   % 668:                 slt tp,t3,a2   # If t3 < a2, damage is from the left, otherwise, it is from the right  %
00001c6d : 00c00e93;   % 670:                 li t4,12       # to be compared with  %
00001c6e : 41c60e33;   % 671:                 sub t3,a2,t3   # t3 = ripper's x offset - player's x offset %
00001c6f : 03de4c63;   % 672:                 blt t3,t4,PLAYER_COLLISION_RIPPER_LOOP_CHECK_Y # If t3 < 12, continue %
00001c70 : 0880006f;   % 673:                     j NEXT_IN_PLAYER_COLLISION_RIPPER_LOOP # Otherwise, ripper isn't near player enough to deal damage, check next %
00001c71 : 0022ce03;   % 676:             lbu t3,2(t0)   # Loads ripper's X offset %
00001c72 : ffce0e13;   % 677:             addi t3,t3,-4  # subtracts 4 from it %
00001c73 : 01c65663;   % 678:             bge a2,t3,STOP_PLAYER_COLLISION_RIPPER_LOOP_LEFT_X # If t3 <= player offset, there wasn't a hit %
00001c74 : 00100213;   % 679:                 li tp,1    # Damage from the left %
00001c75 : 0200006f;   % 680:                 j PLAYER_COLLISION_RIPPER_LOOP_CHECK_Y %
00001c76 : 0700006f;   % 682:                 j NEXT_IN_PLAYER_COLLISION_RIPPER_LOOP # Ripper isn't near player enough to deal damage, check next %
00001c77 : 0022ce03;   % 685:             lbu t3,2(t0)   # Loads ripper's X offset %
00001c78 : 004e0e13;   % 686:             addi t3,t3,4   # adds 4 to it %
00001c79 : 00ce5663;   % 687:             bge t3,a2,STOP_PLAYER_COLLISION_RIPPER_LOOP_RIGHT_X # If t3 >= player offset, there wasn't a hit %
00001c7a : 00000213;   % 688:                 li tp,0    # Damage from the right %
00001c7b : 0080006f;   % 689:                 j PLAYER_COLLISION_RIPPER_LOOP_CHECK_Y %
00001c7c : 0580006f;   % 691:                 j NEXT_IN_PLAYER_COLLISION_RIPPER_LOOP # Ripper isn't near player enough to deal damage, check next %
00001c7d : 0052ce03;   % 694:             lbu t3,5(t0)   # Loads ripper's current Y %
00001c7e : 02be0263;   % 695:             beq t3,a1,PLAYER_COLLISION_RIPPER_LOOP_SAME_Y    # If ripper's Y is the same as the player's %
00001c7f : 00158e93;   % 696:             addi t4,a1,1   # Checks player's base tile (Y + 1) %
00001c80 : 03de0863;   % 697:             beq t3,t4,PLAYER_COLLISION_RIPPER_LOOP_HIT  # If ripper's Y on player's base %
00001c81 : 00258e93;   % 698:             addi t4,a1,2   # Checks bellow player's base tile (Y + 2) %
00001c82 : 01de0463;   % 699:             beq t3,t4,PLAYER_COLLISION_RIPPER_LOOP_BELLOW  # If ripper's X is bellow player %
00001c83 : 03c0006f;   % 701:             j NEXT_IN_PLAYER_COLLISION_RIPPER_LOOP # Ripper isn't near player enough to deal damage, check next %
00001c84 : 00700e13;   % 704:                 li t3, 7 # Ripper's Y offset is always 0, but we add 4 to it (sprite is 4 pixels bellow initial Y) %
00001c85 : 00de4e63;   % 705:                 blt t3,a3,PLAYER_COLLISION_RIPPER_LOOP_HIT # If ripper's "Y offset" is less than the player's Y offset deal damage %
00001c86 : 0300006f;   % 706:                     j NEXT_IN_PLAYER_COLLISION_RIPPER_LOOP # Otherwise, ripper isn't near player enough to deal damage, check next %
00001c87 : 00070463;   % 709:                 beqz a4,CONTINUE_PLAYER_COLLISION_RIPPER_LOOP_SAME_Y  # If not on morph ball, check it was a hit %
00001c88 : 0280006f;   % 711:                     j NEXT_IN_PLAYER_COLLISION_RIPPER_LOOP # Otherwise, ripper isn't near player enough to deal damage, check next %
00001c89 : 00c00e13;   % 714:                     li t3, 12 # Ripper's Y offset is always 0, but we add 12 to it (sprite end 4 lines befor its real end) %
00001c8a : 01c6c463;   % 715:                     bgt t3,a3,PLAYER_COLLISION_RIPPER_LOOP_HIT # If ripper's "Y offset" is greater than the player's Y offset deal damage %
00001c8b : 01c0006f;   % 716:                     j NEXT_IN_PLAYER_COLLISION_RIPPER_LOOP # Otherwise, ripper isn't near player enough to deal damage, check next %
00001c8c : 00000513;   % 720:                 li a0,0  # Hit was from same X %
00001c8d : 00800593;   % 721:                 li a1,8  # Damage dealt %
00001c8e : 00400633;   % 722:                 mv a2,tp # Gets direction %
00001c8f : 00000317;   % 723:                 call DAMAGE_PLAYER %
00001c90 : 888300e7;   % 723:  %
00001c91 : 1f40006f;   % 724:                 j END_PLAYER_COLLISION  # Player already took damage, end procedure here                %
00001c92 : 00728293;   % 727:             addi t0,t0,7   # Going to the next ripper's address                                   %
00001c93 : 00138393;   % 728:             addi t2,t2,1             # Iterating counter by 1                                    %
00001c94 : 0063d463;   % 729:             bge t2,t1, PLAYER_COLLISION_RIDLEY_SKIP # If all of the rippers were checked, end loop                                   %
00001c95 : f35ff06f;   % 730:             j PLAYER_COLLISION_RIPPER_LOOP # otherwise, go back to the loop's beginning   %
00001c96 : 1e00006f;   % 733:         j END_PLAYER_COLLISION %
00001c97 : 0fc09297;   % 736:         la t0,RIDLEY_INFO %
00001c98 : 1fc28293;   % 736:  %
00001c99 : 00028303;   % 737:         lb t1,0(t0) # Loads Ridley's health %
00001c9a : 00604463;   % 738:         blt zero,t1,CONTINUE_PLAYER_COLLISION_RIDLEY # If Ridley is alive %
00001c9b : 1cc0006f;   % 739:             j END_PLAYER_COLLISION %
00001c9c : 00100213;   % 742:         li tp, 1 # tp will start as left %
00001c9d : 00900e13;   % 743:         li t3,9   # Loads Ridley's current X %
00001c9e : 02ae0863;   % 744:         beq t3,a0,PLAYER_COLLISION_RIDLEY_CHECK_Y   # If Ridley's X is the same as the player's %
00001c9f : 00150e93;   % 745:         addi t4,a0,1   # Checks player's tile to the right %
00001ca0 : 01de0e63;   % 746:         beq t3,t4,PLAYER_COLLISION_RIDLEY_RIGHT_X  # If Ridley's X is to the right of player %
00001ca1 : fff50e93;   % 747:         addi t4,a0,-1  # Checks player's tile to the left %
00001ca2 : 01de0463;   % 748:         beq t3,t4,PLAYER_COLLISION_RIDLEY_LEFT_X   # If Ridley's X is to the left of player %
00001ca3 : 0900006f;   % 749:         j PLAYER_COLLISION_PLASMA_BREATH # Otherwise, Ridley isn't near player enough to deal damage, check Plasma Breath %
00001ca4 : 00600e13;   % 752:             li t3,6   # Loads Ridley's X offset %
00001ca5 : 01c64a63;   % 753:             blt a2,t3,PLAYER_COLLISION_RIDLEY_CHECK_Y # If t3 < player offset, check Y %
00001ca6 : 0840006f;   % 754:             j PLAYER_COLLISION_PLASMA_BREATH # Otherwise, Ridley isn't near player enough to deal damage, check Plasma Breath %
00001ca7 : 00600e13;   % 757:             li t3,6   # Loads Ridley's X offset %
00001ca8 : 00ce4463;   % 758:             blt t3,a2,PLAYER_COLLISION_RIDLEY_CHECK_Y # If t3 < player offset, there wasn't a hit %
00001ca9 : 0780006f;   % 759:             j PLAYER_COLLISION_PLASMA_BREATH # Otherwise, Ridley isn't near player enough to deal damage, check Plasma Breath        %
00001caa : 0032ce03;   % 762:             lbu t3,3(t0)   # Loads Ridley's current Y %
00001cab : 04be0c63;   % 763:             beq t3,a1,PLAYER_COLLISION_RIDLEY_HIT    # If Ridley's Y is the same as the player's (player would basically be inside him) %
00001cac : 00158e93;   % 764:             addi t4,a1,1   # Checks player's base tile (Y + 1) %
00001cad : 05de0863;   % 765:             beq t3,t4,PLAYER_COLLISION_RIDLEY_HIT    # If Ridley's Y on player's base, it's a hit (player would basically be inside him) %
00001cae : 00258e93;   % 766:             addi t4,a1,2   # Checks bellow player's base tile (Y + 2) %
00001caf : 03de0063;   % 767:             beq t3,t4,PLAYER_COLLISION_RIDLEY_BELLOW  # If Ridley's Y is bellow player %
00001cb0 : 001e0e13;   % 769:             addi t3,t3,1   # Gets ridley's Y + 1 %
00001cb1 : 04be0063;   % 770:             beq t3,a1,PLAYER_COLLISION_RIDLEY_HIT    # If Ridley's Y + 1 is the same as the player's, it's a hit (player would basically be inside him) %
00001cb2 : 001e0e13;   % 772:             addi t3,t3,1   # Gets ridley's Y + 2 %
00001cb3 : 02be0863;   % 773:             beq t3,a1,PLAYER_COLLISION_RIDLEY_SAME_Y    # If Ridley's Y is the same as the player's %
00001cb4 : fff58e93;   % 774:             addi t4,a1,-1  # Checks 1 tile above player's Y %
00001cb5 : 01de0a63;   % 775:             beq t3,t4,PLAYER_COLLISION_RIDLEY_ABOVE     # If Ridley's X is above the player %
00001cb6 : 0440006f;   % 777:             j PLAYER_COLLISION_PLASMA_BREATH # Otherwise, Ridley isn't near player enough to deal damage, check Plasma Breath  %
00001cb7 : 0022ce03;   % 780:                 lbu t3,2(t0)   # Loads Ridley's current Y offset %
00001cb8 : 02de4263;   % 781:                 blt t3,a3,PLAYER_COLLISION_RIDLEY_HIT # If Ridley's "Y offset" is less than the player's Y offset deal damage %
00001cb9 : 0380006f;   % 782:                     j PLAYER_COLLISION_PLASMA_BREATH # Otherwise, Ridley isn't near player enough to deal damage, check Plasma Breath  %
00001cba : 00070463;   % 785:                 beqz a4,CONTINUE_PLAYER_COLLISION_RIDLEY_ABOVE  # If not on morph ball, check if it was a hit %
00001cbb : 0300006f;   % 786:                     j PLAYER_COLLISION_PLASMA_BREATH # Otherwise, Ridley isn't near player enough to deal damage, check Plasma Breath  %
00001cbc : 0032ce03;   % 789:                 lbu t3,3(t0)   # Loads Ridley's Y offset %
00001cbd : e5c6c6e3;   % 790:                 bgt t3,a3,PLAYER_COLLISION_ZOOMER_LOOP_HIT # If Ridley's adjusted Y offset is greater than the player's Y offset deal damage %
00001cbe : 0240006f;   % 791:                     j PLAYER_COLLISION_PLASMA_BREATH # Otherwise, Ridley isn't near player enough to deal damage, check Plasma Breath  %
00001cbf : 00070463;   % 794:                 beqz a4,PLAYER_COLLISION_RIDLEY_HIT  # If not on morph ball, check it was a hit %
00001cc0 : 01c0006f;   % 796:                     j PLAYER_COLLISION_PLASMA_BREATH # Otherwise, Ridley isn't near player enough to deal damage, check Plasma Breath  %
00001cc1 : 00000513;   % 800:                 li a0,0  # Hit was from same X %
00001cc2 : 00800593;   % 801:                 li a1,8  # Damage dealt %
00001cc3 : 00400633;   % 802:                 mv a2,tp # Gets direction %
00001cc4 : fffff317;   % 803:                 call DAMAGE_PLAYER %
00001cc5 : 7b4300e7;   % 803:  %
00001cc6 : 1200006f;   % 804:                 j END_PLAYER_COLLISION  # Player already took damage, end procedure here      %
00001cc7 : 0fc09297;   % 807:         la t0,PLASMA_BREATH_ARRAY  # Loads Plasma breath array %
00001cc8 : 14c28293;   % 807:  %
00001cc9 : 00000393;   % 809:         li t2,0 # resets counter %
00001cca : 00500313;   % 810:         li t1,5 # gets number of plasma breaths in game %
00001ccb : 0002ce03;   % 812:             lbu t3,0(t0) # Loads enable byte %
00001ccc : 000e1463;   % 813:             bnez t3,PLAYER_COLLISION_PLASMA_BREATH_LOOP_CONTINUE    # If enabled, %
00001ccd : 0f40006f;   % 814:                 j NEXT_IN_PLAYER_COLLISION_PLASMA_BREATH_LOOP       # Otherwise, check other plasma breaths %
00001cce : 00300213;   % 817:             li tp, 3 # tp will start as 3 (random direction)  %
00001ccf : 0062ce03;   % 818:             lbu t3,6(t0)   # Loads plasma breath's current X %
00001cd0 : 00ae0c63;   % 819:             beq t3,a0,PLAYER_COLLISION_PLASMA_BREATH_LOOP_SAME_X   # If plasma breath's X is the same as the player's %
00001cd1 : 00150e93;   % 820:             addi t4,a0,1   # Checks player's tile to the right %
00001cd2 : 05de0263;   % 821:             beq t3,t4,PLAYER_COLLISION_PLASMA_BREATH_LOOP_RIGHT_X  # If plasma breath's X is to the right of player %
00001cd3 : fff50e93;   % 822:             addi t4,a0,-1  # Checks player's tile to the left %
00001cd4 : 03de0263;   % 823:             beq t3,t4,PLAYER_COLLISION_PLASMA_BREATH_LOOP_LEFT_X   # If plasma breath's X is to the left of player %
00001cd5 : 0d40006f;   % 824:             j NEXT_IN_PLAYER_COLLISION_PLASMA_BREATH_LOOP # Otherwise, plasma breath isn't near player enough to deal damage, check next %
00001cd6 : 0032ce03;   % 827:                 lbu t3,3(t0)   # Loads plasma breath's X offset %
00001cd7 : 00ce0463;   % 828:                 beq t3,a2,PLAYER_COLLISION_PLASMA_BREATH_LOOP_SAME_X_RANDOM # If offsets are the same, randomize direction %
00001cd8 : 00ce2233;   % 830:                     slt tp,t3,a2   # If t3 < a2, damage is from the left, otherwise, it is from the right  %
00001cd9 : 00c00e93;   % 832:                     li t4,12       # to be compared with  %
00001cda : 41c60e33;   % 833:                     sub t3,a2,t3   # t3 = plasma breath's x offset - player's x offset %
00001cdb : 03de4c63;   % 834:                     blt t3,t4,PLAYER_COLLISION_PLASMA_BREATH_LOOP_CHECK_Y # If t3 < 12, continue %
00001cdc : 0b80006f;   % 835:                         j NEXT_IN_PLAYER_COLLISION_PLASMA_BREATH_LOOP # Otherwise, plasma breath isn't near player enough to deal damage, check next %
00001cdd : 0032ce03;   % 838:                 lbu t3,3(t0)   # Loads plasma breath's X offset %
00001cde : ffce0e13;   % 839:                 addi t3,t3,-4  # subtracts 4 from it %
00001cdf : 01c65663;   % 840:                 bge a2,t3,STOP_PLAYER_COLLISION_PLASMA_BREATH_LOOP_LEFT_X # If t3 <= player offset, there wasn't a hit %
00001ce0 : 00100213;   % 841:                     li tp,1    # Damage from the left %
00001ce1 : 0200006f;   % 842:                     j PLAYER_COLLISION_PLASMA_BREATH_LOOP_CHECK_Y %
00001ce2 : 0a00006f;   % 844:                     j NEXT_IN_PLAYER_COLLISION_PLASMA_BREATH_LOOP # Zoomer isn't near player enough to deal damage, check next %
00001ce3 : 0032ce03;   % 847:                 lbu t3,3(t0)   # Loads plasma breath's X offset %
00001ce4 : 004e0e13;   % 848:                 addi t3,t3,4   # adds 4 to it %
00001ce5 : 00ce5663;   % 849:                 bge t3,a2,STOP_PLAYER_COLLISION_PLASMA_BREATH_LOOP_RIGHT_X # If t3 >= player offset, there wasn't a hit %
00001ce6 : 00000213;   % 850:                     li tp,0    # Damage from the right %
00001ce7 : 0080006f;   % 851:                     j PLAYER_COLLISION_PLASMA_BREATH_LOOP_CHECK_Y %
00001ce8 : 0880006f;   % 853:                     j NEXT_IN_PLAYER_COLLISION_PLASMA_BREATH_LOOP # Zoomer isn't near player enough to deal damage, check next %
00001ce9 : 0082ce03;   % 856:                 lbu t3,8(t0)   # Loads plasma breath's current Y %
00001cea : 04be0a63;   % 857:                 beq t3,a1,PLAYER_COLLISION_PLASMA_BREATH_LOOP_SAME_Y    # If plasma breath's Y is the same as the player's %
00001ceb : 00158e93;   % 858:                 addi t4,a1,1   # Checks player's base tile (Y + 1) %
00001cec : 03de0463;   % 859:                 beq t3,t4,PLAYER_COLLISION_PLASMA_BREATH_LOOP_BASE  # If plasma breath's Y on player's base %
00001ced : 00258e93;   % 860:                 addi t4,a1,2   # Checks bellow player's base tile (Y + 2) %
00001cee : 01de0863;   % 861:                 beq t3,t4,PLAYER_COLLISION_PLASMA_BREATH_LOOP_BELLOW  # If plasma breath's X is bellow player %
00001cef : fff58e93;   % 862:                 addi t4,a1,-1  # Checks 1 tile above player's Y %
00001cf0 : 03de0463;   % 863:                 beq t3,t4,PLAYER_COLLISION_PLASMA_BREATH_LOOP_ABOVE     # If plasma breath's X is above the player %
00001cf1 : 0640006f;   % 864:                 j NEXT_IN_PLAYER_COLLISION_PLASMA_BREATH_LOOP # Otherwise, plasma breath isn't near player enough to deal damage, check next %
00001cf2 : 0042ce03;   % 867:                     lbu t3,4(t0)   # Loads plasma breath's Y offset %
00001cf3 : 008e0e13;   % 868:                     addi t3,t3,8 %
00001cf4 : 02de4e63;   % 869:                     blt t3,a3,PLAYER_COLLISION_PLASMA_BREATH_LOOP_HIT # If plasma breath's Y offset is less than the player's Y offset deal damage %
00001cf5 : 0540006f;   % 870:                         j NEXT_IN_PLAYER_COLLISION_PLASMA_BREATH_LOOP # Otherwise, plasma breath isn't near player enough to deal damage, check next %
00001cf6 : 0042ce03;   % 873:                     lbu t3,4(t0)   # Loads plasma breath's Y offset %
00001cf7 : 008e0e13;   % 874:                     addi t3,t3,8 %
00001cf8 : 02de4663;   % 875:                     blt t3,a3,PLAYER_COLLISION_PLASMA_BREATH_LOOP_HIT # If plasma breath's Y offset is less than the player's Y offset deal damage %
00001cf9 : 0440006f;   % 876:                         j NEXT_IN_PLAYER_COLLISION_PLASMA_BREATH_LOOP # Otherwise, plasma breath isn't near player enough to deal damage, check next %
00001cfa : 00070463;   % 879:                     beqz a4,CONTINUE_PLAYER_COLLISION_PLASMA_BREATH_LOOP_ABOVE  # If not on morph ball, check if it was a hit %
00001cfb : 03c0006f;   % 880:                         j NEXT_IN_PLAYER_COLLISION_PLASMA_BREATH_LOOP # Otherwise, plasma breath isn't near player enough to deal damage, check next %
00001cfc : 0042ce03;   % 883:                     lbu t3,4(t0)   # Loads plasma breath's Y offset %
00001cfd : 01c6cc63;   % 884:                     bgt t3,a3,PLAYER_COLLISION_PLASMA_BREATH_LOOP_HIT # If plasma breath's Y offset is greater than the player's Y offset deal damage %
00001cfe : 0300006f;   % 885:                         j NEXT_IN_PLAYER_COLLISION_PLASMA_BREATH_LOOP # Otherwise, plasma breath isn't near player enough to deal damage, check next %
00001cff : 00070863;   % 888:                     beqz a4,PLAYER_COLLISION_PLASMA_BREATH_LOOP_HIT  # If not on morph ball, it was a hit %
00001d00 : 0042ce03;   % 890:                     lbu t3,4(t0)   # Loads plasma breath's Y offset %
00001d01 : 01c6c463;   % 891:                     bgt t3,a3,PLAYER_COLLISION_PLASMA_BREATH_LOOP_HIT # If plasma breath's Y offset is greater than the player's Y offset deal damage %
00001d02 : 0200006f;   % 892:                         j NEXT_IN_PLAYER_COLLISION_PLASMA_BREATH_LOOP # Otherwise, plasma breath isn't near player enough to deal damage, check next %
00001d03 : 00028023;   % 896:                     sb zero,0(t0)     # Disables plasma breath %
00001d04 : 00000513;   % 897:                     li a0,0  # Hit was from same X %
00001d05 : 00800593;   % 898:                     li a1,8  # Damage dealt %
00001d06 : 00400633;   % 899:                     mv a2,tp # Gets direction %
00001d07 : fffff317;   % 900:                     call DAMAGE_PLAYER %
00001d08 : 6a8300e7;   % 900:  %
00001d09 : 0140006f;   % 901:                     j END_PLAYER_COLLISION  # Player already took damage, end procedure here                 %
00001d0a : 00a28293;   % 904:             addi t0,t0,10  # Going to the next plasma breath's address                                   %
00001d0b : 00138393;   % 905:             addi t2,t2,1            # Iterating counter by 1                                    %
00001d0c : 0063d463;   % 906:             bge t2,t1, END_PLAYER_COLLISION       # If all of the plasma breaths were checked, end loop                               %
00001d0d : ef9ff06f;   % 907:             j PLAYER_COLLISION_PLASMA_BREATH_LOOP # otherwise, go back to the loop's beginning  %
00001d0e : 00012083;   % 911:         lw ra,0(sp) %
00001d0f : 00410113;   % 912:         addi sp,sp,4 %
00001d10 : 00008067;   % 914:         ret  %
00001d11 : ffc10113;   % 941:     addi sp,sp,-4 %
00001d12 : 00112023;   % 942:     sw ra,0(sp) %
00001d13 : 0fc09517;   % 944:     la a0,BEAMS_ARRAY   # Loads Beams array %
00001d14 : d2450513;   % 944:  %
00001d15 : 00150513;   % 945:     addi a0,a0,1        # skips cooldown byte %
00001d16 : 00000613;   % 947:     li a2,0             # resets counter %
00001d17 : 00300593;   % 948:     li a1,3  # gets number of beams in game %
00001d18 : 00054283;   % 950:         lbu t0,0(a0) # Loads enable byte %
00001d19 : 00029463;   % 951:         bnez t0,BEAM_COLLISION_LOOP_CONTINUE    # If enabled, %
00001d1a : 4600006f;   % 952:             j NEXT_IN_BEAM_COLLISION_LOOP       # Otherwise, check other beams %
00001d1b : 00554683;   % 955:         lbu a3, 5(a0)      # Loads Player's current X (matrix) %
00001d1c : 00754703;   % 956:         lbu a4, 7(a0)     # Loads Player's current Y (matrix)   %
00001d1d : 00354783;   % 957:         lbu a5, 3(a0)      # Loads Player's current X offset %
00001d1e : 00454803;   % 958:         lbu a6, 4(a0)      # Loads Player's current Y offset %
00001d1f : 0fc09297;   % 960:         la t0,CURRENT_MAP             # Loads map address %
00001d20 : ca828293;   % 960:  %
00001d21 : 0042c283;   % 961:         lbu t0,4(t0)                  # and from it, loads map's number %
00001d22 : 00700313;   % 962:         li t1,7                       # Loads 7 to compare with map's number %
00001d23 : 00629463;   % 963:         bne t0,t1,BEAM_COLLISION_SKIP_RIDLEY         # If not on map 7, skip Ridley and Plasma Breath >:D %
00001d24 : 2180006f;   % 964:             j BEAM_COLLISION_RIDLEY # Otherwise, skip the rest of the checks %
00001d25 : 0fc09297;   % 969:         la t0,Zoomers  # Loads Zoomers address %
00001d26 : db428293;   % 969:  %
00001d27 : 0002a283;   % 971:         lw t0,0(t0)    # Loads the ZoomersA address over the Zoomers address %
00001d28 : 00029463;   % 972:         bnez t0,CONTINUE_BEAM_COLLISION_ZOOMER  # If there are zoomers in this map %
00001d29 : 13c0006f;   % 973:             j BEAM_COLLISION_RIPPER             # If t0 = 0, there are no zoomers in this map %
00001d2a : 0002c303;   % 977:         lbu t1,0(t0)   # Loads number of Zoomers in current map %
00001d2b : 00000393;   % 978:         li t2,0        # Counter for zoomers %
00001d2c : 00128293;   % 979:         addi t0,t0,1   # Goes to next byte (where zoomers from current map start) %
00001d2d : 00028e03;   % 982:             lb t3,0(t0) # Loads zoomer's health %
00001d2e : 01c04463;   % 983:             blt zero,t3,CONTINUE_BEAM_COLLISION_ZOOMER_LOOP # If zoomer is alive %
00001d2f : 1140006f;   % 985:                 j NEXT_IN_BEAM_COLLISION_ZOOMER_LOOP %
00001d30 : 0042ce03;   % 988:             lbu t3,4(t0)   # Loads zoomer's current X %
00001d31 : 00de0c63;   % 989:             beq t3,a3,BEAM_COLLISION_ZOOMER_LOOP_SAME_X   # If zoomer's X is the same as the beam %
00001d32 : 00168e93;   % 990:             addi t4,a3,1   # Checks beam's tile to the right %
00001d33 : 03de0c63;   % 991:             beq t3,t4,BEAM_COLLISION_ZOOMER_LOOP_RIGHT_X  # If zoomer's X is to the right of beam %
00001d34 : fff68e93;   % 992:             addi t4,a3,-1  # Checks beam's tile to the left %
00001d35 : 03de0063;   % 993:             beq t3,t4,BEAM_COLLISION_ZOOMER_LOOP_LEFT_X   # If zoomer's X is to the left of beam %
00001d36 : 0f80006f;   % 994:             j NEXT_IN_BEAM_COLLISION_ZOOMER_LOOP # Otherwise, zoomer isn't near beam enough be hit, check next %
00001d37 : 0022ce03;   % 997:                     lbu t3,2(t0)   # Loads zoomer's X offset %
00001d38 : 02fe0a63;   % 998:                     beq t3,a5,BEAM_COLLISION_ZOOMER_LOOP_CHECK_Y # If offsets are the same, continue to check Y %
00001d39 : 00c00e93;   % 999:                     li t4,12       # to be compared with  %
00001d3a : 41c78e33;   % 1000:                     sub t3,a5,t3   # t3 = zoomer's x offset - beam's x offset %
00001d3b : 03de4463;   % 1001:                     blt t3,t4,BEAM_COLLISION_ZOOMER_LOOP_CHECK_Y # If t3 < 12, continue %
00001d3c : 0e00006f;   % 1002:                         j NEXT_IN_BEAM_COLLISION_ZOOMER_LOOP # Otherwise, zoomer isn't near beam enough be hit, check next %
00001d3d : 0022ce03;   % 1005:                     lbu t3,2(t0)   # Loads zoomer's X offset %
00001d3e : ff8e0e13;   % 1006:                     addi t3,t3,-8  # subtracts 4 from it %
00001d3f : 00fe5c63;   % 1007:                     bge t3,a5,BEAM_COLLISION_ZOOMER_LOOP_CHECK_Y # If t3 - 8 >= beam's offset, continue to check Y %
00001d40 : 0d00006f;   % 1008:                         j NEXT_IN_BEAM_COLLISION_ZOOMER_LOOP # Otherwise, zoomer isn't near beam enough be hit, check next %
00001d41 : 0022ce03;   % 1011:                     lbu t3,2(t0)   # Loads zoomer's X offset %
00001d42 : ff878e93;   % 1012:                     addi t4,a5,-8  # Subtracts 8 from beam offset %
00001d43 : 01c7d463;   % 1013:                     bge a5,t3,BEAM_COLLISION_ZOOMER_LOOP_CHECK_Y # If t3 <= beam's offset - 8, continue to check Y %
00001d44 : 0c00006f;   % 1014:                         j NEXT_IN_BEAM_COLLISION_ZOOMER_LOOP # Otherwise, zoomer isn't near beam enough be hit, check next %
00001d45 : 0062ce03;   % 1017:                 lbu t3,6(t0)   # Loads zoomer's current Y %
00001d46 : 00ee0e63;   % 1018:                 beq t3,a4,BEAM_COLLISION_ZOOMER_LOOP_SAME_Y    # If zoomer's Y is the same as the beam's %
00001d47 : 00170e93;   % 1019:                 addi t4,a4,1   # Checks beam's base tile (Y + 1) %
00001d48 : 01de0463;   % 1020:                 beq t3,t4,BEAM_COLLISION_ZOOMER_LOOP_BELLOW  # If zoomer's Y on beam's base %
00001d49 : 0ac0006f;   % 1021:                 j NEXT_IN_BEAM_COLLISION_ZOOMER_LOOP # Otherwise, zoomer isn't near beam enough be hit, check next %
00001d4a : 0032ce03;   % 1024:                     lbu t3,3(t0)   # Loads zoomer's Y offset %
00001d4b : 010e4c63;   % 1025:                     blt t3,a6,BEAM_COLLISION_ZOOMER_LOOP_HIT # If zoomer's Y offset is less than the beam's Y offset deal damage %
00001d4c : 0a00006f;   % 1026:                         j NEXT_IN_BEAM_COLLISION_ZOOMER_LOOP # Otherwise, zoomer isn't near beam enough be hit, check next %
00001d4d : 0032ce03;   % 1029:                     lbu t3,3(t0)   # Loads zoomer's Y  %
00001d4e : 008e0e13;   % 1030:                     addi t3,t3,8   #  %
00001d4f : 010e5463;   % 1031:                     bge t3,a6,BEAM_COLLISION_ZOOMER_LOOP_HIT # If zoomer's Y offset + 8 is greater than the beam's Y offset deal damage %
00001d50 : 0900006f;   % 1032:                         j NEXT_IN_BEAM_COLLISION_ZOOMER_LOOP # Otherwise, zoomer isn't near beam enough be hit, check next %
00001d51 : 0002ce03;   % 1036:                     lbu t3,0(t0)   # Loads zoomer's health %
00001d52 : 060e0c63;   % 1037:                     beqz t3,BEAM_COLLISION_ZOOMER_LOOP_HIT_DISABLE_BEAM    # Zoomer is already dead %
00001d53 : fffe0e13;   % 1038:                     addi t3,t3,-1  # Takes 1 away from it %
00001d54 : 000e0c63;   % 1039:                     beqz t3,BEAM_COLLISION_ZOOMER_LOOP_HIT_DESTROY_ZOOMER  # If zoomer is killed %
00001d55 : 01c28023;   % 1040:                         sb t3,0(t0)    # and stores it back %
00001d56 : 0012ce03;   % 1041:                         lbu t3,1(t0)   # Loads zoomer's type %
00001d57 : 002e0e13;   % 1042:                         addi t3,t3,2   # Adds 2 to it ( will go to damage state) %
00001d58 : 01c280a3;   % 1043:                         sb t3,1(t0)    # and stores it back %
00001d59 : 05c0006f;   % 1044:                         j BEAM_COLLISION_ZOOMER_LOOP_HIT_DISABLE_BEAM %
00001d5a : 00028023;   % 1047:                         sb zero,0(t0)  # Stores 0 to zoomer's health %
00001d5b : 0022c583;   % 1048:                         lbu a1,2(t0)   # Loads zoomer's X offset %
00001d5c : 0032c603;   % 1049:                         lbu a2,3(t0)   # Loads zoomer's Y offset %
00001d5d : 0042c683;   % 1050:                         lbu a3,4(t0)   # Loads zoomer's X  %
00001d5e : 0062c703;   % 1051:                         lbu a4,6(t0)   # Loads zoomer's Y %
00001d5f : 00000793;   % 1052:                         li a5,0        # No Delay %
00001d60 : ff810113;   % 1054:                             addi sp,sp,-8 %
00001d61 : 00a12023;   % 1055:                             sw a0,0(sp) %
00001d62 : 00512223;   % 1056:                             sw t0,4(sp) %
00001d63 : 00000513;   % 1059:                             li a0, 0       # Small explosion %
00001d64 : ffffc317;   % 1060:                             call EXPLOSION_SPAWN   # Summons explosion %
00001d65 : a54300e7;   % 1060:  %
00001d66 : 00412283;   % 1062:                             lw t0,4(sp)    # Restores zoomer's address %
00001d67 : 00b2c503;   % 1063:                             lbu a0,11(t0)  # Loads zoomer's loot value %
00001d68 : 0022c583;   % 1064:                             lbu a1,2(t0)   # Loads zoomer's X offset %
00001d69 : 0032c603;   % 1065:                             lbu a2,3(t0)   # Loads zoomer's Y offset %
00001d6a : 0042c683;   % 1066:                             lbu a3,4(t0)   # Loads zoomer's X  %
00001d6b : 0062c703;   % 1067:                             lbu a4,6(t0)   # Loads zoomer's Y %
00001d6c : ffffc317;   % 1068:                             call LOOT_SPAWN   # Summons explosion %
00001d6d : 85c300e7;   % 1068:  %
00001d6e : 00012503;   % 1071:                             lw a0,0(sp) %
00001d6f : 00810113;   % 1073:                             addi sp,sp,8 %
00001d70 : 00300313;   % 1078:                         li t1,3           # Loads "Hit to be Disabled"  %
00001d71 : 00650023;   % 1079:                         sb t1,0(a0)       # and stores it on enable byte %
00001d72 : 00050123;   % 1080:                         sb zero,2(a0)     # Resets render counter %
00001d73 : 2fc0006f;   % 1081:                         j NEXT_IN_BEAM_COLLISION_LOOP  # Beam was deactivated, end procedure here                %
00001d74 : 00c28293;   % 1084:                 addi t0,t0,12   # Going to the next zoomer's address                                   %
00001d75 : 00138393;   % 1085:                 addi t2,t2,1             # Iterating counter by 1                                    %
00001d76 : 0063d463;   % 1086:                 bge t2,t1, BEAM_COLLISION_RIPPER # If all of the zoomers were checked, end loop                                   %
00001d77 : ed9ff06f;   % 1087:                 j BEAM_COLLISION_ZOOMER_LOOP # otherwise, go back to the loop's beginning                      %
00001d78 : 0fc09297;   % 1090:         la t0,Rippers  # Loads Rippers address %
00001d79 : e2828293;   % 1090:  %
00001d7a : 0002a283;   % 1092:         lw t0,0(t0)    # Loads the RippersA address over the Rippers address %
00001d7b : 00029463;   % 1093:         bnez t0,CONTINUE_BEAM_COLLISION_RIPPER  # If there are rippers in this map %
00001d7c : 2d80006f;   % 1094:             j NEXT_IN_BEAM_COLLISION_LOOP             # If t0 = 0, there are no rippers in this map %
00001d7d : 0002c303;   % 1098:         lbu t1,0(t0)   # Loads number of Rippers in current map %
00001d7e : 00000393;   % 1099:         li t2,0        # Counter for rippers %
00001d7f : 00128293;   % 1100:         addi t0,t0,1   # Goes to next byte (where rippers from current map start) %
00001d80 : 00300213;   % 1103:             li tp, 3 # tp will start as 3 (random direction)  %
00001d81 : 0032ce03;   % 1104:             lbu t3,3(t0)   # Loads ripper's current X %
00001d82 : 00de0c63;   % 1105:             beq t3,a3,BEAM_COLLISION_RIPPER_LOOP_SAME_X   # If ripper's X is the same as the player's %
00001d83 : 00168e93;   % 1106:             addi t4,a3,1   # Checks player's tile to the right %
00001d84 : 03de0c63;   % 1107:             beq t3,t4,BEAM_COLLISION_RIPPER_LOOP_RIGHT_X  # If ripper's X is to the right of player %
00001d85 : fff68e93;   % 1108:             addi t4,a3,-1  # Checks player's tile to the left %
00001d86 : 03de0063;   % 1109:             beq t3,t4,BEAM_COLLISION_RIPPER_LOOP_LEFT_X   # If ripper's X is to the left of player %
00001d87 : 0780006f;   % 1110:             j NEXT_IN_BEAM_COLLISION_RIPPER_LOOP # Otherwise, ripper isn't near player enough to deal damage, check next %
00001d88 : 0022ce03;   % 1113:                 lbu t3,2(t0)   # Loads ripper's X offset %
00001d89 : 02fe0a63;   % 1114:                 beq t3,a5,BEAM_COLLISION_RIPPER_LOOP_CHECK_Y # If offsets are the same, continue to check Y %
00001d8a : 00c00e93;   % 1115:                 li t4,12       # to be compared with  %
00001d8b : 41c78e33;   % 1116:                 sub t3,a5,t3   # t3 = ripper's x offset - beam's x offset %
00001d8c : 03de4463;   % 1117:                 blt t3,t4,BEAM_COLLISION_RIPPER_LOOP_CHECK_Y # If t3 < 12, continue %
00001d8d : 0600006f;   % 1118:                     j NEXT_IN_BEAM_COLLISION_RIPPER_LOOP # Otherwise, ripper isn't near beam enough be hit, check next %
00001d8e : 0022ce03;   % 1121:                 lbu t3,2(t0)   # Loads ripper's X offset %
00001d8f : ff8e0e13;   % 1122:                 addi t3,t3,-8  # subtracts 4 from it %
00001d90 : 00fe5c63;   % 1123:                 bge t3,a5,BEAM_COLLISION_RIPPER_LOOP_CHECK_Y # If t3 - 8 >= beam's offset, continue to check Y %
00001d91 : 0500006f;   % 1124:                     j NEXT_IN_BEAM_COLLISION_RIPPER_LOOP # Otherwise, ripper isn't near beam enough be hit, check next %
00001d92 : 0022ce03;   % 1127:                 lbu t3,2(t0)   # Loads ripper's X offset %
00001d93 : ff878e93;   % 1128:                 addi t4,a5,-8  # Subtracts 8 from beam offset %
00001d94 : 01c7d463;   % 1129:                 bge a5,t3,BEAM_COLLISION_RIPPER_LOOP_CHECK_Y # If t3 <= beam's offset - 8, continue to check Y %
00001d95 : 0400006f;   % 1130:                     j NEXT_IN_BEAM_COLLISION_RIPPER_LOOP # Otherwise, ripper isn't near beam enough be hit, check next %
00001d96 : 0052ce03;   % 1133:                 lbu t3,5(t0)   # Loads ripper's current Y %
00001d97 : 00ee0e63;   % 1134:                 beq t3,a4,BEAM_COLLISION_RIPPER_LOOP_SAME_Y    # If ripper's Y is the same as the player's %
00001d98 : 00170e93;   % 1135:                 addi t4,a4,1   # Checks bellow beam (Y + 1) %
00001d99 : 01de0463;   % 1136:                 beq t3,t4,BEAM_COLLISION_RIPPER_LOOP_BELLOW  # If ripper's Y is bellow beam %
00001d9a : 02c0006f;   % 1138:                 j NEXT_IN_BEAM_COLLISION_RIPPER_LOOP # Otherwise, ripper isn't near beam enough be hit, check next %
00001d9b : 00700e13;   % 1141:                     li t3, 7 # Ripper's Y offset is always 0, but we add 7 to it (sprite is 4 pixels bellow initial Y) %
00001d9c : 010e4a63;   % 1142:                     blt t3,a6,BEAM_COLLISION_RIPPER_LOOP_HIT # If ripper's "Y offset" is less than the player's Y offset hit ripper %
00001d9d : 0200006f;   % 1143:                         j NEXT_IN_BEAM_COLLISION_RIPPER_LOOP # Otherwise, ripper isn't near beam enough be hit, check next %
00001d9e : 00c00e13;   % 1146:                     li t3, 12 # Ripper's Y offset is always 0, but we add 12 to it (sprite end 4 lines befor its real end) %
00001d9f : 01c84463;   % 1147:                     bgt t3,a6,BEAM_COLLISION_RIPPER_LOOP_HIT # If ripper's "Y offset" is greater than the player's Y offset hit ripper %
00001da0 : 0140006f;   % 1148:                         j NEXT_IN_BEAM_COLLISION_RIPPER_LOOP # Otherwise, ripper isn't near beam enough be hit, check next %
00001da1 : 00300313;   % 1152:                     li t1,3           # Loads "Hit to be Disabled"  %
00001da2 : 00650023;   % 1153:                     sb t1,0(a0)       # and stores it on enable byte %
00001da3 : 00050123;   % 1154:                     sb zero,2(a0)     # Resets render counter %
00001da4 : 2380006f;   % 1155:                     j NEXT_IN_BEAM_COLLISION_LOOP  # Beam was deactivated, end procedure here             %
00001da5 : 00728293;   % 1158:                 addi t0,t0,7   # Going to the next ripper's address                                   %
00001da6 : 00138393;   % 1159:                 addi t2,t2,1             # Iterating counter by 1                                    %
00001da7 : 0063d463;   % 1160:                 bge t2,t1, BEAM_COLLISION_RIDLEY_SKIP # If all of the rippers were checked, end loop                                   %
00001da8 : f61ff06f;   % 1161:                 j BEAM_COLLISION_RIPPER_LOOP # otherwise, go back to the loop's beginning   %
00001da9 : 2240006f;   % 1164:             j NEXT_IN_BEAM_COLLISION_LOOP %
00001daa : 0fc09297;   % 1167:             la t0,RIDLEY_INFO %
00001dab : db028293;   % 1167:  %
00001dac : 00028303;   % 1168:             lb t1,0(t0) # Loads Ridley's health %
00001dad : 00604463;   % 1169:             blt zero,t1,CONTINUE_BEAM_COLLISION_RIDLEY # If Ridley is alive %
00001dae : 2100006f;   % 1170:                 j NEXT_IN_BEAM_COLLISION_LOOP %
00001daf : 00100213;   % 1173:             li tp, 1 # tp will start as left %
00001db0 : 00900e13;   % 1174:             li t3,9   # Loads Ridley's current X %
00001db1 : 02de0863;   % 1175:             beq t3,a3,BEAM_COLLISION_RIDLEY_CHECK_Y   # If Ridley's X is the same as the beam's %
00001db2 : 00168e93;   % 1176:             addi t4,a3,1   # Checks beam's tile to the right %
00001db3 : 01de0e63;   % 1177:             beq t3,t4,BEAM_COLLISION_RIDLEY_RIGHT_X  # If Ridley's X is to the right of beam %
00001db4 : fff68e93;   % 1178:             addi t4,a3,-1  # Checks beam's tile to the left %
00001db5 : 01de0463;   % 1179:             beq t3,t4,BEAM_COLLISION_RIDLEY_LEFT_X   # If Ridley's X is to the left of beam %
00001db6 : 1240006f;   % 1180:             j BEAM_COLLISION_PLASMA_BREATH # Otherwise, Ridley isn't near beam to be hit, check Plasma Breath %
00001db7 : 00600e13;   % 1183:                 li t3,6   # Loads Ridley's X offset %
00001db8 : 01c7ca63;   % 1184:                 blt a5,t3,BEAM_COLLISION_RIDLEY_CHECK_Y # If t3 < beam offset, check Y %
00001db9 : 1180006f;   % 1185:                 j BEAM_COLLISION_PLASMA_BREATH # Otherwise, Ridley isn't near beam to be hit, check Plasma Breath %
00001dba : 00600e13;   % 1188:                 li t3,6   # Loads Ridley's X offset %
00001dbb : 00fe4463;   % 1189:                 blt t3,a5,BEAM_COLLISION_RIDLEY_CHECK_Y # If t3 < beam offset, there wasn't a hit %
00001dbc : 10c0006f;   % 1190:                 j BEAM_COLLISION_PLASMA_BREATH # Otherwise, Ridley isn't near beam to be hit, check Plasma Breath      %
00001dbd : 0032ce03;   % 1193:                 lbu t3,3(t0)   # Loads Ridley's current Y %
00001dbe : 02ee0e63;   % 1194:                 beq t3,a4,BEAM_COLLISION_RIDLEY_HIT    # If Ridley's Y is the same as the beam's (beam would basically be inside him) %
00001dbf : 00170e93;   % 1195:                 addi t4,a4,1   # Checks beam's base tile (Y + 1) %
00001dc0 : 01de0c63;   % 1196:                 beq t3,t4,BEAM_COLLISION_RIDLEY_BELLOW  # If Ridley's Y is bellow beam %
00001dc1 : 001e0e13;   % 1198:                 addi t3,t3,1   # Gets ridley's Y + 1 %
00001dc2 : 02ee0663;   % 1199:                 beq t3,a4,BEAM_COLLISION_RIDLEY_HIT    # If Ridley's Y + 1 is the same as the beam's, it's a hit (beam would basically be inside him) %
00001dc3 : 001e0e13;   % 1201:                 addi t3,t3,1   # Gets ridley's Y + 2 %
00001dc4 : 00ee0a63;   % 1202:                 beq t3,a4,BEAM_COLLISION_RIDLEY_SAME_Y    # If Ridley's Y + 2 is the same as the beam's %
00001dc5 : 0e80006f;   % 1204:                 j BEAM_COLLISION_PLASMA_BREATH # Otherwise, Ridley isn't near beam to be hit, check Plasma Breath    %
00001dc6 : 0022ce03;   % 1207:                     lbu t3,2(t0)   # Loads Ridley's current Y offset %
00001dc7 : 010e4c63;   % 1208:                     blt t3,a6,BEAM_COLLISION_RIDLEY_HIT # If Ridley's "Y offset" is less than the beam's Y offset deal damage %
00001dc8 : 0dc0006f;   % 1209:                         j BEAM_COLLISION_PLASMA_BREATH # Otherwise, Ridley isn't near beam to be hit, check Plasma Breath    %
00001dc9 : 0022ce03;   % 1212:                     lbu t3,2(t0)   # Loads Ridley's current Y offset %
00001dca : 008e0e13;   % 1213:                     addi t3,t3,8   #  %
00001dcb : 010e5463;   % 1214:                     bge t3,a6,BEAM_COLLISION_RIDLEY_HIT # If ridley's Y offset + 8 is greater than the beam's Y offset deal damage %
00001dcc : 0cc0006f;   % 1215:                         j BEAM_COLLISION_PLASMA_BREATH # Otherwise, Ridley isn't near beam to be hit, check Plasma Breath    %
00001dcd : 0002ce03;   % 1219:                     lbu t3,0(t0)   # Loads Ridley's health %
00001dce : 0a0e0a63;   % 1220:                     beqz t3,BEAM_COLLISION_RIDLEY_HIT_DISABLE_BEAM %
00001dcf : fffe0e13;   % 1221:                     addi t3,t3,-1  # Takes 1 away from it %
00001dd0 : 000e0c63;   % 1222:                     beqz t3,BEAM_COLLISION_RIDLEY_HIT_DESTROY_RIDLEY  # If Ridley is killed %
00001dd1 : 01c28023;   % 1223:                         sb t3,0(t0)    # and stores it back %
00001dd2 : 0012ce03;   % 1224:                         lbu t3,1(t0)   # Loads Ridley's type %
00001dd3 : 001e0e13;   % 1225:                         addi t3,t3,1   # Adds 1 to it ( will go to damage state) %
00001dd4 : 01c280a3;   % 1226:                         sb t3,1(t0)    # and stores it back %
00001dd5 : 0980006f;   % 1227:                         j BEAM_COLLISION_RIDLEY_HIT_DISABLE_BEAM %
00001dd6 : 00028023;   % 1230:                         sb zero,0(t0)  # Stores 0 to Ridley's health %
00001dd7 : 00600593;   % 1231:                         li a1,6   # Loads Ridley's X offset %
00001dd8 : 0022c603;   % 1232:                         lbu a2,2(t0)            # Loads Ridley's Y offset %
00001dd9 : 00900693;   % 1233:                         li a3,9          # Loads Ridley's X  %
00001dda : 0032c703;   % 1234:                         lbu a4,3(t0)            # Loads Ridley's Y %
00001ddb : 00000793;   % 1235:                         li a5,0        # No Delay %
00001ddc : ffc10113;   % 1237:                             addi sp,sp,-4 %
00001ddd : 00a12023;   % 1238:                             sw a0,0(sp) %
00001dde : 00100513;   % 1240:                             li a0, 1               # Big explosion %
00001ddf : ffffc317;   % 1241:                             call EXPLOSION_SPAWN   # Summons explosion %
00001de0 : 868300e7;   % 1241:  %
00001de1 : 0fc09297;   % 1243:                             la t0,RIDLEY_INFO %
00001de2 : cd428293;   % 1243:  %
00001de3 : 00600593;   % 1244:                             li a1,6   # Loads Ridley's X offset %
00001de4 : 0022c603;   % 1245:                             lbu a2,2(t0)            # Loads Ridley's Y offset %
00001de5 : 00900693;   % 1246:                             li a3,9          # Loads Ridley's X  %
00001de6 : 00168693;   % 1247:                             addi a3,a3,1 %
00001de7 : 0032c703;   % 1248:                             lbu a4,3(t0)            # Loads Ridley's Y %
00001de8 : 00170713;   % 1249:                             addi a4,a4,1 %
00001de9 : 00000793;   % 1250:                             li a5,0        # No Delay %
00001dea : 00100513;   % 1251:                             li a0, 1               # Big explosion %
00001deb : ffffc317;   % 1252:                             call EXPLOSION_SPAWN   # Summons explosion %
00001dec : 838300e7;   % 1252:  %
00001ded : 0fc09297;   % 1254:                             la t0,RIDLEY_INFO %
00001dee : ca428293;   % 1254:  %
00001def : 00600593;   % 1255:                             li a1,6   # Loads Ridley's X offset %
00001df0 : 0022c603;   % 1256:                             lbu a2,2(t0)            # Loads Ridley's Y offset %
00001df1 : 00900693;   % 1257:                             li a3,9          # Loads Ridley's X  %
00001df2 : fff68693;   % 1258:                             addi a3,a3,-1 %
00001df3 : 0032c703;   % 1259:                             lbu a4,3(t0)            # Loads Ridley's Y %
00001df4 : 00270713;   % 1260:                             addi a4,a4,2 %
00001df5 : 00000793;   % 1261:                             li a5,0        # No Delay %
00001df6 : 00100513;   % 1262:                             li a0, 1               # Big explosion %
00001df7 : ffffc317;   % 1263:                             call EXPLOSION_SPAWN   # Summons explosion %
00001df8 : 808300e7;   % 1263:  %
00001df9 : 00012503;   % 1265:                             lw a0,0(sp) %
00001dfa : 00410113;   % 1266:                             addi sp,sp,4 %
00001dfb : 00300313;   % 1272:                         li t1,3           # Loads "Hit to be Disabled"  %
00001dfc : 00650023;   % 1273:                         sb t1,0(a0)       # and stores it on enable byte %
00001dfd : 00050123;   % 1274:                         sb zero,2(a0)     # Resets render counter %
00001dfe : 0d00006f;   % 1275:                         j NEXT_IN_BEAM_COLLISION_LOOP  # Beam was deactivated, end procedure here          %
00001dff : 0fc09297;   % 1278:             la t0,PLASMA_BREATH_ARRAY  # Loads Plasma breath array %
00001e00 : c6c28293;   % 1278:  %
00001e01 : 00000393;   % 1280:             li t2,0 # resets counter %
00001e02 : 00500313;   % 1281:             li t1,5 # gets number of plasma breaths in game %
00001e03 : 0002ce03;   % 1283:                 lbu t3,0(t0) # Loads enable byte %
00001e04 : 000e1463;   % 1284:                 bnez t3,BEAM_COLLISION_PLASMA_BREATH_LOOP_CONTINUE    # If enabled, %
00001e05 : 0a40006f;   % 1285:                     j NEXT_IN_BEAM_COLLISION_PLASMA_BREATH_LOOP       # Otherwise, check other plasma breaths %
00001e06 : 00300213;   % 1288:                 li tp, 3 # tp will start as 3 (random direction)  %
00001e07 : 0062ce03;   % 1289:                 lbu t3,6(t0)   # Loads plasma breath's current X %
00001e08 : 00de0c63;   % 1290:                 beq t3,a3,BEAM_COLLISION_PLASMA_BREATH_LOOP_SAME_X   # If plasma breath's X is the same as the beam's %
00001e09 : 00168e93;   % 1291:                 addi t4,a3,1   # Checks beam's tile to the right %
00001e0a : 03de0c63;   % 1292:                 beq t3,t4,BEAM_COLLISION_PLASMA_BREATH_LOOP_RIGHT_X  # If plasma breath's X is to the right of beam %
00001e0b : fff68e93;   % 1293:                 addi t4,a3,-1  # Checks beam's tile to the left %
00001e0c : 03de0063;   % 1294:                 beq t3,t4,BEAM_COLLISION_PLASMA_BREATH_LOOP_LEFT_X   # If plasma breath's X is to the left of beam %
00001e0d : 0840006f;   % 1295:                 j NEXT_IN_BEAM_COLLISION_PLASMA_BREATH_LOOP # Otherwise, plasma breath isn't near beam enough to deal damage, check next %
00001e0e : 0032ce03;   % 1298:                         lbu t3,3(t0)   # Loads plasma breath's X offset %
00001e0f : 02fe0a63;   % 1299:                         beq t3,a5,BEAM_COLLISION_PLASMA_BREATH_LOOP_CHECK_Y # If offsets are the same, continue to check Y %
00001e10 : 00c00e93;   % 1300:                         li t4,12       # to be compared with  %
00001e11 : 41c78e33;   % 1301:                         sub t3,a5,t3   # t3 = plasma breath's x offset - beam's x offset %
00001e12 : 03de4463;   % 1302:                         blt t3,t4,BEAM_COLLISION_PLASMA_BREATH_LOOP_CHECK_Y # If t3 < 12, continue %
00001e13 : 06c0006f;   % 1303:                             j NEXT_IN_BEAM_COLLISION_PLASMA_BREATH_LOOP # Otherwise, plasma breath isn't near beam enough be hit, check next                   %
00001e14 : 0032ce03;   % 1306:                         lbu t3,3(t0)   # Loads plasma breath's X offset %
00001e15 : ff8e0e13;   % 1307:                         addi t3,t3,-8  # subtracts 4 from it %
00001e16 : 00fedc63;   % 1308:                         bge t4,a5,BEAM_COLLISION_PLASMA_BREATH_LOOP_CHECK_Y # If t3 <= player offset, there wasn't a hit %
00001e17 : 05c0006f;   % 1309:                             j NEXT_IN_BEAM_COLLISION_PLASMA_BREATH_LOOP # Otherwise, plasma breath isn't near beam enough be hit, check next %
00001e18 : 0032ce03;   % 1312:                         lbu t3,3(t0)   # Loads plasma breath's X offset %
00001e19 : ff8e0e13;   % 1313:                         addi t3,t3,-8  # subtracts 4 from it %
00001e1a : 00fe5463;   % 1314:                         bge t3,a5,BEAM_COLLISION_PLASMA_BREATH_LOOP_CHECK_Y # If t3 - 8 >= beam's offset, continue to check Y %
00001e1b : 04c0006f;   % 1315:                             j NEXT_IN_BEAM_COLLISION_PLASMA_BREATH_LOOP # Otherwise, plasma breath isn't near beam enough be hit, check next %
00001e1c : 0082ce03;   % 1318:                     lbu t3,8(t0)   # Loads plasma breath's current Y %
00001e1d : 02ee0063;   % 1319:                     beq t3,a4,BEAM_COLLISION_PLASMA_BREATH_LOOP_SAME_Y    # If plasma breath's Y is the same as the beam's %
00001e1e : 00170e93;   % 1320:                     addi t4,a4,1   # Checks beam's base tile (Y + 1) %
00001e1f : 01de0463;   % 1321:                     beq t3,t4,BEAM_COLLISION_PLASMA_BREATH_LOOP_BELLOW  # If plasma breath's X is bellow beam %
00001e20 : 0380006f;   % 1322:                         j NEXT_IN_BEAM_COLLISION_PLASMA_BREATH_LOOP # Otherwise, plasma breath isn't near beam enough be hit, check next %
00001e21 : 0042ce03;   % 1325:                         lbu t3,4(t0)   # Loads plasma breath's Y offset %
00001e22 : 008e0e13;   % 1326:                         addi t3,t3,8 %
00001e23 : 010e4c63;   % 1327:                         blt t3,a6,BEAM_COLLISION_PLASMA_BREATH_LOOP_HIT # If plasma breath's Y offset is less than the beam's Y offset deal damage %
00001e24 : 0280006f;   % 1328:                             j NEXT_IN_BEAM_COLLISION_PLASMA_BREATH_LOOP # Otherwise, plasma breath isn't near beam enough be hit, check next %
00001e25 : 0042ce03;   % 1331:                         lbu t3,4(t0)   # Loads plasma breath's Y offset %
00001e26 : 008e0e13;   % 1332:                         addi t3,t3,8   #  %
00001e27 : 010e5463;   % 1333:                         bge t3,a6,BEAM_COLLISION_PLASMA_BREATH_LOOP_HIT # If plasma breath's Y offset + 8 is greater than the beam's Y offset deal damage %
00001e28 : 0180006f;   % 1334:                             j NEXT_IN_BEAM_COLLISION_PLASMA_BREATH_LOOP # Otherwise, plasma breath isn't near beam enough be hit, check next %
00001e29 : 00028023;   % 1338:                         sb zero,0(t0)     # Disables plasma breath %
00001e2a : 00300313;   % 1339:                         li t1,3           # Loads "Hit to be Disabled"  %
00001e2b : 00650023;   % 1340:                         sb t1,0(a0)       # and stores it on enable byte %
00001e2c : 00050123;   % 1341:                         sb zero,2(a0)     # Resets render counter %
00001e2d : 0140006f;   % 1342:                         j NEXT_IN_BEAM_COLLISION_LOOP  # Beam was deactivated, end procedure here            %
00001e2e : 00a28293;   % 1345:                 addi t0,t0,10  # Going to the next plasma breath's address                                   %
00001e2f : 00138393;   % 1346:                 addi t2,t2,1            # Iterating counter by 1                                    %
00001e30 : 0063d463;   % 1347:                 bge t2,t1, NEXT_IN_BEAM_COLLISION_LOOP       # If all of the plasma breaths were checked, end loop                               %
00001e31 : f49ff06f;   % 1348:                 j BEAM_COLLISION_PLASMA_BREATH_LOOP # otherwise, go back to the loop's beginning  %
00001e32 : 00950513;   % 1351:             addi a0,a0,9  # Going to the next beam's address                                   %
00001e33 : 00160613;   % 1352:             addi a2,a2,1            # Iterating counter by 1                                    %
00001e34 : 00b65463;   % 1353:             bge a2,a1, END_BEAM_COLLISION # If all of the beams were checked, end loop (don't attack)                                 %
00001e35 : b8dff06f;   % 1354:             j BEAM_COLLISION_LOOP # otherwise, go back to the loop's beginning  %
00001e36 : 00012083;   % 1359:         lw ra,0(sp) %
00001e37 : 00410113;   % 1360:         addi sp,sp,4 %
00001e38 : 00008067;   % 1362:         ret  %
00001e39 : ffc10113;   % 1386:     addi sp,sp,-4 %
00001e3a : 00112023;   % 1387:     sw ra,0(sp) %
00001e3b : 0fc09597;   % 1391:     la a1,CURRENT_MAP    # Won't check for bombs when map is moving %
00001e3c : 83858593;   % 1391:  %
00001e3d : 0005a583;   % 1392:     lw a1,0(a1)          # Gets current map address %
00001e3e : 0015c783;   % 1395:     lbu a5,1(a1)     # Loads map's matrix width %
00001e3f : 00554803;   % 1396:     lbu a6,5(a0)     # Loads Bomb's current X %
00001e40 : 00754883;   % 1397:     lbu a7,7(a0)     # Loads Bomb's current Y %
00001e41 : 00358593;   % 1399:     addi a1,a1,3     # Adds 3 to the Matrix's address so that it goes to the beginning of matrix %
00001e42 : 02f882b3;   % 1400:     mul t0,a7,a5     # (Bomb's matrix Y + 3)  * Map Matrix's width %
00001e43 : 005802b3;   % 1401:     add t0,a6,t0     # t0 = Bomb's X related to matrix + (Bomb's matrix Y + 3)  * Map Matrix's width %
00001e44 : 005585b3;   % 1402:     add a1,a1,t0     # a1 = Map Matrix's address adjusted for Bomb's X and Y (+3) related to matrix        %
00001e45 : 40f585b3;   % 1405:     sub a1,a1,a5     # Moves matrix one tile up  %
00001e46 : fff88893;   % 1406:     addi a7,a7,-1    # Moves Y one tile up %
00001e47 : 00354e03;   % 1409:     lbu t3,3(a0)     # Loads Bomb's X offset %
00001e48 : 00800293;   % 1410:     li t0, 8   # Loads number 8 for comparing with X offset  %
00001e49 : 005e4a63;   % 1411:     blt t3,t0, START_BREAK_BOMB_COLLISION # If X offset < 8, just check one tile bellow, and consider right doors %
00001e4a : 01c2c463;   % 1412:     blt t0,t3, BOMB_COLLISION_RIGHT # If X offset > 8, check one tile bellow to the right , and consider left doors %
00001e4b : 00c0006f;   % 1414:         j START_BREAK_BOMB_COLLISION            %
00001e4c : 00158593;   % 1418:         addi a1,a1, 1 # Looks to the tile on the right of Bomb's current tile %
00001e4d : 00180813;   % 1419:         addi a6,a6,1  # Increments current X on matrix (+1 X) %
00001e4e : fec10113;   % 1424:         addi sp,sp,-20 %
00001e4f : 00d12823;   % 1425:         sw a3,16(sp) %
00001e50 : 00c12623;   % 1426:         sw a2,12(sp) %
00001e51 : 00b12423;   % 1427:         sw a1,8(sp) %
00001e52 : 00a12223;   % 1428:         sw a0,4(sp) %
00001e53 : 00112023;   % 1429:         sw ra,0(sp) %
00001e54 : 00000513;   % 1431:         li a0,0  # Doesn't matter, since no doors will be checked %
00001e55 : 00300613;   % 1433:         li a2, 3  # Will check 3 tiles %
00001e56 : 00000693;   % 1434:         li a3, 0  # "Horizontal" check  -> will check 3 tiles in a vertical line %
00001e57 : 00000713;   % 1435:         li a4, 0  # Base case: Don't consider doors %
00001e58 : 00300213;   % 1439:         li tp, 3  # Entity collision %
00001e59 : 00001317;   % 1440:         call CHECK_MAP_COLLISION %
00001e5a : f98300e7;   % 1440:  %
00001e5b : 00a002b3;   % 1441:         mv t0,a0 %
00001e5c : 01012683;   % 1444:         lw a3,16(sp) %
00001e5d : 00c12603;   % 1445:         lw a2,12(sp) %
00001e5e : 00812583;   % 1446:         lw a1,8(sp) %
00001e5f : 00412503;   % 1447:         lw a0,4(sp) %
00001e60 : 00012083;   % 1448:         lw ra,0(sp) %
00001e61 : 01410113;   % 1449:         addi sp,sp,20 %
00001e62 : 00354e03;   % 1452:     lbu t3,3(a0)     # Loads Bomb's X offset %
00001e63 : 00800293;   % 1453:     li t0, 8   # Loads number 8 for comparing with X offset  %
00001e64 : 07c29263;   % 1454:     bne t0,t3,SKIP_SECOND_BREAK_BOMB_COLLISION %
00001e65 : fec10113;   % 1457:         addi sp,sp,-20 %
00001e66 : 00d12823;   % 1458:         sw a3,16(sp) %
00001e67 : 00c12623;   % 1459:         sw a2,12(sp) %
00001e68 : 00b12423;   % 1460:         sw a1,8(sp) %
00001e69 : 00a12223;   % 1461:         sw a0,4(sp) %
00001e6a : 00112023;   % 1462:         sw ra,0(sp) %
00001e6b : 00554803;   % 1464:         lbu a6,5(a0)     # Loads Bomb's current X %
00001e6c : 00754883;   % 1465:         lbu a7,7(a0)     # Loads Bomb's current Y %
00001e6d : fff88893;   % 1466:         addi a7,a7,-1 %
00001e6e : 00000513;   % 1467:         li a0,0  # Doesn't matter, since no doors will be checked %
00001e6f : 00158593;   % 1468:         addi a1,a1,1   %
00001e70 : 00300613;   % 1469:         li a2, 3  # Will check 3 tiles %
00001e71 : 00000693;   % 1470:         li a3, 0  # "Horizontal" check  -> will check 3 tiles in a vertical line %
00001e72 : 00000713;   % 1471:         li a4, 0  # Base case: Don't consider doors %
00001e73 : 00180813;   % 1473:         addi a6,a6,1 %
00001e74 : 00300213;   % 1475:         li tp, 3  # Entity collision %
00001e75 : 00001317;   % 1477:         call CHECK_MAP_COLLISION %
00001e76 : f28300e7;   % 1477:  %
00001e77 : 01012683;   % 1480:         lw a3,16(sp) %
00001e78 : 00c12603;   % 1481:         lw a2,12(sp) %
00001e79 : 00812583;   % 1482:         lw a1,8(sp) %
00001e7a : 00412503;   % 1483:         lw a0,4(sp) %
00001e7b : 00012083;   % 1484:         lw ra,0(sp) %
00001e7c : 01410113;   % 1485:         addi sp,sp,20 %
00001e7d : 00554583;   % 1489:     lbu a1, 5(a0)      # Loads Player's current X (matrix) %
00001e7e : 00754603;   % 1490:     lbu a2, 7(a0)     # Loads Player's current Y (matrix)   %
00001e7f : 00354683;   % 1491:     lbu a3, 3(a0)      # Loads Player's current X offset %
00001e80 : 00454703;   % 1492:     lbu a4, 4(a0)      # Loads Player's current Y offset %
00001e81 : 0fc08297;   % 1494:     la t0,CURRENT_MAP             # Loads map address %
00001e82 : 72028293;   % 1494:  %
00001e83 : 0042c283;   % 1495:     lbu t0,4(t0)                  # and from it, loads map's number %
00001e84 : 00700313;   % 1496:     li t1,7                       # Loads 7 to compare with map's number %
00001e85 : 00629463;   % 1497:     bne t0,t1,BOMB_COLLISION_SKIP_RIDLEY         # If not on map 7, skip Ridley and Plasma Breath >:D %
00001e86 : 1140006f;   % 1498:         j BOMB_COLLISION_RIDLEY # Otherwise, skip the rest of the checks %
00001e87 : 0fc09297;   % 1503:     la t0,Zoomers  # Loads Zoomers address %
00001e88 : 82c28293;   % 1503:  %
00001e89 : 0002a283;   % 1505:     lw t0,0(t0)    # Loads the ZoomersA address over the Zoomers address %
00001e8a : 00029463;   % 1506:     bnez t0,CONTINUE_BOMB_COLLISION_ZOOMER  # If there are zoomers in this map %
00001e8b : 0fc0006f;   % 1507:         j BOMB_COLLISION_RIDLEY_SKIP        # If t0 = 0, there are no zoomers in this map %
00001e8c : 0002c303;   % 1511:     lbu t1,0(t0)   # Loads number of Zoomers in current map %
00001e8d : 00000393;   % 1512:     li t2,0        # Counter for zoomers %
00001e8e : 00128293;   % 1513:     addi t0,t0,1   # Goes to next byte (where zoomers from current map start) %
00001e8f : 00028e03;   % 1516:         lb t3,0(t0) # Loads zoomer's health %
00001e90 : 01c04463;   % 1517:         blt zero,t3,CONTINUE_BOMB_COLLISION_ZOOMER_LOOP # If zoomer is alive %
00001e91 : 0d40006f;   % 1519:             j NEXT_IN_BOMB_COLLISION_ZOOMER_LOOP %
00001e92 : 0042ce03;   % 1522:         lbu t3,4(t0)   # Loads zoomer's current X %
00001e93 : 00be0c63;   % 1523:         beq t3,a1,BOMB_COLLISION_ZOOMER_LOOP_CHECK_Y   # If zoomer's X is the same as the beam %
00001e94 : 00158e93;   % 1524:         addi t4,a1,1   # Checks beam's tile to the right %
00001e95 : 01de0863;   % 1525:         beq t3,t4,BOMB_COLLISION_ZOOMER_LOOP_CHECK_Y  # If zoomer's X is to the right of beam %
00001e96 : fff58e93;   % 1526:         addi t4,a1,-1  # Checks beam's tile to the left %
00001e97 : 01de0463;   % 1527:         beq t3,t4,BOMB_COLLISION_ZOOMER_LOOP_CHECK_Y   # If zoomer's X is to the left of beam %
00001e98 : 0b80006f;   % 1528:             j NEXT_IN_BOMB_COLLISION_ZOOMER_LOOP # Otherwise, zoomer isn't near beam enough be hit, check next %
00001e99 : 0062ce03;   % 1531:             lbu t3,6(t0)   # Loads zoomer's current Y %
00001e9a : 00ce0e63;   % 1532:             beq t3,a2,BOMB_COLLISION_ZOOMER_LOOP_SAME_Y    # If zoomer's Y is the same as the beam's %
00001e9b : 00160e93;   % 1533:             addi t4,a2,1   # Checks beam's base tile (Y + 1) %
00001e9c : 01de0463;   % 1534:             beq t3,t4,BOMB_COLLISION_ZOOMER_LOOP_BELLOW  # If zoomer's Y on beam's base %
00001e9d : 0a40006f;   % 1535:             j NEXT_IN_BOMB_COLLISION_ZOOMER_LOOP # Otherwise, zoomer isn't near beam enough be hit, check next %
00001e9e : 0032ce03;   % 1538:                 lbu t3,3(t0)   # Loads zoomer's Y offset %
00001e9f : 00ee4c63;   % 1539:                 blt t3,a4,BOMB_COLLISION_ZOOMER_LOOP_HIT # If zoomer's Y offset is less than the beam's Y offset deal damage %
00001ea0 : 0980006f;   % 1540:                     j NEXT_IN_BOMB_COLLISION_ZOOMER_LOOP # Otherwise, zoomer isn't near beam enough be hit, check next %
00001ea1 : 0032ce03;   % 1543:                 lbu t3,3(t0)   # Loads zoomer's Y  %
00001ea2 : 008e0e13;   % 1544:                 addi t3,t3,8   #  %
00001ea3 : 00ee5463;   % 1545:                 bge t3,a4,BOMB_COLLISION_ZOOMER_LOOP_HIT # If zoomer's Y offset + 8 is greater than the beam's Y offset deal damage %
00001ea4 : 0880006f;   % 1546:                     j NEXT_IN_BOMB_COLLISION_ZOOMER_LOOP # Otherwise, zoomer isn't near beam enough be hit, check next %
00001ea5 : 0002ce03;   % 1550:                 lbu t3,0(t0)   # Loads zoomer's health %
00001ea6 : 000e1463;   % 1551:                 bnez t3,CONTINUE_BOMB_COLLISION_ZOOMER_LOOP_HIT    # Zoomer isn't dead  %
00001ea7 : 1c00006f;   % 1552:                     j END_BOMB_COLLISION  # Beam was deactivated, end procedure here    %
00001ea8 : ffae0e13;   % 1554:                 addi t3,t3,-6  # Takes 6 away from it %
00001ea9 : 01c05c63;   % 1555:                 bge zero,t3,BOMB_COLLISION_ZOOMER_LOOP_HIT_DESTROY_ZOOMER  # If zoomer is killed %
00001eaa : 01c28023;   % 1556:                     sb t3,0(t0)    # and stores it back %
00001eab : 0012ce03;   % 1557:                     lbu t3,1(t0)   # Loads zoomer's type %
00001eac : 002e0e13;   % 1558:                     addi t3,t3,2   # Adds 2 to it ( will go to damage state) %
00001ead : 01c280a3;   % 1559:                     sb t3,1(t0)    # and stores it back %
00001eae : 1a40006f;   % 1560:                     j END_BOMB_COLLISION %
00001eaf : 00028023;   % 1563:                     sb zero,0(t0)  # Stores 0 to zoomer's health %
00001eb0 : 0022c583;   % 1564:                     lbu a1,2(t0)   # Loads zoomer's X offset %
00001eb1 : 0032c603;   % 1565:                     lbu a2,3(t0)   # Loads zoomer's Y offset %
00001eb2 : 0042c683;   % 1566:                     lbu a3,4(t0)   # Loads zoomer's X  %
00001eb3 : 0062c703;   % 1567:                     lbu a4,6(t0)   # Loads zoomer's Y %
00001eb4 : 00400793;   % 1568:                     li a5,4        # Delay %
00001eb5 : ff810113;   % 1570:                         addi sp,sp,-8 %
00001eb6 : 00a12023;   % 1571:                         sw a0,0(sp) %
00001eb7 : 00512223;   % 1572:                         sw t0,4(sp) %
00001eb8 : 00000513;   % 1575:                         li a0, 0       # Small explosion %
00001eb9 : ffffb317;   % 1576:                         call EXPLOSION_SPAWN   # Summons explosion %
00001eba : 500300e7;   % 1576:  %
00001ebb : 00412283;   % 1578:                         lw t0,4(sp)    # Restores zoomer's address %
00001ebc : 00b2c503;   % 1579:                         lbu a0,11(t0)  # Loads zoomer's loot value %
00001ebd : 0022c583;   % 1580:                         lbu a1,2(t0)   # Loads zoomer's X offset %
00001ebe : 0032c603;   % 1581:                         lbu a2,3(t0)   # Loads zoomer's Y offset %
00001ebf : 0042c683;   % 1582:                         lbu a3,4(t0)   # Loads zoomer's X  %
00001ec0 : 0062c703;   % 1583:                         lbu a4,6(t0)   # Loads zoomer's Y %
00001ec1 : ffffb317;   % 1584:                         call LOOT_SPAWN   # Summons explosion %
00001ec2 : 308300e7;   % 1584:  %
00001ec3 : 00012503;   % 1587:                         lw a0,0(sp) %
00001ec4 : 00810113;   % 1589:                         addi sp,sp,8 %
00001ec5 : 1480006f;   % 1592:                     j END_BOMB_COLLISION  # Beam was deactivated, end procedure here    %
00001ec6 : 00c28293;   % 1596:             addi t0,t0,12   # Going to the next zoomer's address                                   %
00001ec7 : 00138393;   % 1597:             addi t2,t2,1             # Iterating counter by 1                                    %
00001ec8 : 0063d463;   % 1598:             bge t2,t1, BOMB_COLLISION_RIDLEY_SKIP # If all of the zoomers were checked, end loop                                   %
00001ec9 : f19ff06f;   % 1599:             j BOMB_COLLISION_ZOOMER_LOOP # otherwise, go back to the loop's beginning                      %
00001eca : 1340006f;   % 1602:         j END_BOMB_COLLISION %
00001ecb : 0fc09297;   % 1605:         la t0,RIDLEY_INFO %
00001ecc : 92c28293;   % 1605:  %
00001ecd : 00028303;   % 1606:         lb t1,0(t0) # Loads Ridley's health %
00001ece : 00604463;   % 1607:         blt zero,t1,CONTINUE_BOMB_COLLISION_RIDLEY # If Ridley is alive %
00001ecf : 1200006f;   % 1608:             j END_BOMB_COLLISION %
00001ed0 : 00100213;   % 1611:         li tp, 1 # tp will start as left %
00001ed1 : 00900e13;   % 1612:         li t3,9   # Loads Ridley's current X %
00001ed2 : 00be0c63;   % 1613:         beq t3,a1,BOMB_COLLISION_RIDLEY_CHECK_Y   # If Ridley's X is the same as the beam's %
00001ed3 : 00158e93;   % 1614:         addi t4,a1,1   # Checks beam's tile to the right %
00001ed4 : 01de0863;   % 1615:         beq t3,t4,BOMB_COLLISION_RIDLEY_CHECK_Y  # If Ridley's X is to the right of beam %
00001ed5 : fff58e93;   % 1616:         addi t4,a1,-1  # Checks beam's tile to the left %
00001ed6 : 01de0463;   % 1617:         beq t3,t4,BOMB_COLLISION_RIDLEY_CHECK_Y   # If Ridley's X is to the left of beam %
00001ed7 : 1000006f;   % 1618:         j END_BOMB_COLLISION # Otherwise, Ridley isn't near beam to be hit, check Plasma Breath   %
00001ed8 : 0032ce03;   % 1621:             lbu t3,3(t0)   # Loads Ridley's current Y %
00001ed9 : 02ce0e63;   % 1622:             beq t3,a2,BOMB_COLLISION_RIDLEY_HIT    # If Ridley's Y is the same as the beam's (beam would basically be inside him) %
00001eda : 00160e93;   % 1623:             addi t4,a2,1   # Checks beam's base tile (Y + 1) %
00001edb : 01de0c63;   % 1624:             beq t3,t4,BOMB_COLLISION_RIDLEY_BELLOW  # If Ridley's Y is bellow beam %
00001edc : 001e0e13;   % 1626:             addi t3,t3,1   # Gets ridley's Y + 1 %
00001edd : 02ce0663;   % 1627:             beq t3,a2,BOMB_COLLISION_RIDLEY_HIT    # If Ridley's Y + 1 is the same as the beam's, it's a hit (beam would basically be inside him) %
00001ede : 001e0e13;   % 1629:             addi t3,t3,1   # Gets ridley's Y + 2 %
00001edf : 00ce0a63;   % 1630:             beq t3,a2,BOMB_COLLISION_RIDLEY_SAME_Y    # If Ridley's Y + 2 is the same as the beam's %
00001ee0 : 0dc0006f;   % 1632:             j END_BOMB_COLLISION # Otherwise, Ridley isn't near beam to be hit, check Plasma Breath    %
00001ee1 : 0022ce03;   % 1635:                 lbu t3,2(t0)   # Loads Ridley's current Y offset %
00001ee2 : 00ee4c63;   % 1636:                 blt t3,a4,BOMB_COLLISION_RIDLEY_HIT # If Ridley's "Y offset" is less than the beam's Y offset deal damage %
00001ee3 : 0d00006f;   % 1637:                     j END_BOMB_COLLISION # Otherwise, Ridley isn't near beam to be hit, check Plasma Breath    %
00001ee4 : 0022ce03;   % 1640:                 lbu t3,2(t0)   # Loads Ridley's current Y offset %
00001ee5 : 008e0e13;   % 1641:                 addi t3,t3,8   #  %
00001ee6 : 00ee5463;   % 1642:                 bge t3,a4,BOMB_COLLISION_RIDLEY_HIT # If ridley's Y offset + 8 is greater than the beam's Y offset deal damage %
00001ee7 : 0c00006f;   % 1643:                     j END_BOMB_COLLISION # Otherwise, Ridley isn't near beam to be hit, check Plasma Breath    %
00001ee8 : 0002ce03;   % 1647:                 lbu t3,0(t0)   # Loads Ridley's health %
00001ee9 : 0a0e0a63;   % 1648:                 beqz t3,BOMB_COLLISION_RIDLEY_HIT_DISABLE_BEAM %
00001eea : ffae0e13;   % 1649:                 addi t3,t3,-6  # Takes 1 away from it %
00001eeb : 01c05c63;   % 1650:                 blez t3,BOMB_COLLISION_RIDLEY_HIT_DESTROY_RIDLEY  # If Ridley is killed %
00001eec : 01c28023;   % 1651:                     sb t3,0(t0)    # and stores it back %
00001eed : 0012ce03;   % 1652:                     lbu t3,1(t0)   # Loads Ridley's type %
00001eee : 001e0e13;   % 1653:                     addi t3,t3,1   # Adds 1 to it ( will go to damage state) %
00001eef : 01c280a3;   % 1654:                     sb t3,1(t0)    # and stores it back %
00001ef0 : 0980006f;   % 1655:                     j BOMB_COLLISION_RIDLEY_HIT_DISABLE_BEAM %
00001ef1 : 00028023;   % 1658:                     sb zero,0(t0)  # Stores 0 to Ridley's health %
00001ef2 : 00600593;   % 1659:                     li a1,6   # Loads Ridley's X offset %
00001ef3 : 0022c603;   % 1660:                     lbu a2,2(t0)            # Loads Ridley's Y offset %
00001ef4 : 00900693;   % 1661:                     li a3,9          # Loads Ridley's X  %
00001ef5 : 0032c703;   % 1662:                     lbu a4,3(t0)            # Loads Ridley's Y %
00001ef6 : ffc10113;   % 1664:                         addi sp,sp,-4 %
00001ef7 : 00a12023;   % 1665:                         sw a0,0(sp) %
00001ef8 : 00100513;   % 1667:                         li a0, 1               # Big explosion %
00001ef9 : 00400793;   % 1668:                         li a5,4                # Delay %
00001efa : ffffb317;   % 1669:                         call EXPLOSION_SPAWN   # Summons explosion %
00001efb : 3fc300e7;   % 1669:  %
00001efc : 0fc09297;   % 1671:                         la t0,RIDLEY_INFO %
00001efd : 86828293;   % 1671:  %
00001efe : 00600593;   % 1672:                         li a1,6   # Loads Ridley's X offset %
00001eff : 0022c603;   % 1673:                         lbu a2,2(t0)            # Loads Ridley's Y offset %
00001f00 : 00900693;   % 1674:                         li a3,9          # Loads Ridley's X  %
00001f01 : 00168693;   % 1675:                         addi a3,a3,1 %
00001f02 : 0032c703;   % 1676:                         lbu a4,3(t0)            # Loads Ridley's Y %
00001f03 : 00170713;   % 1677:                         addi a4,a4,1 %
00001f04 : 00300793;   % 1678:                         li a5,3                # Delay %
00001f05 : 00100513;   % 1679:                         li a0, 1               # Big explosion %
00001f06 : ffffb317;   % 1680:                         call EXPLOSION_SPAWN   # Summons explosion %
00001f07 : 3cc300e7;   % 1680:  %
00001f08 : 0fc09297;   % 1682:                         la t0,RIDLEY_INFO %
00001f09 : 83828293;   % 1682:  %
00001f0a : 00600593;   % 1683:                         li a1,6   # Loads Ridley's X offset %
00001f0b : 0022c603;   % 1684:                         lbu a2,2(t0)            # Loads Ridley's Y offset %
00001f0c : 00900693;   % 1685:                         li a3,9          # Loads Ridley's X  %
00001f0d : fff68693;   % 1686:                         addi a3,a3,-1 %
00001f0e : 0032c703;   % 1687:                         lbu a4,3(t0)            # Loads Ridley's Y %
00001f0f : 00270713;   % 1688:                         addi a4,a4,2 %
00001f10 : 00400793;   % 1689:                         li a5,4                # Delay %
00001f11 : 00100513;   % 1690:                         li a0, 1               # Big explosion %
00001f12 : ffffb317;   % 1691:                         call EXPLOSION_SPAWN   # Summons explosion %
00001f13 : 39c300e7;   % 1691:  %
00001f14 : 00012503;   % 1693:                         lw a0,0(sp) %
00001f15 : 00410113;   % 1694:                         addi sp,sp,4 %
00001f16 : 0040006f;   % 1700:                     j END_BOMB_COLLISION  # Beam was deactivated, end procedure here          %
00001f17 : 00012083;   % 1704:         lw ra,0(sp) %
00001f18 : 00410113;   % 1705:         addi sp,sp,4 %
00001f19 : 00008067;   % 1707:         ret  %
00001f1a : 0015c783;   % 1726:     lbu a5,1(a1)  # Loads map's matrix width %
00001f1b : 00554803;   % 1727:     lbu a6,5(a0)  # Loads Beam's current X %
00001f1c : 00754883;   % 1728:     lbu a7,7(a0)  # Loads Beam's current Y %
00001f1d : 00358593;   % 1730:     addi a1,a1,3   # Adds 3 to the Matrix's address so that it goes to the beginning of matrix %
00001f1e : 02f882b3;   % 1731:     mul t0,a7,a5   # Beam's Y related to matrix * Map Matrix's width %
00001f1f : 005802b3;   % 1732:     add t0,a6,t0   # t0 = Beam's X related to matrix +  Beam's Y related to matrix * Map Matrix's width   %
00001f20 : 005585b3;   % 1733:     add a1,a1,t0   # a1 = Map Matrix's address adjusted for Beam's X and Y related to matrix %
00001f21 : 00150283;   % 1735:     lb t0, 1(a0) # loads direction %
00001f22 : 00028663;   % 1736:     beqz t0,MOVE_BEAM_CHECK_Y     # If direction is 0 (Up)  %
00001f23 : 00000213;   % 1737:         li tp, 0 # If it's 0, it's on the first check %
00001f24 : 04c0006f;   % 1738:         j MOVE_BEAM_CHECK_X  %
00001f25 : 00454283;   % 1741:         lbu t0,4(a0)   # Loads beam's Y offset %
00001f26 : 00c00313;   % 1742:         li t1,12       # Number for comparision %
00001f27 : 00535463;   % 1743:         bge t1,t0,CONTINUE_MOVE_BEAM_CHECK_Y # If beam's offset <= 12, continue checking %
00001f28 : 1380006f;   % 1744:         j MOVE_BEAM_Y_PROPERLY %
00001f29 : 00100613;   % 1748:         li a2, 1  # Base case: Check only one tile        %
00001f2a : 00100693;   % 1749:         li a3, 1  # Vertical check %
00001f2b : 00000713;   % 1750:         li a4, 0  # Base case: Don't consider doors       %
00001f2c : 00354e03;   % 1752:         lbu t3,3(a0)     # Loads Beam's X offset %
00001f2d : 00800293;   % 1753:         li t0, 8   # Loads number 8 for comparing with X offset  %
00001f2e : 005e4863;   % 1754:         blt t3,t0, MOVE_BEAM_CHECK_Y_1_TILE # If X offset < 8, just check one tile bellow, and consider right doors %
00001f2f : 01c2c863;   % 1755:         blt t0,t3, MOVE_BEAM_CHECK_Y_1_TILE_RIGHT # If X offset > 8, check one tile bellow to the right , and consider left doors %
00001f30 : 00200613;   % 1757:             li a2,2   # Check 2 tiles above beam (one above, the other above to the right) %
00001f31 : 0b80006f;   % 1758:             j START_BEAM_COLLISION %
00001f32 : 0b40006f;   % 1762:             j START_BEAM_COLLISION %
00001f33 : 00100313;   % 1766:             li t1, 1 # Only consider doors on the left side of the map %
00001f34 : 00158593;   % 1767:             addi a1,a1, 1 # Looks to the tile on the right of Beam's current tile %
00001f35 : 00180813;   % 1768:             addi a6,a6,1  # Increments current X on matrix (+1 X) %
00001f36 : 0a40006f;   % 1769:             j START_BEAM_COLLISION  %
00001f37 : 00100613;   % 1773:         li a2, 1  # Base case: Check only one tile        %
00001f38 : 00000693;   % 1774:         li a3, 0  # Horizontal check %
00001f39 : 00000713;   % 1775:         li a4, 0  # Base case: Don't consider doors      %
00001f3a : 00454283;   % 1776:         lbu t0,4(a0)   # Loads beam's Y offset %
00001f3b : 00400313;   % 1777:         li t1, 4       # For comparision %
00001f3c : 0062ce63;   % 1778:         blt t0,t1,CONTINUE_MOVE_BEAM_CHECK_X_GET_DIRECTION  # If less than 4, check current Y only %
00001f3d : 00800313;   % 1779:         li t1, 8       # For comparision %
00001f3e : 0062d663;   % 1780:         bge t0,t1,CONTINUE_MOVE_BEAM_CHECK_X_BELLOW  # If greater than or equal to 8, check Y bellow %
00001f3f : 00200613;   % 1781:             li a2,2    # Otherwise (4 <= Y offset < 8) check both tiles %
00001f40 : 00c0006f;   % 1782:             j CONTINUE_MOVE_BEAM_CHECK_X_GET_DIRECTION %
00001f41 : 00188893;   % 1785:         addi a7,a7,1  # Goes to tile bellow %
00001f42 : 00f585b3;   % 1786:         add a1,a1,a5  # as well as in matrix %
00001f43 : 00154283;   % 1796:         lbu t0, 1(a0)  # loads direction %
00001f44 : fff28293;   % 1797:         addi t0,t0,-1 # if t0 == 1 (right) it'll be set to 0 %
00001f45 : 02028663;   % 1798:         beqz t0,MOVE_BEAM_CHECK_X_RIGHT  # If beam is moving right %
00001f46 : 00020863;   % 1800:         beqz tp,CONTINUE_MOVE_BEAM_CHECK_X_LEFT_FIRST_CHECK # If on first check %
00001f47 : 00158593;   % 1802:             addi a1,a1, 1  # Looks to the tile on the right of beam's current tile %
00001f48 : 00180813;   % 1803:             addi a6,a6,1   # Increments current X on matrix(+1 X) %
00001f49 : 00100613;   % 1804:             li a2, 1  # Base case: Check only one tile        %
00001f4a : 00354283;   % 1807:             lbu t0,3(a0)   # Loads beam's X offset %
00001f4b : 00400313;   % 1808:             li t1,4        # Loads number 4 for comparing with X offset  %
00001f4c : 00628463;   % 1809:             beq t0,t1,CONTINUE_MOVE_BEAM_CHECK_X_LEFT_DOORS  # Will check considering only doors %
00001f4d : 00029463;   % 1810:             bnez t0,CONTINUE_MOVE_BEAM_CHECK_X_LEFT_SKIP_DOORS  # Will check considering only doors %
00001f4e : 00100713;   % 1813:                 li a4,1   # Consider only doors %
00001f4f : 0400006f;   % 1816:                 j START_BEAM_COLLISION %
00001f50 : 00020a63;   % 1819:         beqz tp,CONTINUE_MOVE_BEAM_CHECK_X_RIGHT_FIRST_CHECK # If on first check %
00001f51 : fff58593;   % 1821:             addi a1,a1, -1  # Looks to the tile on the right of beam's current tile %
00001f52 : fff80813;   % 1822:             addi a6,a6,-1   # Increments current X on matrix(+1 X) %
00001f53 : 00100613;   % 1823:             li a2, 1  # Base case: Check only one tile    %
00001f54 : 00c0006f;   % 1824:             j CONTINUE_MOVE_BEAM_CHECK_X_RIGHT %
00001f55 : 00158593;   % 1827:             addi a1,a1, 1  # Looks to the tile on the right of beam's current tile %
00001f56 : 00180813;   % 1828:             addi a6,a6,1   # Increments current X on matrix(+1 X) %
00001f57 : 00354283;   % 1830:             lbu t0,3(a0)   # Loads beam's X offset %
00001f58 : 00c00313;   % 1831:             li t1,12        # Loads number 12 for comparing with X offset  %
00001f59 : 00628663;   % 1832:             beq t0,t1,CONTINUE_MOVE_BEAM_CHECK_X_RIGHT_DOORS  # Will check considering only doors %
00001f5a : 00800313;   % 1833:             li t1,8        # Loads number 8 for comparing with X offset  %
00001f5b : 00629463;   % 1834:             bne t0,t1,CONTINUE_MOVE_BEAM_CHECK_X_RIGHT_SKIP_DOORS  # Will check ignoring doors %
00001f5c : 00100713;   % 1836:                 li a4,1   # Consider only doors %
00001f5d : 08028663;   % 1839:                 beqz t0,MOVE_BEAM_X_PROPERLY # If offset is 0, skip collision check %
00001f5e : 0040006f;   % 1840:                 j START_BEAM_COLLISION %
00001f5f : ff410113;   % 1844:         addi sp,sp,-12 %
00001f60 : 00a12023;   % 1845:         sw a0,0(sp) %
00001f61 : 00b12223;   % 1846:         sw a1,4(sp) %
00001f62 : 00112423;   % 1847:         sw ra,8(sp) %
00001f63 : 00200513;   % 1850:         li a0,2  # Consider both doors (if a4 != 0) %
00001f64 : 00200213;   % 1858:         li tp, 2  # Beam collision %
00001f65 : 00001317;   % 1860:         call CHECK_MAP_COLLISION %
00001f66 : b68300e7;   % 1860:  %
00001f67 : 00a002b3;   % 1861:         mv t0,a0 %
00001f68 : 00b00233;   % 1862:         mv tp,a1 %
00001f69 : 00012503;   % 1865:         lw a0,0(sp) %
00001f6a : 00412583;   % 1866:         lw a1,4(sp) %
00001f6b : 00812083;   % 1867:         lw ra,8(sp) %
00001f6c : 00c10113;   % 1868:         addi sp,sp,12 %
00001f6d : f4021ce3;   % 1872:         bnez tp,CONTINUE_MOVE_BEAM_CHECK_X_GET_DIRECTION %
00001f6e : 00029a63;   % 1873:         bnez t0,MOVE_BEAM_PROPERLY # If returning anything but 0, continue moving ripper %
00001f6f : 00300313;   % 1875:         li t1,3           # Loads "Hit to be Disabled"  %
00001f70 : 00650023;   % 1876:         sb t1,0(a0)       # and stores it on enable byte %
00001f71 : 00050123;   % 1877:         sb zero,2(a0)     # Resets render counter %
00001f72 : 0980006f;   % 1878:         j END_MOVE_BEAM %
00001f73 : 00150283;   % 1881:         lb t0, 1(a0) # loads direction %
00001f74 : 00028463;   % 1882:         beqz t0,MOVE_BEAM_Y_PROPERLY     # If direction is 0 (Up)  %
00001f75 : 02c0006f;   % 1883:         j MOVE_BEAM_X_PROPERLY  %
00001f76 : 00754303;   % 1886:         lbu t1, 7(a0)    # Loads beam's current Y %
00001f77 : 00650423;   % 1887:         sb t1, 8(a0)     # and stores it on beam's old Y %
00001f78 : 00454283;   % 1889:         lbu t0,4(a0)   # Loads beam's current Y offset %
00001f79 : ff828293;   % 1890:         addi t0,t0,-8  # moves it up %
00001f7a : 0002d863;   % 1892:         bge t0,zero,MOVE_BEAM_Y_PROPERLY_STORE_BEAM # If no correction is needed %
00001f7b : fff30313;   % 1894:             addi t1,t1,-1          # Moves Y up one tile %
00001f7c : 01028293;   % 1895:             addi t0,t0,16   # adds 16 to offset %
00001f7d : 006503a3;   % 1896:             sb t1, 7(a0)     # Stores beam's new Y %
00001f7e : 00550223;   % 1899:             sb t0, 4(a0)     # Stores new Y offset %
00001f7f : 0640006f;   % 1900:             j END_MOVE_BEAM # Goes to render %
00001f80 : 00150283;   % 1903:         lb t0, 1(a0)     # loads direction %
00001f81 : 00554303;   % 1904:         lbu t1, 5(a0)    # Loads beam's current X %
00001f82 : 00650323;   % 1905:         sb t1, 6(a0)     # and stores it on beam's old X %
00001f83 : 0fc08e17;   % 1907:         la t3,MOVE_X     # Loads MOVE_X %
00001f84 : 344e0e13;   % 1907:  %
00001f85 : 000e0e03;   % 1908:         lb t3,0(t3)      # and gets player's movement speed %
00001f86 : 00000e93;   % 1909:         li t4,0          # X momentum %
00001f87 : 000e0463;   % 1910:         beqz t3,MOVE_BEAM_X_PROPERLY_SKIP_ADD %
00001f88 : 00229e93;   % 1911:             slli t4,t0,2     # Multiplies t0 by 4 (so that beam moves +-4) %
00001f89 : 00329393;   % 1913:             slli t2,t0,3     # Multiplies t0 by 8 (so that beam moves +-8) %
00001f8a : 00354283;   % 1915:             lbu t0,3(a0)     # Loads beam's current X offset %
00001f8b : 007282b3;   % 1916:             add t0,t0,t2     # moves it %
00001f8c : 01d282b3;   % 1917:             add t0,t0,t4     # and adds player's momentum %
00001f8d : 0002da63;   % 1919:         bge t0,zero,MOVE_BEAM_X_PROPERLY_SKIP_NEGATIVE_CORRECTION %
00001f8e : fff30313;   % 1921:             addi t1,t1,-1          # Moves X one tile to the left %
00001f8f : 01028293;   % 1922:             addi t0,t0,16   # adds 16 to offset %
00001f90 : 006502a3;   % 1923:             sb t1, 5(a0)           # Stores beam's new X %
00001f91 : 0180006f;   % 1924:             j MOVE_BEAM_X_PROPERLY_STORE_BEAM %
00001f92 : 01000393;   % 1928:             li t2,16 %
00001f93 : 0072c863;   % 1929:             blt t0,t2,MOVE_BEAM_X_PROPERLY_STORE_BEAM  # If  0 <= resulting offset < 16, don't change X %
00001f94 : 00130313;   % 1931:                 addi t1,t1,1           # Moves X one tile to the right %
00001f95 : 407282b3;   % 1932:                 sub t0,t0,t2           # subtracts 16 from offset %
00001f96 : 006502a3;   % 1933:                 sb t1, 5(a0)           # Stores beam's new X %
00001f97 : 005501a3;   % 1937:             sb t0, 3(a0)     # Stores new X offset %
00001f98 : 00008067;   % 1941:         ret %
00001f99 : 00754603;   % 1970:     lbu a2,7(a0)    # Loads bomb's current Y %
00001f9a : 00c50423;   % 1971:     sb a2,8(a0)     # And stores it on old Y %
00001f9b : 00454683;   % 1972:     lbu a3,4(a0)    # Loads bomb's current Y offset %
00001f9c : 00857553;   % 1976:     fadd.s fa0,fa0,fs0    # fa0 = Bomb's current Y speed + gravity factor        %
00001f9d : c0057e53;   % 1977:     fcvt.w.s t3,fa0       # Sets t3 = floor(fa0) %
00001f9e : 00800293;   % 1979:     li t0,8                    # Loads max speed (8, when falling) %
00001f9f : 005e4663;   % 1980:     blt t3,t0, SKIP_BOMB_MAX_SPEED   # If t3 < 8, skip this part %
00001fa0 : 00800e13;   % 1982:         li t3,8 %
00001fa1 : d002f553;   % 1983:         fcvt.s.w fa0,t0 %
00001fa2 : 01c686b3;   % 1986:         add a3,a3,t3	# Adds the Y Movement to the Bomb's Offset       %
00001fa3 : 01000293;   % 1988:         li t0, 16 %
00001fa4 : 0056c663;   % 1989:         blt a3,t0, SKIP_DOWN_Y_BOMB %
00001fa5 : 00160613;   % 1991:         addi a2,a2, 1	 # Bomb's Y on matrix += 1 (goes to the right) %
00001fa6 : 405686b3;   % 1992:         sub a3,a3,t0	 # Offset gets corrected (relative to new Y on matrix coordinate) %
00001fa7 : 0015c783;   % 1996:         lbu a5,1(a1)     # Loads map's matrix width %
00001fa8 : 00554803;   % 1997:         lbu a6,5(a0)     # Loads Bomb's current X %
00001fa9 : 00754883;   % 1998:         lbu a7,7(a0)     # Loads Bomb's current Y %
00001faa : 00358593;   % 2000:         addi a1,a1,3     # Adds 3 to the Matrix's address so that it goes to the beginning of matrix %
00001fab : 02f882b3;   % 2001:         mul t0,a7,a5     # (Bomb's matrix Y + 3)  * Map Matrix's width %
00001fac : 005802b3;   % 2002:         add t0,a6,t0     # t0 = Bomb's X related to matrix + (Bomb's matrix Y + 3)  * Map Matrix's width %
00001fad : 005585b3;   % 2003:         add a1,a1,t0     # a1 = Map Matrix's address adjusted for Bomb's X and Y (+3) related to matrix        %
00001fae : 00454283;   % 2006:         lbu t0,4(a0)     # Loads Bomb's Y offset     %
00001faf : 00f585b3;   % 2007:         add a1,a1,a5  # Moves matrix one tile down %
00001fb0 : 00188893;   % 2008:         addi a7,a7,1  # Moves Y one tile down %
00001fb1 : 00028e63;   % 2009:         beqz t0 CONTINUE_CHECK_Y_DOWN_BOMB   # If Bomb's Y offset == 0, continue checking %
00001fb2 : 00f585b3;   % 2012:         add a1,a1,a5  # If Y offset != 0 %
00001fb3 : 00188893;   % 2013:         addi a7,a7,1  # If Y offset != 0 %
00001fb4 : 01000313;   % 2015:         li t1,16  # Loads 16 %
00001fb5 : 01c282b3;   % 2016:         add t0,t0,t3     # Current Y offset + Y offset modifier %
00001fb6 : 0062d463;   % 2017:         bge t0,t1 CONTINUE_CHECK_Y_DOWN_BOMB  # If current offset + offset modifier >= 16, continue checking (but check one tile bellow) %
00001fb7 : 0b00006f;   % 2018:             j MOVE_BOMB_PROPERLY              # Othewise, just move the bomb %
00001fb8 : 00100713;   % 2023:             li a4, 1  # Base case: Consider doors       %
00001fb9 : 00100393;   % 2024:             li t2, 1  # Base case: Check only one tile   %
00001fba : 00354e03;   % 2026:             lbu t3,3(a0)     # Loads Bomb's X offset %
00001fbb : 000e0e63;   % 2027:             beqz t3 CHECK_BOMB_Y_DOWN_BOTH_DOORS # If X offset = 0, just check one tile bellow, and consider both doors %
00001fbc : 00800293;   % 2028:             li t0, 8   # Loads number 8 for comparing with X offset  %
00001fbd : 005e4e63;   % 2029:             blt t3,t0, CHECK_BOMB_Y_DOWN_RIGHT_DOOR # If X offset < 8, just check one tile bellow, and consider right doors %
00001fbe : 03c2c063;   % 2030:             blt t0,t3, CHECK_BOMB_Y_DOWN_LEFT_DOOR # If X offset > 8, check one tile bellow to the right , and consider left doors %
00001fbf : 00200393;   % 2032:                 li t2,2   # Check 2 tiles bellow bomb (one bellow, the other bellow to the right)   %
00001fc0 : 00000713;   % 2033:                 li a4,0   # Ignore doors %
00001fc1 : 0200006f;   % 2034:                 j START_BOMB_COLLISION %
00001fc2 : 00200313;   % 2038:                 li t1, 2 # Consider both doors on the left and on the right sides of the map %
00001fc3 : 0180006f;   % 2039:                 j START_BOMB_COLLISION %
00001fc4 : 00000313;   % 2043:                 li t1, 0 # Only consider doors on the right side of the map %
00001fc5 : 0100006f;   % 2044:                 j START_BOMB_COLLISION %
00001fc6 : 00100313;   % 2048:                 li t1, 1 # Only consider doors on the left side of the map %
00001fc7 : 00158593;   % 2049:                 addi a1,a1, 1 # Looks to the tile on the right of Bomb's current tile %
00001fc8 : 00180813;   % 2050:                 addi a6,a6,1  # Increments current X on matrix (+1 X) %
00001fc9 : fec10113;   % 2055:                 addi sp,sp,-20 %
00001fca : 00d12823;   % 2056:                 sw a3,16(sp) %
00001fcb : 00c12623;   % 2057:                 sw a2,12(sp) %
00001fcc : 00b12423;   % 2058:                 sw a1,8(sp) %
00001fcd : 00a12223;   % 2059:                 sw a0,4(sp) %
00001fce : 00112023;   % 2060:                 sw ra,0(sp) %
00001fcf : 00600533;   % 2063:                 mv a0,t1  # Doesn't matter, since no doors will be checked %
00001fd0 : 00700633;   % 2065:                 mv a2,t2  # Only check one tile %
00001fd1 : 00100693;   % 2066:                 li a3,1   # Vertical check %
00001fd2 : 00100213;   % 2070:                 li tp, 1  # Entity collision %
00001fd3 : 00001317;   % 2071:                 call CHECK_MAP_COLLISION %
00001fd4 : 9b0300e7;   % 2071:  %
00001fd5 : 00a002b3;   % 2072:                 mv t0,a0 %
00001fd6 : 01012683;   % 2075:                 lw a3,16(sp) %
00001fd7 : 00c12603;   % 2076:                 lw a2,12(sp) %
00001fd8 : 00812583;   % 2077:                 lw a1,8(sp) %
00001fd9 : 00412503;   % 2078:                 lw a0,4(sp) %
00001fda : 00012083;   % 2079:                 lw ra,0(sp) %
00001fdb : 01410113;   % 2080:                 addi sp,sp,20 %
00001fdc : 00029e63;   % 2084:             bnez t0, MOVE_BOMB_PROPERLY   # If returning anything but 0, Plasma Breath can move %
00001fdd : d0007553;   % 2086:                 fcvt.s.w fa0,zero # Resets Bomb's jump speed %
00001fde : 00454283;   % 2088:                 lbu t0,4(a0)   # Loads Bomb's current Y offset   %
00001fdf : 00028663;   % 2089:                 beqz t0,MOVE_BOMB_SKIP_ADJUST_Y   %
00001fe0 : 00050223;   % 2090:                     sb zero, 4(a0) # Sets Bomb's Y offset to 0  %
00001fe1 : 00c503a3;   % 2091:                     sb a2,7(a0)    # Stores new Y  %
00001fe2 : 00c0006f;   % 2094:                     j END_MOVE_BOMB   # Finish procedure                %
00001fe3 : 00c503a3;   % 2097:             sb a2,7(a0)     # Stores Bomb's new Y  %
00001fe4 : 00d50223;   % 2098:             sb a3,4(a0)     # Stores new Y offset %
00001fe5 : 00008067;   % 2102:         ret %
00001fe6 : 00454303;   % 2136:     lbu t1,4(a0)  # Loads Zoomer's X %
00001fe7 : 006502a3;   % 2137:     sb t1,5(a0)   # And stores it in Zoomer's old  %
00001fe8 : 00654303;   % 2138:     lbu t1,6(a0)  # Loads Zoomer's Y %
00001fe9 : 006503a3;   % 2139:     sb t1,7(a0)   # And stores it in Zoomer's old Y %
00001fea : 00000613;   % 2141:     li a2, 0      # First stage of check (platform)  %
00001feb : ffc10113;   % 2143:         addi sp,sp,-4 %
00001fec : 00b12023;   % 2144:         sw a1,0(sp) %
00001fed : 00100293;   % 2148:         li t0,1       # In case no collision check is made %
00001fee : 00012583;   % 2150:         lw a1,0(sp)   # Loads map's matrix original address %
00001fef : 0015c783;   % 2151:         lbu a5,1(a1)  # Loads map's matrix width %
00001ff0 : 00454803;   % 2152:         lbu a6,4(a0)  # Loads Zoomer's current X %
00001ff1 : 00654883;   % 2153:         lbu a7,6(a0)  # Loads Zoomer's current Y %
00001ff2 : 00358593;   % 2155:         addi a1,a1,3   # Adds 3 to the Matrix's address so that it goes to the beginning of matrix %
00001ff3 : 02f88333;   % 2156:         mul t1,a7,a5   # Zoomer's Y related to matrix * Map Matrix's width %
00001ff4 : 00680333;   % 2157:         add t1,a6,t1   # t1 = Zoomer's X related to matrix +  Zoomer's Y related to matrix * Map Matrix's width   %
00001ff5 : 006585b3;   % 2158:         add a1,a1,t1   # a1 = Map Matrix's address adjusted for Zoomer's X and Y related to matrix %
00001ff6 : 00000713;   % 2160:         li a4,0  # Base case: Don't consider doors (if X offset stays 0) %
00001ff7 : 00100213;   % 2161:         li tp,1  # Base case (will be passed to a2): only check 1 tile (if X offset stays 0) %
00001ff8 : 00a54303;   % 2163:         lbu t1,10(a0)  # Loads Zoomer's Platform %
00001ff9 : 00254383;   % 2164:         lbu t2,2(a0)   # Loads Zoomer's X offset %
00001ffa : 00354e03;   % 2165:         lbu t3,3(a0)   # Loads Zoomer's Y offset %
00001ffb : 00954e83;   % 2166:         lbu t4,9(a0)   # Loads Zoomer's Clock movement %
00001ffc : 06031663;   % 2167:         bnez t1,TRY_MOVE_ZOOMER_COLLISION_LEFT %
00001ffd : 00100713;   % 2169:             li a4,1  # Base case: Consider doors %
00001ffe : 00800313;   % 2170:             li t1,8 %
00001fff : 00731c63;   % 2171:             bne t1,t2,MOVE_ZOOMER_CHECK_DOWN_0_OFF  # If offset != 8, check if it's 0 %
00002000 : 00100713;   % 2172:                 li a4,1  # Base case: Consider doors %
00002001 : 00c70733;   % 2173:                 add a4,a4,a2 # If on second check, consider ONLY doors %
00002002 : 00200213;   % 2174:                 li tp,2  # Check 2 tiles %
00002003 : 40c20233;   % 2175:                 sub tp,tp,a2 # If on second check, check ONLY 1 tile %
00002004 : 00c0006f;   % 2176:                 j MOVE_ZOOMER_CHECK_DOWN_SETUP # start collision check %
00002005 : 00038463;   % 2179:             beqz t2, MOVE_ZOOMER_CHECK_DOWN_SETUP %
00002006 : 3ec0006f;   % 2180:                 j MOVE_ZOOMER_PROPERLY %
00002007 : 00061a63;   % 2183:             bnez a2, MOVE_ZOOMER_CHECK_DOWN_FOWARD %
00002008 : 00188893;   % 2185:                 addi a7,a7,1 # Checking one tile down %
00002009 : 00f585b3;   % 2186:                 add a1,a1,a5 # Updates starting address on map matrix %
0000200a : 00100693;   % 2187:                 li a3,1  # Vertical check %
0000200b : 1600006f;   % 2188:                 j START_ZOOMER_COLLISION %
0000200c : 000e8e63;   % 2192:                 beqz t4, MOVE_ZOOMER_CHECK_DOWN_FOWARD_CLOCKWISE %
0000200d : 00800313;   % 2194:                 li t1,8 %
0000200e : 00730663;   % 2195:                 beq t1,t2,MOVE_ZOOMER_CHECK_DOWN_FOWARD_OFF_8 # If offset == 8, don't alter X %
0000200f : fff80813;   % 2196:                     addi a6,a6,-1   # Checking left tile %
00002010 : fff58593;   % 2197:                     addi a1,a1,-1   # Updates starting address on map matrix %
00002011 : 00000693;   % 2199:                     li a3,0  # Horizontal check %
00002012 : 1440006f;   % 2200:                     j START_ZOOMER_COLLISION %
00002013 : 00180813;   % 2204:                     addi a6,a6,1  # Checking right tile %
00002014 : 00158593;   % 2205:                     addi a1,a1,1   # Updates starting address on map matrix %
00002015 : 00000693;   % 2206:                     li a3,0  # Horizontal check %
00002016 : 1340006f;   % 2207:                     j START_ZOOMER_COLLISION %
00002017 : 00100f13;   % 2210:         TRY_MOVE_ZOOMER_COLLISION_LEFT:  li t5,1 %
00002018 : 07e31463;   % 2211:             bne t1,t5,TRY_MOVE_ZOOMER_COLLISION_UP %
00002019 : 00800313;   % 2213:             li t1,8 %
0000201a : 00731663;   % 2214:             bne t1,t2,MOVE_ZOOMER_CHECK_LEFT_0_OFF  # If X offset != 8, skip it %
0000201b : 00100713;   % 2215:                 li a4,1  # Base case: Consider doors %
0000201c : 40c70733;   % 2216:                 sub a4,a4,a2 # If on second check, don't consider doors            %
0000201d : 000e0463;   % 2219:             beqz t3, MOVE_ZOOMER_CHECK_LEFT_SETUP %
0000201e : 38c0006f;   % 2220:                 j MOVE_ZOOMER_PROPERLY %
0000201f : 00061e63;   % 2223:             bnez a2, MOVE_ZOOMER_CHECK_LEFT_FOWARD %
00002020 : 00800313;   % 2225:                 li t1,8 %
00002021 : 00730663;   % 2226:                 beq t1,t2,MOVE_ZOOMER_CHECK_LEFT_8_OFF  # If X offset is 8, don't update X  %
00002022 : fff80813;   % 2227:                     addi a6,a6,-1  # Checking left tile (or current tile if X offset == 8) %
00002023 : fff58593;   % 2228:                     addi a1,a1,-1   # Updates starting address on map matrix  %
00002024 : 00000693;   % 2230:                 li a3,0  # Horizontal check %
00002025 : 0f80006f;   % 2231:                 j START_ZOOMER_COLLISION %
00002026 : 00800313;   % 2235:                 li t1,8 %
00002027 : 00730463;   % 2236:                 beq t1,t2,MOVE_ZOOMER_CHECK_LEFT_FOWARD_8_OFF  # If X offset is 8, don't consider doors %
00002028 : 00100713;   % 2237:                     li a4,1  # Base case: Consider doors %
00002029 : 000e8a63;   % 2239:                 beqz t4, MOVE_ZOOMER_CHECK_LEFT_FOWARD_CLOCKWISE %
0000202a : fff88893;   % 2241:                     addi a7,a7,-1 # Checking one tile up %
0000202b : 40f585b3;   % 2242:                     sub a1,a1,a5  # Updates starting address on map matrix %
0000202c : 00100693;   % 2243:                     li a3,1  # Vertical check %
0000202d : 0d80006f;   % 2244:                     j START_ZOOMER_COLLISION %
0000202e : 00188893;   % 2248:                     addi a7,a7,1 # Checking one tile down %
0000202f : 00f585b3;   % 2249:                     add a1,a1,a5 # Updates starting address on map matrix %
00002030 : 00100693;   % 2250:                     li a3,1  # Vertical check %
00002031 : 0c80006f;   % 2251:                     j START_ZOOMER_COLLISION %
00002032 : 00200f13;   % 2254:         TRY_MOVE_ZOOMER_COLLISION_UP:  li t5,2 %
00002033 : 07e31463;   % 2255:             bne t1,t5,MOVE_ZOOMER_COLLISION_RIGHT %
00002034 : 00800f13;   % 2257:             li t5,8 %
00002035 : 007f1c63;   % 2258:             bne t5,t2,MOVE_ZOOMER_CHECK_UP_0_OFF  # If offset != 8, check if it's 0 %
00002036 : 00100713;   % 2259:                 li a4,1  # Base case: Consider doors %
00002037 : 00c70733;   % 2260:                 add a4,a4,a2 # If on second check, consider ONLY doors %
00002038 : 00200213;   % 2262:                 li tp,2  # Check 2 tiles %
00002039 : 40c20233;   % 2263:                 sub tp,tp,a2 # If on second check, check ONLY 1 tile %
0000203a : 00c0006f;   % 2265:                 j MOVE_ZOOMER_CHECK_UP_SETUP # start collision check %
0000203b : 00038463;   % 2268:             beqz t2, MOVE_ZOOMER_CHECK_UP_SETUP %
0000203c : 3140006f;   % 2269:                 j MOVE_ZOOMER_PROPERLY %
0000203d : 00061a63;   % 2272:             bnez a2, MOVE_ZOOMER_CHECK_UP_FOWARD %
0000203e : fff88893;   % 2274:                 addi a7,a7,-1 # Checking one tile above %
0000203f : 40f585b3;   % 2275:                 sub a1,a1,a5  # Updates starting address on map matrix %
00002040 : 00100693;   % 2276:                 li a3,1  # Vertical check %
00002041 : 0880006f;   % 2277:                 j START_ZOOMER_COLLISION %
00002042 : 000e8a63;   % 2281:                 beqz t4, MOVE_ZOOMER_CHECK_UP_FOWARD_CLOCKWISE %
00002043 : 00180813;   % 2283:                     addi a6,a6,1  # Checking right tile %
00002044 : 00158593;   % 2284:                     addi a1,a1,1   # Updates starting address on map matrix %
00002045 : 00000693;   % 2285:                     li a3,0  # Horizontal check %
00002046 : 0740006f;   % 2286:                     j START_ZOOMER_COLLISION %
00002047 : 00800f13;   % 2290:                     li t5,8 %
00002048 : 007f0663;   % 2291:                     beq t5,t2,MOVE_ZOOMER_CHECK_UP_FOWARD_CLOCKWISE_0_OFF  # If offset is 8, don't update this %
00002049 : fff80813;   % 2292:                         addi a6,a6,-1  # Checking left tile %
0000204a : fff58593;   % 2293:                         addi a1,a1,-1   # Updates starting address on map matrix %
0000204b : 00000693;   % 2295:                     li a3,0  # Horizontal check %
0000204c : 05c0006f;   % 2296:                     j START_ZOOMER_COLLISION %
0000204d : 00800313;   % 2301:             li t1,8 %
0000204e : 00731863;   % 2302:             bne t1,t2,MOVE_ZOOMER_CHECK_RIGHT_0_OFF  # If X offset != 8, skip this %
0000204f : 00100713;   % 2303:                 li a4,1  # Base case: Consider doors %
00002050 : 00c80833;   % 2305:                 add a6,a6,a2   # Checking right tile %
00002051 : 00c585b3;   % 2306:                 add a1,a1,a2   # Updates starting address on map matrix %
00002052 : 000e0463;   % 2310:             beqz t3, MOVE_ZOOMER_CHECK_RIGHT_SETUP %
00002053 : 2b80006f;   % 2311:                 j MOVE_ZOOMER_PROPERLY %
00002054 : 00061a63;   % 2314:             bnez a2, MOVE_ZOOMER_CHECK_RIGHT_FOWARD %
00002055 : 00180813;   % 2316:                 addi a6,a6,1   # Checking right tile %
00002056 : 00158593;   % 2317:                 addi a1,a1,1   # Updates starting address on map matrix %
00002057 : 00000693;   % 2318:                 li a3,0  # Horizontal check %
00002058 : 02c0006f;   % 2319:                 j START_ZOOMER_COLLISION %
00002059 : 00100713;   % 2323:                 li a4,1  # Base case: Consider doors %
0000205a : 000e8a63;   % 2324:                 beqz t4, MOVE_ZOOMER_CHECK_RIGHT_FOWARD_CLOCKWISE %
0000205b : 00188893;   % 2326:                     addi a7,a7,1 # Checking one tile down %
0000205c : 00f585b3;   % 2327:                     add a1,a1,a5 # Updates starting address on map matrix %
0000205d : 00100693;   % 2328:                     li a3,1  # Vertical check %
0000205e : 0140006f;   % 2329:                     j START_ZOOMER_COLLISION %
0000205f : fff88893;   % 2333:                     addi a7,a7,-1 # Checking one tile up %
00002060 : 40f585b3;   % 2334:                     sub a1,a1,a5  # Updates starting address on map matrix %
00002061 : 00100693;   % 2335:                     li a3,1  # Vertical check %
00002062 : 0040006f;   % 2336:                     j START_ZOOMER_COLLISION %
00002063 : ff010113;   % 2340:             addi sp,sp,-16 %
00002064 : 00112023;   % 2341:             sw ra,0(sp) %
00002065 : 00a12223;   % 2342:             sw a0,4(sp) %
00002066 : 00b12423;   % 2343:             sw a1,8(sp) %
00002067 : 00c12623;   % 2344:             sw a2,12(sp) %
00002068 : 00200513;   % 2347:             li a0,2  # All doors should be checked %
00002069 : 00400633;   % 2349:             mv a2,tp #li a2,1  # Only check one tile %
0000206a : 00100213;   % 2355:             li tp, 1  # Entity collision %
0000206b : 00000317;   % 2357:             call CHECK_MAP_COLLISION %
0000206c : 750300e7;   % 2357:  %
0000206d : 00a002b3;   % 2358:             mv t0,a0   # Stores result from a0 to t0 %
0000206e : 00b00233;   % 2359:             mv tp,a1   # Stores result from a1 to tp %
0000206f : 00012083;   % 2362:             lw ra,0(sp) %
00002070 : 00412503;   % 2363:             lw a0,4(sp) %
00002071 : 00812583;   % 2364:             lw a1,8(sp) %
00002072 : 00c12603;   % 2365:             lw a2,12(sp) %
00002073 : 01010113;   % 2366:             addi sp,sp,16 %
00002074 : 00060463;   % 2369:         beqz a2, MOVE_ZOOMER_FIRST_CHECK  %
00002075 : 18c0006f;   % 2370:             j MOVE_ZOOMER_SECOND_CHECK %
00002076 : 04029c63;   % 2374:             bnez t0, MOVE_ZOOMER_CHANGE_PLATFORM # If returning anything but 0, change zoomer's platform %
00002077 : 00800f13;   % 2375:             li t5,8 %
00002078 : 00254383;   % 2376:             lbu t2,2(a0)   # Loads Zoomer's X offset %
00002079 : 047f1263;   % 2377:             bne t5,t2,MOVE_ZOOMER_REPEAT_LOOP # If zoomer's X isn't 8, treat it as solid %
0000207a : 04020063;   % 2378:             beqz tp,MOVE_ZOOMER_REPEAT_LOOP # If zoomer isn't on top of a door, treat as solid %
0000207b : 00a54303;   % 2380:                 lbu t1,10(a0)  # Loads Zoomer's Platform %
0000207c : 00354e03;   % 2381:                 lbu t3,3(a0)   # Loads Zoomer's Y offset %
0000207d : 00954e83;   % 2382:                 lbu t4,9(a0)   # Loads Zoomer's Clock movement %
0000207e : 02031863;   % 2383:                 bnez t1,MOVE_ZOOMER_REPEAT_LOOP %
0000207f : 000e8c63;   % 2385:                     beqz t4, MOVE_ZOOMER_CHANGE_PLATFORM_DOWN_CLOCKWISE_OFF_8 %
00002080 : 00300313;   % 2387:                         li t1, 3       # Sets platform to 3 (on the right) %
00002081 : 00200e13;   % 2388:                         li t3, 2       # Sets Y offset to 4 %
00002082 : 00650523;   % 2390:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
00002083 : 01c501a3;   % 2391:                         sb t3,3(a0)   # Stores Zoomer's new Y offset %
00002084 : 2e00006f;   % 2392:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
00002085 : 00100313;   % 2396:                         li t1, 1       # Sets platform to 1 (on the left) %
00002086 : 00200e13;   % 2398:                         li t3, 2       # Sets Y offset to 4 %
00002087 : 00650523;   % 2400:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
00002088 : 01c501a3;   % 2401:                         sb t3,3(a0)   # Stores Zoomer's new Y offset %
00002089 : 2cc0006f;   % 2402:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
0000208a : 00100613;   % 2406:                 li a2,1 # Loads second check state %
0000208b : d89ff06f;   % 2407:                 j MOVE_ZOOMER_CHECK_LOOP # and return to the beginning %
0000208c : 00a54303;   % 2410:                 lbu t1,10(a0)  # Loads Zoomer's Platform %
0000208d : 00254383;   % 2411:                 lbu t2,2(a0)   # Loads Zoomer's X offset %
0000208e : 00354e03;   % 2412:                 lbu t3,3(a0)   # Loads Zoomer's Y offset %
0000208f : 00954e83;   % 2413:                 lbu t4,9(a0)   # Loads Zoomer's Clock movement %
00002090 : 02031863;   % 2414:                 bnez t1,TRY_MOVE_ZOOMER_CHANGE_PLATFORM_LEFT %
00002091 : 000e8c63;   % 2416:                     beqz t4, MOVE_ZOOMER_CHANGE_PLATFORM_DOWN_CLOCKWISE %
00002092 : 00300313;   % 2418:                         li t1, 3       # Sets platform to 3 (on the right) %
00002093 : 00200e13;   % 2420:                         li t3, 2       # Sets Y offset to 4 %
00002094 : 00650523;   % 2422:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
00002095 : 01c501a3;   % 2423:                         sb t3,3(a0)   # Stores Zoomer's new Y offset %
00002096 : 2980006f;   % 2424:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
00002097 : 00100313;   % 2428:                         li t1, 1       # Sets platform to 1 (on the left) %
00002098 : 00200e13;   % 2430:                         li t3, 2       # Sets Y offset to 4 %
00002099 : 00650523;   % 2432:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
0000209a : 01c501a3;   % 2433:                         sb t3,3(a0)   # Stores Zoomer's new Y offset %
0000209b : 2840006f;   % 2434:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
0000209c : 00100f13;   % 2436:                 TRY_MOVE_ZOOMER_CHANGE_PLATFORM_LEFT:  li t5,1 %
0000209d : 07e31063;   % 2437:                 bne t1,t5,TRY_MOVE_ZOOMER_CHANGE_PLATFORM_UP %
0000209e : 020e8e63;   % 2439:                     beqz t4, MOVE_ZOOMER_CHANGE_PLATFORM_LEFT_CLOCKWISE %
0000209f : 00000313;   % 2441:                         li t1, 0       # Sets platform to 0 (bellow) %
000020a0 : 00800f13;   % 2442:                         li t5,8 %
000020a1 : 027f0063;   % 2443:                         beq t5,t2,MOVE_ZOOMER_CHANGE_PLATFORM_LEFT_OFF_8 # If offset == 8, don't alter X %
000020a2 : 00e00393;   % 2444:                             li t2, 14      # Sets X offset to 12 %
000020a3 : 00454e83;   % 2445:                             lbu t4,4(a0)   # Loads Zoomer's X %
000020a4 : fffe8e93;   % 2446:                             addi t4,t4,-1  # Subtracts 1 from it (offset was reduced) %
000020a5 : 00650523;   % 2449:                             sb t1,10(a0)  # Stores Zoomer's new Platform %
000020a6 : 00750123;   % 2450:                             sb t2,2(a0)   # Stores Zoomer's new X offset %
000020a7 : 01d50223;   % 2451:                             sb t4,4(a0)   # Stores Zoomer's new X %
000020a8 : 2500006f;   % 2452:                             j END_MOVE_ZOOMER # Ends Move Zoomer %
000020a9 : 00600393;   % 2455:                             li t2, 6       # Sets X offset to 6 %
000020aa : 00650523;   % 2458:                             sb t1,10(a0)  # Stores Zoomer's new Platform %
000020ab : 00750123;   % 2459:                             sb t2,2(a0)   # Stores Zoomer's new X offset %
000020ac : 2400006f;   % 2460:                             j END_MOVE_ZOOMER # Ends Move Zoomer %
000020ad : 00200313;   % 2465:                         li t1, 2       # Sets platform to 2 (above) %
000020ae : 00e00393;   % 2466:                         li t2, 14      # Sets X offset to 12 %
000020af : 00454e83;   % 2467:                         lbu t4,4(a0)   # Loads Zoomer's X %
000020b0 : fffe8e93;   % 2468:                         addi t4,t4,-1  # Subtracts 1 from it (offset was reduced) %
000020b1 : 00650523;   % 2471:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
000020b2 : 00750123;   % 2472:                         sb t2,2(a0)   # Stores Zoomer's new X offset %
000020b3 : 01d50223;   % 2473:                         sb t4,4(a0)   # Stores Zoomer's new X %
000020b4 : 2200006f;   % 2474:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
000020b5 : 00200f13;   % 2476:                 TRY_MOVE_ZOOMER_CHANGE_PLATFORM_UP:  li t5,2 %
000020b6 : 05e31463;   % 2477:                 bne t1,t5,MOVE_ZOOMER_CHANGE_PLATFORM_RIGHT %
000020b7 : 020e8263;   % 2479:                     beqz t4, MOVE_ZOOMER_CHANGE_PLATFORM_UP_CLOCKWISE %
000020b8 : 00100313;   % 2481:                         li t1, 1       # Sets platform to 1 (on the left) %
000020b9 : 00e00e13;   % 2483:                         li t3, 14      # Sets Y offset to 12 %
000020ba : 00654e83;   % 2484:                         lbu t4,6(a0)   # Loads Zoomer's Y %
000020bb : fffe8e93;   % 2485:                         addi t4,t4,-1  # Subtracts 1 from it (offset was reduced) %
000020bc : 00650523;   % 2487:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
000020bd : 01c501a3;   % 2488:                         sb t3,3(a0)   # Stores Zoomer's new Y offset %
000020be : 01d50323;   % 2489:                         sb t4,6(a0)   # Stores Zoomer's new Y %
000020bf : 1f40006f;   % 2490:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
000020c0 : 00300313;   % 2494:                         li t1, 3       # Sets platform to 3 (on the right) %
000020c1 : 00e00e13;   % 2496:                         li t3, 14      # Sets Y offset to 12 %
000020c2 : 00654e83;   % 2497:                         lbu t4,6(a0)   # Loads Zoomer's Y %
000020c3 : fffe8e93;   % 2498:                         addi t4,t4,-1  # Subtracts 1 from it (offset was reduced) %
000020c4 : 00650523;   % 2500:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
000020c5 : 01c501a3;   % 2501:                         sb t3,3(a0)   # Stores Zoomer's new Y offset %
000020c6 : 01d50323;   % 2502:                         sb t4,6(a0)   # Stores Zoomer's new Y %
000020c7 : 1d40006f;   % 2503:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
000020c8 : 000e8c63;   % 2507:                     beqz t4, MOVE_ZOOMER_CHANGE_PLATFORM_RIGHT_CLOCKWISE %
000020c9 : 00200313;   % 2509:                         li t1, 2       # Sets platform to 2 (above) %
000020ca : 00200393;   % 2510:                         li t2, 2       # Sets X offset to 4 %
000020cb : 00650523;   % 2513:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
000020cc : 00750123;   % 2514:                         sb t2,2(a0)   # Stores Zoomer's new X offset %
000020cd : 1bc0006f;   % 2515:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
000020ce : 00000313;   % 2519:                         li t1, 0       # Sets platform to 0 (bellow) %
000020cf : 00038a63;   % 2520:                         beqz t2,MOVE_ZOOMER_CHANGE_PLATFORM_RIGHT_CLOCKWISE_0 %
000020d0 : 00a00393;   % 2521:                             li t2, 10      # Sets X offset to 10 %
000020d1 : 00650523;   % 2524:                             sb t1,10(a0)  # Stores Zoomer's new Platform %
000020d2 : 00750123;   % 2525:                             sb t2,2(a0)   # Stores Zoomer's new X offset %
000020d3 : 1a40006f;   % 2526:                             j END_MOVE_ZOOMER # Ends Move Zoomer %
000020d4 : 00200393;   % 2528:                             li t2, 2      # Sets X offset to 4 %
000020d5 : 00650523;   % 2531:                             sb t1,10(a0)  # Stores Zoomer's new Platform %
000020d6 : 00750123;   % 2532:                             sb t2,2(a0)   # Stores Zoomer's new X offset %
000020d7 : 1940006f;   % 2533:                             j END_MOVE_ZOOMER # Ends Move Zoomer %
000020d8 : 0a029263;   % 2537:             bnez t0, MOVE_ZOOMER_PROPERLY  # If returning anything but 0, properly move zoomer %
000020d9 : 00a54303;   % 2539:                 lbu t1,10(a0)  # Loads Zoomer's Platform %
000020da : 00954e83;   % 2541:                 lbu t4,9(a0)   # Loads Zoomer's Clock movement %
000020db : 02031863;   % 2542:                 bnez t1,TRY_MOVE_ZOOMER_CHANGE_PLATFORM_LEFT_V2 %
000020dc : 00254383;   % 2544:                     lbu t2,2(a0)   # Loads Zoomer's new X offset %
000020dd : 00800f13;   % 2545:                     li t5,8 %
000020de : 007f0463;   % 2546:                     beq t5,t2,CONTINUE_MOVE_ZOOMER_CHANGE_PLATFORM_DOWN # If offset == 8, continue %
000020df : 08021463;   % 2548:                         bnez tp,MOVE_ZOOMER_PROPERLY # If there was a door, don't change direction %
000020e0 : 000e8863;   % 2550:                     beqz t4, MOVE_ZOOMER_CHANGE_PLATFORM_DOWN_CLOCKWISE_V2 %
000020e1 : 00100313;   % 2552:                         li t1, 1       # Sets platform to 1 (on the left) %
000020e2 : 00650523;   % 2553:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
000020e3 : 1640006f;   % 2554:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
000020e4 : 00300313;   % 2558:                         li t1, 3       # Sets platform to 3 (on the right) %
000020e5 : 00650523;   % 2559:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
000020e6 : 1580006f;   % 2560:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
000020e7 : 00100f13;   % 2562:                 TRY_MOVE_ZOOMER_CHANGE_PLATFORM_LEFT_V2:  li t5,1 %
000020e8 : 03e31063;   % 2563:                 bne t1,t5,TRY_MOVE_ZOOMER_CHANGE_PLATFORM_UP_V2 %
000020e9 : 000e8863;   % 2565:                     beqz t4, MOVE_ZOOMER_CHANGE_PLATFORM_LEFT_CLOCKWISE_V2 %
000020ea : 00200313;   % 2567:                         li t1, 2       # Sets platform to 2 (above) %
000020eb : 00650523;   % 2568:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
000020ec : 1400006f;   % 2569:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
000020ed : 00000313;   % 2573:                         li t1, 0       # Sets platform to 0 (bellow) %
000020ee : 00650523;   % 2574:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
000020ef : 1340006f;   % 2575:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
000020f0 : 00200f13;   % 2577:                 TRY_MOVE_ZOOMER_CHANGE_PLATFORM_UP_V2:  li t5,2 %
000020f1 : 03e31063;   % 2578:                 bne t1,t5,MOVE_ZOOMER_CHANGE_PLATFORM_RIGHT_V2 %
000020f2 : 000e8863;   % 2580:                     beqz t4, MOVE_ZOOMER_CHANGE_PLATFORM_UP_CLOCKWISE_V2 %
000020f3 : 00300313;   % 2582:                         li t1, 3       # Sets platform to 3 (on the right) %
000020f4 : 00650523;   % 2583:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
000020f5 : 11c0006f;   % 2584:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
000020f6 : 00100313;   % 2588:                         li t1, 1       # Sets platform to 1 (on the left) %
000020f7 : 00650523;   % 2589:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
000020f8 : 1100006f;   % 2590:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
000020f9 : 02021063;   % 2594:                     bnez tp,MOVE_ZOOMER_PROPERLY %
000020fa : 000e8863;   % 2595:                     beqz t4, MOVE_ZOOMER_CHANGE_PLATFORM_RIGHT_CLOCKWISE_V2 %
000020fb : 00000313;   % 2597:                         li t1, 0       # Sets platform to 0 (bellow) %
000020fc : 00650523;   % 2598:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
000020fd : 0fc0006f;   % 2599:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
000020fe : 00200313;   % 2603:                         li t1, 2       # Sets platform to 2 (above) %
000020ff : 00650523;   % 2604:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
00002100 : 0f00006f;   % 2605:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
00002101 : 00a54303;   % 2609:             lbu t1,10(a0)  # Loads Zoomer's Platform %
00002102 : 00254383;   % 2610:             lbu t2,2(a0)   # Loads Zoomer's X offset %
00002103 : 00354e03;   % 2611:             lbu t3,3(a0)   # Loads Zoomer's Y offset %
00002104 : 00954e83;   % 2612:             lbu t4,9(a0)   # Loads Zoomer's Clock movement %
00002105 : 00031c63;   % 2613:             bnez t1,TRY_MOVE_ZOOMER_PROPERLY_LEFT %
00002106 : 000e8663;   % 2615:                 beqz t4, MOVE_ZOOMER_PROPERLY_DOWN_CLOCKWISE %
00002107 : ffe38393;   % 2617:                     addi t2,t2,-2     # Updates X offset %
00002108 : 0540006f;   % 2619:                     j MOVE_ZOOMER_PROPERLY_OFFSET_CHECK # Checking if offset is ok %
00002109 : 00238393;   % 2623:                     addi t2,t2,2     # Updates X offset %
0000210a : 04c0006f;   % 2625:                     j MOVE_ZOOMER_PROPERLY_OFFSET_CHECK # Checking if offset is ok %
0000210b : 00100f13;   % 2627:             TRY_MOVE_ZOOMER_PROPERLY_LEFT:  li t5,1 %
0000210c : 01e31c63;   % 2628:             bne t1,t5,TRY_MOVE_ZOOMER_PROPERLY_UP %
0000210d : 000e8663;   % 2630:                 beqz t4, MOVE_ZOOMER_PROPERLY_LEFT_CLOCKWISE %
0000210e : ffee0e13;   % 2633:                     addi t3,t3,-2     # Updates Y offset %
0000210f : 0380006f;   % 2634:                     j MOVE_ZOOMER_PROPERLY_OFFSET_CHECK # Checking if offset is ok %
00002110 : 002e0e13;   % 2639:                     addi t3,t3,2     # Updates Y offset %
00002111 : 0300006f;   % 2640:                     j MOVE_ZOOMER_PROPERLY_OFFSET_CHECK # Checking if offset is ok %
00002112 : 00200f13;   % 2642:             TRY_MOVE_ZOOMER_PROPERLY_UP:  li t5,2 %
00002113 : 01e31c63;   % 2643:             bne t1,t5,MOVE_ZOOMER_PROPERLY_RIGHT %
00002114 : 000e8663;   % 2645:                 beqz t4, MOVE_ZOOMER_PROPERLY_UP_CLOCKWISE %
00002115 : 00238393;   % 2647:                     addi t2,t2,2     # Updates X offset %
00002116 : 01c0006f;   % 2649:                     j MOVE_ZOOMER_PROPERLY_OFFSET_CHECK # Checking if offset is ok %
00002117 : ffe38393;   % 2653:                     addi t2,t2,-2     # Updates X offset %
00002118 : 0140006f;   % 2655:                     j MOVE_ZOOMER_PROPERLY_OFFSET_CHECK # Checking if offset is ok %
00002119 : 000e8663;   % 2659:                 beqz t4, MOVE_ZOOMER_PROPERLY_RIGHT_CLOCKWISE %
0000211a : 002e0e13;   % 2662:                     addi t3,t3,2     # Updates Y offset %
0000211b : 0080006f;   % 2663:                     j MOVE_ZOOMER_PROPERLY_OFFSET_CHECK # Checking if offset is ok %
0000211c : ffee0e13;   % 2668:                     addi t3,t3,-2     # Updates Y offset %
0000211d : 00750123;   % 2672:                 sb t2,2(a0)   # Stores Zoomer's new X offset (may change depending on next checks) %
0000211e : 0003de63;   % 2673:                 bge t2,zero, SKIP_MOVE_ZOOMER_PROPERLY_X_OFFSET_NEGATIVE %
0000211f : 01038393;   % 2675:                     addi t2,t2,16 # adds 16 to offset %
00002120 : 00454e83;   % 2676:                     lbu t4,4(a0)         # Loads Zoomer's X %
00002121 : fffe8e93;   % 2677:                     addi t4,t4,-1        # subtracts 1 from it %
00002122 : 00750123;   % 2679:                     sb t2,2(a0)          # Stores Zoomer's new X offset %
00002123 : 01d50223;   % 2680:                     sb t4,4(a0)          # Stores Zoomer's new X %
00002124 : 0200006f;   % 2681:                     j MOVE_ZOOMER_PROPERLY_OFFSET_CHECK_Y    # check Y offset %
00002125 : 01000293;   % 2685:                 li t0,16 %
00002126 : 0053cc63;   % 2686:                 blt t2,t0,MOVE_ZOOMER_PROPERLY_OFFSET_CHECK_Y # X offset is ok %
00002127 : 405383b3;   % 2688:                     sub t2,t2,t0         # subtracts 16 to offset %
00002128 : 00454e83;   % 2689:                     lbu t4,4(a0)         # Loads Zoomer's X %
00002129 : 001e8e93;   % 2690:                     addi t4,t4,1         # adds 1 from it %
0000212a : 00750123;   % 2692:                     sb t2,2(a0)          # Stores Zoomer's new X offset %
0000212b : 01d50223;   % 2693:                     sb t4,4(a0)          # Stores Zoomer's new X %
0000212c : 01c501a3;   % 2697:                 sb t3,3(a0)   # Stores Zoomer's new X offset (may change depending on next checks) %
0000212d : 000e5e63;   % 2698:                 bge t3,zero, SKIP_MOVE_ZOOMER_PROPERLY_Y_OFFSET_NEGATIVE %
0000212e : 010e0e13;   % 2700:                     addi t3,t3,16 # adds 16 to offset %
0000212f : 00654e83;   % 2701:                     lbu t4,6(a0)         # Loads Zoomer's Y %
00002130 : fffe8e93;   % 2702:                     addi t4,t4,-1        # subtracts 1 from it %
00002131 : 01c501a3;   % 2704:                     sb t3,3(a0)          # Stores Zoomer's new Y offset %
00002132 : 01d50323;   % 2705:                     sb t4,6(a0)          # Stores Zoomer's new Y %
00002133 : 0240006f;   % 2706:                     j END_MOVE_ZOOMER    # Finishes procedure %
00002134 : 01000293;   % 2710:                 li t0,16 %
00002135 : 005e4e63;   % 2711:                 blt t3,t0,END_MOVE_ZOOMER # Y offset is ok %
00002136 : 405e0e33;   % 2713:                     sub t3,t3,t0         # subtracts 16 to offset %
00002137 : 00654e83;   % 2714:                     lbu t4,6(a0)         # Loads Zoomer's Y %
00002138 : 001e8e93;   % 2715:                     addi t4,t4,1         # adds 1 from it %
00002139 : 01c501a3;   % 2717:                     sb t3,3(a0)          # Stores Zoomer's new Y offset %
0000213a : 01d50323;   % 2718:                     sb t4,6(a0)          # Stores Zoomer's new Y %
0000213b : 0040006f;   % 2719:                     j END_MOVE_ZOOMER    # Finishes procedure %
0000213c : 00410113;   % 2724:         addi sp,sp,4 %
0000213d : 00008067;   % 2726:         ret %
0000213e : 00354303;   % 2751:     lbu t1,3(a0)  # Loads Ripper's X %
0000213f : 00650223;   % 2752:     sb t1,4(a0)   # And stores it in Ripper's old  %
00002140 : 00554303;   % 2753:     lbu t1,5(a0)  # Loads Ripper's Y %
00002141 : 00650323;   % 2754:     sb t1,6(a0)   # And stores it in Ripper's old Y %
00002142 : 00100293;   % 2757:     li t0,1       # In case no collision check is made %
00002143 : 00254303;   % 2758:     lbu t1,2(a0)  # Loads Ripper's X offset %
00002144 : 06031e63;   % 2760:     bnez t1,SKIP_RIPPER_COLLISION   # If offset isn't 0, just move ripper %
00002145 : 0015c783;   % 2762:         lbu a5,1(a1)  # Loads map's matrix width %
00002146 : 00354803;   % 2763:         lbu a6,3(a0)  # Loads Ripper's current X %
00002147 : 00554883;   % 2764:         lbu a7,5(a0)  # Loads Ripper's current Y %
00002148 : 00358593;   % 2766:         addi a1,a1,3   # Adds 3 to the Matrix's address so that it goes to the beginning of matrix %
00002149 : 02f882b3;   % 2767:         mul t0,a7,a5   # Ripper's Y related to matrix * Map Matrix's width %
0000214a : 005802b3;   % 2768:         add t0,a6,t0   # t0 = Ripper's X related to matrix +  Ripper's Y related to matrix * Map Matrix's width   %
0000214b : 005585b3;   % 2769:         add a1,a1,t0   # a1 = Map Matrix's address adjusted for Ripper's X and Y related to matrix %
0000214c : 00154283;   % 2771:         lbu t0,1(a0)  # Loads Ripper's direction %
0000214d : 00028863;   % 2772:         beqz t0,RIPPER_COLLISION_RIGHT   # If moving right %
0000214e : fff80813;   % 2774:             addi a6,a6,-1 # Checking tile to the left %
0000214f : fff58593;   % 2775:             addi a1,a1,-1 # Updates starting address on map matrix %
00002150 : 00c0006f;   % 2776:             j START_RIPPER_COLLISION %
00002151 : 00180813;   % 2779:             addi a6,a6,1 # Checking tile to the right %
00002152 : 00158593;   % 2780:             addi a1,a1,1 # Updates starting address on map matrix %
00002153 : ff410113;   % 2785:         addi sp,sp,-12 %
00002154 : 00a12023;   % 2786:         sw a0,0(sp) %
00002155 : 00b12223;   % 2787:         sw a1,4(sp) %
00002156 : 00112423;   % 2788:         sw ra,8(sp) %
00002157 : 00200513;   % 2791:         li a0,2  # Doesn't matter, since no doors will be checked %
00002158 : 00100613;   % 2793:         li a2,1  # Only check one tile %
00002159 : 00000693;   % 2794:         li a3,0  # Horizontal check %
0000215a : 00000713;   % 2795:         li a4,0  # Don't consider doors (since it never spawns there) %
0000215b : 00100213;   % 2799:         li tp, 1  # Entity collision %
0000215c : 00000317;   % 2801:         call CHECK_MAP_COLLISION %
0000215d : 38c300e7;   % 2801:  %
0000215e : 00a002b3;   % 2802:         mv t0,a0 %
0000215f : 00012503;   % 2805:         lw a0,0(sp) %
00002160 : 00412583;   % 2806:         lw a1,4(sp) %
00002161 : 00812083;   % 2807:         lw ra,8(sp) %
00002162 : 00c10113;   % 2808:         addi sp,sp,12 %
00002163 : 00154303;   % 2813:         lbu t1,1(a0)  # Loads Ripper's direction %
00002164 : 00029863;   % 2814:         bnez t0, CONTINUE_MOVE_RIPPER  # If returning anything but 0, continue moving ripper %
00002165 : 00134313;   % 2816:             xori t1,t1,1  # Inverts direction %
00002166 : 006500a3;   % 2817:             sb t1,1(a0)   # and stores it back %
00002167 : 00008067;   % 2818:             ret # and finish procedure %
00002168 : 00354283;   % 2822:             lbu t0,3(a0)  # Loads Ripper's X %
00002169 : 00254383;   % 2823:             lbu t2,2(a0)  # Loads Ripper's X offset %
0000216a : 02030063;   % 2824:             beqz t1,MOVE_RIPPER_RIGHT  # If direction is to the right %
0000216b : ffe38393;   % 2826:                 addi t2,t2,-2   # Movement for ripper to the left %
0000216c : 0003d663;   % 2827:                 bge t2,zero,MOVE_RIPPER_LEFT_SKIP_CORRECTION %
0000216d : 01038393;   % 2828:                     addi t2,t2,16 # adds 16 to offset %
0000216e : fff28293;   % 2829:                     addi t0,t0,-1        # subtracts 1 from X %
0000216f : 005501a3;   % 2831:                     sb t0,3(a0)    # Stores Ripper's new X %
00002170 : 00750123;   % 2832:                     sb t2,2(a0)    # Stores Ripper's new X offset %
00002171 : 00008067;   % 2833:                     ret # and finish procedure %
00002172 : 00238393;   % 2836:                 addi t2,t2,2      # Movement for ripper to the right %
00002173 : 01000313;   % 2837:                 li t1,16   # loads 16 %
00002174 : 0063c663;   % 2838:                 blt t2,t1,MOVE_RIPPER_RIGHT_SKIP_CORRECTION %
00002175 : 406383b3;   % 2839:                     sub t2,t2,t1  # subtracts 16 from offset %
00002176 : 00128293;   % 2840:                     addi t0,t0,1  # subtracts 1 from X %
00002177 : 005501a3;   % 2842:                     sb t0,3(a0)   # Stores Ripper's new X %
00002178 : 00750123;   % 2843:                     sb t2,2(a0)   # Stores Ripper's new X offset %
00002179 : 00008067;   % 2844:                     ret # and finish procedure %
0000217a : 00254683;   % 2872:     lbu a3,2(a0)    # Loads Ridley's Y offset %
0000217b : 00354603;   % 2874:     lbu a2,3(a0)  # Loads Ridley's Y %
0000217c : 00c50223;   % 2875:     sb a2,4(a0)   # And stores it in Ridley's old Y %
0000217d : 00750283;   % 2878:     lb t0,7(a0)   # Loads Ridley's MOVE_Y %
0000217e : 00850383;   % 2879:     lb t2,8(a0)   # Loads JUMP information %
0000217f : 0002c663;   % 2880:     blt t0,zero, MOVE_RIDLEY_UP   # In case MOVE_Y = -1 %
00002180 : 02029663;   % 2881:     bnez t0, ITERATE_RIDLEY_JUMP  # In case of MOVE_Y = 1, just iterate jump downards %
00002181 : 1280006f;   % 2883:         j MOVE_RIDLEY_PROPERLY %
00002182 : c00a7353;   % 2886:         fcvt.w.s t1,fs4                    # gets Ridley's current Y speed (truncated) %
00002183 : 00035663;   % 2887:         bge t1,zero, SWITCH_RIDLEY_DOWN    # if less then zero, switch down %
00002184 : 02800313;   % 2888:         li t1, 40             # maximum height of jump  %
00002185 : 0063cc63;   % 2889:         blt t2, t1, ITERATE_RIDLEY_JUMP    # if still not there, iterate jump %
00002186 : 00100313;   % 2892:                 li t1, 1         # Loads 1 (Down)        %
00002187 : 006503a3;   % 2893:                 sb t1, 7(a0)     # Switches MOVE_Y to 1 (Down)   %
00002188 : 00050423;   % 2894:                 sb zero, 8(a0)   # reset jump information %
00002189 : d0007a53;   % 2896:                 fcvt.s.w fs4,zero       # Sets speed to zero        %
0000218a : 1300006f;   % 2897:                 j END_MOVE_RIDLEY   %
0000218b : 008a7a53;   % 2900:             fadd.s fs4,fs4,fs0    # fs4 = Ridley's current Y speed + gravity factor        %
0000218c : c00a7e53;   % 2901:             fcvt.w.s t3,fs4       # Sets t3 = floor(fs4) %
0000218d : 01c002b3;   % 2911:             mv t0,t3                # moves t3 to t0 %
0000218e : 0002d463;   % 2912:             bge t0,zero, SKIP_ABS_RIDLEY   # if t0 >= 0, skip this %
0000218f : 405002b3;   % 2913:                 sub t0,zero,t0             # otherwise, t0 will be its opposite  %
00002190 : 005383b3;   % 2915:                 add t2,t2,t0               # t0 to t2 (JUMP factor) %
00002191 : 00750423;   % 2916:                 sb t2, 8(a0)               # and stores it %
00002192 : 01c686b3;   % 2918:         add a3,a3,t3	# Adds the Y Movement to the Ridley's Offset %
00002193 : 0006d663;   % 2920:         bge a3,zero,SKIP_UP_Y_RIDLEY %
00002194 : fff60613;   % 2922:         addi a2, a2, -1		    # Ridley's Y on matrix -= 1 (goes to the left) %
00002195 : 01068693;   % 2923:         addi a3, a3, 16  # Offset gets corrected (relative to new Y on matrix coordinate) %
00002196 : 01000293;   % 2926:             li t0, 16 %
00002197 : 0056c663;   % 2927:             blt a3,t0, SKIP_DOWN_Y_RIDLEY %
00002198 : 00160613;   % 2929:             addi a2,a2, 1	 # Ridley's Y on matrix += 1 (goes to the right) %
00002199 : 405686b3;   % 2930:             sub a3,a3,t0	 # Offset gets corrected (relative to new Y on matrix coordinate) %
0000219a : 00100293;   % 2934:         li t0,1       # In case no collision check is made %
0000219b : 00750303;   % 2935:         lb t1,7(a0)   # Loads Ridley's MOVE_Y %
0000219c : 0a034e63;   % 2936:         blt t1,zero,MOVE_RIDLEY_PROPERLY # If moving up, doesn't need collision (he doesn't jump to high) %
0000219d : 00254283;   % 2938:             lbu t0,2(a0)   # Loads Ridley's Y offset %
0000219e : 00a00313;   % 2939:             li t1, 10      # For comparing %
0000219f : 01c282b3;   % 2940:             add t0,t0,t3   # Current Y offset + Y offset modifier %
000021a0 : 0062d463;   % 2942:             bge t0,t1 CONTINUE_RIDLEY_COLLISION    # If the result >= 10, continue checking %
000021a1 : 0a80006f;   % 2943:                 j MOVE_RIDLEY_PROPERLY             # Othewise, just move the reptile dragon thing ¯\_(ツ)_/¯ %
000021a2 : 00750283;   % 2946:             lb t0,7(a0)   # Loads Ridley's MOVE_Y %
000021a3 : 00504463;   % 2947:             bgt t0,zero CONTINUE_RIDLEY_COLLISION_2   # In case MOVE_Y = 1 %
000021a4 : 09c0006f;   % 2948:                 j MOVE_RIDLEY_PROPERLY # If MOVE_Y = 0 or -1 %
000021a5 : 0015c783;   % 2951:             lbu a5,1(a1)     # Loads map's matrix width %
000021a6 : 00900813;   % 2952:             li a6,9   # Loads Ridley's current X %
000021a7 : 00354883;   % 2953:             lbu a7,3(a0)     # Loads Ridley's current Y %
000021a8 : 00388893;   % 2954:             addi a7,a7,3     # adds 3 to Y, so that address will be 3 tiles down %
000021a9 : 00358593;   % 2956:             addi a1,a1,3          # Adds 3 to the Matrix's address so that it goes to the beginning of matrix %
000021aa : 02f882b3;   % 2957:             mul t0,a7,a5          # (Ridley's matrix Y + 3)  * Map Matrix's width %
000021ab : 005802b3;   % 2958:             add t0,a6,t0          # t0 = Ridley's X related to matrix + (Ridley's matrix Y + 3)  * Map Matrix's width %
000021ac : 005585b3;   % 2959:             add a1,a1,t0          # a1 = Map Matrix's address adjusted for Ridley's X and Y (+3) related to matrix        %
000021ad : fec10113;   % 2963:                 addi sp,sp,-20 %
000021ae : 00d12823;   % 2964:                 sw a3,16(sp) %
000021af : 00c12623;   % 2965:                 sw a2,12(sp) %
000021b0 : 00b12423;   % 2966:                 sw a1,8(sp) %
000021b1 : 00a12223;   % 2967:                 sw a0,4(sp) %
000021b2 : 00112023;   % 2968:                 sw ra,0(sp) %
000021b3 : 00200513;   % 2971:                 li a0,2  # Doesn't matter, since no doors will be checked %
000021b4 : 00100613;   % 2973:                 li a2,1  # Only check one tile %
000021b5 : 00100693;   % 2974:                 li a3,1  # Vertical check %
000021b6 : 00000713;   % 2975:                 li a4,0  # Don't consider doors (since it never spawns there) %
000021b7 : 00100213;   % 2979:                 li tp, 1  # Entity collision %
000021b8 : 00000317;   % 2980:                 call CHECK_MAP_COLLISION %
000021b9 : 21c300e7;   % 2980:  %
000021ba : 00a002b3;   % 2981:                 mv t0,a0 %
000021bb : 01012683;   % 2984:                 lw a3,16(sp) %
000021bc : 00c12603;   % 2985:                 lw a2,12(sp) %
000021bd : 00812583;   % 2986:                 lw a1,8(sp) %
000021be : 00412503;   % 2987:                 lw a0,4(sp) %
000021bf : 00012083;   % 2988:                 lw ra,0(sp) %
000021c0 : 01410113;   % 2989:                 addi sp,sp,20 %
000021c1 : 02029463;   % 2993:             bnez t0, MOVE_RIDLEY_PROPERLY   # If returning anything but 0, Ridley can move %
000021c2 : d0007a53;   % 2995:                 fcvt.s.w fs4,zero # Resets Ridley's jump speed %
000021c3 : 000503a3;   % 2996:                 sb zero, 7(a0) # RIDLEY_MOVE_Y = 0 %
000021c4 : 00050423;   % 2997:                 sb zero, 8(a0) # RIDLEY_JUMP = 0 %
000021c5 : 00a00293;   % 2999:                 li t0,10        # setting new Y offset     %
000021c6 : 00550123;   % 3000:                 sb t0,2(a0)     # Sets Ridley's Y offset to 10 %
000021c7 : 00954283;   % 3002:                 lbu t0, 9(a0)   # Loads jump cooldown %
000021c8 : 00029663;   % 3003:                 bnez t0,MOVE_RIDLEY_SKIP_COOLDOWN_RESET  # If cooldown isn't 0, don't reset it %
000021c9 : 01400293;   % 3005:                     li t0,20   %
000021ca : 005504a3;   % 3006:                     sb t0, 9(a0) %
000021cb : 00954283;   % 3011:             lbu t0, 9(a0)   # Loads jump cooldown  %
000021cc : 00029863;   % 3012:             bnez t0,MOVE_RIDLEY_PROPERLY_ITERATE_COOLDOWN %
000021cd : 00c501a3;   % 3014:                 sb a2,3(a0)     # Stores Ridley's new Y  %
000021ce : 00d50123;   % 3015:                 sb a3,2(a0)     # Stores new Y offset %
000021cf : 01c0006f;   % 3016:                 j END_MOVE_RIDLEY %
000021d0 : fff28293;   % 3020:                 addi t0,t0,-1   # Takes 1 from cooldown %
000021d1 : 00029863;   % 3021:                 bnez t0,MOVE_RIDLEY_PROPERLY_FINISH_ITERATE_COOLDOWN %
000021d2 : 21398a53;   % 3023:                     fmv.s fs4,fs3  # moves ridley's initial speed to fs4 %
000021d3 : fff00313;   % 3024:                     li t1,-1       # Loads -1 (Up) %
000021d4 : 006503a3;   % 3025:                     sb t1,7(a0)    # and stores it on Ridley's MOVE_Y %
000021d5 : 005504a3;   % 3029:                     sb t0, 9(a0)   # Loads jump cooldown %
000021d6 : 00008067;   % 3033:         ret %
000021d7 : 00654e03;   % 3064:     lbu t3,6(a0) # Loads plasma breath's current X %
000021d8 : 01c503a3;   % 3065:     sb t3,7(a0)  # And stores it on old X %
000021d9 : 00354283;   % 3067:     lbu t0,3(a0) # Loads plasma breath's X offset %
000021da : 00154303;   % 3068:     lbu t1,1(a0) # Loads plasma breath's X movement (always positive) %
000021db : 006282b3;   % 3070:     add t0,t0,t1 # Adds X movement to X offset %
000021dc : 01000393;   % 3072:     li t2,16 # Loads 16 %
000021dd : 0072c663;   % 3073:     blt t0,t2,MOVE_PLASMA_BREATH_SKIP_CORRECTION # If less than 16, skip correction %
000021de : 001e0e13;   % 3074:         addi t3,t3,1   # Adds 1 to X %
000021df : 407282b3;   % 3075:         sub t0,t0,t2   # Corrects X offset  %
000021e0 : 01c50323;   % 3077:         sb t3,6(a0)    # Stores new X (or the same, if unaltered) %
000021e1 : 005501a3;   % 3078:         sb t0,3(a0)    # Stores new X offset %
000021e2 : 01000313;   % 3080:     li t1,16  # Loads X where plasma breath should be disabled %
000021e3 : 006e4663;   % 3081:     blt t3,t1,MOVE_PLASMA_BREATH_KEEP  # If it didn't surpass the threshold, continue %
000021e4 : 00200313;   % 3083:         li t1,2     # Loads "To be Disabled"  %
000021e5 : 00650023;   % 3084:         sb t1,0(a0) # and stores it on enable byte %
000021e6 : 00854603;   % 3090:     lbu a2,8(a0)    # Loads plasma breath's current Y %
000021e7 : 00c504a3;   % 3091:     sb a2,9(a0)     # And stores it on old Y %
000021e8 : 00454683;   % 3092:     lbu a3,4(a0)    # Loads plasma breath's current Y offset %
000021e9 : 00250283;   % 3095:     lb t0,2(a0)   # Loads Plasma Breath's MOVE_Y %
000021ea : 0002c463;   % 3097:     blt t0,zero, MOVE_PLASMA_BREATH_UP   # In case MOVE_Y = -1  %
000021eb : 01c0006f;   % 3098:         j ITERATE_PLASMA_BREATH_JUMP     # Otherwise, just iterate %
000021ec : c0057353;   % 3101:         fcvt.w.s t1,fa0                           # Gets Plasma Breath's current Y speed (truncated) %
000021ed : 00035463;   % 3102:         bge t1,zero, SWITCH_PLASMA_BREATH_DOWN    # If less then zero, switch down %
000021ee : 0100006f;   % 3103:         j ITERATE_PLASMA_BREATH_JUMP                     # If still not there, iterate jump %
000021ef : 00100313;   % 3106:                 li t1, 1         # Loads 1 (Down)        %
000021f0 : 00650123;   % 3107:                 sb t1, 2(a0)     # Switches MOVE_Y to 1 (Down)  %
000021f1 : 1340006f;   % 3110:                 j END_MOVE_PLASMA_BREATH %
000021f2 : 00857553;   % 3113:             fadd.s fa0,fa0,fs0    # fa0 = Plasma Breath's current Y speed + gravity factor        %
000021f3 : c0057e53;   % 3114:             fcvt.w.s t3,fa0       # Sets t3 = floor(fa0) %
000021f4 : 00800293;   % 3116:             li t0,8             # Loads max speed (8, when falling) %
000021f5 : 005e4663;   % 3117:             blt t3,t0, SKIP_PLASMA_MAX_SPEED   # If t3 < 8, skip this part %
000021f6 : 00800e13;   % 3119:                 li t3,8 %
000021f7 : d002f553;   % 3120:                 fcvt.s.w fa0,t0 %
000021f8 : 01c686b3;   % 3131:         add a3,a3,t3	# Adds the Y Movement to the Plasma Breath's Offset       %
000021f9 : 0006d663;   % 3132:         bge a3,zero,SKIP_UP_Y_PLASMA_BREATH %
000021fa : fff60613;   % 3134:         addi a2, a2, -1		    # Plasma Breath's Y on matrix -= 1 (goes to the left) %
000021fb : 01068693;   % 3135:         addi a3, a3, 16  # Offset gets corrected (relative to new Y on matrix coordinate) %
000021fc : 01000293;   % 3138:             li t0, 16 %
000021fd : 0056c663;   % 3139:             blt a3,t0, SKIP_DOWN_Y_PLASMA_BREATH %
000021fe : 00160613;   % 3141:             addi a2,a2, 1	 # Plasma Breath's Y on matrix += 1 (goes to the right) %
000021ff : 405686b3;   % 3142:             sub a3,a3,t0	 # Offset gets corrected (relative to new Y on matrix coordinate) %
00002200 : 0015c783;   % 3148:         lbu a5,1(a1)     # Loads map's matrix width %
00002201 : 00654803;   % 3149:         lbu a6,6(a0)     # Loads plasma breath's current X %
00002202 : 00854883;   % 3150:         lbu a7,8(a0)     # Loads plasma breath's current Y %
00002203 : 00358593;   % 3152:         addi a1,a1,3     # Adds 3 to the Matrix's address so that it goes to the beginning of matrix %
00002204 : 02f882b3;   % 3153:         mul t0,a7,a5     # (Plasma Breath's matrix Y + 3)  * Map Matrix's width %
00002205 : 005802b3;   % 3154:         add t0,a6,t0     # t0 = Plasma Breath's X related to matrix + (Plasma Breath's matrix Y + 3)  * Map Matrix's width %
00002206 : 005585b3;   % 3155:         add a1,a1,t0     # a1 = Map Matrix's address adjusted for Plasma Breath's X and Y (+3) related to matrix        %
00002207 : 00454283;   % 3157:         lbu t0,4(a0)     # Loads Plasma Breath's Y offset %
00002208 : 00250303;   % 3158:         lb t1,2(a0)      # Loads Plasma Breath's MOVE_Y %
00002209 : 00034463;   % 3159:         blt t1,zero, CHECK_Y_UP_PLASMA_BREATH # If t1 < 0, check up,  %
0000220a : 0180006f;   % 3160:         j CHECK_Y_DOWN_PLASMA_BREATH          # otherwise check down %
0000220b : 00800313;   % 3163:             li t1, 8       # For comparing %
0000220c : 01c282b3;   % 3164:             add t0,t0,t3   # Current Y offset + Y offset modifier %
0000220d : 00535463;   % 3165:             bge t1,t0 CONTINUE_PLASMA_BREATH_COLLISION_UP    # If the result <= 8, continue checking %
0000220e : 0b80006f;   % 3166:                 j MOVE_PLASMA_BREATH_PROPERLY  # Othewise, just move the fourth state of matter breath  %
0000220f : 02c0006f;   % 3171:                 j START_PLASMA_BREATH_COLLISION %
00002210 : 00f585b3;   % 3174:             add a1,a1,a5  # Moves matrix one tile down %
00002211 : 00188893;   % 3175:             addi a7,a7,1  # Moves Y one tile down %
00002212 : 000e0e63;   % 3176:             beqz t3 CONTINUE_CHECK_Y_DOWN_PLASMA_BREATH   # If plasma breath's Y offset == 0, continue checking %
00002213 : 00f585b3;   % 3179:             add a1,a1,a5  # If Y offset != 0 %
00002214 : 00188893;   % 3180:             addi a7,a7,1  # If Y offset != 0 %
00002215 : 01000313;   % 3182:             li t1,16  # Loads 16 %
00002216 : 01c282b3;   % 3183:             add t0,t0,t3     # Current Y offset + Y offset modifier %
00002217 : 0062d463;   % 3184:             bge t0,t1 CONTINUE_CHECK_Y_DOWN_PLASMA_BREATH  # If current offset + offset modifier >= 16, continue checking (but check one tile bellow) %
00002218 : 0900006f;   % 3185:                 j MOVE_PLASMA_BREATH_PROPERLY              # Othewise, just move the the fourth state of matter breath (Ha, you've only read one "the") %
00002219 : 0040006f;   % 3190:                 j START_PLASMA_BREATH_COLLISION %
0000221a : fec10113;   % 3194:                 addi sp,sp,-20 %
0000221b : 00d12823;   % 3195:                 sw a3,16(sp) %
0000221c : 00c12623;   % 3196:                 sw a2,12(sp) %
0000221d : 00b12423;   % 3197:                 sw a1,8(sp) %
0000221e : 00a12223;   % 3198:                 sw a0,4(sp) %
0000221f : 00112023;   % 3199:                 sw ra,0(sp) %
00002220 : 00200513;   % 3202:                 li a0,2  # Doesn't matter, since no doors will be checked %
00002221 : 00100613;   % 3204:                 li a2,1  # Only check one tile %
00002222 : 00100693;   % 3205:                 li a3,1  # Vertical check %
00002223 : 00000713;   % 3206:                 li a4,0  # Don't consider doors (since it never spawns there) %
00002224 : 00100213;   % 3210:                 li tp, 1  # Entity collision %
00002225 : 00000317;   % 3211:                 call CHECK_MAP_COLLISION %
00002226 : 068300e7;   % 3211:  %
00002227 : 00a002b3;   % 3212:                 mv t0,a0 %
00002228 : 01012683;   % 3215:                 lw a3,16(sp) %
00002229 : 00c12603;   % 3216:                 lw a2,12(sp) %
0000222a : 00812583;   % 3217:                 lw a1,8(sp) %
0000222b : 00412503;   % 3218:                 lw a0,4(sp) %
0000222c : 00012083;   % 3219:                 lw ra,0(sp) %
0000222d : 01410113;   % 3220:                 addi sp,sp,20 %
0000222e : 02029c63;   % 3224:             bnez t0, MOVE_PLASMA_BREATH_PROPERLY   # If returning anything but 0, Plasma Breath can move %
0000222f : 20a51553;   % 3227:                 fneg.s fa0,fa0  # Invert speed %
00002230 : 00250283;   % 3229:                 lb t0,2(a0)   # Loads Plasma Breath's MOVE_Y, %
00002231 : 40500333;   % 3230:                 neg t1,t0     # inverts it, %
00002232 : 00250303;   % 3231:                 lb t1,2(a0)   # and stores it back %
00002233 : 0002cc63;   % 3233:                 blt t0,zero,SWITCH_PLASMA_BREATH_DOWN_2 # If t0 (old MOVE_Y) <= -1 adjust coordinates %
00002234 : 00454283;   % 3235:                     lbu t0,4(a0)   # Loads plasma breath's current Y offset   %
00002235 : 00028663;   % 3236:                     beqz t0,MOVE_PLASMA_BREATH_SKIP_ADJUST_Y   %
00002236 : 00050223;   % 3237:                         sb zero, 4(a0) # Sets plasma breath's Y offset to 0      %
00002237 : 00c50423;   % 3238:                         sb a2,8(a0)    # Stores new Y  %
00002238 : 0180006f;   % 3241:                         j END_MOVE_PLASMA_BREATH   # Finish procedure %
00002239 : 00800293;   % 3245:                     li t0,8      # Loads new Y offset %
0000223a : 00550223;   % 3246:                     sb t0,4(a0)  # and stores it back %
0000223b : 00c0006f;   % 3247:                     j END_MOVE_PLASMA_BREATH   # Finish procedure %
0000223c : 00c50423;   % 3250:             sb a2,8(a0)     # Stores Plasma Breath's new Y  %
0000223d : 00d50223;   % 3251:             sb a3,4(a0)     # Stores new Y offset %
0000223e : 00008067;   % 3255:         ret %
0000223f : 00400f33;   % 3288: mv t5,tp %
00002240 : 00a00233;   % 3289: mv tp,a0 # Moves door check to tp %
00002241 : 00100513;   % 3290: li a0,1  # Sets a0 to 1 (can move) %
00002242 : 00000f93;   % 3291: li t6,0  # Sets t6 to 0 (no doors detected) %
00002243 : 00051863;   % 3295:         bnez a0, CONTINUE_CHECK_MAP_COLLISION_1 # Otherwise, continue check %
00002244 : 00300293;   % 3296:         li t0,3 %
00002245 : 01e28463;   % 3297:         beq t0,t5,CONTINUE_CHECK_MAP_COLLISION_1 # If checking with bombs, ignore regular collision rules %
00002246 : 22c0006f;   % 3298:         j END_COLLISON_MAP %
00002247 : 00c04463;   % 3302:             blt zero, a2, CONTINUE_CHECK_MAP_COLLISION_2 %
00002248 : 2240006f;   % 3303:             j END_COLLISON_MAP %
00002249 : 0005c303;   % 3306:             lbu t1, 0(a1) # Loads tile from current map %
0000224a : 0ff00293;   % 3307:             li t0,255 %
0000224b : 02629c63;   % 3308:             bne t0,t1, NOT_CAPSULE_CHECK %
0000224c : 0fc08297;   % 3310:                 la t0, ITEM_CAPSULE_INFO %
0000224d : 83c28293;   % 3310:  %
0000224e : 0002c303;   % 3311:                 lbu t1,0(t0) %
0000224f : 02031263;   % 3312:                 bnez t1, SKIP_CAPSULE_CHECK  # If broken %
00002250 : 00200313;   % 3313:                     li t1,2 %
00002251 : 01e31c63;   % 3314:                     bne t1,t5,CAPSULE_CHECK_NOT_BEAM %
00002252 : 00100313;   % 3315:                         li t1,1 %
00002253 : 00628023;   % 3316:                         sb t1,0(t0) %
00002254 : 0fc08297;   % 3317:                         la t0, BOMB_POWER_INFO %
00002255 : 81828293;   % 3317:  %
00002256 : 00628023;   % 3318:                         sb t1,0(t0) %
00002257 : 1c00006f;   % 3320:                         j COLLISION_BLOCKED      # Otherwise, it's blocked %
00002258 : 1c00006f;   % 3322:                         j CONTINUE_CHECK_MAP_COLLISION_3 %
00002259 : 00070e63;   % 3325:             beqz a4, SKIP_DOOR_CHECK_MAP_COLLISION  # If a4 = 0 (don't consider door), skip door check  %
0000225a : 02800293;   % 3326:                 li t0,40   # Tile where doors start %
0000225b : 00534463;   % 3327:                 blt t1,t0, NOT_DOOR_CHECK_MAP_COLLISION # If current tile isn't a door    %
0000225c : 10c0006f;   % 3328:                 j COLLISION_DOOR  # If tile is a door (t1 >= 40) %
0000225d : 00100293;   % 3330:                     li t0,1   # Consider all tiles %
0000225e : 00570463;   % 3331:                     beq a4,t0, SKIP_DOOR_CHECK_MAP_COLLISION # If no door was detected and other tiles should be checked, continue %
0000225f : 1a40006f;   % 3332:                     j CONTINUE_CHECK_MAP_COLLISION_3  # If no door was detected and only doors should be checked, skip to the end %
00002260 : 00400293;   % 3334:                 li t0, 4      # Loads t0 = 4 for comparison %
00002261 : 08535463;   % 3335:                 bge t1,t0,COLLISION_NOT_BACKGROUND # If tile isn't part of background or isn't breakable (t1 >= 4) %
00002262 : 00100293;   % 3337:                     li t0,1 %
00002263 : 00628463;   % 3338:                     beq t0,t1, COLLISION_BREAKABLE   # If tile is breakable, there needs to be a check if it was broken %
00002264 : 1900006f;   % 3339:                     j CONTINUE_CHECK_MAP_COLLISION_3 # Otherwise, continue checking collision %
00002265 : 0fc07297;   % 3342:                 la t0,NEXT_MAP # Loads NEXT_MAP address %
00002266 : 79c28293;   % 3342:  %
00002267 : 00a2c283;   % 3343:                 lbu t0,10(t0)  # Gets the Render Next Map byte	 %
00002268 : 00028a63;   % 3344:                 beqz t0, COLLISION_BREAKABLE_CURRENT   # If Render Next Map Door == 0, render current map's door %
00002269 : 0fc08297;   % 3346:                     la t0,Blocks_Next  # Loads blocks address %
0000226a : 87828293;   % 3346:  %
0000226b : 0002a283;   % 3347:                     lw t0,0(t0)        # and loads the breakable block address %
0000226c : 0100006f;   % 3348:                     j CONTINUE_COLLISION_BREAKABLE %
0000226d : 0fc08297;   % 3351:                     la t0,Blocks  # Loads blocks address %
0000226e : 86428293;   % 3351:  %
0000226f : 0002a283;   % 3352:                     lw t0,0(t0)   # and loads the breakable block address %
00002270 : 04028463;   % 3356:                     beqz t0,COLLISION_BREAKABLE_NOT_BLOCKING %
00002271 : 0012c303;   % 3358:                     lbu t1,1(t0)  # Gets Y where blocks start %
00002272 : 40688333;   % 3359:                     sub t1,a7,t1  # Sets current Y to be related to Y where blocks start %
00002273 : 0022c383;   % 3361:                     lbu t2,2(t0)  # Loads width %
00002274 : 02730333;   % 3362:                     mul t1,t1,t2  # and multiplies it by current Y	 %
00002275 : 0002c383;   % 3364:                     lbu t2,0(t0)  # Gets X where blocks start %
00002276 : 407803b3;   % 3365:                     sub t2,a6,t2  # Sets current X to be related to X where blocks start %
00002277 : 00730333;   % 3367:                     add t1,t1,t2  # adds X to it %
00002278 : 00428293;   % 3369:                     addi t0,t0,4  # Skip first 4 information bytes %
00002279 : 005302b3;   % 3370:                     add t0,t1,t0  # and adds t4 to it %
0000227a : 00028303;   % 3372:                     lb t1,0(t0)  # Loads t0  %
0000227b : 00031e63;   % 3373:                     bnez t1, COLLISION_BREAKABLE_NOT_BLOCKING  # If block is destroyed, can go through %
0000227c : 00300313;   % 3375:                     li t1,3 # To check if it was colliding with exploding bomb %
0000227d : 006f1863;   % 3376:                     bne t5,t1, COLLISION_BREAKABLE_BLOCKING %
0000227e : 00100313;   % 3378:                         li t1,1 %
0000227f : 00628023;   % 3379:                         sb t1,0(t0)  # Sets t0 to 1 (first phase of exploding)  %
00002280 : 1200006f;   % 3380:                         j CONTINUE_CHECK_MAP_COLLISION_3     # Otherwise, finish this iteration's checks %
00002281 : 1180006f;   % 3382:                         j COLLISION_BLOCKED %
00002282 : 1180006f;   % 3386:                 j CONTINUE_CHECK_MAP_COLLISION_3 %
00002283 : 00628863;   % 3389:                 beq t0,t1,COLLISION_DOOR_FRAME  # If t1 = 4, it's a door frame %
00002284 : 02400293;   % 3390:                 li t0,36   # Tile from which collision behaves differently %
00002285 : 04535c63;   % 3391:                 bge t1,t0, COLLISION_SPECIAL_2  # If current tile is a door or a damaging tile (t1 >= 36) %
00002286 : 1040006f;   % 3392:                     j COLLISION_BLOCKED # If tile isn't special (3 < t1 < 36) %
00002287 : 0e0f1e63;   % 3395:                 bnez t5,COLLISION_DOOR_FRAME_COLLISION_BLOCKED  # If not player, consider this a solid object %
00002288 : 000002b3;   % 3396:                 mv t0,zero   # Resets counter %
00002289 : 0fc08317;   % 3397:                 la t1, Frames # Loads Frames address %
0000228a : ab830313;   % 3397:  %
0000228b : 00032303;   % 3398:                 lw t1,0(t1)	 # Gets the current map's door frame address %
0000228c : 00034383;   % 3399:                 lbu t2,0(t1) # Gets the number of door frames in this map %
0000228d : 00130313;   % 3400:                 addi t1,t1,1 # Starting address of the map's first door frame %
0000228e : 00034e03;   % 3403:                     lbu t3, 0(t1) # Loads door frame's X on matrix %
0000228f : 010e1e63;   % 3404:                     bne t3, a6, NEXT_IN_COLLISION_DOOR_FRAME_LOOP # If door frame's X isn't the same as current X, skip it        %
00002290 : 00134e03;   % 3405:                     lbu t3, 1(t1) # Loads door frame's Y on matrix %
00002291 : 41c88e33;   % 3406:                     sub t3,a7,t3  # t3 needs to be equal to 0, 1 or 2 in order to be a tile from this door frame %
00002292 : 00200e93;   % 3407:                     li t4,2       # 2 is the threshold to be compared with t3 %
00002293 : 01cee663;   % 3408:                     bgtu t3,t4, NEXT_IN_COLLISION_DOOR_FRAME_LOOP # If current Y is above the door frame's uppermost Y or bellow it's downmost Y, skip it                        %
00002294 : 00600533;   % 3410:                         mv a0,t1       # Moves current door frame's address to a0 %
00002295 : e30fd06f;   % 3411:                         j CHANGE_MAP                             %
00002296 : 00630313;   % 3413:                         addi t1,t1,6 # Going to the next door frame's address                                   %
00002297 : 00128293;   % 3414:                         addi t0,t0,1 # Iterating counter by 1                                    %
00002298 : 0072d463;   % 3415:                         bge t0,t2, END_COLLISION_DOOR_FRAME_LOOP # If all of the map's door frames were checked, end loop                                   %
00002299 : fd5ff06f;   % 3416:                         j COLLISION_DOOR_FRAME_LOOP # otherwise, go back to the loop's beginning                      %
0000229a : 0b80006f;   % 3419:                     j CONTINUE_CHECK_MAP_COLLISION_3      %
0000229b : 02800293;   % 3423:                 li t0,40   # Tile from which door tiles begin %
0000229c : 00534463;   % 3424:                 blt t1,t0, CONTINUE_COLLISION_SCPECIAL_2   # If tile is a door (t1 >= 40) %
0000229d : 0ac0006f;   % 3425:                     j CONTINUE_CHECK_MAP_COLLISION_3     # Otherwise, finish this iteration's checks %
0000229e : 0a40006f;   % 3429:                     j COLLISION_BLOCKED # For now >:[ %
0000229f : 000002b3;   % 3432:                 mv t0,zero   # Resets counter %
000022a0 : 0fc08317;   % 3433:                 la t1, Doors # Loads Doors address %
000022a1 : a1c30313;   % 3433:  %
000022a2 : 00032303;   % 3434:                 lw t1,0(t1)	 # Gets the current map's door address %
000022a3 : 00034383;   % 3435:                 lbu t2,0(t1) # Gets the number of doors in this map %
000022a4 : 00130313;   % 3436:                 addi t1,t1,1 # Starting address of the map's first door %
000022a5 : 00034e03;   % 3439:                     lbu t3, 0(t1) # Loads door's X on matrix %
000022a6 : 070e1663;   % 3440:                     bne t3, a6, NEXT_IN_COLLISION_DOOR_LOOP # If door's X isn't the same as current X, skip this door %
000022a7 : 00134e03;   % 3441:                     lbu t3, 1(t1) # Loads door's Y on matrix %
000022a8 : 41c88e33;   % 3442:                     sub t3,a7,t3  # t3 needs to be equal to 0, 1 or 2 in order to be a tile from this door %
000022a9 : 00200e93;   % 3443:                     li t4,2       # 2 is the threshold to be compared with t3 %
000022aa : 05ceee63;   % 3444:                     bgtu t3,t4, NEXT_IN_COLLISION_DOOR_LOOP # If current Y is above the door's uppermost Y or bellow it's downmost Y, skip this door                         %
000022ab : 024e8063;   % 3446:                         beq t4,tp,AFTER_COLLISION_DOOR_LOOP_DIRECTION_CHECK # If tp = 2, check any type of door %
000022ac : 00034e03;   % 3447:                         lbu t3, 0(t1) # Loads door's X on matrix  %
000022ad : 00020663;   % 3448:                         beqz tp,COLLISION_DOOR_LOOP_CHECK_RIGHT # If tp = 0, check if door is on right wall %
000022ae : 01c20a63;   % 3450:                             beq tp,t3,AFTER_COLLISION_DOOR_LOOP_DIRECTION_CHECK # If t3 = 1, door is on left wall; continue checking collision %
000022af : 0580006f;   % 3451:                             j END_COLLISION_DOOR_LOOP # Otherwise, door is on right wall and not on left wall (stop checking) %
000022b0 : 00100e93;   % 3453:                             li t4, 1 # 1 is the threshold of when a door can be on right wall %
000022b1 : 01cec463;   % 3454:                             bgt t3,t4, AFTER_COLLISION_DOOR_LOOP_DIRECTION_CHECK # If t3 > 1, door is on right wall; continue checking collision %
000022b2 : 04c0006f;   % 3455:                             j END_COLLISION_DOOR_LOOP # Otherwise, door is on left wall and not on right wall (stop checking) %
000022b3 : 00234e83;   % 3457:                             lbu t4, 2(t1) # Loads door's state %
000022b4 : 040e9263;   % 3458:                             bnez t4, END_COLLISION_DOOR_LOOP # If door is open or opening, player can move through  %
000022b5 : 00200e93;   % 3459:                                 li t4,2 # Comparing if it's beam collision %
000022b6 : 01df1c63;   % 3460:                                 bne t5,t4,NOT_BEAM_COLLISION %
000022b7 : 00100e93;   % 3461:                                     li t4,1       # Loads 1 (opening/closing) %
000022b8 : 01d30123;   % 3462:                                     sb t4,2(t1)   # and stores it on door's state byte   %
000022b9 : ffe00e93;   % 3463:                                     li t4,-2  # Gets new counter (related to opening door -- negative, in order to open) %
000022ba : 01d301a3;   % 3464:                                     sb t4,3(t1)         # and stores it on door's counter byte   %
000022bb : 0300006f;   % 3465:                                     j COLLISION_BLOCKED # Door is closed and player can't move %
000022bc : 020f9663;   % 3468:                                 bnez t6,COLLISION_BLOCKED  # if t6 != 0 , don't update it %
000022bd : 00034e03;   % 3469:                                     lbu t3, 0(t1) # Loads door's X on matrix  %
000022be : 01de2fb3;   % 3470:                                     slt t6,t3,t4   # door's x < 2 ? t6 = 1 : t6 = 0 %
000022bf : 001f8f93;   % 3471:                                     addi t6,t6,1   # If right door, t6 = 1; left door, t6 = 2 %
000022c0 : 01c0006f;   % 3472:                                     j COLLISION_BLOCKED # Otherwise, door is closed and player can't move                    %
000022c1 : 00430313;   % 3474:                         addi t1,t1,4 # Going to the next door's address                                   %
000022c2 : 00128293;   % 3475:                         addi t0,t0,1 # Iterating counter by 1                                    %
000022c3 : 0072d463;   % 3476:                         bge t0,t2, END_COLLISION_DOOR_LOOP # If all of the map's doors were checked, end loop                                   %
000022c4 : f85ff06f;   % 3477:                         j COLLISION_DOOR_LOOP # otherwise, go back to the loop's beginning                      %
000022c5 : 00c0006f;   % 3480:                     j CONTINUE_CHECK_MAP_COLLISION_3                                                                  %
000022c6 : 00300f93;   % 3483:                 li t6,3   %
000022c7 : 00000513;   % 3485:                 li a0,0 # Player can't move   %
000022c8 : 00069a63;   % 3489:             bnez a3, CHECK_MAP_COLLISION_VERTICAL %
000022c9 : 00f585b3;   % 3491:                 add a1,a1,a5   # a1 = current tile address + matrix width (+1 Y) %
000022ca : 00188893;   % 3492:                 addi a7,a7,1   # a7++ (+1 Y) %
000022cb : fff60613;   % 3493:                 addi a2,a2,-1  # Iterates a2 (a2--) %
000022cc : dddff06f;   % 3494:                 j MAP_COLLISION_LOOP %
000022cd : 00158593;   % 3497:                 addi a1,a1,1   # a1 = current tile address + 1 (+1 X) %
000022ce : 00180813;   % 3498:                 addi a6,a6,1   # a6++ (+1 X) %
000022cf : fff60613;   % 3499:                 addi a2,a2,-1  # Iterates a2 (a2--) %
000022d0 : dcdff06f;   % 3500:                 j MAP_COLLISION_LOOP %
000022d1 : 01f005b3;   % 3503:     mv a1,t6  # moves t6 (0 - no door, 1 - right door, 2 - left door, 3 - door frame) %
000022d2 : 00008067;   % 3504:     ret %
000022d3 : 0fc07297;   % 8: 			la		t0, MUSIC_NOTAS %
000022d4 : 4b428293;   % 8:  %
000022d5 : 0fc07317;   % 9: 			la		t1, MUSIC_STATUS %
000022d6 : 5ac30313;   % 9:  %
000022d7 : 00532223;   % 10: 			sw		t0, 4(t1) %
000022d8 : 00032023;   % 11: 			sw		zero, 0(t1) %
000022d9 : 00008067;   % 13: 			ret %
000022da : 0fc07517;   % 21: MUSIC.PLAY:		la		a0, MUSIC_STATUS %
000022db : 59850513;   % 21:  %
000022dc : 00000613;   % 22: 			li		a2, 0 %
000022dd : 03200693;   % 23: 			li		a3, 50 %
000022de : 00052283;   % 25: 			lw		t0, 0(a0) %
000022df : 00028663;   % 26: 			beqz		t0, MUSIC.PLAY.NOTE %
000022e0 : c0102373;   % 28: 			csrr		t1, 3073		# current time %
000022e1 : 04536263;   % 29: 			bltu		t1, t0, MUSIC.RET	# if (now < next note) do nothing ELSE play note %
000022e2 : 00452283;   % 31: MUSIC.PLAY.NOTE:	lw		t0, 4(a0)		# t0 = current note address %
000022e3 : 0002a303;   % 32: 			lw		t1, 0(t0)		# nota %
000022e4 : 0042a383;   % 33: 			lw		t2, 4(t0)		# duracao %
000022e5 : 00030e63;   % 35: 			beqz		t1, MUSIC.LAST.PLAYED	# nota == 0, s� espera %
000022e6 : 00a00e33;   % 37: 			mv		t3, a0		# salva a0 %
000022e7 : 00600533;   % 39: 			mv		a0, t1		# a0 = nota %
000022e8 : 007005b3;   % 40: 			mv		a1, t2		# a1 = duracao %
000022e9 : 01f00893;   % 41: 			li		a7, 31		# define a chamada de syscall %
000022ea : 00000073;   % 42: 			ecall				# toca a nota %
000022eb : 01c00533;   % 44: 			mv		a0, t3		# restaura a0 %
000022ec : f8038ee3;   % 46: MUSIC.LAST.PLAYED:	beqz		t2, MUSIC.SETUP	# nota == 0 e duracao == 0, recomeca %
000022ed : c0102e73;   % 48: 			csrr		t3, 3073	# current time %
000022ee : 007e0e33;   % 49: 			add		t3, t3, t2	# current time + note duration = next note time %
000022ef : 01c52023;   % 50: 			sw		t3, 0(a0)	# save next note time %
000022f0 : 00828293;   % 52: 			addi		t0, t0, 8	# incrementa endere�o da proxima nota %
000022f1 : 00552223;   % 53: 			sw		t0, 4(a0)	# salva proxima nota %
000022f2 : 00008067;   % 55: MUSIC.RET:		ret %
END;
