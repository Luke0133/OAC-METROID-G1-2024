DEPTH = 16384;
WIDTH = 32;
ADDRESS_RADIX = HEX;
DATA_RADIX = HEX;
CONTENT
BEGIN
00000000 : 00002217;   % 224:  	la 	tp, ExceptionHandling	# carrega em tp o endereço base das rotinas do sistema ECALL %
00000001 : 5e020213;   % 224:  %
00000002 : 00521073;   % 225:  	csrw 	tp, utvec 		# seta utvec para o endereço tp %
00000003 : 0000e073;   % 226:  	csrsi 	ustatus, 1 		# seta o bit de habilitação de interrupção em ustatus (reg 0)																																																				 %
00000004 : 00000493;   % 15: 	li s1, 0  # Reseting time %
00000005 : 00000913;   % 16: 	li s2, 0  # Game loop state  %
00000006 : 0fc10297;   % 18: 	la t0, GRAVITY_FACTOR %
00000007 : 11828293;   % 18:  %
00000008 : 0002a407;   % 19: 	flw fs0,0(t0) %
00000009 : 0fc10297;   % 20: 	la t0, JUMP_SPEED %
0000000a : 11028293;   % 20:  %
0000000b : 0002a487;   % 21: 	flw fs1,0(t0) %
0000000c : 0fc10297;   % 23: 	la t0, RIDLEY_JUMP_SPEED %
0000000d : 34028293;   % 23:  %
0000000e : 0002a987;   % 24: 	flw fs3,0(t0) %
0000000f : 08c0006f;   % 26: 	j SETUP %
00000010 : c0102573;   % 46:     csrr a0,3073 %
00000011 : 40950533;   % 47:     sub a0, a0, s1 #  # a0 = current time - last frame's time %
00000012 : 03200293;   % 48:     li t0, 50	# Loads frame rate (time (in ms) per frame) %
00000013 : fe556ae3;   % 49:     bltu a0,t0, GAME_LOOP  # While a0 < minimum time for a frame, keep looping  %
00000014 : 00144413;   % 52:     xori s0,s0,1		    # Switches frame value (register) %
00000015 : 00001317;   % 54: 	call INPUT_CHECK	    # Checks player's input %
00000016 : a7c300e7;   % 54:  %
00000017 : 00001317;   % 55: 	call PHYSICS            # Physics operations %
00000018 : e3c300e7;   % 55:  %
00000019 : 00001317;   % 57: 	call UPDATE_DOORS       # Updates doors %
0000001a : 948300e7;   % 57:  %
0000001b : 00004317;   % 58: 	call MAP_MOVE_RENDER    # Renders map when necessary %
0000001c : ed8300e7;   % 58:  %
0000001d : 00000513;   % 60: 	li a0,0 %
0000001e : 00002317;   % 61: 	call ENEMY_OPERATIONS %
0000001f : 064300e7;   % 61:  %
00000020 : 00004317;   % 63: 	call UPDATE_MARU_MARI   # Updates Maru Mari's sprite (in sprite op) %
00000021 : 75c300e7;   % 63:  %
00000022 : 00004317;   % 65: 	call UPDATE_STATUS      # Updates player's sprite status %
00000023 : 69c300e7;   % 65:  %
00000024 : 00000513;   % 67: 	li a0, 0     # Rendering player operation %
00000025 : 00000593;   % 68: 	li a1, 0     # Rendering full player %
00000026 : 00001317;   % 69: 	call RENDER_PLAYER	 %
00000027 : 4f4300e7;   % 69:  %
00000028 : 00000513;   % 71: 	li a0, 0     # Rendering UI operation %
00000029 : 00002317;   % 72: 	call RENDER_UI	 %
0000002a : 864300e7;   % 72:  %
0000002b : 00002317;   % 75: 	call RENDER_DOOR_FRAMES %
0000002c : b4c300e7;   % 75:  %
0000002d : ff2002b7;   % 78: 	li t0,0xFF200604	# Loads Bitmap Display address %
0000002e : 60428293;   % 78:  %
0000002f : 0082a023;   % 79: 	sw s0,0(t0)         # Stores new frame value (from s0) on Bitmap Display %
00000030 : c01024f3;   % 96: 	csrr s1,3073    # new time is stored in s1, in order to be compared later		 %
00000031 : f7dff06f;   % 100: 	j GAME_LOOP	# Volta para ENGINE_LOOP %
00000032 : 00005317;   % 18:     call MUSIC.SETUP %
00000033 : 354300e7;   % 18:  %
00000034 : 0fc10297;   % 21:     la t0, NEXT_MAP   # Loads NEXT_MAP address %
00000035 : 03c28293;   % 21:  %
00000036 : 00030523;   % 22:     sb zero,10(t1)    # Stores 0 on Render Next Map Door (in order to render current map's doors properly) %
00000037 : 0fc10297;   % 25:     la t0, MAP_INFO # Loads Map Info address %
00000038 : 02828293;   % 25:  %
00000039 : 0002c303;   % 26:     lbu t1, 0 (t0)  # Loads byte related to map number %
0000003a : 0012c383;   % 27:     lbu t2, 1 (t0)  # Loads rendering byte (0 - don't render, 1 - render once, 2 - render twice,  %
0000003b : 0fc10e97;   % 30:     la t4, Doors    # Doors info address %
0000003c : 288e8e93;   % 30:  %
0000003d : 0fc10f17;   % 31:     la t5, Frames   # Frames info address %
0000003e : 2c0f0f13;   % 31:  %
0000003f : 00100293;   % 33:     li t0, 1  %
00000040 : 00629463;   % 34:     bne t0, t1, SKIP_MAP1_SETUP  %
00000041 : 0ac0006f;   % 35:     j MAP1_SETUP %
00000042 : 00200293;   % 38:         li t0, 2  %
00000043 : 00629463;   % 39:         bne t0, t1, SKIP_MAP2_SETUP  %
00000044 : 1c00006f;   % 40:         j MAP2_SETUP %
00000045 : 00300293;   % 43:         li t0, 3  %
00000046 : 00629463;   % 44:         bne t0, t1, SKIP_MAP3_SETUP  %
00000047 : 2dc0006f;   % 45:         j MAP3_SETUP %
00000048 : 00400293;   % 48:         li t0, 4 %
00000049 : 00629463;   % 49:         bne t0, t1, SKIP_MAP4_SETUP  %
0000004a : 3f00006f;   % 50:         j MAP4_SETUP %
0000004b : 00500293;   % 53:         li t0, 5  %
0000004c : 00629463;   % 54:         bne t0, t1, SKIP_MAP5_SETUP  %
0000004d : 50c0006f;   % 55:         j MAP5_SETUP %
0000004e : 00600293;   % 58:         li t0, 6 %
0000004f : 00629463;   % 59:         bne t0, t1, SKIP_MAP6_SETUP  %
00000050 : 6200006f;   % 60:         j MAP6_SETUP %
00000051 : 00700293;   % 63:             li t0, 7  %
00000052 : 00629463;   % 64:             bne t0, t1, SKIP_MAP7_SETUP  %
00000053 : 72c0006f;   % 65:             j MAP7_SETUP %
00000054 : 00700513;   % 68:         li a0, 7 %
00000055 : 00000593;   % 69:         li a1, 0 %
00000056 : 00000613;   % 70:         li a2, 0 %
00000057 : 14000693;   % 71:         li a3, 320 %
00000058 : 0f000713;   % 72:         li a4, 240 %
00000059 : 00000793;   % 73:         li a5, 0 %
0000005a : 00000813;   % 74:         li a6, 0	 %
0000005b : 00001317;   % 76:         call RENDER_COLOR %
0000005c : 390300e7;   % 76:  %
0000005d : 00700513;   % 78:         li a0, 7 %
0000005e : 00000593;   % 79:         li a1, 0 %
0000005f : 00000613;   % 80:         li a2, 0 %
00000060 : 14000693;   % 81:         li a3, 320 %
00000061 : 0f000713;   % 82:         li a4, 240 %
00000062 : 00100793;   % 83:         li a5, 1 %
00000063 : 00000813;   % 84:         li a6, 0 %
00000064 : 00001317;   % 85:         call RENDER_COLOR %
00000065 : 36c300e7;   % 85:  %
00000066 : 00001537;   % 87: 	    li a0, 3000 %
00000067 : bb850513;   % 87:  %
00000068 : 02000893;   % 88: 	    li a7,32 %
00000069 : 00000073;   % 89: 	    ecall %
0000006a : 00a00893;   % 90: 	    li a7, 10 %
0000006b : 00000073;   % 91:         ecall	    					 %
0000006c : 0fc10297;   % 94:         la t0, Doors1   # Doors address %
0000006d : 1cc28293;   % 94:  %
0000006e : 005ea023;   % 95:         sw t0,0(t4)     # Stores Doors1 address on Doors address %
0000006f : 0fc10297;   % 97:         la t0, Frames1  # Frames address %
00000070 : 1fc28293;   % 97:  %
00000071 : 005f2023;   % 98:         sw t0,0(t5)     # Stores Frames1 address on Doors address %
00000072 : 0fc10297;   % 100:         la t0,Zoomers   # Zoomers address %
00000073 : f9428293;   % 100:  %
00000074 : 0fc10317;   % 101:         la t1,Zoomers1  # Loads Zoomers1 address for Map 1 %
00000075 : f9030313;   % 101:  %
00000076 : 0062a023;   % 102:         sw t1,0(t0)     # and stores it %
00000077 : 0fc10297;   % 104:         la t0,Rippers   # Rippers address %
00000078 : 13c28293;   % 104:  %
00000079 : 0002a023;   % 105:         sw zero,0(t0)   # Stores 0 to it (no rippers) %
0000007a : 0fc13517;   % 107:         la a0, Map1 	# Map Address      %
0000007b : 52450513;   % 107:  %
0000007c : 0fc10297;   % 108:         la t0, CURRENT_MAP # Loads CURRENT_MAP address %
0000007d : f1028293;   % 108:  %
0000007e : 00a2a023;   % 109:         sw a0, 0(t0)    # Stores Map1 address on CURRENT_MAP %
0000007f : 0062c583;   % 111:         lbu a1, 6(t0)   # Loads current X on Map (starting X on Matrix (top left)) %
00000080 : 0072c603;   % 112:         lbu a2, 7(t0)   # Loads current Y on Map (starting Y on Matrix (top left))	 %
00000081 : 0082c683;   % 113:         lbu a3, 8(t0)   # Loads current X offset on Map %
00000082 : 0092c703;   % 114:         lbu a4, 9(t0)   # Loads current Y offset on Map	 %
00000083 : 00400313;   % 116:         li t1, 4 %
00000084 : 06639263;   % 117:         bne t2, t1 CONTINUE_MAP1_SETUP %
00000085 : 00200393;   % 119:             li t2, 2 %
00000086 : 007282a3;   % 120:             sb t2, 5 (t0)  # Stores new rendering byte (2 - render twice)  %
00000087 : 01700593;   % 123:             li a1, 23 %
00000088 : 00b28323;   % 124:             sb a1, 6(t0)   # Stores new X on Map (starting X on Matrix (top left)) %
00000089 : 00000613;   % 125:             li a2, 0 %
0000008a : 00c283a3;   % 126:             sb a2, 7(t0)   # Stores new Y on Map (starting Y on Matrix (top left))	 %
0000008b : 00800693;   % 127:             li a3, 8 %
0000008c : 00d28423;   % 128:             sb a3, 8(t0)   # Stores new X offset on Map %
0000008d : 00000713;   % 129:             li a4, 0 %
0000008e : 00e284a3;   % 130:             sb a4, 9(t0)   # Stores new Y offset on Map	 %
0000008f : 0fc10297;   % 133:             la t0, PLYR_POS %
00000090 : ede28293;   % 133:  %
00000091 : 09800313;   % 134:             li t1, 152 %
00000092 : 00629023;   % 135:             sh t1, 0(t0)   # Stores new player's X related to the screen %
00000093 : 0a000313;   % 136:             li t1, 160 %
00000094 : 00628223;   % 137:             sb t1, 4(t0)   # Stores new player's Y related to the screen %
00000095 : 00000313;   % 139:             li t1, 0     %
00000096 : 00628323;   % 140:             sb t1, 6(t0)   # Stores new player's X offset %
00000097 : 00000313;   % 141:             li t1, 0 %
00000098 : 006283a3;   % 142:             sb t1, 7(t0)   # Stores new player's Y offset %
00000099 : 02100313;   % 144:             li t1, 33 %
0000009a : 00628423;   % 145:             sb t1, 8(t0)   # Stores new player's X related to the matrix %
0000009b : 00a00313;   % 146:             li t1, 10 %
0000009c : 00628523;   % 147:             sb t1, 10(t0)  # Stores new player's Y related to the matrix %
0000009d : 00000793;   % 150:         li a5, 0		# Frame = 0 %
0000009e : 01400813;   % 151:         li a6, 20	# Screen Width = 20 %
0000009f : 00f00893;   % 152:         li a7, 15	# Screen Height = 15 %
000000a0 : 00000e13;   % 153:         li t3, 0		# Starting X for rendering (top left, related to Matrix) %
000000a1 : 00000393;   % 154:         li t2, 0		# Starting Y for rendering (top left, related to Matrix) %
000000a2 : 00000213;   % 155:         li tp, 0        # Map won't be dislocated %
000000a3 : 00002317;   % 157:         call RENDER_MAP %
000000a4 : a80300e7;   % 157:  %
000000a5 : 0fc10297;   % 159:         la t0, CURRENT_MAP # Loads CURRENT_MAP address %
000000a6 : e6c28293;   % 159:  %
000000a7 : 0062c583;   % 160:         lbu a1, 6(t0)   # Loads current X on Map (starting X on Matrix (top left)) %
000000a8 : 0072c603;   % 161:         lbu a2, 7(t0)   # Loads current Y on Map (starting Y on Matrix (top left))	 %
000000a9 : 0082c683;   % 162:         lbu a3, 8(t0)   # Loads current X offset on Map %
000000aa : 0092c703;   % 163:         lbu a4, 9(t0)   # Loads current Y offset on Map %
000000ab : 00100793;   % 164:         li a5, 1		# Frame = 0 %
000000ac : 01400813;   % 165:         li a6, 20	# Screen Width = 20 %
000000ad : 00f00893;   % 166:         li a7, 15	# Screen Height = 15 %
000000ae : 00000e13;   % 167:         li t3, 0		# Starting X for rendering (top left, related to Matrix) %
000000af : 00000393;   % 168:         li t2, 0		# Starting Y for rendering (top left, related to Matrix) %
000000b0 : 00000213;   % 169:         li tp, 0        # Map won't be dislocated %
000000b1 : 00002317;   % 171:         call RENDER_MAP %
000000b2 : a48300e7;   % 171:  %
000000b3 : 6c40006f;   % 173:         j END_SETUP %
000000b4 : 0fc10297;   % 176:         la t0, Doors2   # Doors address %
000000b5 : 0b128293;   % 176:  %
000000b6 : 005ea023;   % 177:         sw t0,0(t4)     # Stores Doors2 address on Doors address %
000000b7 : 0fc10297;   % 179:         la t0, Frames2  # Frames address %
000000b8 : 0e328293;   % 179:  %
000000b9 : 005f2023;   % 180:         sw t0,0(t5)     # Stores Frames2 address on Doors address %
000000ba : 0fc10297;   % 182:         la t0,Zoomers   # Zoomers address %
000000bb : e7428293;   % 182:  %
000000bc : 0fc10317;   % 183:         la t1,Zoomers2  # Loads Zoomers2 address for Map 2 %
000000bd : eb930313;   % 183:  %
000000be : 0062a023;   % 184:         sw t1,0(t0)     # and stores it %
000000bf : 0fc10297;   % 186:         la t0,Rippers   # Rippers address %
000000c0 : 01c28293;   % 186:  %
000000c1 : 0fc10317;   % 187:         la t1,Rippers2  # Loads Rippers2 address for Map 2 %
000000c2 : 01830313;   % 187:  %
000000c3 : 0062a023;   % 188:         sw t1,0(t0)     # and stores it %
000000c4 : 0fc13517;   % 190:         la a0, Map2 	# Map Address      %
000000c5 : 78350513;   % 190:  %
000000c6 : 0fc10297;   % 191:         la t0, CURRENT_MAP # Loads CURRENT_MAP address %
000000c7 : de828293;   % 191:  %
000000c8 : 00a2a023;   % 192:         sw a0, 0(t0)    # Stores Map2 address on CURRENT_MAP %
000000c9 : 0062c583;   % 194:         lbu a1, 6(t0)   # Loads current X on Map (starting X on Matrix (top left)) %
000000ca : 0072c603;   % 195:         lbu a2, 7(t0)   # Loads current Y on Map (starting Y on Matrix (top left))	 %
000000cb : 0082c683;   % 196:         lbu a3, 8(t0)   # Loads current X offset on Map %
000000cc : 0092c703;   % 197:         lbu a4, 9(t0)   # Loads current Y offset on Map		 %
000000cd : 00400313;   % 199:         li t1, 4 %
000000ce : 06639263;   % 200:         bne t2, t1 CONTINUE_MAP2_SETUP %
000000cf : 00200393;   % 202:             li t2, 2 %
000000d0 : 007282a3;   % 203:             sb t2, 5 (t0)  # Stores new rendering byte (2 - render twice)  %
000000d1 : 00000593;   % 206:             li a1, 0 %
000000d2 : 00b28323;   % 207:             sb a1, 6(t0)   # Stores new X on Map (starting X on Matrix (top left)) %
000000d3 : 00000613;   % 208:             li a2, 0 %
000000d4 : 00c283a3;   % 209:             sb a2, 7(t0)   # Stores new Y on Map (starting Y on Matrix (top left))	 %
000000d5 : 00000693;   % 210:             li a3, 0 %
000000d6 : 00d28423;   % 211:             sb a3, 8(t0)   # Stores new X offset on Map %
000000d7 : 00000713;   % 212:             li a4, 0 %
000000d8 : 00e284a3;   % 213:             sb a4, 9(t0)   # Stores new Y offset on Map	 %
000000d9 : 0fc10297;   % 216:             la t0, PLYR_POS %
000000da : db628293;   % 216:  %
000000db : 02000313;   % 217:             li t1, 32 %
000000dc : 00629023;   % 218:             sh t1, 0(t0)   # Stores new player's X related to the screen %
000000dd : 06000313;   % 219:             li t1, 96 %
000000de : 00628223;   % 220:             sb t1, 4(t0)   # Stores new player's Y related to the screen %
000000df : 00000313;   % 222:             li t1, 0     %
000000e0 : 00628323;   % 223:             sb t1, 6(t0)   # Stores new player's X offset %
000000e1 : 00000313;   % 224:             li t1, 0 %
000000e2 : 006283a3;   % 225:             sb t1, 7(t0)   # Stores new player's Y offset %
000000e3 : 00200313;   % 227:             li t1, 2 %
000000e4 : 00628423;   % 228:             sb t1, 8(t0)   # Stores new player's X related to the matrix %
000000e5 : 00600313;   % 229:             li t1, 6 %
000000e6 : 00628523;   % 230:             sb t1, 10(t0)  # Stores new player's Y related to the matrix %
000000e7 : 00000793;   % 233:         li a5, 0		# Frame = 0 %
000000e8 : 01400813;   % 234:         li a6, 20	# Screen Width = 20 %
000000e9 : 00f00893;   % 235:         li a7, 15	# Screen Height = 15 %
000000ea : 00000e13;   % 236:         li t3, 0		# Starting X for rendering (top left, related to Matrix) %
000000eb : 00000393;   % 237:         li t2, 0		# Starting Y for rendering (top left, related to Matrix) %
000000ec : 00000213;   % 238:         li tp, 0        # Map won't be dislocated %
000000ed : 00002317;   % 240:         call RENDER_MAP %
000000ee : 958300e7;   % 240:  %
000000ef : 0fc10297;   % 242:         la t0, CURRENT_MAP # Loads CURRENT_MAP address %
000000f0 : d4428293;   % 242:  %
000000f1 : 0062c583;   % 243:         lbu a1, 6(t0)   # Loads current X on Map (starting X on Matrix (top left)) %
000000f2 : 0072c603;   % 244:         lbu a2, 7(t0)   # Loads current Y on Map (starting Y on Matrix (top left))	 %
000000f3 : 0082c683;   % 245:         lbu a3, 8(t0)   # Loads current X offset on Map %
000000f4 : 0092c703;   % 246:         lbu a4, 9(t0)   # Loads current Y offset on Map	 %
000000f5 : 00100793;   % 247:         li a5, 1		# Frame = 1 %
000000f6 : 01400813;   % 248:         li a6, 20	# Screen Width = 20 %
000000f7 : 00f00893;   % 249:         li a7, 15	# Screen Height = 15 %
000000f8 : 00000e13;   % 250:         li t3, 0		# Starting X for rendering (top left, related to Matrix) %
000000f9 : 00000393;   % 251:         li t2, 0		# Starting Y for rendering (top left, related to Matrix) %
000000fa : 00000213;   % 252:         li tp, 0        # Map won't be dislocated %
000000fb : 00002317;   % 253:         call RENDER_MAP %
000000fc : 920300e7;   % 253:  %
000000fd : 59c0006f;   % 255:         j END_SETUP %
000000fe : 0fc10297;   % 258:         la t0, Doors3   # Doors address %
000000ff : f9628293;   % 258:  %
00000100 : 005ea023;   % 259:         sw t0,0(t4)     # Stores Doors3 address on Doors address %
00000101 : 0fc10297;   % 261:         la t0, Frames3  # Frames address %
00000102 : fce28293;   % 261:  %
00000103 : 005f2023;   % 262:         sw t0,0(t5)     # Stores Frames3 address on Doors address %
00000104 : 0fc10297;   % 264:         la t0,Zoomers   # Zoomers address %
00000105 : d4c28293;   % 264:  %
00000106 : 0fc10317;   % 265:         la t1,Zoomers3  # Loads Zoomers3 address for Map 3 %
00000107 : dfe30313;   % 265:  %
00000108 : 0062a023;   % 266:         sw t1,0(t0)     # and stores it %
00000109 : 0fc10297;   % 268:         la t0,Rippers   # Rippers address %
0000010a : ef428293;   % 268:  %
0000010b : 0002a023;   % 269:         sw zero,0(t0)   # Stores 0 to it (no rippers) %
0000010c : 0fc14517;   % 271:         la a0, Map3 	# Map Address      %
0000010d : 9ea50513;   % 271:  %
0000010e : 0fc10297;   % 272:         la t0, CURRENT_MAP # Loads CURRENT_MAP address %
0000010f : cc828293;   % 272:  %
00000110 : 00a2a023;   % 273:         sw a0, 0(t0)    # Stores Map3 address on CURRENT_MAP %
00000111 : 0062c583;   % 275:         lbu a1, 6(t0)   # Loads current X on Map (starting X on Matrix (top left)) %
00000112 : 0072c603;   % 276:         lbu a2, 7(t0)   # Loads current Y on Map (starting Y on Matrix (top left))	 %
00000113 : 0082c683;   % 277:         lbu a3, 8(t0)   # Loads current X offset on Map %
00000114 : 0092c703;   % 278:         lbu a4, 9(t0)   # Loads current Y offset on Map		 %
00000115 : 00400313;   % 280:         li t1, 4 %
00000116 : 06639263;   % 281:         bne t2, t1 CONTINUE_MAP3_SETUP %
00000117 : 00200393;   % 283:             li t2, 2 %
00000118 : 007282a3;   % 284:             sb t2, 5 (t0)  # Stores new rendering byte (2 - render twice)  %
00000119 : 00000593;   % 287:             li a1, 0 %
0000011a : 00b28323;   % 288:             sb a1, 6(t0)   # Stores new X on Map (starting X on Matrix (top left)) %
0000011b : 00000613;   % 289:             li a2, 0 %
0000011c : 00c283a3;   % 290:             sb a2, 7(t0)   # Stores new Y on Map (starting Y on Matrix (top left))	 %
0000011d : 00000693;   % 291:             li a3, 0 %
0000011e : 00d28423;   % 292:             sb a3, 8(t0)   # Stores new X offset on Map %
0000011f : 00000713;   % 293:             li a4, 0 %
00000120 : 00e284a3;   % 294:             sb a4, 9(t0)   # Stores new Y offset on Map	 %
00000121 : 0fc10297;   % 297:             la t0, PLYR_POS %
00000122 : c9628293;   % 297:  %
00000123 : 02000313;   % 298:             li t1, 32 %
00000124 : 00629023;   % 299:             sh t1, 0(t0)   # Stores new player's X related to the screen %
00000125 : 06000313;   % 300:             li t1, 96 %
00000126 : 00628223;   % 301:             sb t1, 4(t0)   # Stores new player's Y related to the screen %
00000127 : 00000313;   % 303:             li t1, 0     %
00000128 : 00628323;   % 304:             sb t1, 6(t0)   # Stores new player's X offset %
00000129 : 00000313;   % 305:             li t1, 0 %
0000012a : 006283a3;   % 306:             sb t1, 7(t0)   # Stores new player's Y offset %
0000012b : 00200313;   % 308:             li t1, 2 %
0000012c : 00628423;   % 309:             sb t1, 8(t0)   # Stores new player's X related to the matrix %
0000012d : 00600313;   % 310:             li t1, 6 %
0000012e : 00628523;   % 311:             sb t1, 10(t0)  # Stores new player's Y related to the matrix %
0000012f : 00000793;   % 314:         li a5, 0		# Frame = 0 %
00000130 : 01400813;   % 315:         li a6, 20	# Screen Width = 20 %
00000131 : 00f00893;   % 316:         li a7, 15	# Screen Height = 15 %
00000132 : 00000e13;   % 317:         li t3, 0		# Starting X for rendering (top left, related to Matrix) %
00000133 : 00000393;   % 318:         li t2, 0		# Starting Y for rendering (top left, related to Matrix) %
00000134 : 00000213;   % 319:         li tp, 0        # Map won't be dislocated %
00000135 : 00002317;   % 321:         call RENDER_MAP %
00000136 : 838300e7;   % 321:  %
00000137 : 0fc10297;   % 323:         la t0, CURRENT_MAP # Loads CURRENT_MAP address %
00000138 : c2428293;   % 323:  %
00000139 : 0062c583;   % 324:         lbu a1, 6(t0)   # Loads current X on Map (starting X on Matrix (top left)) %
0000013a : 0072c603;   % 325:         lbu a2, 7(t0)   # Loads current Y on Map (starting Y on Matrix (top left))	 %
0000013b : 0082c683;   % 326:         lbu a3, 8(t0)   # Loads current X offset on Map %
0000013c : 0092c703;   % 327:         lbu a4, 9(t0)   # Loads current Y offset on Map	 %
0000013d : 00100793;   % 328:         li a5, 1		# Frame = 1 %
0000013e : 01400813;   % 329:         li a6, 20	# Screen Width = 20 %
0000013f : 00f00893;   % 330:         li a7, 15	# Screen Height = 15 %
00000140 : 00000e13;   % 331:         li t3, 0		# Starting X for rendering (top left, related to Matrix) %
00000141 : 00000393;   % 332:         li t2, 0		# Starting Y for rendering (top left, related to Matrix) %
00000142 : 00000213;   % 333:         li tp, 0        # Map won't be dislocated %
00000143 : 00002317;   % 334:         call RENDER_MAP %
00000144 : 800300e7;   % 334:  %
00000145 : 47c0006f;   % 336:         j END_SETUP %
00000146 : 0fc10297;   % 340:         la t0, Doors4   # Doors address %
00000147 : e7f28293;   % 340:  %
00000148 : 005ea023;   % 341:         sw t0,0(t4)     # Stores Doors4 address on Doors address %
00000149 : 0fc10297;   % 343:         la t0, Frames4  # Frames address %
0000014a : ebb28293;   % 343:  %
0000014b : 005f2023;   % 344:         sw t0,0(t5)     # Stores Frames4 address on Doors address %
0000014c : 0fc10297;   % 346:         la t0,Zoomers   # Zoomers address %
0000014d : c2c28293;   % 346:  %
0000014e : 0fc10317;   % 347:         la t1,Zoomers4  # Loads Zoomers4 address for Map 4 %
0000014f : d2730313;   % 347:  %
00000150 : 0062a023;   % 348:         sw t1,0(t0)     # and stores it %
00000151 : 0fc10297;   % 350:         la t0,Rippers   # Rippers address %
00000152 : dd428293;   % 350:  %
00000153 : 0fc10317;   % 351:         la t1,Rippers4  # Loads Rippers4 address for Map 4 %
00000154 : df430313;   % 351:  %
00000155 : 0062a023;   % 352:         sw t1,0(t0)     # and stores it %
00000156 : 0fc14517;   % 354:         la a0, Map4 	# Map Address      %
00000157 : c4950513;   % 354:  %
00000158 : 0fc10297;   % 355:         la t0, CURRENT_MAP # Loads CURRENT_MAP address %
00000159 : ba028293;   % 355:  %
0000015a : 00a2a023;   % 356:         sw a0, 0(t0)    # Stores Map4 address on CURRENT_MAP %
0000015b : 0062c583;   % 358:         lbu a1, 6(t0)   # Loads current X on Map (starting X on Matrix (top left)) %
0000015c : 0072c603;   % 359:         lbu a2, 7(t0)   # Loads current Y on Map (starting Y on Matrix (top left))	 %
0000015d : 0082c683;   % 360:         lbu a3, 8(t0)   # Loads current X offset on Map %
0000015e : 0092c703;   % 361:         lbu a4, 9(t0)   # Loads current Y offset on Map		 %
0000015f : 00400313;   % 363:         li t1, 4 %
00000160 : 06639263;   % 364:         bne t2, t1 CONTINUE_MAP4_SETUP %
00000161 : 00200393;   % 366:             li t2, 2 %
00000162 : 007282a3;   % 367:             sb t2, 5 (t0)  # Stores new rendering byte (2 - render twice)  %
00000163 : 00000593;   % 370:             li a1, 0 %
00000164 : 00b28323;   % 371:             sb a1, 6(t0)   # Stores new X on Map (starting X on Matrix (top left)) %
00000165 : 01e00613;   % 372:             li a2, 30 %
00000166 : 00c283a3;   % 373:             sb a2, 7(t0)   # Stores new Y on Map (starting Y on Matrix (top left))	 %
00000167 : 00000693;   % 374:             li a3, 0 %
00000168 : 00d28423;   % 375:             sb a3, 8(t0)   # Stores new X offset on Map %
00000169 : 00000713;   % 376:             li a4, 0 %
0000016a : 00e284a3;   % 377:             sb a4, 9(t0)   # Stores new Y offset on Map	 %
0000016b : 0fc10297;   % 380:             la t0, PLYR_POS %
0000016c : b6e28293;   % 380:  %
0000016d : 02000313;   % 381:             li t1, 32 %
0000016e : 00629023;   % 382:             sh t1, 0(t0)   # Stores new player's X related to the screen %
0000016f : 06000313;   % 383:             li t1, 96 %
00000170 : 00628223;   % 384:             sb t1, 4(t0)   # Stores new player's Y related to the screen %
00000171 : 00000313;   % 386:             li t1, 0     %
00000172 : 00628323;   % 387:             sb t1, 6(t0)   # Stores new player's X offset %
00000173 : 00000313;   % 388:             li t1, 0 %
00000174 : 006283a3;   % 389:             sb t1, 7(t0)   # Stores new player's Y offset %
00000175 : 00200313;   % 391:             li t1, 2 %
00000176 : 00628423;   % 392:             sb t1, 8(t0)   # Stores new player's X related to the matrix %
00000177 : 02400313;   % 393:             li t1, 36 %
00000178 : 00628523;   % 394:             sb t1, 10(t0)  # Stores new player's Y related to the matrix %
00000179 : 00000793;   % 397:         li a5, 0		# Frame = 0 %
0000017a : 01400813;   % 398:         li a6, 20	# Screen Width = 20 %
0000017b : 00f00893;   % 399:         li a7, 15	# Screen Height = 15 %
0000017c : 00000e13;   % 400:         li t3, 0		# Starting X for rendering (top left, related to Matrix) %
0000017d : 00000393;   % 401:         li t2, 0		# Starting Y for rendering (top left, related to Matrix) %
0000017e : 00000213;   % 402:         li tp, 0        # Map won't be dislocated %
0000017f : 00001317;   % 404:         call RENDER_MAP %
00000180 : 710300e7;   % 404:  %
00000181 : 0fc10297;   % 406:         la t0, CURRENT_MAP # Loads CURRENT_MAP address %
00000182 : afc28293;   % 406:  %
00000183 : 0062c583;   % 407:         lbu a1, 6(t0)   # Loads current X on Map (starting X on Matrix (top left)) %
00000184 : 0072c603;   % 408:         lbu a2, 7(t0)   # Loads current Y on Map (starting Y on Matrix (top left))	 %
00000185 : 0082c683;   % 409:         lbu a3, 8(t0)   # Loads current X offset on Map %
00000186 : 0092c703;   % 410:         lbu a4, 9(t0)   # Loads current Y offset on Map	 %
00000187 : 00100793;   % 411:         li a5, 1		# Frame = 1 %
00000188 : 01400813;   % 412:         li a6, 20	# Screen Width = 20 %
00000189 : 00f00893;   % 413:         li a7, 15	# Screen Height = 15 %
0000018a : 00000e13;   % 414:         li t3, 0		# Starting X for rendering (top left, related to Matrix) %
0000018b : 00000393;   % 415:         li t2, 0		# Starting Y for rendering (top left, related to Matrix) %
0000018c : 00000213;   % 416:         li tp, 0        # Map won't be dislocated %
0000018d : 00001317;   % 417:         call RENDER_MAP %
0000018e : 6d8300e7;   % 417:  %
0000018f : 3540006f;   % 419:         j END_SETUP %
00000190 : 0fc10297;   % 422:         la t0, Doors5   # Doors address %
00000191 : d6028293;   % 422:  %
00000192 : 005ea023;   % 423:         sw t0,0(t4)     # Stores Doors5 address on Doors address %
00000193 : 0fc10297;   % 425:         la t0, Frames5  # Frames address %
00000194 : da028293;   % 425:  %
00000195 : 005f2023;   % 426:         sw t0,0(t5)     # Stores Frames5 address on Doors address %
00000196 : 0fc10297;   % 428:         la t0,Zoomers   # Zoomers address %
00000197 : b0428293;   % 428:  %
00000198 : 0fc10317;   % 429:         la t1,Zoomers5  # Loads Zoomers5 address for Map 5 %
00000199 : c8430313;   % 429:  %
0000019a : 0062a023;   % 430:         sw t1,0(t0)     # and stores it %
0000019b : 0fc10297;   % 432:         la t0,Rippers   # Rippers address %
0000019c : cac28293;   % 432:  %
0000019d : 0002a023;   % 433:         sw zero,0(t0)   # Stores 0 to it (no rippers) %
0000019e : 0fc14517;   % 435:         la a0, Map5 	# Map Address      %
0000019f : eb050513;   % 435:  %
000001a0 : 0fc10297;   % 436:         la t0, CURRENT_MAP # Loads CURRENT_MAP address %
000001a1 : a8028293;   % 436:  %
000001a2 : 00a2a023;   % 437:         sw a0, 0(t0)    # Stores Map5 address on CURRENT_MAP %
000001a3 : 0062c583;   % 439:         lbu a1, 6(t0)   # Loads current X on Map (starting X on Matrix (top left)) %
000001a4 : 0072c603;   % 440:         lbu a2, 7(t0)   # Loads current Y on Map (starting Y on Matrix (top left))	 %
000001a5 : 0082c683;   % 441:         lbu a3, 8(t0)   # Loads current X offset on Map %
000001a6 : 0092c703;   % 442:         lbu a4, 9(t0)   # Loads current Y offset on Map		 %
000001a7 : 00400313;   % 444:         li t1, 4 %
000001a8 : 06639263;   % 445:         bne t2, t1 CONTINUE_MAP5_SETUP %
000001a9 : 00200393;   % 447:             li t2, 2 %
000001aa : 007282a3;   % 448:             sb t2, 5 (t0)  # Stores new rendering byte (2 - render twice)  %
000001ab : 01400593;   % 451:             li a1, 20 %
000001ac : 00b28323;   % 452:             sb a1, 6(t0)   # Stores new X on Map (starting X on Matrix (top left)) %
000001ad : 00000613;   % 453:             li a2, 0 %
000001ae : 00c283a3;   % 454:             sb a2, 7(t0)   # Stores new Y on Map (starting Y on Matrix (top left))	 %
000001af : 00000693;   % 455:             li a3, 0 %
000001b0 : 00d28423;   % 456:             sb a3, 8(t0)   # Stores new X offset on Map %
000001b1 : 00000713;   % 457:             li a4, 0 %
000001b2 : 00e284a3;   % 458:             sb a4, 9(t0)   # Stores new Y offset on Map	 %
000001b3 : 0fc10297;   % 461:             la t0, PLYR_POS %
000001b4 : a4e28293;   % 461:  %
000001b5 : 11000313;   % 462:             li t1, 272 %
000001b6 : 00629023;   % 463:             sh t1, 0(t0)   # Stores new player's X related to the screen %
000001b7 : 06000313;   % 464:             li t1, 96 %
000001b8 : 00628223;   % 465:             sb t1, 4(t0)   # Stores new player's Y related to the screen %
000001b9 : 00000313;   % 467:             li t1, 0     %
000001ba : 00628323;   % 468:             sb t1, 6(t0)   # Stores new player's X offset %
000001bb : 00000313;   % 469:             li t1, 0 %
000001bc : 006283a3;   % 470:             sb t1, 7(t0)   # Stores new player's Y offset %
000001bd : 02500313;   % 472:             li t1, 37 %
000001be : 00628423;   % 473:             sb t1, 8(t0)   # Stores new player's X related to the matrix %
000001bf : 00600313;   % 474:             li t1, 6 %
000001c0 : 00628523;   % 475:             sb t1, 10(t0)  # Stores new player's Y related to the matrix %
000001c1 : 00000793;   % 478:         li a5, 0		# Frame = 0 %
000001c2 : 01400813;   % 479:         li a6, 20	# Screen Width = 20 %
000001c3 : 00f00893;   % 480:         li a7, 15	# Screen Height = 15 %
000001c4 : 00000e13;   % 481:         li t3, 0		# Starting X for rendering (top left, related to Matrix) %
000001c5 : 00000393;   % 482:         li t2, 0		# Starting Y for rendering (top left, related to Matrix) %
000001c6 : 00000213;   % 483:         li tp, 0        # Map won't be dislocated %
000001c7 : 00001317;   % 485:         call RENDER_MAP %
000001c8 : 5f0300e7;   % 485:  %
000001c9 : 0fc10297;   % 487:         la t0, CURRENT_MAP # Loads CURRENT_MAP address %
000001ca : 9dc28293;   % 487:  %
000001cb : 0062c583;   % 488:         lbu a1, 6(t0)   # Loads current X on Map (starting X on Matrix (top left)) %
000001cc : 0072c603;   % 489:         lbu a2, 7(t0)   # Loads current Y on Map (starting Y on Matrix (top left))	 %
000001cd : 0082c683;   % 490:         lbu a3, 8(t0)   # Loads current X offset on Map %
000001ce : 0092c703;   % 491:         lbu a4, 9(t0)   # Loads current Y offset on Map	 %
000001cf : 00100793;   % 492:         li a5, 1		# Frame = 1 %
000001d0 : 01400813;   % 493:         li a6, 20	# Screen Width = 20 %
000001d1 : 00f00893;   % 494:         li a7, 15	# Screen Height = 15 %
000001d2 : 00000e13;   % 495:         li t3, 0		# Starting X for rendering (top left, related to Matrix) %
000001d3 : 00000393;   % 496:         li t2, 0		# Starting Y for rendering (top left, related to Matrix) %
000001d4 : 00000213;   % 497:         li tp, 0        # Map won't be dislocated %
000001d5 : 00001317;   % 498:         call RENDER_MAP %
000001d6 : 5b8300e7;   % 498:  %
000001d7 : 2340006f;   % 500:         j END_SETUP %
000001d8 : 0fc10297;   % 503:         la t0, Doors6   # Doors address %
000001d9 : c4928293;   % 503:  %
000001da : 005ea023;   % 504:         sw t0,0(t4)     # Stores Doors6 address on Doors address %
000001db : 0fc10297;   % 506:         la t0, Frames6  # Frames address %
000001dc : c8d28293;   % 506:  %
000001dd : 005f2023;   % 507:         sw t0,0(t5)     # Stores Frames6 address on Doors address %
000001de : 0fc10297;   % 509:         la t0,Zoomers   # Zoomers address %
000001df : 9e428293;   % 509:  %
000001e0 : 0002a023;   % 510:         sw zero,0(t0)   # Stores 0 to it (no zoomers) %
000001e1 : 0fc10297;   % 512:         la t0,Rippers   # Rippers address %
000001e2 : b9428293;   % 512:  %
000001e3 : 0002a023;   % 513:         sw zero,0(t0)   # Stores 0 to it (no rippers) %
000001e4 : 0fc14517;   % 515:         la a0, Map6 	# Map Address      %
000001e5 : ff350513;   % 515:  %
000001e6 : 0fc10297;   % 516:         la t0, CURRENT_MAP # Loads CURRENT_MAP address %
000001e7 : 96828293;   % 516:  %
000001e8 : 00a2a023;   % 517:         sw a0, 0(t0)    # Stores Map6 address on CURRENT_MAP %
000001e9 : 0062c583;   % 519:         lbu a1, 6(t0)   # Loads current X on Map (starting X on Matrix (top left)) %
000001ea : 0072c603;   % 520:         lbu a2, 7(t0)   # Loads current Y on Map (starting Y on Matrix (top left))	 %
000001eb : 0082c683;   % 521:         lbu a3, 8(t0)   # Loads current X offset on Map %
000001ec : 0092c703;   % 522:         lbu a4, 9(t0)   # Loads current Y offset on Map		 %
000001ed : 00400313;   % 524:         li t1, 4 %
000001ee : 06639263;   % 525:         bne t2, t1 CONTINUE_MAP6_SETUP %
000001ef : 00200393;   % 527:             li t2, 2 %
000001f0 : 007282a3;   % 528:             sb t2, 5 (t0)  # Stores new rendering byte (2 - render twice)  %
000001f1 : 00000593;   % 531:             li a1, 0 %
000001f2 : 00b28323;   % 532:             sb a1, 6(t0)   # Stores new X on Map (starting X on Matrix (top left)) %
000001f3 : 00000613;   % 533:             li a2, 0 %
000001f4 : 00c283a3;   % 534:             sb a2, 7(t0)   # Stores new Y on Map (starting Y on Matrix (top left))	 %
000001f5 : 00000693;   % 535:             li a3, 0 %
000001f6 : 00d28423;   % 536:             sb a3, 8(t0)   # Stores new X offset on Map %
000001f7 : 00000713;   % 537:             li a4, 0 %
000001f8 : 00e284a3;   % 538:             sb a4, 9(t0)   # Stores new Y offset on Map	 %
000001f9 : 0fc10297;   % 541:             la t0, PLYR_POS %
000001fa : 93628293;   % 541:  %
000001fb : 11000313;   % 542:             li t1, 272 %
000001fc : 00629023;   % 543:             sh t1, 0(t0)   # Stores new player's X related to the screen %
000001fd : 06000313;   % 544:             li t1, 96 %
000001fe : 00628223;   % 545:             sb t1, 4(t0)   # Stores new player's Y related to the screen %
000001ff : 00000313;   % 547:             li t1, 0     %
00000200 : 00628323;   % 548:             sb t1, 6(t0)   # Stores new player's X offset %
00000201 : 00000313;   % 549:             li t1, 0 %
00000202 : 006283a3;   % 550:             sb t1, 7(t0)   # Stores new player's Y offset %
00000203 : 01100313;   % 552:             li t1, 17 %
00000204 : 00628423;   % 553:             sb t1, 8(t0)   # Stores new player's X related to the matrix %
00000205 : 00600313;   % 554:             li t1, 6 %
00000206 : 00628523;   % 555:             sb t1, 10(t0)  # Stores new player's Y related to the matrix %
00000207 : 00000793;   % 558:         li a5, 0		# Frame = 0 %
00000208 : 01400813;   % 559:         li a6, 20	# Screen Width = 20 %
00000209 : 00f00893;   % 560:         li a7, 15	# Screen Height = 15 %
0000020a : 00000e13;   % 561:         li t3, 0		# Starting X for rendering (top left, related to Matrix) %
0000020b : 00000393;   % 562:         li t2, 0		# Starting Y for rendering (top left, related to Matrix) %
0000020c : 00000213;   % 563:         li tp, 0        # Map won't be dislocated %
0000020d : 00001317;   % 564:         call RENDER_MAP %
0000020e : 4d8300e7;   % 564:  %
0000020f : 0fc10297;   % 566:         la t0, CURRENT_MAP # Loads CURRENT_MAP address %
00000210 : 8c428293;   % 566:  %
00000211 : 0062c583;   % 567:         lbu a1, 6(t0)   # Loads current X on Map (starting X on Matrix (top left)) %
00000212 : 0072c603;   % 568:         lbu a2, 7(t0)   # Loads current Y on Map (starting Y on Matrix (top left))	 %
00000213 : 0082c683;   % 569:         lbu a3, 8(t0)   # Loads current X offset on Map %
00000214 : 0092c703;   % 570:         lbu a4, 9(t0)   # Loads current Y offset on Map	 %
00000215 : 00100793;   % 571:         li a5, 1		# Frame = 1 %
00000216 : 01400813;   % 572:         li a6, 20	# Screen Width = 20 %
00000217 : 00f00893;   % 573:         li a7, 15	# Screen Height = 15 %
00000218 : 00000e13;   % 574:         li t3, 0		# Starting X for rendering (top left, related to Matrix) %
00000219 : 00000393;   % 575:         li t2, 0		# Starting Y for rendering (top left, related to Matrix) %
0000021a : 00000213;   % 576:         li tp, 0        # Map won't be dislocated  %
0000021b : 00001317;   % 577:         call RENDER_MAP %
0000021c : 4a0300e7;   % 577:  %
0000021d : 11c0006f;   % 579:         j END_SETUP %
0000021e : 0fc10297;   % 582:         la t0, Doors7   # Doors address %
0000021f : b3628293;   % 582:  %
00000220 : 005ea023;   % 583:         sw t0,0(t4)     # Stores Doors1 address on Doors address %
00000221 : 0fc10297;   % 585:         la t0, Frames7  # Frames address %
00000222 : b7c28293;   % 585:  %
00000223 : 005f2023;   % 586:         sw t0,0(t5)     # Stores Frames7 address on Doors address %
00000224 : 0fc10297;   % 588:         la t0,Zoomers   # Zoomers address %
00000225 : 8cc28293;   % 588:  %
00000226 : 0002a023;   % 589:         sw zero,0(t0)   # Stores 0 to it (no zoomers) %
00000227 : 0fc10297;   % 591:         la t0,Rippers   # Rippers address %
00000228 : a7c28293;   % 591:  %
00000229 : 0002a023;   % 592:         sw zero,0(t0)   # Stores 0 to it (no rippers) %
0000022a : 0fc14517;   % 594:         la a0, Map7 	# Map Address      %
0000022b : 00a50513;   % 594:  %
0000022c : 0fc10297;   % 595:         la t0, CURRENT_MAP # Loads CURRENT_MAP address %
0000022d : 85028293;   % 595:  %
0000022e : 00a2a023;   % 596:         sw a0, 0(t0)    # Stores Map7 address on CURRENT_MAP %
0000022f : 0062c583;   % 598:         lbu a1, 6(t0)   # Loads current X on Map (starting X on Matrix (top left)) %
00000230 : 0072c603;   % 599:         lbu a2, 7(t0)   # Loads current Y on Map (starting Y on Matrix (top left))	 %
00000231 : 0082c683;   % 600:         lbu a3, 8(t0)   # Loads current X offset on Map %
00000232 : 0092c703;   % 601:         lbu a4, 9(t0)   # Loads current Y offset on Map		 %
00000233 : 00400313;   % 603:         li t1, 4 %
00000234 : 06639263;   % 604:         bne t2, t1 CONTINUE_MAP7_SETUP %
00000235 : 00200393;   % 606:             li t2, 2 %
00000236 : 007282a3;   % 607:             sb t2, 5 (t0)  # Stores new rendering byte (2 - render twice)  %
00000237 : 00000593;   % 610:             li a1, 0 %
00000238 : 00b28323;   % 611:             sb a1, 6(t0)   # Stores new X on Map (starting X on Matrix (top left)) %
00000239 : 00000613;   % 612:             li a2, 0 %
0000023a : 00c283a3;   % 613:             sb a2, 7(t0)   # Stores new Y on Map (starting Y on Matrix (top left))	 %
0000023b : 00000693;   % 614:             li a3, 0 %
0000023c : 00d28423;   % 615:             sb a3, 8(t0)   # Stores new X offset on Map %
0000023d : 00000713;   % 616:             li a4, 0 %
0000023e : 00e284a3;   % 617:             sb a4, 9(t0)   # Stores new Y offset on Map	 %
0000023f : 0fc10297;   % 620:             la t0, PLYR_POS %
00000240 : 81e28293;   % 620:  %
00000241 : 11000313;   % 621:             li t1, 272 %
00000242 : 00629023;   % 622:             sh t1, 0(t0)   # Stores new player's X related to the screen %
00000243 : 06000313;   % 623:             li t1, 96 %
00000244 : 00628223;   % 624:             sb t1, 4(t0)   # Stores new player's Y related to the screen %
00000245 : 00000313;   % 626:             li t1, 0     %
00000246 : 00628323;   % 627:             sb t1, 6(t0)   # Stores new player's X offset %
00000247 : 00000313;   % 628:             li t1, 0 %
00000248 : 006283a3;   % 629:             sb t1, 7(t0)   # Stores new player's Y offset %
00000249 : 01100313;   % 631:             li t1, 17 %
0000024a : 00628423;   % 632:             sb t1, 8(t0)   # Stores new player's X related to the matrix %
0000024b : 00600313;   % 633:             li t1, 6 %
0000024c : 00628523;   % 634:             sb t1, 10(t0)  # Stores new player's Y related to the matrix %
0000024d : 00000793;   % 637:         li a5, 0		# Frame = 0 %
0000024e : 01400813;   % 638:         li a6, 20	# Screen Width = 20 %
0000024f : 00f00893;   % 639:         li a7, 15	# Screen Height = 15 %
00000250 : 00000e13;   % 640:         li t3, 0		# Starting X for rendering (top left, related to Matrix) %
00000251 : 00000393;   % 641:         li t2, 0		# Starting Y for rendering (top left, related to Matrix) %
00000252 : 00000213;   % 642:         li tp, 0        # Map won't be dislocated %
00000253 : 00001317;   % 643:         call RENDER_MAP %
00000254 : 3c0300e7;   % 643:  %
00000255 : 0fc0f297;   % 645:         la t0, CURRENT_MAP # Loads CURRENT_MAP address %
00000256 : 7ac28293;   % 645:  %
00000257 : 0062c583;   % 646:         lbu a1, 6(t0)   # Loads current X on Map (starting X on Matrix (top left)) %
00000258 : 0072c603;   % 647:         lbu a2, 7(t0)   # Loads current Y on Map (starting Y on Matrix (top left))	 %
00000259 : 0082c683;   % 648:         lbu a3, 8(t0)   # Loads current X offset on Map %
0000025a : 0092c703;   % 649:         lbu a4, 9(t0)   # Loads current Y offset on Map	 %
0000025b : 00100793;   % 650:         li a5, 1		# Frame = 1 %
0000025c : 01400813;   % 651:         li a6, 20	# Screen Width = 20 %
0000025d : 00f00893;   % 652:         li a7, 15	# Screen Height = 15 %
0000025e : 00000e13;   % 653:         li t3, 0		# Starting X for rendering (top left, related to Matrix) %
0000025f : 00000393;   % 654:         li t2, 0		# Starting Y for rendering (top left, related to Matrix) %
00000260 : 00000213;   % 655:         li tp, 0        # Map won't be dislocated %
00000261 : 00001317;   % 656:         call RENDER_MAP %
00000262 : 388300e7;   % 656:  %
00000263 : 0040006f;   % 658:         j END_SETUP %
00000264 : 0fc0f297;   % 661:     la t0, CURRENT_MAP   # Loads CURRENT_MAP address %
00000265 : 77028293;   % 661:  %
00000266 : 0052c303;   % 662:     lbu t1,5(t0)         # Loads rendering byte      %
00000267 : 00300393;   % 663:     li t2, 3             # Loads 3 (switch map through door) to be compared with %
00000268 : 00731463;   % 664:     bne t1,t2, END_SETUP_NORMAL # If rendering byte != 3, return to game loop %
00000269 : 33d0306f;   % 665:         j LEAVE_DOOR_ANIMATION_PREP # Otherwise, finish map switch %
0000026a : e98ff06f;   % 667:     j GAME_LOOP %
0000026b : 0fc10297;   % 686:     la t0, Doors # Loads Doors address %
0000026c : 9c828293;   % 686:  %
0000026d : 0fc0f217;   % 687: 	la tp, CURRENT_MAP # Loads CURRENT_MAP address %
0000026e : 74c20213;   % 687:  %
0000026f : 0002a503;   % 688: 	lw a0,0(t0)   # Gets current map's doors address %
00000270 : 00054283;   % 689: 	lbu t0,0(a0)  # Loads number of doors in this map %
00000271 : 00150513;   % 690: 	addi a0,a0,1  # Goes to next byte (where doors from current map start) %
00000272 : 00000313;   % 691: 	li t1,0       # Counter for doors %
00000273 : 00000593;   % 692:     li a1,0       # Default: won't render doors unless there's a change of state %
00000274 : 00350383;   % 695:         lb t2,3(a0)  # Loads C (counter) parameter %
00000275 : 0003c663;   % 696:         blt t2,zero,UPDATE_DOORS_LOOP_COUNT_UP    # If counter is negative, iterate up %
00000276 : 02704663;   % 697:         bgt t2,zero,UPDATE_DOORS_LOOP_COUNT_DOWN  # If counter is positive, iterate down %
00000277 : 0640006f;   % 698:             j NEXT_IN_UPDATE_DOORS_LOOP # Otherwise, counter is 0 and should stay this way %
00000278 : 00138393;   % 701:             addi t2,t2,1  # C++ %
00000279 : 007501a3;   % 702:             sb t2,3(a0)   # and stores updated C on door's counter byte %
0000027a : 04039c63;   % 703:             bnez t2,NEXT_IN_UPDATE_DOORS_LOOP # If C != 0, go update next door %
0000027b : 00200393;   % 705:                 li t2,2         # Loads 2 (open) %
0000027c : 00750123;   % 706:                 sb t2,2(a0)     # and stores it on door's state byte %
0000027d : 03c00393;   % 707:                 li t2,60 # Gets new counter (related to open door) %
0000027e : 007501a3;   % 708:                 sb t2,3(a0)     # and stores it on door's counter byte %
0000027f : 00100593;   % 709:                 li a1,1         # Since status was updated, should render doors   %
00000280 : 0400006f;   % 710:                 j NEXT_IN_UPDATE_DOORS_LOOP   %
00000281 : fff38393;   % 714:             addi t2,t2,-1  # C-- %
00000282 : 007501a3;   % 715:             sb t2,3(a0)    # and stores updated C on door's counter byte %
00000283 : 02039a63;   % 716:             bnez t2,NEXT_IN_UPDATE_DOORS_LOOP # If C != 0, go update next door %
00000284 : 00254383;   % 718:                 lbu t2,2(a0)  # Loads door's state byte %
00000285 : fff38393;   % 719:                 addi t2,t2,-1 # If state is 2 -> 1; if state is 1 -> 0 %
00000286 : 00038e63;   % 720:                 beqz t2, UPDATE_DOORS_LOOP_CHANGE_OPENING  # If t2 = 0, state was 1 (opening) %
00000287 : 00100393;   % 723:                     li t2,1             # Loads 1 (opening) %
00000288 : 00750123;   % 724:                     sb t2,2(a0)         # and stores it on door's state byte %
00000289 : 00400393;   % 725:                     li t2,4  # Gets new counter (related to opening door -- positive, in order to close) %
0000028a : 007501a3;   % 726:                     sb t2,3(a0)         # and stores it on door's counter byte %
0000028b : 00100593;   % 727:                     li a1,1             # Since status was updated, should render doors   %
0000028c : 0100006f;   % 728:                     j NEXT_IN_UPDATE_DOORS_LOOP  %
0000028d : 00000393;   % 731:                     li t2,0         # Loads 0 (closed) %
0000028e : 00750123;   % 732:                     sb t2,2(a0)     # and stores it on door's state byte %
0000028f : 00100593;   % 734:                     li a1,1         # Since status was updated, should render doors   %
00000290 : 00450513;   % 738:             addi a0,a0,4 # Going to the next door's address                                   %
00000291 : 00130313;   % 739:             addi t1,t1,1 # Iterating counter by 1                                    %
00000292 : 00535463;   % 740:             bge t1,t0, END_UPDATE_DOORS_LOOP # If all of the map's doors were checked, end loop                                   %
00000293 : f85ff06f;   % 741:             j UPDATE_DOORS_LOOP # otherwise, go back to the loop's beginning                      %
00000294 : 00058c63;   % 745:         beqz a1,END_UPDATE_DOORS # If a1 is 0, doors shouldn't be rendered again %
00000295 : 00300293;   % 746:         li t0, 3        # To be compared with rendering byte (3 - switch map through doors) %
00000296 : 00524303;   % 747:         lbu t1, 5(tp)   # Loads CURRENT_MAP's rendering byte on t1 %
00000297 : 00628663;   % 748:         beq t0,t1,END_UPDATE_DOORS # If rendering byte is 3, don't change it %
00000298 : 00200393;   % 750:         li t2, 2       # t2 = 2 (map will be rendered again) %
00000299 : 007202a3;   % 751:         sb t2, 5(tp)   # Stores t3 on CURRENT_MAP's rendering byte %
0000029a : 00008067;   % 755:         ret  %
0000029b : 0fc10297;   % 778:     la t0, Doors # Loads Doors address %
0000029c : 90828293;   % 778:  %
0000029d : 0fc0f217;   % 779: 	la tp, CURRENT_MAP # Loads CURRENT_MAP address %
0000029e : 68c20213;   % 779:  %
0000029f : 0002a603;   % 780: 	lw a2,0(t0)   # Gets current map's doors address %
000002a0 : 00064283;   % 781: 	lbu t0,0(a2)  # Loads number of doors in this map %
000002a1 : 00160613;   % 782: 	addi a2,a2,1  # Goes to next byte (where doors from current map start) %
000002a2 : 00159593;   % 783:     slli a1,a1,1  # Multiplies a1 by 2  %
000002a3 : 00000313;   % 785:     li t1,0       # Counter for doors      %
000002a4 : 00100393;   % 788:         li t2,1       # Loads 1 (opening/closing) %
000002a5 : 00760123;   % 789:         sb t2,2(a2)   # and stores it on door's state byte     %
000002a6 : 00050a63;   % 790:         beqz a0, CHANGE_DOORS_STATE_LOOP_OPEN_DOORS # If a0 = 0, open doors %
000002a7 : 00400393;   % 792:             li t2,4  # Gets new counter (related to closing door -- positive, in order to close) %
000002a8 : 40b383b3;   % 793:             sub t2,t2,a1        # t2 = 4 if a1 is 0, otherwise, t2 = 2 %
000002a9 : 007601a3;   % 794:             sb t2,3(a2)         # Stores C on door's counter byte %
000002aa : 00c0006f;   % 795:             j NEXT_IN_CHANGE_DOORS_STATE_LOOP  %
000002ab : ffe00393;   % 798:             li t2,-2  # Gets new counter (related to opening door -- negative, in order to open) %
000002ac : 007601a3;   % 799:             sb t2,3(a2)         # and stores it on door's counter byte %
000002ad : 00460613;   % 802:         addi a2,a2,4 # Going to the next door's address                                   %
000002ae : 00130313;   % 803:         addi t1,t1,1 # Iterating counter by 1                                    %
000002af : 00535463;   % 804:         bge t1,t0, END_CHANGE_DOORS_STATE_LOOP # If all of the map's doors were checked, end loop                                   %
000002b0 : fd1ff06f;   % 805:         j CHANGE_DOORS_STATE_LOOP # otherwise, go back to the loop's beginning                      %
000002b1 : 00200393;   % 808:         li t2, 2       # t2 = 2 (map will be rendered again) %
000002b2 : 007202a3;   % 809:         sb t2, 5(tp)   # Stores t3 on CURRENT_MAP's rendering byte %
000002b3 : 00008067;   % 810:         ret  # End of procedure, return     %
000002b4 : ff200337;   % 4:     li t1,0xFF200000  	  # KDMMIO Address %
000002b5 : 00030313;   % 4:  %
000002b6 : 00032283;   % 5:     lw t0, 0(t1)	      # Reads the Keyboard Control bit %
000002b7 : 0012f293;   % 6:     andi t0, t0, 0x0001	  # Masks the least significant bit %
000002b8 : 0fc0f517;   % 8:     la a0, PLYR_STATUS      # Loads Player Status %
000002b9 : 64650513;   % 8:  %
000002ba : 0fc0f617;   % 9:     la a2, PLYR_POS # Loads Player Pos %
000002bb : 63260613;   % 9:  %
000002bc : 00029463;   % 10:     bnez t0, CONTINUE_CHECK # if an input is detected, continue checking %
000002bd : 0e40006f;   % 11:     j NO_INPUT 		    # otherwise no input was detected  %
000002be : 00450e03;   % 14:     lb t3, 4(a0) # loads ball mode %
000002bf : 0fc0f297;   % 16:     la t0, PLYR_INPUT # Loads PLYR_INPUT address %
000002c0 : 63328293;   % 16:  %
000002c1 : 0002c383;   % 17:     lbu t2,0(t0)      # gets its value %
000002c2 : 00039663;   % 18:     bnez t2, DONT_UPDATE_PLYR_INPUT  # If it isn't 0, don't update it %
000002c3 : 00100393;   % 19:         li t2, 1      # Otherwise, there's input %
000002c4 : 00728023;   % 20:         sb t2, 0(t0)  # store it %
000002c5 : 00432283;   % 23:     lw t0, 4(t1)   # Reads key value %
000002c6 : 07700313;   % 25:     li t1, 'w'	   # Loads ascii value of 'w' key %
000002c7 : 00629463;   % 26:     bne t0, t1, CHECK_INPUT.A %
000002c8 : 0e40006f;   % 27:     j INPUT.W	# If 'w' key was pressed %
000002c9 : 06100313;   % 30:     li t1, 'a'	# Loads ascii value of 'a' key %
000002ca : 00629463;   % 31:     bne t0,t1, CHECK_INPUT.S %
000002cb : 0ec0006f;   % 32:     j INPUT.A	# If 'a' key was pressed %
000002cc : 07300313;   % 35:     li t1, 's'	# Loads ascii value of 's' key %
000002cd : 00629463;   % 36:     bne t0, t1, CHECK_INPUT.D %
000002ce : 0ec0006f;   % 37:     j INPUT.S	# If 's' key was pressed %
000002cf : 06400313;   % 40:     li t1, 'd'	# Loads ascii value of 'd' key %
000002d0 : 00629463;   % 41:     bne t0,t1, CHECK_INPUT.SPACE %
000002d1 : 1080006f;   % 42:     j INPUT.D	# If 'd' key was pressed %
000002d2 : 02000313;   % 45:     li t1, 32	  # Loads ascii value of space key %
000002d3 : 00629463;   % 46:     bne t0,t1, CHECK_INPUT.K %
000002d4 : 1080006f;   % 47:     j INPUT.SPACE # If space key was pressed %
000002d5 : 06b00313;   % 50:     li t1, 'k'	  # Loads ascii value of 'k' key %
000002d6 : 00629463;   % 51:     bne t0,t1, CHECK_INPUT.J %
000002d7 : 1280006f;   % 52:     j INPUT.K # If 'k' key was pressed %
000002d8 : 06a00313;   % 55:     li t1, 'j'	  # Loads ascii value of 'j' key %
000002d9 : 00629463;   % 56:     bne t0,t1, CHECK_INPUT.1 %
000002da : 1300006f;   % 57:     j INPUT.J # If 'j' key was pressed %
000002db : 03100313;   % 61:     li t1, '1' %
000002dc : 00629463;   % 62:     bne t0,t1, CHECK_INPUT.2 %
000002dd : 14c0006f;   % 63:     j INPUT.1 %
000002de : 03200313;   % 66:     li t1, '2' %
000002df : 00629463;   % 67:     bne t0,t1, CHECK_INPUT.3 %
000002e0 : 1640006f;   % 68:     j INPUT.2 %
000002e1 : 03300313;   % 71:     li t1, '3' %
000002e2 : 00629463;   % 72:     bne t0,t1, CHECK_INPUT.4 %
000002e3 : 17c0006f;   % 73:     j INPUT.3 %
000002e4 : 03400313;   % 76:     li t1, '4' %
000002e5 : 00629463;   % 77:     bne t0,t1, CHECK_INPUT.5 %
000002e6 : 1940006f;   % 78:     j INPUT.4 %
000002e7 : 03500313;   % 81:     li t1, '5' %
000002e8 : 00629463;   % 82:     bne t0,t1, CHECK_INPUT.6 %
000002e9 : 1ac0006f;   % 83:     j INPUT.5 %
000002ea : 03600313;   % 86:     li t1, '6' %
000002eb : 00629463;   % 87:     bne t0,t1, CHECK_INPUT.7 %
000002ec : 1c40006f;   % 88:     j INPUT.6 %
000002ed : 03700313;   % 91:     li t1, '7' %
000002ee : 00629463;   % 92:     bne t0,t1, CHECK_INPUT.O %
000002ef : 1dc0006f;   % 93:     j INPUT.7 %
000002f0 : 06f00313;   % 96:     li t1, 'o' %
000002f1 : 00629463;   % 97:     bne t0,t1, CHECK_INPUT.DEL %
000002f2 : 1f40006f;   % 98:     j INPUT.O %
000002f3 : 07f00313;   % 101:     li t1, 127	# Loads ascii value of del key %
000002f4 : 00629463;   % 102:     bne t0,t1, NO_INPUT %
000002f5 : 1f00006f;   % 103:     j INPUT.DEL 	# If del key was pressed %
000002f6 : 0fc0f297;   % 106:         la t0, PLYR_INPUT %
000002f7 : 55728293;   % 106:  %
000002f8 : 00000393;   % 107:         li t2, 0   # There isn't input %
000002f9 : 00728023;   % 108:         sb t2, 0(t0)  %
000002fa : 0fc0f517;   % 110:         la a0, PLYR_STATUS      # Loads Player Status %
000002fb : 53e50513;   % 110:  %
000002fc : 00000313;   % 111:         li t1, 0        # Loads vertical direction (0 = normal) %
000002fd : 00650123;   % 112:         sb t1, 2(a0)    # Stores new direction on PLYR_STATUS %
000002fe : 006502a3;   % 114:         sb t1, 5(a0)                   %
000002ff : 00050323;   % 115: 	    sb zero, 6(a0)  # Stores new direction on MOVE_X %
00000300 : 2140006f;   % 116:         j END_INPUT_CHECK  %
00000301 : 000e0463;   % 119:         beqz t3, W.NOT_MORPH_BALL # t3 != 0 ? BALL = OFF : BALL = ON (If on ball mode, deactivate it) %
00000302 : 1cc0006f;   % 120:         j OUT_OF_MORPH_BALL %
00000303 : 00100313;   % 123:         li t1, 1      # Loads vertical direction (1 = up) %
00000304 : 00650123;   % 124:         sb t1, 2(a0)  # Stores new direction on PLYR_STATUS %
00000305 : 2000006f;   % 125: 	    j END_INPUT_CHECK %
00000306 : fff00313;   % 128:         li t1, -1     # Loads direction for MOVE_X (-1 = left) %
00000307 : 00650323;   % 129:         sb t1, 6(a0)  # Stores new direction on MOVE_X %
00000308 : 1f40006f;   % 130:         j END_INPUT_CHECK     %
00000309 : 0fc0f297;   % 133:         la t0, PLYR_INFO %
0000030a : 4f428293;   % 133:  %
0000030b : 0012c303;   % 134:         lbu t1, 1(t0) # Loads player's abilities %
0000030c : 00750383;   % 135:         lb t2, 7(a0)  # Loads direction on MOVE_Y %
0000030d : 00602333;   % 136:         slt t1, zero, t1 # t1 > 0 ? t1=1 : t1=0 --> if t1 = 1 or 2 (morph ball ability aquired) then go into morph ball %
0000030e : 00039863;   % 138:         bnez t2, SkipMorphBallTransformation %
0000030f : 00030663;   % 139:         beqz t1, SkipMorphBallTransformation   %
00000310 : 000e1463;   % 140:         bnez t3, SkipMorphBallTransformation %
00000311 : 1840006f;   % 141:             j INTO_MORPH_BALL %
00000312 : 1cc0006f;   % 143:         j END_INPUT_CHECK %
00000313 : 00100313;   % 146:         li t1, 1      # Loads direction for MOVE_X (1 = right) %
00000314 : 00650323;   % 147:         sb t1, 6(a0)  # Stores new direction on MOVE_X %
00000315 : 1c00006f;   % 148:         j END_INPUT_CHECK  %
00000316 : 000e0463;   % 151:         beqz t3, SPACE.NOT_MORPH_BALL %
00000317 : 1780006f;   % 152:         j OUT_OF_MORPH_BALL %
00000318 : 00750303;   % 154:             lb t1, 7(a0)  # Loads current direction on MOVE_Y %
00000319 : 00030463;   % 155:             beqz t1, CAN_JUMP %
0000031a : 1ac0006f;   % 156:             j END_INPUT_CHECK %
0000031b : 00100313;   % 158:                 li t1, 1     # Loads ground position (1 = freefall) %
0000031c : 006501a3;   % 159:                 sb t1, 3(a0) # Stores new direction on PLYR_STATUS %
0000031d : fff00313;   % 161:                 li t1, -1      # Loads direction for MOVE_Y (-1 = up) %
0000031e : 006503a3;   % 162:                 sb t1, 7(a0)  # Stores new direction on MOVE_Y %
0000031f : 20948953;   % 165:                 fmv.s fs2,fs1  # Sets fs2 (player's Y speed) to -9  %
00000320 : 1940006f;   % 166: 	            j END_INPUT_CHECK %
00000321 : 000e0463;   % 169:         beqz t3, K.SHOOT %
00000322 : 18c0006f;   % 170:         j END_INPUT_CHECK %
00000323 : 00100313;   % 171:         K.SHOOT:    li t1, 1     # Loads attacking status (1 = attacking) %
00000324 : 006502a3;   % 172:         sb t1, 5(a0) # Stores new attack status on PLYR_STATUS %
00000325 : 1840006f;   % 174:         j BEAM_OPERATIONS %
00000326 : 0fc0f297;   % 177:         la t0, PLYR_INFO_2    # Loads address to PLYR_INFO_2 %
00000327 : 4a028293;   % 177:  %
00000328 : 0012c383;   % 178:         lbu t2,1(t0)          # Loads missile cooldown %
00000329 : 00039863;   % 179:         bnez t2,SKIP_ENABLE_MISSILE  # If cooldown != 0, don't enable byte %
0000032a : 0002c303;   % 180:             lbu t1,0(t0)          # Loads missile enable byte %
0000032b : 00134313;   % 181:             xori t1,t1,1          # Switches its value %
0000032c : 00628023;   % 182:             sb t1,0(t0)           # and stores it back %
0000032d : 0013c393;   % 184:             xori t2,t2,1      # Switches cooldown value %
0000032e : 007280a3;   % 185:             sb t2,1(t0)       # and stores it back %
0000032f : 1580006f;   % 186:         j END_INPUT_CHECK  %
00000330 : 0fc0f297;   % 189:         la t0 MAP_INFO %
00000331 : 44428293;   % 189:  %
00000332 : 00100313;   % 190:         li t1, 1 %
00000333 : 00628023;   % 191:         sb t1, 0(t0) %
00000334 : 00400313;   % 192:         li t1, 4 %
00000335 : 006280a3;   % 193:         sb t1, 1(t0) %
00000336 : 00000313;   % 195:         li t1,0 %
00000337 : 006500a3;   % 196:         sb t1,1(a0) %
00000338 : be8ff06f;   % 198:         j SETUP %
00000339 : 0fc0f297;   % 201:         la t0 MAP_INFO %
0000033a : 42028293;   % 201:  %
0000033b : 00200313;   % 202:         li t1, 2 %
0000033c : 00628023;   % 203:         sb t1, 0(t0) %
0000033d : 00400313;   % 204:         li t1, 4 %
0000033e : 006280a3;   % 205:         sb t1, 1(t0) %
0000033f : 00000313;   % 207:         li t1,0 %
00000340 : 006500a3;   % 208:         sb t1,1(a0) %
00000341 : bc4ff06f;   % 210:         j SETUP %
00000342 : 0fc0f297;   % 213:         la t0 MAP_INFO %
00000343 : 3fc28293;   % 213:  %
00000344 : 00300313;   % 214:         li t1, 3 %
00000345 : 00628023;   % 215:         sb t1, 0(t0) %
00000346 : 00400313;   % 216:         li t1, 4 %
00000347 : 006280a3;   % 217:         sb t1, 1(t0) %
00000348 : 00000313;   % 219:         li t1,0 %
00000349 : 006500a3;   % 220:         sb t1,1(a0) %
0000034a : ba0ff06f;   % 222:         j SETUP %
0000034b : 0fc0f297;   % 225:         la t0 MAP_INFO %
0000034c : 3d828293;   % 225:  %
0000034d : 00400313;   % 226:         li t1, 4 %
0000034e : 00628023;   % 227:         sb t1, 0(t0) %
0000034f : 00400313;   % 228:         li t1, 4 %
00000350 : 006280a3;   % 229:         sb t1, 1(t0) %
00000351 : 00000313;   % 231:         li t1,0 %
00000352 : 006500a3;   % 232:         sb t1,1(a0) %
00000353 : b7cff06f;   % 234:         j SETUP %
00000354 : 0fc0f297;   % 237:         la t0 MAP_INFO %
00000355 : 3b428293;   % 237:  %
00000356 : 00500313;   % 238:         li t1, 5 %
00000357 : 00628023;   % 239:         sb t1, 0(t0) %
00000358 : 00400313;   % 240:         li t1, 4 %
00000359 : 006280a3;   % 241:         sb t1, 1(t0) %
0000035a : 00100313;   % 243:         li t1,1 %
0000035b : 006500a3;   % 244:         sb t1,1(a0) %
0000035c : b58ff06f;   % 246:         j SETUP %
0000035d : 0fc0f297;   % 249:         la t0 MAP_INFO %
0000035e : 39028293;   % 249:  %
0000035f : 00600313;   % 250:         li t1, 6 %
00000360 : 00628023;   % 251:         sb t1, 0(t0) %
00000361 : 00400313;   % 252:         li t1, 4 %
00000362 : 006280a3;   % 253:         sb t1, 1(t0) %
00000363 : 00100313;   % 255:         li t1,1 %
00000364 : 006500a3;   % 256:         sb t1,1(a0) %
00000365 : b34ff06f;   % 258:         j SETUP %
00000366 : 0fc0f297;   % 261:         la t0 MAP_INFO %
00000367 : 36c28293;   % 261:  %
00000368 : 00700313;   % 262:         li t1, 7 %
00000369 : 00628023;   % 263:         sb t1, 0(t0) %
0000036a : 00400313;   % 264:         li t1, 4 %
0000036b : 006280a3;   % 265:         sb t1, 1(t0) %
0000036c : 00100313;   % 267:         li t1,1 %
0000036d : 006500a3;   % 268:         sb t1,1(a0) %
0000036e : b10ff06f;   % 270:         j SETUP %
0000036f : 00000513;   % 273:         li a0, 0    # open doors %
00000370 : cadff06f;   % 275:         j CHANGE_DOORS_STATE %
00000371 : 0500006f;   % 280:         j END_INPUT_CHECK %
00000372 : 00100313;   % 284:         li t1, 1      # Loads morph ball mode (1 = enabled) %
00000373 : 00650223;   % 285:         sb t1, 4(a0)  # Stores new direction on PLYR_STATUS %
00000374 : 0440006f;   % 286:         j END_INPUT_CHECK %
00000375 : fff00313;   % 293:         li t1, -1      # Loads direction for MOVE_Y (-1 = up) %
00000376 : 006503a3;   % 294:         sb t1, 7(a0)  # Stores new direction on MOVE_Y %
00000377 : 0fc0f517;   % 297:         la a0, MOVE_Y %
00000378 : 35150513;   % 297:  %
00000379 : 0fc0f597;   % 298:         la a1, CURRENT_MAP %
0000037a : 31c58593;   % 298:  %
0000037b : 0005a583;   % 299:         lw a1, 0(a1) %
0000037c : 00100db3;   % 302:         mv s11, ra # storing return address in s11 %
0000037d : 00004317;   % 303:         call CHECK_VERTICAL_COLLISION %
0000037e : b64300e7;   % 303:  %
0000037f : 01b000b3;   % 304:         mv ra, s11 # loading return address from s11 %
00000380 : 0fc0f297;   % 306:         la t0, PLYR_STATUS      # Loads Player Status %
00000381 : 32628293;   % 306:  %
00000382 : 00050463;   % 307:         beqz a0, SKIP_OUT_OF_MORPH_BALL %
00000383 : 00028223;   % 308:             sb zero, 4(t0) # key = up ? ball = 0  %
00000384 : 000283a3;   % 310:         sb zero, 7(t0)  # Stores new direction on MOVE_Y %
00000385 : 00008067;   % 313: 		ret	 %
00000386 : 0fc0f317;   % 316:     la t1, BEAMS # loads plyrs_status attacking %
00000387 : 32630313;   % 316:  %
00000388 : 00300e93;   % 317:     li t4, 3 # max counter of number beams %
00000389 : 00000e13;   % 318:     li t3,0 %
0000038a : 00030383;   % 321:         lb t2, 0(t1) #loads if beam is already active %
0000038b : 00039463;   % 322:         bnez t2, CHECK_BEAM_ACTIVE_LOOP # beam active? proceed into loop %
0000038c : 0180006f;   % 323:         j ACTIVATE_BEAM #activate the beam %
0000038d : 01de4463;   % 326:             blt t3,t4,BEAM_CONTINUE #counter < beam_number ? continue : end %
0000038e : fddff06f;   % 327:             j END_INPUT_CHECK %
0000038f : 001e0e13;   % 330:                 addi t3,t3,1 #inc counter %
00000390 : 00930313;   % 331:                 addi t1,t1,9 #proceed into beam(i+1) %
00000391 : fe5ff06f;   % 332:                 j CHECK_BEAM_ACTIVE #check if beam is active %
00000392 : 00660383;   % 338:             lb t2, 6(a2) #loads player x offset %
00000393 : 007302a3;   % 339:             sb t2, 5(t1) #x new for beam %
00000394 : 007303a3;   % 340:             sb t2, 7(t1) #x old for beam %
00000395 : 00760383;   % 342:             lb t2, 7(a2) #loads player y offset %
00000396 : 00730323;   % 343:             sb t2, 6(t1) #y new for beam %
00000397 : 00730423;   % 344:             sb t2, 8(t1) #y old for beam %
00000398 : 00100393;   % 349:             li t2,1 # fills with 1 the beam info  %
00000399 : 00730023;   % 350:             sb t2,0(t1) # stores in beam array %
0000039a : 00250383;   % 352:             lb t2, 2(a0) # loads if player is facing up %
0000039b : 02039263;   % 353:             bnez t2, ACTIVATE_Y_AXIS_BEAM %
0000039c : 00150383;   % 359:             lb t2, 1(a0) # loads player x direction %
0000039d : 00039863;   % 360:             bnez t2,ACTIVATE_LEFT_AXIS_BEAM # direction != 0 ? left : right %
0000039e : 00100393;   % 364:             li t2,1 #loads right direction %
0000039f : 007300a3;   % 365:             sb t2,1(t1) #stores in beam direction %
000003a0 : f95ff06f;   % 368:             j END_INPUT_CHECK %
000003a1 : 00200393;   % 371:                 li t2,2 #loads left direction %
000003a2 : 007300a3;   % 372:                 sb t2,1(t1) #stores in beam direction %
000003a3 : f89ff06f;   % 373:                 j END_INPUT_CHECK %
000003a4 : 000300a3;   % 376:                 sb zero, 1(t1) %
000003a5 : f81ff06f;   % 377:                 j END_INPUT_CHECK %
000003a6 : 0fc0f517;   % 22:     la a0, MOVE_X	       # Loads address of MOVE_X %
000003a7 : 29450513;   % 22:  %
000003a8 : 00050283;   % 23:     lb t0, 0(a0)	       # Loads information from MOVE_X %
000003a9 : 0fc0f597;   % 24:     la a1, CURRENT_MAP     # Loads CURRENT_MAP's address %
000003aa : 25c58593;   % 24:  %
000003ab : 0005a603;   % 25:     lw a2, 0(a1) 	       # a2 has the current map's address  %
000003ac : 0fc0f697;   % 26:     la a3, PLYR_POS        # Loads Player Position %
000003ad : 26a68693;   % 26:  %
000003ae : 00029c63;   % 28:     bnez t0, MOVE_PLAYER_X # If there's X movement, go to MOVE_PLAYER_X %
000003af : 00069303;   % 29:     lh t1, 0(a3)  # Loads Player's X related to screen %
000003b0 : 00669123;   % 30:     sh t1, 2(a3)  # Stores Player's X related to screen on old X %
000003b1 : 0086c303;   % 31:     lbu t1, 8(a3)  # Loads Player's X related to screen %
000003b2 : 006684a3;   % 32:     sb t1, 9(a3)  # Stores Player's X related to screen on old X %
000003b3 : 1940006f;   % 33:     j CHECK_MOVE_Y         # Otherwise, go check Y movement %
000003b4 : 00229713;   % 36:         slli a4, t0, 2  # Multiplies the value stored on MOVE_X by 4. a0 will store the movement of the player (+/- 4 pixels) %
000003b5 : 00d6c303;   % 38:         lbu t1, 13(a3)  # Loads Player's Facing direction (0 = Right, 1 = Left) %
000003b6 : 006282b3;   % 39:         add t0,t0,t1    # Adds Facing direction with MOVE_X (if the result t0 = -1 or 2, the direction has changed) %
000003b7 : 00200393;   % 40:         li t2,2         # t1 = 2 %
000003b8 : 0072f463;   % 41:         bgeu t0,t2,CHANGE_X_DIRECTION # If t0 = -1 or 2, the direction chas changed %
000003b9 : 0100006f;   % 42:             j KEEP_X_DIRECTION  %
000003ba : 00134313;   % 45:             xori t1,t1,1   # Inverts direction (0 -> 1; 1 -> 0) %
000003bb : 006686a3;   % 46:             sb t1, 13(a3)  # Loads Player's Facing direction (0 = Right, 1 = Left) %
000003bc : 1700006f;   % 47:             j CHECK_MOVE_Y %
000003bd : 00668803;   % 49:             lb a6, 6(a3)	# Loads Player's X offset %
000003be : 00e80833;   % 50:             add a6,a6,a4	# Adds the X Movement to the Player's Offset %
000003bf : 0086c883;   % 52:             lbu a7, 8(a3)	# Loads Player's X on Matrix %
000003c0 : 011684a3;   % 53:             sb a7, 9(a3)	# Stores Player's X on Matrix on the Old X %
000003c1 : 00085663;   % 55:             bge a6,zero,SKIP_LEFT_X %
000003c2 : fff88893;   % 58:             addi a7, a7, -1		  # Player's X on matrix -= 1 (goes to the left) %
000003c3 : 01080813;   % 59:             addi a6,a6,16  # Offset gets corrected (relative to new X on matrix coordinate) %
000003c4 : 01000e13;   % 62:             li t3, 16 %
000003c5 : 01c84663;   % 63:             blt a6,t3, SKIP_RIGHT_X %
000003c6 : 00188893;   % 65:             addi a7,a7, 1	 # Player's X on matrix += 1 (goes to the right) %
000003c7 : 41c80833;   % 66:             sub a6,a6,t3	 # Offset gets corrected (relative to new X on matrix coordinate) %
000003c8 : fe010113;   % 70:             addi sp,sp,-32 %
000003c9 : 01112e23;   % 71:             sw a7,28(sp) %
000003ca : 01012c23;   % 72:             sw a6,24(sp) %
000003cb : 00e12a23;   % 73:             sw a4,20(sp) %
000003cc : 00d12823;   % 74:             sw a3,16(sp) %
000003cd : 00c12623;   % 75:             sw a2,12(sp) %
000003ce : 00b12423;   % 76:             sw a1,8(sp) %
000003cf : 00a12223;   % 77:             sw a0,4(sp) %
000003d0 : 00112023;   % 78:             sw ra,0(sp) %
000003d1 : 00c005b3;   % 80:             mv a1,a2 # Moves current map's address to a1  %
000003d2 : 00d00633;   % 81:             mv a2,a3 # Moves PLYR_POS to a2 %
000003d3 : 00004317;   % 82:             call CHECK_HORIZONTAL_COLLISION # Checking collision %
000003d4 : 918300e7;   % 82:  %
000003d5 : 00a002b3;   % 84:             mv t0,a0     # Moves result of collision check to t0  %
000003d6 : 01c12883;   % 87:             lw a7,28(sp) %
000003d7 : 01812803;   % 88:             lw a6,24(sp) %
000003d8 : 01412703;   % 89:             lw a4,20(sp) %
000003d9 : 01012683;   % 90:             lw a3,16(sp) %
000003da : 00c12603;   % 91:             lw a2,12(sp) %
000003db : 00812583;   % 92:             lw a1,8(sp) %
000003dc : 00412503;   % 93:             lw a0,4(sp) %
000003dd : 00012083;   % 94:             lw ra,0(sp) %
000003de : 02010113;   % 95:             addi sp,sp,32 %
000003df : 00069383;   % 98:             lh t2, 0(a3)          # Loads Player's Current X %
000003e0 : 00029e63;   % 99:             bnez t0, CAN_MOVE_X   # If a0 != 0, player can move (go to CAN_MOVE_X) %
000003e1 : 00700f33;   % 101:                 mv t5,t2              # store player's current X (t2) in t5 %
000003e2 : 0fc0f297;   % 102:                 la t0,PLYR_INPUT      # Loads PLYR_INPUT on t0 %
000003e3 : 1a728293;   % 102:  %
000003e4 : 00200313;   % 103:                 li t1, 2              # Sets t1 to 2 (there's player input, but can't move) %
000003e5 : 00628023;   % 104:                 sb t1, 0(t0)          # and stores it in PLYR_INPUT %
000003e6 : 0300006f;   % 105:                 j Fixed_X_Map %
000003e7 : 0fc0f297;   % 108:         la t0,PLYR_INPUT      # Loads PLYR_INPUT on t0 %
000003e8 : 19328293;   % 108:  %
000003e9 : 00100313;   % 109:         li t1, 1              # Sets t1 to 1 (there's player input, and can move) %
000003ea : 00628023;   % 110:         sb t1, 0(t0)          # and stores it in PLYR_INPUT %
000003eb : 01068323;   % 112:         sb a6, 6(a3)    # Stores new X offset %
000003ec : 01168423;   % 113:         sb a7, 8(a3)    # Stores new X coordinate on matrix %
000003ed : 00770f33;   % 115:         add t5, a4, t2  # t5 = Player's current X + Movement of Player on X axis %
000003ee : 00064283;   % 117:         lbu t0, 0(a2)   # loads first byte to check what type of map it is (0 - Fixed, 1 - Horizontal, 2 - Vertical) %
000003ef : 00100e13;   % 118:         li t3, 1        # Loads 1 and  %
000003f0 : 005e1463;   % 119:         bne t3, t0, Fixed_X_Map # compares with the result %
000003f1 : 0100006f;   % 120:         j Horizontal_Map %
000003f2 : 00769123;   % 124:           sh t2,2(a3) # Stores original X on old X related to screen %
000003f3 : 01e69023;   % 125:           sh t5,0(a3) # Stores new X on current X related to screen %
000003f4 : 0900006f;   % 126:           j CHECK_MOVE_Y %
000003f5 : 0065c283;   % 129:             lbu t0, 6(a1)    # Loads Map's X postition on Matrix %
000003f6 : 0085c303;   % 130:             lbu t1, 8(a1)    # Loads Map's X offset %
000003f7 : 07700e13;   % 132:             li t3, 119      # loads left_border = 120  %
000003f8 : 01ee4863;   % 133:             blt t3, t5, NOT_LEFT_BORDER_PASS  # if new player position on screen doesn't pass the left border, go to NOT_LEFT_BORDER_PASS %
000003f9 : 00628eb3;   % 136:             add t4,t0,t1     # Will be 0 if Map's X offset and X position are 0 %
000003fa : fe0e80e3;   % 137:           	beqz t4, Fixed_X_Map  # If on leftmost part of the map, map won't move %
000003fb : 01c0006f;   % 138:             j MOVE_SCREEN_X     # otherwise, move the map left %
000003fc : 0b800e13;   % 141:             li t3, 184 #loads right_border = 180  %
000003fd : fdee5ae3;   % 142:             bge t3,t5,Fixed_X_Map   # if new player position on screen doesn't pass the right border, go to Fixed_X_Map %
000003fe : 00164303;   % 143:             lbu t1, 1(a2)    # Loads Map matrix width %
000003ff : 01400e13;   % 144:             li t3, 20 # Loads Map screen width related to matrix %
00000400 : 41c30333;   % 145:             sub t1,t1,t3    # t1 = Map Matrix Width - Screen Matrix Width (t1 = Map's X when it's on rightmost part of the map) %
00000401 : fc6282e3;   % 146:             beq t0,t1, Fixed_X_Map  # If on rightmost part of the map, map won't move %
00000402 : 00200e13;   % 150:             li t3, 2       # t3 = 2 (map will be rendered again) %
00000403 : 01c582a3;   % 151:             sb t3, 5(a1)   # Stores t3 on CURRENT_MAP's rendering byte %
00000404 : 00769123;   % 152:             sh t2,2(a3)    # Stores player's original X on old X related to screen %
00000405 : 0065c383;   % 155:             lbu t2, 6(a1)  # Loads Map X postition on Matrix %
00000406 : 0085c803;   % 156:             lbu a6, 8(a1)  # Loads map's X offset %
00000407 : 00e80833;   % 157:             add a6,a6,a4  # Adds the X Movement to the map's Offset %
00000408 : 00000313;   % 158:             li t1,0  # Right now, the map's X won't be updated  %
00000409 : 00085e63;   % 159:             bge a6, zero, NO_X_OFFSET_NEGATIVE_CORRECTION  %
0000040a : 00038863;   % 161:                 beqz t2 LEFTMOST_PART_OF_MAP_RESET %
0000040b : fff00313;   % 163:                     li t1, -1 %
0000040c : 01080813;   % 164:                     addi a6,a6,16 # Corrects negative offset by adding 16 %
0000040d : 01c0006f;   % 165:                     j NO_X_OFFSET_CORRECTION %
0000040e : 00000813;   % 168:                     li a6,0 %
0000040f : 0140006f;   % 169:                     j NO_X_OFFSET_CORRECTION %
00000410 : 01000293;   % 173:                 li t0, 16 %
00000411 : 00584663;   % 174:                 blt a6,t0, NO_X_OFFSET_CORRECTION %
00000412 : 00100313;   % 175:                 li t1,1 %
00000413 : 40580833;   % 176:                 sub a6,a6,t0 # Corrects values that surpass 16 by subtracting 16 from them %
00000414 : 01058423;   % 179:                 sb a6, 8(a1)   # Stores Map new X offset that is equal to player's X offset %
00000415 : 006383b3;   % 180:                 add t2,t2,t1  # adds to the X -1, 0 or 1 (moves map horizontally) %
00000416 : 00758323;   % 181:                 sb t2, 6(a1)   # Stores Map X postition on Matrix %
00000417 : 0040006f;   % 182:                 j CHECK_MOVE_Y %
00000418 : 0fc0f517;   % 186:     la a0, MOVE_Y	       # Loads address of MOVE_Y %
00000419 : 0cd50513;   % 186:  %
0000041a : 00050283;   % 187:     lb t0, 0(a0)	       # Loads information from MOVE_Y %
0000041b : 0fc0f597;   % 188:     la a1, CURRENT_MAP     # Loads CURRENT_MAP's address %
0000041c : 09458593;   % 188:  %
0000041d : 0005a603;   % 189:     lw a2, 0(a1) 	       # a2 has the current map's address  %
0000041e : 0fc0f697;   % 190:     la a3, PLYR_POS        # Loads Player Position address %
0000041f : 0a268693;   % 190:  %
00000420 : 06029a63;   % 192:     bnez t0, MOVE_PLAYER_Y # If there's Y movement, go to MOVE_PLAYER_Y %
00000421 : 0046c303;   % 193:         lbu t1, 4(a3)  # Loads Player's Y related to screen %
00000422 : 006682a3;   % 194:         sb t1, 5(a3)  # Stores Player's Y related to screen on old Y %
00000423 : 00a6c303;   % 195:         lbu t1, 10(a3)  # Loads Player's Y related to screen %
00000424 : 006685a3;   % 196:         sb t1, 11(a3)  # Stores Player's Y related to screen on old Y %
00000425 : fec10113;   % 198:         addi sp,sp,-20 %
00000426 : 00d12823;   % 199:         sw a3,16(sp) %
00000427 : 00c12623;   % 200:         sw a2,12(sp) %
00000428 : 00b12423;   % 201:         sw a1,8(sp) %
00000429 : 00a12223;   % 202:         sw a0,4(sp) %
0000042a : 00112023;   % 203:         sw ra,0(sp) %
0000042b : 00c005b3;   % 205:         mv a1,a2 # Moves current map's address to a1  %
0000042c : 00d00633;   % 206:         mv a2,a3 # Moves PLYR_POS to a2 %
0000042d : 00004317;   % 207:         call CHECK_VERTICAL_COLLISION # Checking collision %
0000042e : 8a4300e7;   % 207:  %
0000042f : 00a002b3;   % 208:         mv t0,a0     # Moves result of collision check to t0  %
00000430 : 01012683;   % 211:         lw a3,16(sp) %
00000431 : 00c12603;   % 212:         lw a2,12(sp) %
00000432 : 00812583;   % 213:         lw a1,8(sp) %
00000433 : 00412503;   % 214:         lw a0,4(sp) %
00000434 : 00012083;   % 215:         lw ra,0(sp) %
00000435 : 01410113;   % 216:         addi sp,sp,20 %
00000436 : 00028c63;   % 218:         beqz t0, HAS_GROUND    # If t0 (holds result of collision check) != 0 go to HAS_GROUND %
00000437 : 0fc0f517;   % 220:         la a0, MOVE_Y	   # Loads address of MOVE_Y %
00000438 : 05150513;   % 220:  %
00000439 : 00100293;   % 221:         li t0, 1           # Gets number correspondent to DOWN (1) %
0000043a : 00550023;   % 222:         sb t0, 0(a0)	   # and stores it %
0000043b : 0080006f;   % 225:         j MOVE_PLAYER_Y %
0000043c : 2d40006f;   % 228:       j END_PHYSICS %
0000043d : 00150383;   % 231:         lb t2, 1(a0)   # Loads JUMP information %
0000043e : 0002c463;   % 232:         blt t0,zero, MOVE_PLAYER_UP %
0000043f : 04c0006f;   % 233:         j ITERATE_JUMP %
00000440 : 02000313;   % 236:             li t1, 32 # minimum height of jump required for the movement  %
00000441 : 0063c863;   % 237:             blt t2, t1, SKIP_INPUT_CHECK %
00000442 : 00254303;   % 238:             lbu t1, 2(a0)   # Loads PLYR_INPUT %
00000443 : 00031463;   % 239:             bnez t1, SKIP_INPUT_CHECK # t1 != 0 ? SKIP_INPUT_CHECK : SWITCH_DOWN %
00000444 : 0140006f;   % 240:             j SWITCH_DOWN %
00000445 : c0097353;   % 243:                 fcvt.w.s t1,fs2  %
00000446 : 00035663;   % 244:                 bge t1,zero, SWITCH_DOWN %
00000447 : 05000313;   % 245:                 li t1, 80 # minimum height of jump required for the movement  %
00000448 : 0263c463;   % 246:                 blt t2, t1, ITERATE_JUMP   #  %
00000449 : 0fc0f297;   % 249:                 la t0,PLYR_INPUT      # Loads PLYR_INPUT on t0 %
0000044a : 00b28293;   % 249:  %
0000044b : 00100313;   % 250:                 li t1, 1              # Sets t1 to 1 (there's player input, and can move) %
0000044c : 00628023;   % 251:                 sb t1, 0(t0)          # and stores it in PLYR_INPUT  %
0000044d : 006500a3;   % 253:                 sb t1, 1(a0)        # reset jump information %
0000044e : 00650023;   % 254:                 sb t1,0(a0)           # Switches MOVE_Y to 1 (Down)     %
0000044f : 00200313;   % 256:                 li t1, 2 %
00000450 : d0037953;   % 257:                 fcvt.s.w fs2,t1     # Sets speed to zero        %
00000451 : 2800006f;   % 258:                 j END_PHYSICS %
00000452 : 00897953;   % 261:             fadd.s fs2,fs2,fs0    # fs2 = Player's current Y speed + gravity factor        %
00000453 : c0097753;   % 262:             fcvt.w.s a4,fs2       # Sets a4 = floor(fs2) %
00000454 : 00800293;   % 264:             li t0,8             # Loads max speed (8, when falling) %
00000455 : 00574463;   % 265:             blt a4,t0, SKIP_MAX_SPEED   # If a4 < 8, skip this part %
00000456 : 00800713;   % 267:                 li a4,8 %
00000457 : 00e002b3;   % 271:                 mv t0,a4                # moves a4 to t0 %
00000458 : 0002d463;   % 272:                 bge t0,zero, SKIP_ABS   # if t0 >= 0, skip this %
00000459 : 405002b3;   % 273:                     sub t0,zero,t0      # otherwise, t0 will be its opposite  %
0000045a : 005383b3;   % 275:                     add t2,t2,t0        # t0 to t2 (JUMP factor) %
0000045b : 007500a3;   % 276:                     sb t2, 1(a0)        # and stores it %
0000045c : 0076c803;   % 278:         lbu a6, 7(a3)	# Loads Player's Y offset %
0000045d : 00e80833;   % 279:         add a6,a6,a4	# Adds the X Movement to the Player's Offset %
0000045e : 00a6c883;   % 281:         lbu a7, 10(a3)	# Loads Player's Y on Matrix %
0000045f : 011685a3;   % 282:         sb a7, 11(a3)	# Stores Plater's Y on Matrix on the Old Y %
00000460 : 00085663;   % 284:         bge a6,zero,SKIP_UP_Y %
00000461 : fff88893;   % 286:         addi a7, a7, -1		  # Player's Y on matrix -= 1 (goes to the left) %
00000462 : 01080813;   % 287:         addi a6,a6,16  # Offset gets corrected (relative to new X on matrix coordinate) %
00000463 : 01000e13;   % 290:             li t3, 16 %
00000464 : 01c84663;   % 291:             blt a6,t3, SKIP_DOWN_Y %
00000465 : 00188893;   % 293:             addi a7,a7, 1	 # Player's Y on matrix += 1 (goes to the right) %
00000466 : 41c80833;   % 294:             sub a6,a6,t3	 # Offset gets corrected (relative to new Y on matrix coordinate) %
00000467 : fe010113;   % 298:             addi sp,sp,-32 %
00000468 : 01112e23;   % 299:             sw a7,28(sp) %
00000469 : 01012c23;   % 300:             sw a6,24(sp) %
0000046a : 00e12a23;   % 301:             sw a4,20(sp) %
0000046b : 00d12823;   % 302:             sw a3,16(sp) %
0000046c : 00c12623;   % 303:             sw a2,12(sp) %
0000046d : 00b12423;   % 304:             sw a1,8(sp) %
0000046e : 00a12223;   % 305:             sw a0,4(sp) %
0000046f : 00112023;   % 306:             sw ra,0(sp) %
00000470 : 00c005b3;   % 308:             mv a1,a2 # Moves current map's address to a1  %
00000471 : 00d00633;   % 309:             mv a2,a3 # Moves PLYR_POS to a2 %
00000472 : 00e006b3;   % 310:             mv a3,a4 # Moves offset modifier to a3 %
00000473 : 00003317;   % 311:             call CHECK_VERTICAL_COLLISION # Checking collision %
00000474 : 78c300e7;   % 311:  %
00000475 : 00a002b3;   % 312:             mv t0,a0     # Moves result of collision check to t0  %
00000476 : 01c12883;   % 315:             lw a7,28(sp) %
00000477 : 01812803;   % 316:             lw a6,24(sp) %
00000478 : 01412703;   % 317:             lw a4,20(sp) %
00000479 : 01012683;   % 318:             lw a3,16(sp) %
0000047a : 00c12603;   % 319:             lw a2,12(sp) %
0000047b : 00812583;   % 320:             lw a1,8(sp) %
0000047c : 00412503;   % 321:             lw a0,4(sp) %
0000047d : 00012083;   % 322:             lw ra,0(sp) %
0000047e : 02010113;   % 323:             addi sp,sp,32 %
0000047f : 0046c383;   % 326:             lbu t2, 4(a3)    # Loads Player's Current Y %
00000480 : 0c029663;   % 327:             bnez t0, CAN_MOVE_Y # t0 != 0 ? CAN_MOVE_Y : Fixed_Y_Map %
00000481 : 00700f33;   % 328:                 mv t5,t2 # storing PLYRS_current Y in t5 %
00000482 : d0007953;   % 329:                 fcvt.s.w fs2,zero # Resets player's jump speed %
00000483 : 00050283;   % 331:                 lb t0, 0(a0) # Gets MOVE_Y info %
00000484 : 0602c263;   % 332:                 blt t0,zero, STOP_JUMP # If t1 <= -1 (aka, player would start jumping), reset %
00000485 : 0076c283;   % 334:                     lbu t0, 7(a3)  # Loads player's Y offset %
00000486 : 04028463;   % 335:                     beqz t0,SKIP_ADJUST_Y_DOWN # If player is on ground and Y offset = 0, don't reajust position %
00000487 : 01168523;   % 337:                         sb a7, 10(a3)   # Stores new Y coordinate on matrix %
00000488 : 00064283;   % 338:                         lbu t0, 0(a2)   # Loads first byte to check what type of map it is (0 - Fixed, 1 - Horizontal, 2 - Vertical) %
00000489 : 00200e13;   % 339:                         li t3, 2        # Loads 2 and  %
0000048a : 025e1c63;   % 340:                         bne t3, t0, SKIP_ADJUST_Y_DOWN # compares with the result %
0000048b : 0095c283;   % 342:                             lbu t0, 9(a1)    # Loads map's Y offset %
0000048c : 000584a3;   % 343:                             sb zero, 9(a1)   # Sets map's Y offset to 0 %
0000048d : 00264e83;   % 344:                             lbu t4, 2(a2)    # Loads Map matrix height %
0000048e : 00f00e13;   % 345:                             li t3, 15 # Loads Map screen height related to matrix %
0000048f : 41ce8e33;   % 346:                             sub t3,t4,t3     # t4 = Map Matrix Height - Screen Matrix Height (t4 = Map's Y when it's on lowermost part of the map) %
00000490 : 0075ce83;   % 347:                             lbu t4, 7(a1)    # Loads Map Y postition on Matrix %
00000491 : 01cede63;   % 348:                             bge t4,t3,SKIP_ADJUST_Y_DOWN  # If on lowermost Y, don't update map's Y it %
00000492 : 005e82b3;   % 349:                             add t0,t4,t0   # t4 will only be 4 if offset was 0 and Y is zero %
00000493 : 00028a63;   % 350:                             beqz t0,SKIP_ADJUST_Y_DOWN    # If on topmost Y, don't update map's Y it %
00000494 : 001e8e93;   % 351:                             addi t4,t4,1     # adds 1 to it %
00000495 : 01d583a3;   % 352:                             sb t4, 7(a1)     # and stores it %
00000496 : 00200e13;   % 353:                             li t3, 2         # t3 = 2 (map will be rendered again) %
00000497 : 01c582a3;   % 354:                             sb t3, 5(a1)     # Stores t3 on CURRENT_MAP's rendering byte %
00000498 : 000683a3;   % 356:                     sb zero, 7(a3) # Sets player's Y offset to 0 %
00000499 : 00050023;   % 357:                     sb zero, 0(a0) # MOVE_Y = 0 %
0000049a : fff00313;   % 358:                     li t1,-1 %
0000049b : 006500a3;   % 359:                     sb t1, 1(a0) # JUMP = 0 %
0000049c : 0880006f;   % 360:                     j Fixed_Y_Map %
0000049d : 00800293;   % 364:                     li t0,8 %
0000049e : 00154303;   % 365:                     lbu t1,1(a0) # Gets JUMP info %
0000049f : 0062a2b3;   % 366:                     slt t0,t0,t1 # t1 > 8 ? t0 = 1 : t0 = 0 %
000004a0 : 00550023;   % 367:                     sb t0, 0(a0) # MOVE_Y = t0  %
000004a1 : 000500a3;   % 368:                     sb zero,1(a0) # reseting jump byte %
000004a2 : 0076c283;   % 370:                     lbu t0, 7(a3)  # Loads player's Y offset %
000004a3 : 02028e63;   % 371:                     beqz t0,SKIP_ADJUST_Y_UP # If player has Y offset = 0, don't reajust position %
000004a4 : 000683a3;   % 373:                         sb zero, 7(a3) # Sets player's Y offset to 0 %
000004a5 : 00064283;   % 374:                         lbu t0, 0(a2)   # Loads first byte to check what type of map it is (0 - Fixed, 1 - Horizontal, 2 - Vertical) %
000004a6 : 00200e13;   % 375:                         li t3, 2        # Loads 2 and  %
000004a7 : 025e1663;   % 376:                         bne t3, t0, SKIP_ADJUST_Y_UP # compares with the result %
000004a8 : 000584a3;   % 378:                             sb zero, 9(a1)   # Sets map's Y offset to 0 %
000004a9 : 00264e83;   % 379:                             lbu t4, 2(a2)    # Loads Map matrix height %
000004aa : 00f00e13;   % 380:                             li t3, 15 # Loads Map screen height related to matrix %
000004ab : 41ce8e33;   % 381:                             sub t3,t4,t3     # t4 = Map Matrix Height - Screen Matrix Height (t4 = Map's Y when it's on lowermost part of the map) %
000004ac : 0075ce83;   % 382:                             lbu t4, 7(a1)    # Loads Map Y postition on Matrix %
000004ad : 01ceda63;   % 383:                             bge t4,t3,SKIP_ADJUST_Y_UP  # If on lowermost Y, don't update map's Y it %
000004ae : 000e8863;   % 384:                             beqz t4,SKIP_ADJUST_Y_UP    # If on topmost Y, don't update map's Y it %
000004af : 01d583a3;   % 385:                             sb t4, 7(a1)     # and stores it %
000004b0 : 00200e13;   % 386:                             li t3, 2         # t3 = 2 (map will be rendered again) %
000004b1 : 01c582a3;   % 387:                             sb t3, 5(a1)     # Stores t3 on CURRENT_MAP's rendering byte %
000004b2 : 0300006f;   % 389:                         j Fixed_Y_Map %
000004b3 : 0fc0f297;   % 392:             la t0,PLYR_INPUT      # Loads PLYR_INPUT on t0 %
000004b4 : e6328293;   % 392:  %
000004b5 : 00100313;   % 393:             li t1, 1              # Sets t1 to 1 (there's player input, and can move) %
000004b6 : 00628023;   % 394:             sb t1, 0(t0)          # and stores it in PLYR_INPUT  %
000004b7 : 010683a3;   % 396:             sb a6, 7(a3)    # Stores new Y offset %
000004b8 : 01168523;   % 397:             sb a7, 10(a3)   # Stores new Y coordinate on matrix %
000004b9 : 00770f33;   % 399:             add t5, a4, t2  # t5 = Player's current X + Movement of Player on X axis %
000004ba : 00064283;   % 401:             lbu t0, 0(a2)   # loads first byte to check what type of map it is (0 - Fixed, 1 - Horizontal, 2 - Vertical) %
000004bb : 00200e13;   % 402:             li t3, 2        # Loads 2 and  %
000004bc : 005e1463;   % 403:             bne t3, t0, Fixed_Y_Map # compares with the result %
000004bd : 0300006f;   % 404:             j Vertical_Map %
000004be : 0075c383;   % 408:             lbu t2 7(a1)    # Gets map's Y related to matrix %
000004bf : 00a6cf03;   % 409:             lbu t5, 10(a3)	# Loads Player's Y related to matrix %
000004c0 : 407f0f33;   % 410:             sub t5,t5,t2    # Gets the Y matrix related to the map's Y %
000004c1 : 004f1f13;   % 411:             slli t5,t5,4 # Multiplies t5 by 16 in order to get Y related to screen %
000004c2 : 0076c383;   % 412:             lbu t2, 7(a3)	# Loads Player's Y offset %
000004c3 : 007f0f33;   % 413:             add t5,t5,t2    # Adds offset to position %
000004c4 : 0095c383;   % 414:             lbu t2 9(a1)    # Gets map's offset %
000004c5 : 407f0f33;   % 415:             sub t5,t5,t2    # and takes it from player's position %
000004c6 : 01e682a3;   % 417:             sb t5,5(a3) # Stores original Y on old Y  related to screen %
000004c7 : 01e68223;   % 418:             sb t5,4(a3) # Stores new Y on current Y related to screen %
000004c8 : 0a40006f;   % 419:             j END_PHYSICS %
000004c9 : 0075c283;   % 422:             lbu t0, 7(a1)    # Loads Map's Y postition on Matrix %
000004ca : 0095c303;   % 423:             lbu t1, 9(a1)    # Loads Map's Y offset %
000004cb : 05e00e13;   % 425:             li t3, 94      # loads top vertical border = 94  %
000004cc : 01ee4863;   % 426:             blt t3, t5, NOT_TOP_BORDER_PASS  # if new player position on screen doesn't pass the upper border, go to NOT_LEFT_BORDER_PASS %
000004cd : 00628eb3;   % 428:             add t4,t0,t1     # Will be 0 if Map's X offset and X position are 0 %
000004ce : fc0e80e3;   % 429:             beqz t4, Fixed_Y_Map  # If on uppermost part of the map, map won't move %
000004cf : 01c0006f;   % 430:             j MOVE_SCREEN_Y     # otherwise, move the map left %
000004d0 : 06000e13;   % 433:             li t3, 96 #loads bottom vertical border = 96  %
000004d1 : fbee5ae3;   % 434:             bge t3,t5,Fixed_Y_Map   # if new player position on screen doesn't pass the lower border, go to Fixed_X_Map %
000004d2 : 00264303;   % 435:             lbu t1, 2(a2)    # Loads Map matrix height %
000004d3 : 00f00e13;   % 436:             li t3, 15 # Loads Map screen height related to matrix %
000004d4 : 41c30333;   % 437:             sub t1,t1,t3    # t1 = Map Matrix Height - Screen Matrix Height (t1 = Map's Y when it's on lowermost part of the map) %
000004d5 : fa6282e3;   % 438:             beq t0,t1, Fixed_Y_Map  # If on lowermost part of the map, map won't move %
000004d6 : 00200e13;   % 441:             li t3, 2       # t3 = 2 (map will be rendered again) %
000004d7 : 01c582a3;   % 442:             sb t3, 5(a1)   # Stores t3 on CURRENT_MAP's rendering byte %
000004d8 : 007682a3;   % 444:             sb t2,5(a3)    # Stores player's original Y on old Y related to screen %
000004d9 : 0075c383;   % 447:             lbu t2, 7(a1)  # Loads Map Y postition on Matrix %
000004da : 0095c803;   % 448:             lbu a6, 9(a1)  # Loads map's Y offset %
000004db : 00e80833;   % 449:             add a6,a6,a4  # Adds the Y Movement to the map's Offset %
000004dc : 00000313;   % 450:             li t1,0  # Right now, the map's Y won't be updated  %
000004dd : 00085e63;   % 451:             bge a6, zero, NO_Y_OFFSET_NEGATIVE_CORRECTION  %
000004de : 00038863;   % 453:                 beqz t2 TOP_OF_MAP_RESET %
000004df : fff00313;   % 455:                     li t1, -1 %
000004e0 : 01080813;   % 456:                     addi a6,a6,16 # Corrects negative offset by adding 16 %
000004e1 : 0340006f;   % 457:                     j NO_Y_OFFSET_CORRECTION %
000004e2 : 00000813;   % 460:                     li a6,0 %
000004e3 : 02c0006f;   % 461:                     j NO_Y_OFFSET_CORRECTION %
000004e4 : 01000293;   % 465:                 li t0, 16 %
000004e5 : 02584263;   % 466:                 blt a6,t0, NO_Y_OFFSET_CORRECTION %
000004e6 : 00100313;   % 467:                 li t1,1 %
000004e7 : 40580833;   % 468:                 sub a6,a6,t0 # Corrects values that surpass 16 by subtracting 16 from them %
000004e8 : 00264e83;   % 470:                 lbu t4, 2(a2)    # Loads Map matrix height %
000004e9 : 00f00e13;   % 471:                 li t3, 15 # Loads Map screen height related to matrix %
000004ea : 41ce8eb3;   % 472:                 sub t4,t4,t3     # t4 = Map Matrix Height - Screen Matrix Height (t1 = Map's Y when it's on lowermost part of the map) %
000004eb : 00138f13;   % 473:                 addi t5,t2,1     # Maximum Y on map %
000004ec : 01df1463;   % 475:                 bne t5,t4,NO_Y_OFFSET_CORRECTION    # If t5 != maximum Y on map, skip this next correction %
000004ed : 00000813;   % 477:                 li a6,0    # set offset to 0                %
000004ee : 010584a3;   % 480:                 sb a6, 9(a1)   # Stores Map new Y offset that is equal to player's Y offset %
000004ef : 006383b3;   % 481:                 add t2,t2,t1  # adds to the Y -1, 0 or 1 (moves map horizontally) %
000004f0 : 007583a3;   % 482:                 sb t2, 7(a1)   # Stores Map Y postition on Matrix %
000004f1 : 00008067;   % 485:       ret %
000004f2 : 00088e63;   % 38: beqz a7,NORMAL %
000004f3 : 00950533;   % 40: 		add a0,a0,s1	# Image address + X on sprite  %
000004f4 : 03298e33;   % 41: 		mul t3,s3,s2	# t3 = sprite width * Y on sprite %
000004f5 : 01c50533;   % 42: 		add a0,a0,t3	# a0 = Image address + X on sprite + sprite widht * Y on sprite %
000004f6 : 03480eb3;   % 43: 		mul t4,a6,s4	# t4 = sprite status x height of rendering area (for files that have more than one sprite) %
000004f7 : 033e8eb3;   % 44: 		mul t4,t4,s3	# t4 = sprite status x height of rendering area x sprite's width %
000004f8 : 00c0006f;   % 45: 		j START_RENDER %
000004f9 : 02e80eb3;   % 47: 		mul t4,a6,a4	# t4 = sprite status x height of rendering area (for files that have more than one sprite) %
000004fa : 02de8eb3;   % 48: 		mul t4,t4,a3	# t4 = sprite status x height of rendering area x width of rendering area (on NORMAL_RENDER: a3 = sprite's width) %
000004fb : 01d50533;   % 51: 		add a0,a0,t4	# Adds the dislocation calculated on t4 to the sprite's address %
000004fc : 000012b7;   % 53: 	li t0,0x0FF0	#t0 = 0x0FF0 %
000004fd : ff028293;   % 53:  %
000004fe : 00f282b3;   % 54: 	add t0,t0,a5	# Rendering Address corresponds to 0x0FF0 + frame %
000004ff : 01429293;   % 55: 	slli t0,t0,20	# Shifts 20 bits, making printing adress correct (0xFF00 0000 or 0xFF10 0000) %
00000500 : 00b282b3;   % 56: 	add t0,t0,a1	# t0 = 0xFF00 0000 + X or 0xFF10 0000 + X %
00000501 : 14000313;   % 57: 	li t1,320	# t1 = 320 %
00000502 : 02c30333;   % 58: 	mul t1,t1,a2	# t1 = 320 * Y  %
00000503 : 006282b3;   % 59: 	add t0,t0,t1	# t0 = 0xFF00 0000 + X + (Y * 320) or 0xFF10 0000 + X + (Y * 320) %
00000504 : 000003b3;   % 61: 	mv t2,zero	# t2 = 0 (Resets line counter) %
00000505 : 00000e33;   % 62: 	mv t3,zero	# t3 = 0 (Resets column counter) %
00000506 : 00050e83;   % 65: 		lb t4,0(a0)	# loads byte(1 pixel) on t4 %
00000507 : 02000f13;   % 68: 		li t5,32 # Loads 32 (value of green pixel in samus) %
00000508 : 01df1c63;   % 69: 		bne t5,t4,SKIP_SWITCH %
00000509 : 0fc0ff17;   % 70: 			la t5, PLYR_INFO_2    # Loads address to PLYR_INFO_2 %
0000050a : d14f0f13;   % 70:  %
0000050b : 000f4f03;   % 71: 			lbu t5,0(t5)          # Loads missile enable byte %
0000050c : 000f0463;   % 72: 			beqz t5,SKIP_SWITCH   # If player isn't in missile mode %
0000050d : 0f000e93;   % 73: 				li t4 240        # Otherwise render cyan instead of green %
0000050e : 01d28023;   % 76: 		sb t4,0(t0)	# prints 1 pixel from t4 %
0000050f : 00128293;   % 78: 		addi t0,t0,1	# increments bitmap address %
00000510 : 00150513;   % 79: 		addi a0,a0,1	# increments image address %
00000511 : 001e0e13;   % 81: 		addi t3,t3,1		# increments column counter %
00000512 : fcde48e3;   % 82: 		blt t3,a3,PRINT_LINE	# if column counter < width, repeat %
00000513 : 14028293;   % 84: 		addi t0,t0,320	# goes to next line on bitmap display %
00000514 : 40d282b3;   % 85: 		sub t0,t0,a3	# goes to right X on bitmap display (current address - width) %
00000515 : 00088663;   % 87: 		beqz a7, NORMAL_RENDER	# If not on crop mode %
00000516 : 01350533;   % 89: 			add a0,a0,s3	# a0 += sprite width	 %
00000517 : 40d50533;   % 90: 			sub a0,a0,a3	# a0 -= rendering width %
00000518 : 00000e33;   % 93: 			mv t3,zero		# t3 = 0 (Resets column counter) %
00000519 : 00138393;   % 94: 			addi t2,t2,1		# increments line counter %
0000051a : fae3c8e3;   % 95: 			bgt a4,t2,PRINT_LINE	# if height > line counter, repeat %
0000051b : 00008067;   % 96: 			ret %
0000051c : 00088e63;   % 122: beqz a7,NORMAL_WORD %
0000051d : 00950533;   % 124: 		add a0,a0,s1	# Image address + X on sprite  %
0000051e : 03298e33;   % 125: 		mul t3,s3,s2	# t3 = sprite width * Y on sprite %
0000051f : 01c50533;   % 126: 		add a0,a0,t3	# a0 = Image address + X on sprite + sprite widht * Y on sprite %
00000520 : 03480eb3;   % 127: 		mul t4,a6,s4	# t4 = sprite status x height of rendering area (for files that have more than one sprite) %
00000521 : 033e8eb3;   % 128: 		mul t4,t4,s3	# t4 = sprite status x height of rendering area x sprite's width %
00000522 : 00c0006f;   % 129: 		j START_RENDER_WORD %
00000523 : 02e80eb3;   % 131: 		mul t4,a6,a4	# t4 = sprite status x height of rendering area (for files that have more than one sprite) %
00000524 : 02de8eb3;   % 132: 		mul t4,t4,a3	# t4 = sprite status x height of rendering area x width of rendering area (on NORMAL_RENDER: a3 = sprite's width) %
00000525 : 01d50533;   % 135: 		add a0,a0,t4	# Adds the dislocation calculated on t4 to the sprite's address %
00000526 : 000012b7;   % 137: 	li t0,0x0FF0	#t0 = 0x0FF0 %
00000527 : ff028293;   % 137:  %
00000528 : 00f282b3;   % 138: 	add t0,t0,a5	# Rendering Address corresponds to 0x0FF0 + frame %
00000529 : 01429293;   % 139: 	slli t0,t0,20	# Shifts 20 bits, making printing adress correct (0xFF00 0000 or 0xFF10 0000) %
0000052a : 00b282b3;   % 140: 	add t0,t0,a1	# t0 = 0xFF00 0000 + X or 0xFF10 0000 + X %
0000052b : 14000313;   % 141: 	li t1,320	# t1 = 320 %
0000052c : 02c30333;   % 142: 	mul t1,t1,a2	# t1 = 320 * Y  %
0000052d : 006282b3;   % 143: 	add t0,t0,t1	# t0 = 0xFF00 0000 + X + (Y * 320) or 0xFF10 0000 + X + (Y * 320) %
0000052e : 000003b3;   % 145: 	mv t2,zero	# t2 = 0 (Resets line counter) %
0000052f : 00000e33;   % 146: 	mv t3,zero	# t3 = 0 (Resets column counter) %
00000530 : 00050e83;   % 150: 		lb t4,0(a0)	# loads word(4 pixels) on t4 %
00000531 : 01d28023;   % 151: 		sb t4,0(t0)	# prints 4 pixels from t4 %
00000532 : 00128293;   % 153: 		addi t0,t0,1	# increments bitmap address %
00000533 : 00150513;   % 154: 		addi a0,a0,1	# increments image address %
00000534 : 001e0e13;   % 156: 		addi t3,t3,1		# increments column counter %
00000535 : fede46e3;   % 157: 		blt t3,a3,PRINT_LINE_WORD	# if column counter < width, repeat %
00000536 : 14028293;   % 159: 		addi t0,t0,320	# goes to next line on bitmap display %
00000537 : 40d282b3;   % 160: 		sub t0,t0,a3	# goes to right X on bitmap display (current address - width) %
00000538 : 00088663;   % 162: 		beqz a7, NORMAL_RENDER_WORD	# If not on crop mode %
00000539 : 01350533;   % 164: 			add a0,a0,s3	# a0 += sprite width	 %
0000053a : 40d50533;   % 165: 			sub a0,a0,a3	# a0 -= rendering width %
0000053b : 00000e33;   % 168: 			mv t3,zero		# t3 = 0 (Resets column counter) %
0000053c : 00138393;   % 169: 			addi t2,t2,1		# increments line counter %
0000053d : fce3c6e3;   % 170: 			bgt a4,t2,PRINT_LINE_WORD	# if height > line counter, repeat %
0000053e : 00008067;   % 171: 			ret %
0000053f : 000012b7;   % 194: 	li t0,0xFF0	# t0 = 0xFF0 %
00000540 : ff028293;   % 194:  %
00000541 : 00f282b3;   % 195: 	add t0,t0,a5	# Rendering Address corresponds to 0x0FF0 + frame %
00000542 : 01429293;   % 196: 	slli t0,t0,20	# Shifts 20 bits, making printing adress correct (0xFF00 0000 or 0xFF10 0000) %
00000543 : 00b282b3;   % 198: 	add t0,t0,a1	# t0 = 0xFF00 0000 + X or 0xFF10 0000 + X %
00000544 : 14000313;   % 200: 	li t1,320	# t1 = 320 %
00000545 : 02c30333;   % 201: 	mul t1,t1,a2	# t1 = 320 * Y  %
00000546 : 006282b3;   % 202: 	add t0,t0,t1	# t0 = 0xFF00 0000 + X + (Y * 320) or 0xFF10 0000 + X + (Y * 320) %
00000547 : 000003b3;   % 204: 	mv t2,zero	# t2 = 0 (Resets line counter) %
00000548 : 00000e33;   % 205: 	mv t3,zero	# t3 = 0 (Resets column counter) %
00000549 : 00851313;   % 207: 	slli t1,a0,8	# Shifts 8 bits on a0 %
0000054a : 00650533;   % 208: 	add a0,a0,t1	# a0 now stores two bytes of the same color (e.g.: 0x000000FF -> 0x0000FFFF) %
0000054b : 00081863;   % 210: 	bnez a6, PRINT_LINE_COLOR_HALF # If not printing 4 pixels at once %
0000054c : 01051313;   % 211: 		slli t1,a0,16	       # Shifts 16 bits on a0 %
0000054d : 00650533;   % 212: 		add a0,a0,t1	       # a0 now stores four bytes of the same color (e.g.: 0x0000FFFF -> 0xFFFFFFFF) %
0000054e : 02c0006f;   % 213: 		j PRINT_LINE_COLOR_WORD %
0000054f : 00a29023;   % 216: 		sh a0,0(t0)	# Renders two color pixels at once %
00000550 : 00228293;   % 217: 		addi t0,t0,2	# increments bitmap address by 2 bytes %
00000551 : 002e0e13;   % 219: 		addi t3,t3,2			# increments column counter %
00000552 : fede4ae3;   % 220: 		blt t3,a3,PRINT_LINE_COLOR_HALF	# if column counter < width, repeat %
00000553 : 14028293;   % 222: 		addi t0,t0,320	# goes to next line on bitmap display %
00000554 : 40d282b3;   % 223: 		sub t0,t0,a3	# goes to right X on bitmap display (current address - width) %
00000555 : 00000e33;   % 225: 		mv t3,zero			# t3 = 0 (resets column counter) %
00000556 : 00138393;   % 226: 		addi t2,t2,1			# increments line counter %
00000557 : fee3c0e3;   % 227: 		bgt a4,t2,PRINT_LINE_COLOR_HALF	# if height > line counter, repeat %
00000558 : 00008067;   % 228: 		ret			 %
00000559 : 00a2a023;   % 231: 		sw a0,0(t0)	# Renders four color pixels at once %
0000055a : 00428293;   % 232: 		addi t0,t0,4	# increments bitmap address by 4 bytes %
0000055b : 004e0e13;   % 234: 		addi t3,t3,4			# increments column counter %
0000055c : fede4ae3;   % 235: 		blt t3,a3,PRINT_LINE_COLOR_WORD	# if column counter < width, repeat %
0000055d : 14028293;   % 236: 		addi t0,t0,320	# goes to next line on bitmap display %
0000055e : 40d282b3;   % 237: 		sub t0,t0,a3	# goes to right X on bitmap display (current address - width) %
0000055f : 00000e33;   % 239: 		mv t3,zero			# t3 = 0 (resets column counter) %
00000560 : 00138393;   % 240: 		addi t2,t2,1			# increments line counter %
00000561 : fee3c0e3;   % 241: 		bgt a4,t2,PRINT_LINE_COLOR_WORD	# if height > line counter, repeat %
00000562 : 00008067;   % 242: 		ret %
00000563 : 00b00233;   % 263: 	mv tp,a1  # tp gets value from a1 %
00000564 : 0fc0f297;   % 264: 	la t0, PLYR_STATUS # Loads PLAYER_STATUS address %
00000565 : b9628293;   % 264:  %
00000566 : 0fc0f397;   % 265: 	la t2,PLYR_POS	# Loads PLYR_POS address %
00000567 : b8238393;   % 265:  %
00000568 : 00039583;   % 267: 	lh a1, 0(t2)	# Loads top left X coordinate related to sprite %
00000569 : 0043c603;   % 268: 	lbu a2, 4(t2)	# Loads top left Y coordinate related to sprite	 %
0000056a : 008007b3;   % 270: 	mv a5, s0		# Gets frame  %
0000056b : 0002c803;   % 271: 	lbu a6, 0(t0)   # Loads Player's sprite status %
0000056c : 000008b3;   % 272: 	mv a7,zero 		# Operation (0 - normal operation) %
0000056d : 00050463;   % 274: 	beqz a0, RENDER_PLAYER_NORMAL # If a0 = 0,  then player will be rendered normally %
0000056e : 2b80006f;   % 275: 	j RENDER_PLAYER_TRAIL         # Otherwise (a0 = 1) render player's trail %
0000056f : fec10113;   % 278: 		addi sp,sp,-20 %
00000570 : 00912023;   % 279: 		sw s1,0(sp) %
00000571 : 01212223;   % 280: 		sw s2,4(sp) %
00000572 : 01312423;   % 281: 		sw s3,8(sp) %
00000573 : 01412623;   % 282: 		sw s4,12(sp) %
00000574 : 00112823;   % 283: 		sw ra,16(sp) %
00000575 : 0012c303;   % 287: 		lbu t1, 1(t0)	# Loads Player's horizontal direction (0 = Right, 1 = Left) %
00000576 : 0042c383;   % 288: 		lbu t2, 4(t0)   # Loads Player's morph ball status %
00000577 : 00038463;   % 290: 		beqz t2, RENDER_PLAYER_STAND # If player isn't on morph ball, go to RENDER_PLAYER_STAND %
00000578 : 1f80006f;   % 291: 		j RENDER_PLAYER_BALL         # Otherwise, go to RENDER_PLAYER_BALL %
00000579 : 0062c383;   % 294: 		lbu t2, 6(t0)   # Loads Player's MOVE_X value (-1 left, 1 right, 0 not moving on X axis) %
0000057a : 0072ce03;   % 295: 		lbu t3, 7(t0)   # Loads Player's MOVE_Y value (-1 up, 1 right, 0 not moving on Y axis) %
0000057b : 0022ce83;   % 296: 		lbu t4, 2(t0)	# Loads Player's vertical direction (0 = Normal, 1 = Up) %
0000057c : 0052cf03;   % 297: 		lbu t5, 5(t0)	# Loads Player's attacking status (0 - no, 1 - yes) %
0000057d : 00030463;   % 299: 		beqz t1, RENDER_PLYR_RIGHT # Checks if player is looking right %
0000057e : 0f00006f;   % 300: 		j RENDER_PLYR_LEFT	   # If player is looking left %
0000057f : 01c38333;   % 303: 			add t1, t2, t3  # t1 will be 0 if t2 (MOVE_X) = 0 and t3 (MOVE_Y) = 0 %
00000580 : 00030e63;   % 304: 			beqz t1,RENDER_IDLE_RIGHT # If t1 = 0, player isn't moving (go to RENDER_IDLE_RIGHT) %
00000581 : 0fc0f317;   % 305: 				la t1,PLYR_INPUT # Otherwise, load PLYR_INPUT address %
00000582 : b2b30313;   % 305:  %
00000583 : 00034303;   % 306: 				lbu t1,0(t1)     # and get its value %
00000584 : ffe30313;   % 307: 				addi t1,t1,-2    # subtracts 2 from it %
00000585 : 00030463;   % 308: 				beqz t1, RENDER_IDLE_RIGHT # if the result is 0 (t1 would've been 2, so player couldn't move) go to idle %
00000586 : 0340006f;   % 309: 					j NOT_IDLE_RIGHT	   # Otherwise, go to NOT_IDLE_RIGHT %
00000587 : 01400693;   % 312: 				li a3, 20   # Sprite's Widht %
00000588 : 01e00833;   % 313: 				mv a6, t5	# Idle sprites have their status set to 1 if player is attacking %
00000589 : 000e9a63;   % 314: 				bnez t4, RENDER_IDLE_RIGHT_UP # If player is looking up %
0000058a : 0fc13517;   % 317: 				la a0, Samus_Right_Idle # Loads Player's Image Address  %
0000058b : 3bc50513;   % 317:  %
0000058c : 02000713;   % 318: 				li a4, 32  # Sprite's Height %
0000058d : 1b80006f;   % 319: 				j START_RENDER_PLAYER # Start rendering player %
0000058e : ffa60613;   % 322: 				addi a2,a2, -6 # Offseting sprite's Y so that it renders in propper place %
0000058f : 0fc14517;   % 323: 				la a0, Samus_Right_Idle_Up # Loads Player's Image Address  %
00000590 : 8a850513;   % 323:  %
00000591 : 02600713;   % 324: 				li a4, 38  # Sprite's Height %
00000592 : 1a40006f;   % 325: 				j START_RENDER_PLAYER # Start rendering player %
00000593 : 000e1463;   % 328: 				bnez t3, RENDER_JUMP_RIGHT %
00000594 : 0380006f;   % 329: 				j NOT_JUMP_RIGHT %
00000595 : ffc58593;   % 338: 					addi a1,a1, -4 # Offseting sprite's X so that it renders in propper place %
00000596 : ffa60613;   % 339: 					addi a2,a2, -6 # Offseting sprite's Y so that it renders in propper place %
00000597 : 02000713;   % 340: 					li a4, 32  # Sprite's Height %
00000598 : 01e00833;   % 341: 					mv a6, t5	# Jump sprites have their status set to 1 if player is attacking %
00000599 : 000e9a63;   % 342: 					bnez t4, RENDER_JUMP_RIGHT_UP	# If player is looking up %
0000059a : 01800693;   % 344: 						li a3, 24  # Sprite's Widht %
0000059b : 0fc16517;   % 345: 						la a0, Samus_Right_Jump # Loads Player's Image Address  %
0000059c : 23850513;   % 345:  %
0000059d : 1780006f;   % 346: 						j START_RENDER_PLAYER   # Start rendering player %
0000059e : 01400693;   % 349: 						li a3, 20  # Sprite's Widht %
0000059f : 0fc17517;   % 350: 						la a0, Samus_Right_Jump_Up # Loads Player's Image Address  %
000005a0 : 82850513;   % 350:  %
000005a1 : 1680006f;   % 351: 						j START_RENDER_PLAYER      # Start rendering player %
000005a2 : 000e8463;   % 354: 					beqz t4, RENDER_MOVEMENT_RIGHT %
000005a3 : 0300006f;   % 355: 					j RENDER_MOVEMENT_RIGHT_UP %
000005a4 : 02000713;   % 358: 						li a4, 32  # Sprite's Height %
000005a5 : 000f0463;   % 359: 						beqz t5, RENDER_MOVEMENT_RIGHT_NORMAL %
000005a6 : 0140006f;   % 360: 						j RENDER_MOVEMENT_RIGHT_ATTACK %
000005a7 : 0fc14517;   % 363: 							la a0, Samus_Right	   # Loads Player's Image Address  %
000005a8 : e3850513;   % 363:  %
000005a9 : 01400693;   % 364: 							li a3, 20              # Sprite's Widht %
000005aa : 1440006f;   % 365: 							j START_RENDER_PLAYER  # Start rendering player %
000005ab : 0fc14517;   % 368: 							la a0, Samus_Right_Attack  # Loads Player's Image Address  %
000005ac : 5a850513;   % 368:  %
000005ad : 01c00693;   % 369: 							li a3, 28                  # Sprite's Widht %
000005ae : 1340006f;   % 370: 							j START_RENDER_PLAYER      # Start rendering player %
000005af : ffa60613;   % 373: 						addi a2,a2, -6 # Offseting sprite's X so that it renders in propper place %
000005b0 : 01400693;   % 374: 						li a3, 20      # Sprite's Widht %
000005b1 : 02600713;   % 375: 						li a4, 38      # Sprite's Height %
000005b2 : 000f0463;   % 376: 						beqz t5, RENDER_MOVEMENT_RIGHT_UP_NORMAL %
000005b3 : 0100006f;   % 377: 						j RENDER_MOVEMENT_RIGHT_UP_ATTACK %
000005b4 : 0fc15517;   % 380: 							la a0, Samus_Right_Up  # Loads Player's Image Address %
000005b5 : 00450513;   % 380:  %
000005b6 : 1140006f;   % 381: 							j START_RENDER_PLAYER  # Start rendering player %
000005b7 : 0fc16517;   % 384: 							la a0, Samus_Right_Up_Attack  # Loads Player's Image Address %
000005b8 : 8e050513;   % 384:  %
000005b9 : 1080006f;   % 385: 							j START_RENDER_PLAYER         # Start rendering player %
000005ba : ffc58593;   % 388: 			addi a1,a1, -4 # Offseting sprite's X so that it renders in propper place %
000005bb : 01c38333;   % 389: 			add t1, t2, t3  # t1 will only be 0 if player isn't moving  %
000005bc : 00030e63;   % 390: 			beqz t1,RENDER_IDLE_LEFT # Checks if player is mooving or not %
000005bd : 0fc0f317;   % 391: 				la t1,PLYR_INPUT # Otherwise, load PLYR_INPUT address %
000005be : a3b30313;   % 391:  %
000005bf : 00034303;   % 392: 				lbu t1,0(t1)     # and get its value %
000005c0 : ffe30313;   % 393: 				addi t1,t1,-2    # subtracts 2 from it %
000005c1 : 00030463;   % 394: 				beqz t1, RENDER_IDLE_LEFT # if the result is 0 (t1 would've been 2, so player couldn't move) go to idle %
000005c2 : 0340006f;   % 395: 			j NOT_IDLE_LEFT	  # If player is moving or not %
000005c3 : 01400693;   % 398: 				li a3, 20  # Sprite's Widht %
000005c4 : 01e00833;   % 399: 				mv a6, t5	# Idle sprites have their status set to 1 if player is attacking %
000005c5 : 000e9a63;   % 400: 				bnez t4, RENDER_IDLE_LEFT_UP	# If player is looking up %
000005c6 : 0fc17517;   % 403: 					la a0, Samus_Left_Idle # Loads Player's Image Address  %
000005c7 : 58c50513;   % 403:  %
000005c8 : 02000713;   % 404: 					li a4, 32  # Sprite's Height %
000005c9 : 0c80006f;   % 405: 					j START_RENDER_PLAYER # Start rendering player %
000005ca : ffa60613;   % 408: 					addi a2,a2, -6 # Offseting sprite's Y so that it renders in propper place %
000005cb : 0fc18517;   % 409: 					la a0, Samus_Left_Idle_Up # Loads Player's Image Address  %
000005cc : a7850513;   % 409:  %
000005cd : 02600713;   % 410: 					li a4, 38  # Sprite's Height %
000005ce : 0b40006f;   % 411: 					j START_RENDER_PLAYER # Start rendering player %
000005cf : 000e1463;   % 414: 				bnez t3, RENDER_JUMP_LEFT %
000005d0 : 0340006f;   % 415: 				j NOT_JUMP_LEFT %
000005d1 : ffc58593;   % 424: 					addi a1,a1, -4 # Offseting sprite's X so that it renders in propper place %
000005d2 : ffa60613;   % 425: 					addi a2,a2, -6 # Offseting sprite's Y so that it renders in propper place %
000005d3 : 01800693;   % 426: 					li a3, 24  # Sprite's Widht %
000005d4 : 02000713;   % 427: 					li a4, 32  # Sprite's Height %
000005d5 : 01e00833;   % 428: 					mv a6, t5	# Jump sprites have their status set to 1 if player is attacking %
000005d6 : 000e9863;   % 429: 					bnez t4, RENDER_JUMP_LEFT_UP	# If player is looking up %
000005d7 : 0fc1a517;   % 434: 					la a0, Samus_Left_Jump # Loads Player's Image Address  %
000005d8 : 70850513;   % 434:  %
000005d9 : 0880006f;   % 435: 					j START_RENDER_PLAYER   # Start rendering player %
000005da : 0fc1b517;   % 438: 						la a0, Samus_Left_Jump_Up # Loads Player's Image Address  %
000005db : cfc50513;   % 438:  %
000005dc : 07c0006f;   % 439: 						j START_RENDER_PLAYER      # Start rendering player %
000005dd : 000e8463;   % 442: 					beqz t4, RENDER_MOVEMENT_LEFT %
000005de : 0340006f;   % 443: 					j RENDER_MOVEMENT_LEFT_UP %
000005df : ff858593;   % 446: 						addi a1,a1, -8 # Offseting sprite's X so that it renders in propper place %
000005e0 : 02000713;   % 447: 						li a4, 32      # Sprite's Height %
000005e1 : 000f0463;   % 448: 						beqz t5, RENDER_MOVEMENT_LEFT_NORMAL %
000005e2 : 0140006f;   % 449: 						j RENDER_MOVEMENT_LEFT_ATTACK %
000005e3 : 0fc18517;   % 452: 							la a0, Samus_Left	   # Loads Player's Image Address  %
000005e4 : 00850513;   % 452:  %
000005e5 : 01c00693;   % 453: 							li a3, 28              # Sprite's Widht %
000005e6 : 0540006f;   % 454: 							j START_RENDER_PLAYER  # Start rendering player %
000005e7 : 0fc19517;   % 457: 							la a0, Samus_Left_Attack  # Loads Player's Image Address  %
000005e8 : a7850513;   % 457:  %
000005e9 : 01c00693;   % 458: 							li a3, 28                  # Sprite's Widht %
000005ea : 0440006f;   % 459: 							j START_RENDER_PLAYER      # Start rendering player %
000005eb : ffa60613;   % 462: 						addi a2,a2, -6 # Offseting sprite's X so that it renders in propper place %
000005ec : 01400693;   % 463: 						li a3, 20      # Sprite's Widht %
000005ed : 02600713;   % 464: 						li a4, 38      # Sprite's Height %
000005ee : 000f0463;   % 465: 						beqz t5, RENDER_MOVEMENT_LEFT_UP_NORMAL %
000005ef : 0100006f;   % 466: 						j RENDER_MOVEMENT_LEFT_UP_ATTACK %
000005f0 : 0fc19517;   % 469: 							la a0, Samus_Left_Up  # Loads Player's Image Address %
000005f1 : 4d450513;   % 469:  %
000005f2 : 0240006f;   % 470: 							j START_RENDER_PLAYER  # Start rendering player %
000005f3 : 0fc1a517;   % 473: 							la a0, Samus_Left_Up_Attack  # Loads Player's Image Address %
000005f4 : db050513;   % 473:  %
000005f5 : 0180006f;   % 474: 							j START_RENDER_PLAYER         # Start rendering player %
000005f6 : 0fc1c517;   % 477: 			la a0, Morph_Ball # Loads morph ball image address %
000005f7 : b8c50513;   % 477:  %
000005f8 : 01060613;   % 478: 			addi a2, a2, 16 # Adds 16 to Player's Y %
000005f9 : 01000693;   % 479: 			li a3, 16 # Loads 16 to width of rendering area %
000005fa : 01000713;   % 480: 			li a4, 16 # Loads 16 to height of rendering area	 %
000005fb : 04020263;   % 484: 			beqz tp, RENDER_PLAYER_SKIP_CROP # If tp is 0, don't crop image %
000005fc : 00100293;   % 485: 				li t0,1    # To compare with tp (16 pixels to the left) %
000005fd : 02428263;   % 486: 				beq t0,tp, RENDER_PLAYER_CROP_LEFT %
000005fe : 00d009b3;   % 489: 					mv s3,a3         # Moves sprite's width to s3 %
000005ff : 00e00a33;   % 490: 					mv s4,a4         # Moves sprite's height to s4 %
00000600 : 01000693;   % 491: 					li a3,16  # New width of rendering area %
00000601 : 00100893;   % 492: 					li a7,1          # Sets to crop mode %
00000602 : 40d984b3;   % 493: 					sub s1,s3,a3     # Sets starting X to be 16 pixels before width of sprite's width %
00000603 : 00000913;   % 494: 					li s2,0          # Sets starting Y on sprite to 0 %
00000604 : 009585b3;   % 495: 					add a1,a1,s1     # Corrects player's starting X to be dislocated to the cropped X %
00000605 : 01c0006f;   % 496: 					j RENDER_PLAYER_SKIP_CROP %
00000606 : 00d009b3;   % 499: 					mv s3,a3         # Moves sprite's width to s3 %
00000607 : 00e00a33;   % 500: 					mv s4,a4         # Moves sprite's height to s4 %
00000608 : 01000693;   % 501: 					li a3,16  # New width of rendering area %
00000609 : 00100893;   % 502: 					li a7,1          # Sets to crop mode %
0000060a : 00000493;   % 503: 					li s1,0          # Sets starting X on sprite to 0  %
0000060b : 00000913;   % 504: 					li s2,0          # Sets starting Y on sprite to 0	 %
0000060c : 0fc0ff17;   % 508: 				la t5, PLYR_INFO_2    # Loads address to PLYR_INFO_2 %
0000060d : 908f0f13;   % 508:  %
0000060e : 000f4f03;   % 509: 				lbu t5,0(t5)          # Loads missile enable byte %
0000060f : 000f0863;   % 510: 				beqz t5,RENDER_PLAYER_SKIP_MISSILE   # If player isn't in missile mode %
00000610 : 00000317;   % 511: 					call RENDER    # Otherwise, render sprite byte by byte (to change color) %
00000611 : b88300e7;   % 511:  %
00000612 : 00c0006f;   % 512: 					j END_RENDER_PLAYER %
00000613 : 00000317;   % 514: 					call RENDER_WORD	# Calls RENDER_WORD procedure %
00000614 : c24300e7;   % 514:  %
00000615 : 00012483;   % 517: 					lw s1,0(sp) %
00000616 : 00412903;   % 518: 					lw s2,4(sp) %
00000617 : 00812983;   % 519: 					lw s3,8(sp) %
00000618 : 00c12a03;   % 520: 					lw s4,12(sp) %
00000619 : 01012083;   % 521: 					lw ra,16(sp) %
0000061a : 01410113;   % 522: 					addi sp,sp,20 %
0000061b : 00008067;   % 524: 					ret	   # End of procedure %
0000061c : 00144793;   % 527: 		xori a5,s0,1	# Gets oposite frame %
0000061d : 0fc0f297;   % 529: 		la t0, PLYR_MATRIX  # Loads PLYR_MATRIX address %
0000061e : 8ae28293;   % 529:  %
0000061f : 0012ce03;   % 530: 		lbu t3, 1(t0) # Loads Player's old X related to matrix (Starting X for rendering (top left, related to Matrix)) %
00000620 : 0032c383;   % 531: 		lbu t2, 3(t0) # Loads Player's old Y related to matrix (Starting Y for rendering (top left, related to Matrix)) %
00000621 : 00200813;   % 533: 		li a6, 2	    # Width (Number of Tiles) = 2 %
00000622 : 00200893;   % 534: 		li a7, 2	    # Height (Number of Tiles) = 2 %
00000623 : 00b2c303;   % 536: 		lbu t1,11(t0)    # Loads player's MOVE_Y %
00000624 : 00603333;   % 537: 		sltu t1,zero,t1  # t1 != 0 ? t1 = 1 : t1 = 0 %
00000625 : 00c28e83;   % 538: 		lb t4,12(t0)     # Loads player's JUMP %
00000626 : 000ed663;   % 539: 		bge t4,zero,SKIP_JUMP_CORRECTION      # t4 < 0 ? t4 = 1 : t4 = 0 %
00000627 : 00100313;   % 540: 			li t1,1        # Will add 1 to the height %
00000628 : 00028623;   % 541: 			sb zero,12(t0) # Sets JUMP to 0 %
00000629 : 006888b3;   % 543: 		add a7,a7,t1     # If player is moving vertically (t0 != 0), the height will increase by 1  %
0000062a : 0082c283;   % 545: 		lbu t0, 8(t0)   # Loads Player's morph ball status %
0000062b : 020e0a63;   % 546: 		beqz t3,SKIP_MOVE_Y_RENDER_PLAYER_TRAIL   # If player is on leftmost side, don't increase the width %
0000062c : fffe0e13;   % 549: 			addi t3,t3,-1     # Moves X left by 1 tile %
0000062d : 0fc0f317;   % 550: 			la t1 CURRENT_MAP # Loads CURRENT_MAP address %
0000062e : 84c30313;   % 550:  %
0000062f : 00032303;   % 551: 			lw t1,0(t1)       # Gets current map's address %
00000630 : 00134303;   % 552: 			lbu t1,1(t1)      # Gets current map's width %
00000631 : 41c30333;   % 553: 			sub t1,t1,t3      # t1 = Map's width - Player's old X related to matrix %
00000632 : 00400e93;   % 554: 			li t4,4           # t2 is used for comparing %
00000633 : 01d34863;   % 555: 			blt t1,t4,SET_NEW_WIDTH_RENDER_PLAYER_TRAIL # If t1 < 4, set the width to t1 %
00000634 : 0012c313;   % 557: 			xori t1,t0,1	# If player is on morph ball (t0 = 1), t1 = 0 and vice versa %
00000635 : 00330813;   % 558: 			addi a6,t1,3    # Width (Number of Tiles) = 3 (on morph ball) or 4 (not on morph ball) %
00000636 : 0080006f;   % 559: 			j SKIP_MOVE_Y_RENDER_PLAYER_TRAIL %
00000637 : 00600833;   % 561: 				mv a6,t1    # Width (Number of Tiles) = t1 (t1 < 4) %
00000638 : 00028463;   % 563: 		beqz t0, RENDER_PLAYER_TRAIL_STAND  # If player isn't on morph ball, go to RENDER_PLAYER_TRAIL_STAND %
00000639 : 0100006f;   % 564: 		j START_RENDER_PLAYER_TRAIL         # otherwise, player is on morph ball and go to START_RENDER_PLAYER_TRAIL %
0000063a : fff38393;   % 567: 			addi t2,t2,-1   # Moves Y up by 1 tile %
0000063b : 00188893;   % 568: 			addi a7,a7,1    # Height (Number of Tiles) = 3 (if not jumping) or 4 (if jumping) %
0000063c : 0040006f;   % 569: 			j START_RENDER_PLAYER_TRAIL %
0000063d : 00100db3;   % 572: 			mv s11, ra	# Moves ra to s11 -- so that we don't need to use the stack %
0000063e : 00002317;   % 573: 			call SCENE_RENDER	# Calls SCENE_RENDER procedure %
0000063f : 680300e7;   % 573:  %
00000640 : 01b000b3;   % 574: 			mv ra, s11  # Returns s11 to ra -- so that we don't need to use the stack %
00000641 : 00008067;   % 575: 			ret			# End of procedure %
00000642 : 00100db3;   % 594: 	mv s11, ra	# Moves ra to s11 -- so that we don't need to use the stack %
00000643 : 00000317;   % 595: 	call RENDER_LIFE_POINTS %
00000644 : 010300e7;   % 595:  %
00000645 : 01b000b3;   % 596: 	mv ra, s11 %
00000646 : 00008067;   % 597: 	ret %
00000647 : 0fc0e297;   % 600: 	la t0, PLYR_INFO %
00000648 : 7fc28293;   % 600:  %
00000649 : 0002c503;   % 601: 	lbu a0, 0(t0) %
0000064a : 02000593;   % 604: 	li a1,32 # a1 = column %
0000064b : 01c00613;   % 605: 	li a2,28 # a2 = row  %
0000064c : 0000c6b7;   % 606: 	li a3,0xc7ff # a3 = colors  %
0000064d : 7ff68693;   % 606:  %
0000064e : 00100713;   % 607: 	li a4,1 # a4 = frame %
0000064f : 06500893;   % 608: 	li a7,101 # syscal for 'print integer' %
00000650 : 00000073;   % 609: 	ecall %
00000651 : 0002c503;   % 611: 	lbu a0, 0(t0) %
00000652 : 02000593;   % 613: 	li a1,32 # a1 = column %
00000653 : 01c00613;   % 614: 	li a2,28 # a2 = row  %
00000654 : 0000c6b7;   % 615: 	li a3,0xc7ff # a3 = colors  %
00000655 : 7ff68693;   % 615:  %
00000656 : 00000713;   % 616: 	li a4,0 # a4 = frame %
00000657 : 06500893;   % 617: 	li a7,101 #syscal for 'print integer' %
00000658 : 00000073;   % 618: 	ecall %
00000659 : 00008067;   % 620: 	ret %
0000065a : 0a089863;   % 654: bnez a7,RENDER_ENTITY_TRAIL # If a0 != 0, render trail %
0000065b : 00000893;   % 655: 	li a7,0     # at the beginning, sprite doesn't need to be cropped %
0000065c : 00000493;   % 656: 	li s1,0     # Setting s1 to 0, in case needs to crop but skips horizontal crop %
0000065d : 00000913;   % 657: 	li s2,0     # Setting s2 to 0, in case needs to crop but skips vertical crop %
0000065e : 00d009b3;   % 658: 	mv s3,a3    # Storing sprite's width in (in case needs to crop but skips horizontal crop) %
0000065f : 00e00a33;   % 659: 	mv s4,a4    # Storing sprite's width in (in case needs to crop but skips horizontal crop) %
00000660 : 00d582b3;   % 662: 	add t0,a1,a3   # t0 (rightmost X + 1) = top left X related to screen + rendering area width  %
00000661 : 14505e63;   % 663: 	bge zero,t0, END_RENDER_ENTITY # If t0 <= 0, sprite's outside of screen (don't try to render >:[ ) %
00000662 : 14000313;   % 664: 	li t1,320 # t1 = 320 %
00000663 : 1465da63;   % 665: 	bge a1,t1, END_RENDER_ENTITY # If a1 >= 320, sprite's outside of screen (don't try to render >:[ ) %
00000664 : 0005c663;   % 668: 		blt a1,zero,CORRECT_X_LEFT # If so, crop the image %
00000665 : 00534e63;   % 670: 		blt t1,t0,CORRECT_X_RIGHT # If so, crop the image %
00000666 : 0240006f;   % 671: 		j RENDER_ENTITY_CHECK_VERTICAL# Otherwise, the a1 and a3 arguments are already defined correctly, go check vertical		 %
00000667 : 00100893;   % 674: 			li a7,1         # Sprite will need to be cropped %
00000668 : 40b004b3;   % 675: 			sub s1,zero,a1  # s1 (X in sprite where rendering starts) will be the absolute value of a1 %
00000669 : 00b686b3;   % 677: 			add a3,a3,a1    # Since a1 will be negative, a3 will be reduced to a smaller width %
0000066a : 00000593;   % 678: 			li a1,0         # and a1 will be set to 0 (leftmost X)   %
0000066b : 0100006f;   % 679: 			j RENDER_ENTITY_CHECK_VERTICAL # Go check vertical arguments		 %
0000066c : 00100893;   % 682: 			li a7,1         # Sprite will need to be cropped %
0000066d : 406282b3;   % 685: 			sub t0,t0,t1  # t0 will hold the excess width (what passes through the right border) %
0000066e : 405686b3;   % 686: 			sub a3,a3,t0  # take away from width (a3) the excess %
0000066f : 00e602b3;   % 691: 		add t0,a2,a4   # t0 (lowermost Y + 1) = top left Y related to screen + rendering area height  %
00000670 : 12505063;   % 692: 		bge zero,t0, END_RENDER_ENTITY # If t0 <= 0, sprite's outside of screen (don't try to render >:[ ) %
00000671 : 0f000313;   % 693: 		li t1,240 # t1 = 240 %
00000672 : 01030313;   % 694: 		addi t1,t1,16 %
00000673 : 10665a63;   % 695: 		bge a2,t1, END_RENDER_ENTITY # If a2 >= 240, sprite's outside of screen (don't try to render >:[ ) %
00000674 : 00064663;   % 698: 			blt a2,zero,CORRECT_Y_TOP # If so, crop the image %
00000675 : 00534e63;   % 700: 			blt t1,t0,CORRECT_Y_BOTTOM # If so, crop the image %
00000676 : 0240006f;   % 701: 			j RENDER_ENTITY_START # Otherwise, the a2 and a4 arguments are already defined correctly, render	 %
00000677 : 00100893;   % 704: 				li a7,1         # Sprite will need to be cropped %
00000678 : 40c00933;   % 705: 				sub s2,zero,a2  # s2 (Y in sprite where rendering starts) will be the absolute value of a2 %
00000679 : 00c70733;   % 707: 				add a4,a4,a2    # Since a2 will be negative, a4 will be reduced to a smaller height %
0000067a : 00000613;   % 708: 				li a2,0         # and a1 will be set to 0 (topmost Y)   %
0000067b : 0100006f;   % 709: 				j RENDER_ENTITY_START # render	 %
0000067c : 00100893;   % 712: 				li a7,1         # Sprite will need to be cropped %
0000067d : 406282b3;   % 715: 				sub t0,t0,t1  # t0 will hold the excess height (what passes through the bottom border) %
0000067e : 40570733;   % 716: 				sub a4,a4,t0  # take away from height (a4) the excess %
0000067f : ffc10113;   % 722: 			addi sp,sp,-4 %
00000680 : 00112023;   % 723: 			sw ra,0(sp) %
00000681 : 00000317;   % 725: 			call RENDER  %
00000682 : 9c4300e7;   % 725:  %
00000683 : 00012083;   % 727: 			lw ra,0(sp) %
00000684 : 00410113;   % 728: 			addi sp,sp,4 %
00000685 : 0cc0006f;   % 730: 			j END_RENDER_ENTITY %
00000686 : 00000513;   % 733: 	li a0,0         # So that it renders map's trail %
00000687 : 00144793;   % 734: 	xori a5,s0,1	# Gets oposite frame %
00000688 : 00b00e33;   % 737: 	mv t3,a1   # column where rendering will begin (X related to Matrix) %
00000689 : 00c003b3;   % 738: 	mv t2,a2   # line where rendering will begin (Y related to Matrix) %
0000068a : 00d00833;   % 739: 	mv a6,a3   # width (Related to Matrix) of rendering area %
0000068b : 00e008b3;   % 740: 	mv a7,a4   # height (Related to Matrix) of rendering area %
0000068c : 0fc0e217;   % 742: 	la tp,CURRENT_MAP # Loads CURRENT_MAP's address %
0000068d : 6d020213;   % 742:  %
0000068e : 00624283;   % 744: 	lbu t0,6(tp)   # loads map's current X   %
0000068f : 00d58333;   % 745: 	add t1,a1,a3   # t1 (rightmost X + 1) = top left X related to matrix + rendering area width  %
00000690 : 0a62d063;   % 746: 	bge t0,t1, END_RENDER_ENTITY # If t1 <= map's current X, area is outside of screen (don't try to render >:[ ) %
00000691 : 01428e93;   % 747: 	addi t4,t0,20    # t1 = map's current X + 20 %
00000692 : 09d5cc63;   % 748: 	blt a1,t4, END_RENDER_ENTITY # If a1 > map's current X + 20, area is outside of screen (don't try to render >:[ ) %
00000693 : 0055c663;   % 763: 		blt a1,t0,CORRECT_X_LEFT_TRAIL # If so, reduce width %
00000694 : 006ecc63;   % 765: 		blt t4,t1,CORRECT_X_RIGHT_TRAIL # If so, reduce width %
00000695 : 02c0006f;   % 766: 		j RENDER_ENTITY_TRAIL_CHECK_VERTICAL # Otherwise, the a1 and a3 arguments are already defined correctly, go check vertical		 %
00000696 : 40b28eb3;   % 769: 			sub t4,t0,a1    # t4 will have map's current X - Old X %
00000697 : 41d80833;   % 770: 			sub a6,a6,t4    # Reduce width %
00000698 : 00500e33;   % 771: 			mv t3,t0        # t3 will recieve map's current X   %
00000699 : 01c0006f;   % 772: 			j RENDER_ENTITY_TRAIL_CHECK_VERTICAL  # Go check vertical arguments		 %
0000069a : 406e8eb3;   % 776: 			sub t4,t4,t1    # t4 = map's current X + 20 - (top left X related to matrix + rendering area width)  %
0000069b : 41d80833;   % 777: 			sub a6,a6,t4    # Reduce width %
0000069c : 00824e83;   % 778: 			lbu t4,8(tp)    # loads map's X offset  %
0000069d : 01d02eb3;   % 779: 			slt t4,zero,t4  # 0 < x offset ? t4 = 1 : t4 = 0 %
0000069e : 01d80833;   % 780: 			add a6,a6,t4    # add 1 to width if offset != 0 %
0000069f : 06080263;   % 781: 			beqz a6, END_RENDER_ENTITY # if width is 0, end procedure %
000006a0 : 00724283;   % 786: 		lbu t0,7(tp)   # loads map's current Y   %
000006a1 : 00e60333;   % 787: 		add t1,a2,a4   # t1 (rightmost Y + 1) = top left Y related to matrix + rendering area width  %
000006a2 : 0462dc63;   % 788: 		bge t0,t1, END_RENDER_ENTITY # If t1 <= map's current Y, area is outside of screen (don't try to render >:[ ) %
000006a3 : 00f28e93;   % 789: 		addi t4,t0,15   # t1 = map's current Y + 15 %
000006a4 : 05d64863;   % 790: 		blt a2,t4, END_RENDER_ENTITY # If a2 > map's current Y + 15, area is outside of screen (don't try to render >:[ ) %
000006a5 : 00564663;   % 793: 			blt a2,t0,CORRECT_Y_TOP_TRAIL # If so, reduce width %
000006a6 : 006ecc63;   % 795: 			blt t4,t1,CORRECT_Y_BOTTOM_TRAIL # If so, reduce width %
000006a7 : fe5ff06f;   % 796: 			j RENDER_ENTITY_TRAIL_CHECK_VERTICAL # Otherwise, the a2 and a4 arguments are already defined correctly, go check vertical		 %
000006a8 : 40b28eb3;   % 799: 				sub t4,t0,a1    # t4 will have map's current Y - Old Y %
000006a9 : 41d888b3;   % 800: 				sub a7,a7,t4    # Reduce height %
000006aa : 005003b3;   % 801: 				mv t2,t0        # t2 will recieve map's current Y   %
000006ab : 01c0006f;   % 802: 				j RENDER_ENTITY_TRAIL_START  # Render trail %
000006ac : 406e8eb3;   % 806: 				sub t4,t4,t1    # t4 = map's current Y + 20 - (top left Y related to matrix + rendering area width)  %
000006ad : 41d888b3;   % 807: 				sub a7,a7,t4    # Reduce width %
000006ae : 00924e83;   % 808: 				lbu t4,9(tp)    # loads map's Y offset  %
000006af : 01d02eb3;   % 809: 				slt t4,zero,t4  # 0 < Y offset ? t4 = 1 : t4 = 0 %
000006b0 : 01d888b3;   % 810: 				add a7,a7,t4    # add 1 to width if offset != 0 %
000006b1 : 00088e63;   % 811: 				beqz a7, END_RENDER_ENTITY # if width is 0, end procedure %
000006b2 : ffc10113;   % 816: 			addi sp,sp,-4 %
000006b3 : 00112023;   % 817: 			sw ra,0(sp) %
000006b4 : 00002317;   % 819: 			call SCENE_RENDER	# Calls SCENE_RENDER procedure %
000006b5 : 4a8300e7;   % 819:  %
000006b6 : 00012083;   % 821: 			lw ra,0(sp) %
000006b7 : 00410113;   % 822: 			addi sp,sp,4 %
000006b8 : 00008067;   % 826: 	ret %
000006b9 : ffc10113;   % 846: 	addi sp,sp,-4 %
000006ba : 00112023;   % 847: 	sw ra,0(sp) %
000006bb : 0fc0f297;   % 849: 	la t0, Doors # Loads Doors address %
000006bc : 88828293;   % 849:  %
000006bd : 0fc0e217;   % 850: 	la tp, CURRENT_MAP # Loads CURRENT_MAP address %
000006be : 60c20213;   % 850:  %
000006bf : 0002a503;   % 851: 	lw a0,0(t0)   # Gets current map's doors address %
000006c0 : 00054283;   % 852: 	lbu t0,0(a0)  # Loads number of doors in this map %
000006c1 : 00150513;   % 853: 	addi a0,a0,1  # Goes to next byte (where doors from current map start) %
000006c2 : 00000313;   % 854: 	li t1,0       # Counter for doors %
000006c3 : 00054e03;   % 859: 		lbu t3, 0(a0)        # Loads door's X on matrix %
000006c4 : 00624583;   % 860: 		lbu a1, 6(tp)        # Loads map's current X on matrix %
000006c5 : 40be0eb3;   % 861: 		sub t4,t3,a1         # t4 = Door's X - Map's current X %
000006c6 : 01400f13;   % 862: 		li t5,20 # Loads 20 (screen's width related to matrix) %
000006c7 : 01eeea63;   % 863: 		bgtu t5,t4,RENDER_DOOR_UPDATE_LOOP_Y_CHECK # If the result is between 0 and 19 (inclusive), continue on loop %
000006c8 : 01df1663;   % 865: 			bne t5,t4,GO_TO_NEXT_IN_RENDER_DOOR_UPDATE_LOOP   # If t4 != 20, iterate to next door %
000006c9 : 00824e83;   % 866: 				lbu t4, 8(tp)                           # Loads map's X offset %
000006ca : 000e9463;   % 867: 				bnez t4,RENDER_DOOR_UPDATE_LOOP_Y_CHECK # If X offset != 0, continue on this loop %
000006cb : 0b00006f;   % 870: 					j NEXT_IN_RENDER_DOOR_UPDATE_LOOP %
000006cc : 00154383;   % 872: 			lbu t2, 1(a0)    # Loads door's Y on matrix %
000006cd : 00724603;   % 873: 			lbu a2, 7(tp)    # Loads map's current Y on matrix %
000006ce : 40c38eb3;   % 874: 			sub t4,t2,a2     # t4 = Door's top Y - Map's current Y %
000006cf : ffe00f13;   % 875: 			li t5,-2               # Loads -2 (lower threshold) %
000006d0 : 01eeafb3;   % 876: 			slt t6,t4,t5           # t6 will be 0 if t4 >= -2 %
000006d1 : 00f00f13;   % 877: 			li t5,15  # Loads 15 (screen's height related to matrix) %
000006d2 : 01df2f33;   % 878: 			slt t5,t5,t4           # t5 will be 0 if t4 <= 15 %
000006d3 : 01ff0f33;   % 879: 			add t5,t5,t6           # t5 = 0 only if -2 <= t4 <= 15  %
000006d4 : 000f0463;   % 880: 			beqz t5, RENDER_DOOR_UPDATE_LOOP_Y_CHECK_2 # If -2 <= t4 <= 15, continue loop %
000006d5 : 0880006f;   % 882: 				j NEXT_IN_RENDER_DOOR_UPDATE_LOOP %
000006d6 : 000ed863;   % 885: 				bge t4,zero,RENDER_DOOR_UPDATE_LOOP_MIDDLE_TOP  # If t4 >= 0, go to RENDER_DOOR_UPDATE_LOOP_MIDDLE_TOP %
000006d7 : 00000393;   % 887: 					li t2,0        # starting Y will be set to 0 %
000006d8 : 003e8893;   % 888: 					addi a7,t4,3   # and height will be 1 (if t4 = -2) or 2 (if t4 = -1) %
000006d9 : 0300006f;   % 889: 					j START_RENDER_DOOR_UPDATE %
000006da : 00d00f13;   % 893: 					li t5, 13                                  %
000006db : 01eed663;   % 894: 					bge t4,t5, RENDER_DOOR_UPDATE_LOOP_TOP_1 %
000006dc : 00300893;   % 897: 						li a7, 3    # Height of rendering area will be 3 in order to render it fully %
000006dd : 0200006f;   % 898: 						j START_RENDER_DOOR_UPDATE %
000006de : 00924703;   % 902: 						lbu a4, 9(tp)   # Loads current Y offset on Map	 %
000006df : 00f00f13;   % 903: 						li t5,15  # Loads 15 (screen's height related to matrix) %
000006e0 : 41df08b3;   % 904: 						sub a7,t5,t4    # a7 = Screen's Height (15) - (Door's Y - Map's current Y)     %
000006e1 : 00e02f33;   % 905: 						slt t5,zero,a4  # a4 > 0 ? t5 = 1 : t5 = 0 (only if a4 == 0) %
000006e2 : 01e888b3;   % 906: 						add a7,a7,t5    # a7 (height of rendering area) will be increased by 1 if the map's Y offset isn't 0 %
000006e3 : 00089463;   % 907: 						bnez a7,START_RENDER_DOOR_UPDATE # If the result isn't equal to 0, continue to rendering this door %
000006e4 : 04c0006f;   % 909: 							j NEXT_IN_RENDER_DOOR_UPDATE_LOOP		                         %
000006e5 : ff010113;   % 913: 			addi sp,sp,-16 %
000006e6 : 00612623;   % 914: 			sw t1,12(sp) %
000006e7 : 00512423;   % 915: 			sw t0,8(sp) %
000006e8 : 00412223;   % 916: 			sw tp,4(sp) %
000006e9 : 00a12023;   % 917: 			sw a0,0(sp) %
000006ea : 00022503;   % 919: 			lw a0,0(tp) %
000006eb : 00824683;   % 922: 			lbu a3, 8(tp)   # Loads current X offset on Map %
000006ec : 00924703;   % 923: 			lbu a4, 9(tp)   # Loads current Y offset on Map	 %
000006ed : 008007b3;   % 924: 			mv a5, s0		# Frame = s0 %
000006ee : 00100813;   % 925: 			li a6, 1        # Width of rendering area will always be 1 %
000006ef : 00000213;   % 929: 			li tp, 0        # Map won't be dislocated		 %
000006f0 : 00000317;   % 930: 			call RENDER_MAP %
000006f1 : 14c300e7;   % 930:  %
000006f2 : 00c12303;   % 932: 			lw t1,12(sp) %
000006f3 : 00812283;   % 933: 			lw t0,8(sp) %
000006f4 : 00412203;   % 934: 			lw tp,4(sp) %
000006f5 : 00012503;   % 935: 			lw a0,0(sp) %
000006f6 : 01010113;   % 936: 			addi sp,sp,16 %
000006f7 : 00450513;   % 939: 			addi a0,a0,4 # Going to the next door's address                                   %
000006f8 : 00130313;   % 940: 			addi t1,t1,1 # Iterating counter by 1                                    %
000006f9 : 00535463;   % 941: 			bge t1,t0, END_RENDER_DOOR_UPDATE # If all of the map's doors were checked, end loop                                   %
000006fa : f25ff06f;   % 942: 			j RENDER_DOOR_UPDATE_LOOP # otherwise, go back to the loop's beginning                      %
000006fb : 00012083;   % 946: 			lw ra,0(sp) %
000006fc : 00410113;   % 947: 			addi sp,sp,4 %
000006fd : 00008067;   % 949: 			ret %
000006fe : ffc10113;   % 967: 	addi sp,sp,-4 %
000006ff : 00112023;   % 968: 	sw ra,0(sp) %
00000700 : 0fc0e297;   % 970: 	la t0, Frames # Loads Frames address %
00000701 : 7b428293;   % 970:  %
00000702 : 0fc0e217;   % 971: 	la tp, CURRENT_MAP # Loads CURRENT_MAP address %
00000703 : 4f820213;   % 971:  %
00000704 : 0002a503;   % 972: 	lw a0,0(t0)   # Gets current map's frames address %
00000705 : 00054283;   % 973: 	lbu t0,0(a0)  # Loads number of door frames in this map %
00000706 : 00150513;   % 974: 	addi a0,a0,1  # Goes to next byte (where door frames from current map start) %
00000707 : 00000313;   % 975: 	li t1,0       # Counter for door frames %
00000708 : 00054e03;   % 980: 		lbu t3, 0(a0)        # Loads door frame's X on matrix %
00000709 : 00624583;   % 981: 		lbu a1, 6(tp)        # Loads map's current X on matrix %
0000070a : 40be0eb3;   % 982: 		sub t4,t3,a1         # t4 = Door frame's X - Map's current X %
0000070b : 01400f13;   % 983: 		li t5,20 # Loads 20 (screen's width related to matrix) %
0000070c : 01eeea63;   % 984: 		bgtu t5,t4,RENDER_DOOR_FRAMES_LOOP_Y_CHECK # If the result is between 0 and 19 (inclusive), continue on loop %
0000070d : 01df1663;   % 986: 			bne t5,t4,GO_TO_NEXT_IN_RENDER_DOOR_FRAMES_LOOP   # If t4 != 20, iterate to next door %
0000070e : 00824e83;   % 987: 				lbu t4, 8(tp)                           # Loads map's X offset %
0000070f : 000e9463;   % 988: 				bnez t4,RENDER_DOOR_FRAMES_LOOP_Y_CHECK # If X offset != 0, continue on this loop %
00000710 : 0b00006f;   % 991: 					j NEXT_IN_RENDER_DOOR_FRAMES_LOOP %
00000711 : 00154383;   % 993: 			lbu t2, 1(a0)    # Loads door frame's Y on matrix %
00000712 : 00724603;   % 994: 			lbu a2, 7(tp)    # Loads map's current Y on matrix %
00000713 : 40c38eb3;   % 995: 			sub t4,t2,a2     # t4 = Door frame's top Y - Map's current Y %
00000714 : ffe00f13;   % 996: 			li t5,-2               # Loads -2 (lower threshold) %
00000715 : 01eeafb3;   % 997: 			slt t6,t4,t5           # t6 will be 0 if t4 >= -2 %
00000716 : 00f00f13;   % 998: 			li t5,15  # Loads 15 (screen's height related to matrix) %
00000717 : 01df2f33;   % 999: 			slt t5,t5,t4           # t5 will be 0 if t4 <= 15 %
00000718 : 01ff0f33;   % 1000: 			add t5,t5,t6           # t5 = 0 only if -2 <= t4 <= 15  %
00000719 : 000f0463;   % 1001: 			beqz t5, RENDER_DOOR_FRAMES_LOOP_Y_CHECK_2 # If -2 <= t4 <= 15, continue loop %
0000071a : 0880006f;   % 1003: 				j NEXT_IN_RENDER_DOOR_FRAMES_LOOP %
0000071b : 000ed863;   % 1006: 				bge t4,zero,RENDER_DOOR_FRAMES_LOOP_MIDDLE_TOP  # If t4 >= 0, go to RENDER_DOOR_FRAMES_LOOP_MIDDLE_TOP %
0000071c : 00000393;   % 1008: 					li t2,0        # starting Y will be set to 0 %
0000071d : 003e8893;   % 1009: 					addi a7,t4,3   # and height will be 1 (if t4 = -2) or 2 (if t4 = -1) %
0000071e : 0300006f;   % 1010: 					j START_RENDER_DOOR_FRAMES %
0000071f : 00d00f13;   % 1014: 					li t5, 13                                  %
00000720 : 01eed663;   % 1015: 					bge t4,t5, RENDER_DOOR_FRAMES_LOOP_TOP_1 %
00000721 : 00300893;   % 1018: 						li a7, 3    # Height of rendering area will be 3 in order to render it fully %
00000722 : 0200006f;   % 1019: 						j START_RENDER_DOOR_FRAMES %
00000723 : 00924703;   % 1023: 						lbu a4, 9(tp)   # Loads current Y offset on Map	 %
00000724 : 00f00f13;   % 1024: 						li t5,15  # Loads 15 (screen's height related to matrix) %
00000725 : 41df08b3;   % 1025: 						sub a7,t5,t4    # a7 = Screen's Height (15) - (Door frame's Y - Map's current Y)     %
00000726 : 00e02f33;   % 1026: 						slt t5,zero,a4  # a4 > 0 ? t5 = 1 : t5 = 0 (only if a4 == 0) %
00000727 : 01e888b3;   % 1027: 						add a7,a7,t5    # a7 (height of rendering area) will be increased by 1 if the map's Y offset isn't 0 %
00000728 : 00089463;   % 1028: 						bnez a7,START_RENDER_DOOR_FRAMES # If the result isn't equal to 0, continue to rendering this door frame %
00000729 : 04c0006f;   % 1030: 							j NEXT_IN_RENDER_DOOR_FRAMES_LOOP		                         %
0000072a : ff010113;   % 1034: 			addi sp,sp,-16 %
0000072b : 00612623;   % 1035: 			sw t1,12(sp) %
0000072c : 00512423;   % 1036: 			sw t0,8(sp) %
0000072d : 00412223;   % 1037: 			sw tp,4(sp) %
0000072e : 00a12023;   % 1038: 			sw a0,0(sp) %
0000072f : 00022503;   % 1040: 			lw a0,0(tp) %
00000730 : 00824683;   % 1043: 			lbu a3, 8(tp)   # Loads current X offset on Map %
00000731 : 00924703;   % 1044: 			lbu a4, 9(tp)   # Loads current Y offset on Map	 %
00000732 : 008007b3;   % 1045: 			mv a5, s0		# Frame = s0 %
00000733 : 00100813;   % 1046: 			li a6, 1        # Width of rendering area will always be 1 %
00000734 : 00000213;   % 1050: 			li tp, 0        # Map won't be dislocated		 %
00000735 : 00000317;   % 1051: 			call RENDER_MAP %
00000736 : 038300e7;   % 1051:  %
00000737 : 00c12303;   % 1053: 			lw t1,12(sp) %
00000738 : 00812283;   % 1054: 			lw t0,8(sp) %
00000739 : 00412203;   % 1055: 			lw tp,4(sp) %
0000073a : 00012503;   % 1056: 			lw a0,0(sp) %
0000073b : 01010113;   % 1057: 			addi sp,sp,16 %
0000073c : 00650513;   % 1060: 			addi a0,a0,6 # Going to the next door frame's address                                   %
0000073d : 00130313;   % 1061: 			addi t1,t1,1 # Iterating counter by 1                                    %
0000073e : 00535463;   % 1062: 			bge t1,t0, END_RENDER_DOOR_FRAMES # If all of the map's doors were checked, end loop                                   %
0000073f : f25ff06f;   % 1063: 			j RENDER_DOOR_FRAMES_LOOP # otherwise, go back to the loop's beginning                      %
00000740 : 00012083;   % 1067: 			lw ra,0(sp) %
00000741 : 00410113;   % 1068: 			addi sp,sp,4 %
00000742 : 00008067;   % 1070: 			ret %
00000743 : fec10113;   % 1111: 	addi sp,sp,-20 %
00000744 : 00112823;   % 1112: 	sw ra,16(sp) %
00000745 : 01312623;   % 1113: 	sw s3,12(sp) %
00000746 : 01212423;   % 1114: 	sw s2,8(sp) %
00000747 : 00912223;   % 1115: 	sw s1,4(sp) %
00000748 : 00812023;   % 1116: 	sw s0,0(sp) %
00000749 : 00350293;   % 1118: 	addi t0,a0,3 	# skips first 3 bytes of information (goes to the actual matrix) %
0000074a : 00b28433;   % 1119: 	add s0, t0, a1 	# s0 = Matrix Address + Starting X on Matrix %
0000074b : 00154483;   % 1120: 	lbu s1,1(a0)	# s1 = matrix width %
0000074c : 02c482b3;   % 1121: 	mul t0,s1,a2    # t0 = Matrix Width x Starting Y on Matrix %
0000074d : 00540433;   % 1122: 	add s0, s0, t0	# s0 = Address to current X and Y on Matrix %
0000074e : 010e09b3;   % 1125: 	add s3,t3,a6 	# s3 will be compared with t3 (column counter) to go to next line %
0000074f : 000e0a63;   % 1126: 	beqz t3,RENDER_MAP_NoTrailX %
00000750 : 40be0e33;   % 1128: 	sub t3,t3,a1	# t3 now is the column counter related to the screen matrix %
00000751 : 010e09b3;   % 1129: 	add s3,t3,a6 %
00000752 : 01c40433;   % 1130: 	add s0, s0, t3 	# s0 = Matrix Address + Current X on Matrix %
00000753 : 0200006f;   % 1131: 	j RENDER_MAP_GetCurrentY %
00000754 : 00068e63;   % 1134: 	beqz a3, RENDER_MAP_GetCurrentY # If there's no X offset %
00000755 : 01400293;   % 1135: 	li t0, 20 %
00000756 : 00584a63;   % 1136: 	blt a6,t0, RENDER_MAP_GetCurrentY   # If width of rendering area is smaller than the screen's width, ignore %
00000757 : 00404863;   % 1137: 	blt zero,tp, RENDER_MAP_GetCurrentY # If map is dislocated, ignore the next step %
00000758 : 01058333;   % 1138: 	add t1,a1,a6    # t1 = Starting X + Width in tiles %
00000759 : 00930463;   % 1139: 	beq t1,s1, RENDER_MAP_GetCurrentY   # If map is on furthest X to the right, don't increase width %
0000075a : 00128993;   % 1140: 	addi s3,t0,1	# if rendering a full screen (20 wide) with offset, will need to render 21 tiles %
0000075b : 01138933;   % 1143: 	add s2,t2,a7 	# s2 will be compared with t2 (column counter) to go to next line %
0000075c : 00038c63;   % 1144: 	beqz t2,RENDER_MAP_NoTrailY %
0000075d : 40c383b3;   % 1146: 	sub t2,t2,a2	# t2 now is the column counter related to the screen matrix %
0000075e : 01138933;   % 1147: 	add s2,t2,a7 %
0000075f : 027482b3;   % 1148: 	mul t0,s1,t2    # t0 = Matrix Width x Current Y on Matrix %
00000760 : 00540433;   % 1149: 	add s0, s0, t0	# s0 = Address to current X and Y on Matrix %
00000761 : 0140006f;   % 1150: 	j RENDER_MAP_LOOP %
00000762 : 00070863;   % 1153: 	beqz a4, RENDER_MAP_LOOP # If there's an X offset %
00000763 : 00f00293;   % 1154: 	li t0, 15 %
00000764 : 0058c463;   % 1155: 	blt a7,t0 RENDER_MAP_LOOP # If height of rendering area is smaller than the screen's height, ignore %
00000765 : 00128913;   % 1156: 	addi s2,t0,1	# if rendering a full screen (15 wide) with offset, will need to render 16 tiles %
00000766 : 00044303;   % 1159: 	lbu t1,0(s0)	# loads byte stored on matrix for checking what is the tile %
00000767 : 00031463;   % 1160: 	bnez t1,NotBackground %
00000768 : 10c0006f;   % 1161: 	j CONTINUE_RENDER_MAP %
00000769 : 0fb00293;   % 1165: 		li t0, 251     # Value where special tiles start  %
0000076a : 02535463;   % 1166: 		bge t1, t0, RENDER_SPECIAL # If it's a special tile %
0000076b : 02800293;   % 1169: 		li t0, 40      # Value where doors start %
0000076c : 04535863;   % 1170: 		bge t1, t0, RENDER_DOOR # If it's a door %
0000076d : 0fc0e297;   % 1171: 		la t0, Tileset # Loads Tileset address to t0 %
0000076e : 65828293;   % 1171:  %
0000076f : fff30313;   % 1172: 		addi t1,t1,-1  # t1 = Tile Number - 1 (so that if t1 = 1, 0 tiles will be skipped) %
00000770 : 00831313;   % 1173: 		slli t1,t1,8   # t1 = (Tile Number - 1) x 256 %
00000771 : 006282b3;   % 1174: 		add t0,t0,t1  # t0 will skip (Tile Number - 1) x 256 bytes (Tile Number - 1 tiles) %
00000772 : 00000eb3;   % 1175: 		mv t4,zero    # t4 will hold the tile's sprite status (which will be zero) %
00000773 : 0e00006f;   % 1176: 		j CONTINUE_RENDER_MAP %
00000774 : 0ff00293;   % 1179: 		li t0,255 %
00000775 : 02629263;   % 1180: 		bne t0,t1,NOT_MARU_MARI %
00000776 : 0fc0e317;   % 1181: 			la t1,MARU_MARI_INFO # Loads Maru Mari's info address %
00000777 : 36430313;   % 1181:  %
00000778 : 00034283;   % 1182: 			lbu t0, 0(t1)        # Loads enable byte %
00000779 : 00028a63;   % 1183: 			beqz t0,RENDER_BACKGROUND # If disabled, skip %
0000077a : 0fc1c297;   % 1185: 				la t0,MaruMari  # Loads MaruMari tile address %
0000077b : b7c28293;   % 1185:  %
0000077c : 00134e83;   % 1186: 				lbu t4, 1(t1)   # Loads status sprite %
0000077d : 0b80006f;   % 1187: 				j CONTINUE_RENDER_MAP %
0000077e : 00000333;   % 1191: 			mv t1,zero # so background color will be rendered %
0000077f : 0b00006f;   % 1192: 			j CONTINUE_RENDER_MAP %
00000780 : ffc10113;   % 1195: 		addi sp,sp,-4 %
00000781 : 00412023;   % 1196: 		sw tp,0(sp) %
00000782 : 00000fb3;   % 1199: 		mv t6,zero     # Resets counter %
00000783 : 0fc0ee97;   % 1200: 		la t4,NEXT_MAP # Loads NEXT_MAP address %
00000784 : 300e8e93;   % 1200:  %
00000785 : 00aecf03;   % 1201: 		lbu t5,10(t4)  # Gets the Render Next Map Door byte	 %
00000786 : 000f0e63;   % 1202: 		beqz t5, RENDER_DOOR_CURRENT   # If Render Next Map Door == 0, render current map's door %
00000787 : 0fc0ee97;   % 1204: 			la t4, Doors_Next # Loads Doors_Next address %
00000788 : 55ce8e93;   % 1204:  %
00000789 : 000eae83;   % 1205: 			lw t4,0(t4)	      # Gets the next map's door address %
0000078a : 000ecf03;   % 1206: 			lbu t5,0(t4)      # Gets the number of doors in this map %
0000078b : 001e8e93;   % 1207: 			addi t4,t4,1      # Starting address of the map's first door %
0000078c : 0180006f;   % 1208: 			j RENDER_DOOR_LOOP %
0000078d : 0fc0ee97;   % 1211: 			la t4, Doors # Loads Doors address %
0000078e : 540e8e93;   % 1211:  %
0000078f : 000eae83;   % 1212: 			lw t4,0(t4)	 # Gets the current map's door address %
00000790 : 000ecf03;   % 1213: 			lbu t5,0(t4) # Gets the number of doors in this map %
00000791 : 001e8e93;   % 1214: 			addi t4,t4,1 # Starting address of the map's first door %
00000792 : 000ec203;   % 1218: 			lbu tp, 0(t4) # Loads door's X on matrix %
00000793 : 01c582b3;   % 1219: 			add t0,a1,t3  # Gets current X on map matrix %
00000794 : 02521e63;   % 1220: 			bne tp, t0, NEXT_IN_DOOR_LOOP # If door's X isn't the same as current X, skip this door %
00000795 : 001ec203;   % 1221: 			lbu tp, 1(t4) # Loads door's Y on matrix %
00000796 : 007602b3;   % 1222: 			add t0,a2,t2  # Gets current Y on map matrix %
00000797 : 40428233;   % 1223: 			sub tp,t0,tp  # tp needs to be equal to 0, 1 or 2 in order to be a tile from this door %
00000798 : 00200293;   % 1224: 			li t0,2 # 2 is the threshold to be compared with tp %
00000799 : 0242e463;   % 1225: 			bgtu tp,t0, NEXT_IN_DOOR_LOOP # If current Y is above the door's uppermost Y or bellow it's downmost Y, skip this door %
0000079a : 002ec203;   % 1227: 			lbu tp, 2(t4) # Loads door's state %
0000079b : 02525863;   % 1228: 			bge tp,t0, END_RENDER_DOOR_LOOP # If door is open (state = 2 -- >= 2 for containing errors) %
0000079c : 0fc0e297;   % 1230: 				la t0, Tileset # Loads Tileset address to t0 %
0000079d : 59c28293;   % 1230:  %
0000079e : fff30313;   % 1231: 				addi t1,t1,-1  # t1 = Tile Number - 1 (so that if t1 = 1, 0 tiles will be skipped) %
0000079f : 00430333;   % 1232: 				add t1,t1,tp   # t1 will change if door is opening (tp = 1) %
000007a0 : 00831313;   % 1233: 				slli t1,t1,8   # t1 = (Tile Number - 1) x 256 %
000007a1 : 006282b3;   % 1234: 				add t0,t0,t1   # t0 will skip (Tile Number - 1) x 256 bytes (Tile Number - 1 tiles)  %
000007a2 : 0180006f;   % 1235: 				j END_RENDER_DOOR_LOOP_GLOBAL %
000007a3 : 004e8e93;   % 1237: 				addi t4,t4,4 # Going to the next door's address %
000007a4 : 001f8f93;   % 1238: 				addi t6,t6,1 # Iterating counter by 1 %
000007a5 : 01efd463;   % 1239: 				bge t6,t5, END_RENDER_DOOR_LOOP # If all of the map's doors were checked, end loop %
000007a6 : fb1ff06f;   % 1240: 				j RENDER_DOOR_LOOP # otherwise, go back to the loop's beginning %
000007a7 : 00000333;   % 1243: 		mv t1,zero %
000007a8 : 00000eb3;   % 1246: 		mv t4,zero    # t4 will hold the tile's sprite status (which will be zero) %
000007a9 : 00012203;   % 1247: 		lw tp,0(sp) %
000007aa : 00410113;   % 1248: 		addi sp,sp,4 %
000007ab : fc810113;   % 1253: 	addi sp,sp,-56 %
000007ac : 03412a23;   % 1254: 	sw s4,52(sp) %
000007ad : 03312823;   % 1255: 	sw s3,48(sp) %
000007ae : 03212623;   % 1256: 	sw s2,44(sp) %
000007af : 02912423;   % 1257: 	sw s1,40(sp) %
000007b0 : 03112223;   % 1258: 	sw a7,36(sp) %
000007b1 : 03012023;   % 1259: 	sw a6,32(sp) %
000007b2 : 00e12e23;   % 1260: 	sw a4,28(sp) %
000007b3 : 00d12c23;   % 1261: 	sw a3,24(sp) %
000007b4 : 00c12a23;   % 1262: 	sw a2,20(sp) %
000007b5 : 00b12823;   % 1263: 	sw a1,16(sp) %
000007b6 : 00a12623;   % 1264: 	sw a0,12(sp) %
000007b7 : 00712423;   % 1265: 	sw t2,8(sp) %
000007b8 : 01c12223;   % 1266: 	sw t3,4(sp) %
000007b9 : 00412023;   % 1267: 	sw tp,0(sp) %
000007ba : 00500533;   % 1270: 	mv a0, t0 # Moves t0 (storing tile address) to a0 %
000007bb : 01d00833;   % 1271: 	mv a6,t4  # Moves tmv t4 (tile's sprite status) to a6 %
000007bc : 01000293;   % 1274: 	li t0, 16 	# Tile size = 16 %
000007bd : 01c20fb3;   % 1275: 	add t6,tp,t3        # t6 gets t3 (current X) + tp (X dislocation) %
000007be : 025f8eb3;   % 1276: 	mul t4,t6,t0		# t4 gets the X value relative to the screen ((t3 + tp) * tile size) %
000007bf : 02538f33;   % 1277: 	mul t5,t2,t0		# t5 gets the Y value relative to the screen (t2 (current Y) * tile size) %
000007c0 : 00000f93;   % 1279: 	li t6,0 %
000007c1 : 00069463;   % 1280: 	bnez a3, X_Offset 	# If there's a X offset %
000007c2 : 02c0006f;   % 1281: 	j Check_Y_Offset %
000007c3 : 004e02b3;   % 1283: 		add t0,t3,tp %
000007c4 : 00029663;   % 1284: 		bnez t0, TryRightOffset  # If t3 (current colum, i.e., current X) = 0, it's on the left border %
000007c5 : 00100f93;   % 1285: 		li t6,1			         # t6 = 1: Cropping leftmost tile %
000007c6 : 0400006f;   % 1286: 		j START_RENDER_MAP  	 # start rendering process %
000007c7 : 01400293;   % 1288: 		li t0, 20    # screen width related to matrix = 20 %
000007c8 : 41c282b3;   % 1289: 		sub t0,t0,t3             # t0 = screen width - t3 (current X)  %
000007c9 : 404282b3;   % 1290: 		sub t0,t0,tp             # t0 = screen width - t3 (current X) - tp (X dislocation)  %
000007ca : 00501463;   % 1291: 		bne zero, t0, NoX_Offset # If t0 <= 0 (t3 + tp >= 20), it's on the right border %
000007cb : 00200f93;   % 1292: 		li t6,2			 # t6 = 2: Cropping rightmost tile %
000007cc : 0280006f;   % 1294: 		j START_RENDER_MAP	 # start rendering process %
000007cd : 00071463;   % 1297: 	bnez a4, Y_Offset		 # Or a Y offset, go to offset operations %
000007ce : 0200006f;   % 1298: 	j START_RENDER_MAP %
000007cf : 00039663;   % 1301: 		bnez t2, TryBottomOffset # If t3 (current colum, i.e., current X) = 0, it's on the top border %
000007d0 : 00100f93;   % 1302: 		li t6,1			 # t6 = 1: Cropping uppermost tile %
000007d1 : 0140006f;   % 1303: 		j START_RENDER_MAP	 # start rendering process %
000007d2 : 00f00293;   % 1305: 		li t0, 15   # screen height related to matrix = 15 %
000007d3 : 00539463;   % 1306: 		bne t2, t0, NoY_Offset   # If t2 = 15, it's on the lower border %
000007d4 : 00200f93;   % 1307: 		li t6,2			 # t6 = 2: Cropping lowermost tile %
000007d5 : 0040006f;   % 1309: 		j START_RENDER_MAP	 # start rendering process %
000007d6 : 06031863;   % 1312: 	bnez t1,NormalRender %
000007d7 : 00000513;   % 1314: 		li a0, 0x00 		# Black %
000007d8 : 01d005b3;   % 1315: 		mv a1, t4		# Top Left X %
000007d9 : 01e00633;   % 1316: 		mv a2, t5		# Top Left Y	 %
000007da : 00000833;   % 1317: 		mv a6, zero %
000007db : 000f9463;   % 1319: 		bnez t6, CropColor  %
000007dc : 03c0006f;   % 1320: 		j NoCropColor %
000007dd : 00100813;   % 1322: 		li a6, 1 %
000007de : ffff8f93;   % 1323: 		addi t6,t6,-1 %
000007df : 000f9a63;   % 1324: 		bnez t6, RightBottomColorCrop %
000007e0 : 01000293;   % 1326: 				li t0, 16	 %
000007e1 : 40d286b3;   % 1327: 				sub a3,t0, a3		# a3 will hold rendering widht that is equal to the tile size (16) - X offset %
000007e2 : 40e28733;   % 1328: 				sub a4,t0, a4		# a4 will hold rendering height that is equal to the tile size (16) - Y offset %
000007e3 : 0300006f;   % 1329: 				j StartColorRender %
000007e4 : 40d585b3;   % 1331: 				sub a1,a1,a3		# a1 will shift left the ammount of a3 (currently X offset)  %
000007e5 : 40e60633;   % 1332: 				sub a2,a2,a4		# a2 will shift up the ammount of a4 (currently Y offset) %
000007e6 : 00069463;   % 1334: 				bnez a3, CheckYColor # If X offset (a3) isn't zero, the widht for rendering the cropped tile will be the X offset %
000007e7 : 01000693;   % 1335: 				li a3, 16	    # otherwise, it'll be the tile size %
000007e8 : 00071463;   % 1337: 				bnez a4, EndRightBottomCropColor # If Y offset (a4) isn't zero, the widht for rendering the cropped tile will be the Y offset %
000007e9 : 01000713;   % 1338: 				li a4, 16	    # otherwise, it'll be the tile size %
000007ea : 0140006f;   % 1340: 				j StartColorRender %
000007eb : 40d585b3;   % 1342: 			sub a1,a1,a3		# a1 will shift left the ammount of a3 (currently X offset)  %
000007ec : 40e60633;   % 1343: 			sub a2,a2,a4		# a2 will shift up the ammount of a4 (currently Y offset)	 %
000007ed : 01000693;   % 1344: 			li a3, 16	# Tile Width (Screen) %
000007ee : 01000713;   % 1345: 			li a4, 16	# Tile Height (Screen)	 %
000007ef : fffff317;   % 1348: 		call RENDER_COLOR %
000007f0 : 540300e7;   % 1348:  %
000007f1 : 0840006f;   % 1349: 		j EndRender %
000007f2 : 01d005b3;   % 1353: 		mv a1, t4		# Top Left X where tile will start rendering %
000007f3 : 01e00633;   % 1354: 		mv a2, t5		# Top Left Y where tile will start rendering			 %
000007f4 : 000f9463;   % 1357: 		bnez t6, Continue_Crop  %
000007f5 : 0580006f;   % 1358: 		j Skip_Offset %
000007f6 : 00100893;   % 1360: 		li a7,1			# Cropped Render operations %
000007f7 : ffff8f93;   % 1361: 		addi t6,t6,-1		# After this, t6 = 0 or t6 = 1 %
000007f8 : 020f9063;   % 1362: 		bnez t6, RightBottomCrop %
000007f9 : 00d004b3;   % 1364: 			mv s1, a3		# s1 will store the X offset (where rendering will start from) %
000007fa : 00e00933;   % 1365: 			mv s2, a4		# s2 will store the Y offset (where rendering will start from) %
000007fb : 01000993;   % 1366: 			li s3, 16	# s3 = 16 %
000007fc : 01000a13;   % 1367: 			li s4, 16	# s4 = 16 %
000007fd : 409986b3;   % 1368: 			sub a3,s3, s1		# a3 will hold rendering widht that is equal to the tile size (16) - X offset %
000007fe : 41298733;   % 1369: 			sub a4,s3, s2		# a4 will hold rendering height that is equal to the tile size (16) - Y offset %
000007ff : 0440006f;   % 1370: 			j Start_NormalRender %
00000800 : 000004b3;   % 1372: 			mv s1,zero		# s1 = 0 (rendering will start from the left) %
00000801 : 00000933;   % 1373: 			mv s2,zero		# s2 = 0 (rendering will start from the top) %
00000802 : 01000993;   % 1374: 			li s3, 16	# s3 = 16 %
00000803 : 01000a13;   % 1375: 			li s4, 16	# s4 = 16 %
00000804 : 40d585b3;   % 1376: 			sub a1,a1,a3		# a1 will shift left the ammount of a3 (currently X offset)  %
00000805 : 40e60633;   % 1377: 			sub a2,a2,a4		# a2 will shift up the ammount of a4 (currently Y offset) %
00000806 : 00069463;   % 1379: 			bnez a3, CheckY # If X offset (a3) isn't zero, the widht for rendering the cropped tile will be the X offset %
00000807 : 01000693;   % 1380: 			li a3, 16	    # otherwise, it'll be the tile size %
00000808 : 00071463;   % 1382: 			bnez a4, EndRightBottomCrop # If Y offset (a4) isn't zero, the widht for rendering the cropped tile will be the Y offset %
00000809 : 01000713;   % 1383: 			li a4, 16	    # otherwise, it'll be the tile size %
0000080a : 0180006f;   % 1385: 			j Start_NormalRender %
0000080b : 40d585b3;   % 1388: 		sub a1,a1,a3		# a1 will shift left the ammount of a3 (currently X offset)  %
0000080c : 40e60633;   % 1389: 		sub a2,a2,a4		# a2 will shift up the ammount of a4 (currently Y offset)  %
0000080d : 01000693;   % 1390: 		li a3, 16	# Tile Width (Relative to Screen) %
0000080e : 01000713;   % 1391: 		li a4, 16	# Tile Height (Relative to Screen) %
0000080f : 000008b3;   % 1392: 		mv a7,zero		# Normal Render operations %
00000810 : fffff317;   % 1394: 		call RENDER_WORD %
00000811 : 430300e7;   % 1394:  %
00000812 : 03412a03;   % 1398: 	lw s4,52(sp) %
00000813 : 03012983;   % 1399: 	lw s3,48(sp) %
00000814 : 02c12903;   % 1400: 	lw s2,44(sp) %
00000815 : 02812483;   % 1401: 	lw s1,40(sp) %
00000816 : 02412883;   % 1402: 	lw a7,36(sp) %
00000817 : 02012803;   % 1403: 	lw a6,32(sp) %
00000818 : 01c12703;   % 1404: 	lw a4,28(sp) %
00000819 : 01812683;   % 1405: 	lw a3,24(sp) %
0000081a : 01412603;   % 1406: 	lw a2,20(sp) %
0000081b : 01012583;   % 1407: 	lw a1,16(sp) %
0000081c : 00c12503;   % 1408: 	lw a0,12(sp) %
0000081d : 00812383;   % 1409: 	lw t2,8(sp) %
0000081e : 00412e03;   % 1410: 	lw t3,4(sp) %
0000081f : 00012203;   % 1411: 	lw tp,0(sp) %
00000820 : 03810113;   % 1412: 	addi sp,sp,56 %
00000821 : 001e0e13;   % 1415: 	addi t3,t3,1	# Increments column counter (current X on Matrix) %
00000822 : 00140413;   % 1416: 	addi s0,s0,1	# Goes to next byte %
00000823 : 013e5463;   % 1417: 	bge t3,s3,CONTINUE_LINE	# if column counter >= width, repeat %
00000824 : d09ff06f;   % 1418: 	j RENDER_MAP_LOOP	# if column counter < width, repeat %
00000825 : 00940433;   % 1421: 		add s0,s0,s1	# s0 = Current Address on Matrix + Matrix Width %
00000826 : 01400293;   % 1422: 		li t0, 20 %
00000827 : 00585863;   % 1423: 		bge a6,t0, MINUS_WIDTH # If width = 20, probably not on remove trail mode %
00000828 : 41040433;   % 1424: 		sub s0,s0,a6	# s0 = New Current Address on Matrix  %
00000829 : 410e0e33;   % 1425: 		sub t3,t3,a6	# t3 = 0 (resets column counter) %
0000082a : 00c0006f;   % 1426: 		j CONTINUE_LINE2 %
0000082b : 41340433;   % 1428: 		sub s0,s0,s3 %
0000082c : 00000e33;   % 1429: 		mv t3,zero	# t3 = 0 (resets column counter) %
0000082d : 00138393;   % 1432: 		addi t2,t2,1	# Increments line counter (current Y on Matrix) %
0000082e : 0123d463;   % 1433: 		bge t2,s2,CONTINUE_COLUMN # If height > line counter, repeat %
0000082f : cddff06f;   % 1434: 		j RENDER_MAP_LOOP	  # Return to beggining of loop %
00000830 : 01012083;   % 1437: 		lw ra,16(sp)	 %
00000831 : 00c12983;   % 1438: 		lw s3,12(sp) %
00000832 : 00812903;   % 1439: 		lw s2,8(sp) %
00000833 : 00412483;   % 1440: 		lw s1,4(sp) %
00000834 : 00012403;   % 1441: 		lw s0,0(sp) %
00000835 : 01410113;   % 1442: 		addi sp,sp,20 %
00000836 : 00008067;   % 1444: 		ret %
00000837 : ffc10113;   % 9:     addi sp,sp,-4 %
00000838 : 00112023;   % 10:     sw ra,0(sp) %
00000839 : 00000317;   % 12:     call ZOOMER_OPERATIONS        # Checks zoomers %
0000083a : 038300e7;   % 12:  %
0000083b : 00000317;   % 14:     call RIPPER_OPERATIONS        # Checks rippers %
0000083c : 260300e7;   % 14:  %
0000083d : 0fc0e297;   % 16:     la t0,CURRENT_MAP             # Loads map address %
0000083e : 00c28293;   % 16:  %
0000083f : 0042c283;   % 17:     lbu t0,4(t0)                  # and from it, loads map's number %
00000840 : 00700313;   % 18:     li t1,7                       # Loads 7 to compare with map's number %
00000841 : 00629663;   % 19:     bne t0,t1,SKIP_RIDLEY         # If not on map 7, skip Ridley >:D %
00000842 : 00000317;   % 20:         call RIDLEY_OPERATIONS    # Checks Ridley %
00000843 : 3a0300e7;   % 20:  %
00000844 : 00012083;   % 23:     lw ra,0(sp) %
00000845 : 00410113;   % 24:     addi sp,sp,4 %
00000846 : 00008067;   % 26: ret %
00000847 : ffc10113;   % 44:     addi sp,sp,-4 %
00000848 : 00112023;   % 45:     sw ra,0(sp) %
00000849 : 0fc0e517;   % 47:     la a0,Zoomers  # Loads Zoomers address %
0000084a : 03850513;   % 47:  %
0000084b : 0fc0e217;   % 48:     la tp, CURRENT_MAP # Loads CURRENT_MAP address %
0000084c : fd420213;   % 48:  %
0000084d : 00052503;   % 50:     lw a0,0(a0)    # Loads the ZoomersA address over the Zoomers address %
0000084e : 00051463;   % 51:     bnez a0,CONTINUE_ZOOMER_OPERATIONS # If a0 = 0, there are no zoomers in this map %
0000084f : 2040006f;   % 52:         j END_ZOOMER_OPERATIONS_LOOP %
00000850 : 00054583;   % 56:     lbu a1,0(a0)   # Loads number of Zoomers in current map %
00000851 : 00000613;   % 58:     li a2,0        # Counter for zoomers %
00000852 : 00150513;   % 59:     addi a0,a0,1   # Goes to next byte (where zoomers from current map start) %
00000853 : 00624283;   % 62:         lbu t0,6(tp) # Loads map's current X %
00000854 : 00454783;   % 63:         lbu a5,4(a0) # Loads zoomer's current X %
00000855 : 00400393;   % 64:         li t2,4  # Loads 4 (render distance) %
00000856 : 40728e33;   % 65:         sub t3,t0,t2 # Gets leftmost threshold to manage zoomer %
00000857 : 1dc7ca63;   % 67:         blt a5,t3,NEXT_IN_ZOOMER_OPERATIONS_LOOP # If zoomer's X isn't inside left border, go to next %
00000858 : 00728e33;   % 69:         add t3,t0,t2 # Calculate rightmost threshold to manage zoomer %
00000859 : 014e0e13;   % 70:         addi t3,t3,20 # finishing calculating threshold %
0000085a : 1dc7d463;   % 71:         bge a5,t3,NEXT_IN_ZOOMER_OPERATIONS_LOOP # If zoomer's X isn't inside right border, go to next %
0000085b : 00724303;   % 74:         lbu t1,7(tp) # Loads map's current Y %
0000085c : 00654703;   % 75:         lbu a4,6(a0) # Loads zoomer's current Y %
0000085d : 40730e33;   % 77:         sub t3,t1,t2 # Gets uppermost threshold to manage zoomer %
0000085e : 1bc74c63;   % 78:         blt a4,t3,NEXT_IN_ZOOMER_OPERATIONS_LOOP # If zoomer's X isn't inside upper border, go to next %
0000085f : 00730e33;   % 80:         add t3,t1,t2 # Calculate lowermost threshold to manage zoomer %
00000860 : 00fe0e13;   % 81:         addi t3,t3,15 # finishing calculating threshold %
00000861 : 1bc75663;   % 82:         bge a4,t3,NEXT_IN_ZOOMER_OPERATIONS_LOOP # If zoomer's X isn't inside lower border, go to next %
00000862 : fdc10113;   % 86:             addi sp,sp,-36 %
00000863 : 00912023;   % 87:             sw s1,0(sp) %
00000864 : 01212223;   % 88:             sw s2,4(sp) %
00000865 : 01312423;   % 89:             sw s3,8(sp) %
00000866 : 01412623;   % 90:             sw s4,12(sp) %
00000867 : 00a12823;   % 91:             sw a0,16(sp) %
00000868 : 00b12a23;   % 92:             sw a1,20(sp) %
00000869 : 00c12c23;   % 93:             sw a2,24(sp) %
0000086a : 00d12e23;   % 94:             sw a3,28(sp) %
0000086b : 02412023;   % 95:             sw tp,32(sp) %
0000086c : 00022583;   % 99:             lw a1,0(tp) %
0000086d : 00003317;   % 100:             call MOVE_ZOOMER %
0000086e : 8c4300e7;   % 100:  %
0000086f : 01012503;   % 103:             lw a0,16(sp) # Gets a0 from stack again %
00000870 : 02012203;   % 104:             lw tp,32(sp) # Gets tp from stack again %
00000871 : 00454583;   % 105:             lbu a1,4(a0) # Loads zoomer's current X %
00000872 : 00624283;   % 106:             lbu t0,6(tp) # Loads map's current X %
00000873 : 405585b3;   % 107:             sub a1,a1,t0 # Gets the X matrix related to the map's X (a1 = zoomer's X - map's X) %
00000874 : 00459593;   % 108:             slli a1,a1,4 # Multiplies a5 by 16 in order to get X related to screen %
00000875 : 00254283;   % 109:             lbu t0,2(a0) # Loads zoomer's X offset %
00000876 : 005585b3;   % 110:             add a1,a1,t0 # Adds offset to position %
00000877 : 00824283;   % 111:             lbu t0,8(tp) # Loads map's X offset %
00000878 : 405585b3;   % 112:             sub a1,a1,t0 # and takes it from zoomer's position %
00000879 : 00654603;   % 116:             lbu a2,6(a0) # Loads zoomer's current Y %
0000087a : 00724303;   % 117:             lbu t1,7(tp) # Loads map's current Y %
0000087b : 40660633;   % 118:             sub a2,a2,t1 # Gets the Y matrix related to the map's Y (a2 = zoomer's Y - map's Y) %
0000087c : 00461613;   % 119:             slli a2,a2,4 # Multiplies a2 by 16 in order to get Y related to screen %
0000087d : 00354283;   % 120:             lbu t0,3(a0) # Loads zoomer's Y offset %
0000087e : 00560633;   % 121:             add a2,a2,t0 # Adds offset to position %
0000087f : 00924303;   % 122:             lbu t1,9(tp) # Loads map's Y offset %
00000880 : 40660633;   % 123:             sub a2,a2,t1 # and takes it from zoomer's position %
00000881 : 01000693;   % 125:             li a3,16   # 16 = width of rendering area %
00000882 : 01000713;   % 126:             li a4,16   # 16 = height of rendering area %
00000883 : 008007b3;   % 127:             mv a5,s0          # gets frame to be rendered on %
00000884 : 00854803;   % 129:             lbu a6,8(a0)      # Loads zoomer's status is its direction %
00000885 : 00184813;   % 130:             xori a6,a6,1      # switches it %
00000886 : 01050423;   % 131:             sb a6,8(a0)       # and stores it back for using next time %
00000887 : 00154283;   % 133:             lbu t0,1(a0)      # gets zoomer's type number %
00000888 : 00a54303;   % 134:             lbu t1,10(a0)     # gets zoomer's platform %
00000889 : 02031a63;   % 136:             bnez t1,ZOOMER_OPERATIONS_LOOP_TRY_LEFT %
0000088a : 00029863;   % 138:                 bnez t0,ZOOMER_OPERATIONS_LOOP_DOWN_NOT_NORMAL %
0000088b : 0fc1c517;   % 140:                     la a0,Zoomer_Down %
0000088c : b3850513;   % 140:  %
0000088d : 0c40006f;   % 141:                     j ZOOMER_OPERATIONS_LOOP_RENDER %
0000088e : 00100393;   % 142:                 ZOOMER_OPERATIONS_LOOP_DOWN_NOT_NORMAL:li t2,1 %
0000088f : 00729863;   % 143:                 bne t0,t2,ZOOMER_OPERATIONS_LOOP_DOWN_DAMAGE %
00000890 : 0fc1c517;   % 145:                     la a0,Zoomer_Variant_Down %
00000891 : 32450513;   % 145:  %
00000892 : 0b00006f;   % 146:                     j ZOOMER_OPERATIONS_LOOP_RENDER %
00000893 : 0fc1d517;   % 149:                     la a0,Zoomer_Damage_Down %
00000894 : b1850513;   % 149:  %
00000895 : 0a40006f;   % 150:                     j ZOOMER_OPERATIONS_LOOP_RENDER %
00000896 : 00100393;   % 152:             ZOOMER_OPERATIONS_LOOP_TRY_LEFT: li t2,1 %
00000897 : 02731a63;   % 153:             bne t1,t2,ZOOMER_OPERATIONS_LOOP_TRY_UP %
00000898 : 00029863;   % 155:                 bnez t0,ZOOMER_OPERATIONS_LOOP_LEFT_NOT_NORMAL %
00000899 : 0fc1c517;   % 157:                     la a0,Zoomer_Left %
0000089a : d0050513;   % 157:  %
0000089b : 08c0006f;   % 158:                     j ZOOMER_OPERATIONS_LOOP_RENDER %
0000089c : 00100393;   % 159:                 ZOOMER_OPERATIONS_LOOP_LEFT_NOT_NORMAL:li t2,1 %
0000089d : 00729863;   % 160:                 bne t0,t2,ZOOMER_OPERATIONS_LOOP_LEFT_DAMAGE %
0000089e : 0fc1c517;   % 162:                     la a0,Zoomer_Variant_Left %
0000089f : 4ec50513;   % 162:  %
000008a0 : 0780006f;   % 163:                     j ZOOMER_OPERATIONS_LOOP_RENDER %
000008a1 : 0fc1d517;   % 166:                     la a0,Zoomer_Damage_Left %
000008a2 : ce050513;   % 166:  %
000008a3 : 06c0006f;   % 167:                     j ZOOMER_OPERATIONS_LOOP_RENDER %
000008a4 : 00200393;   % 169:             ZOOMER_OPERATIONS_LOOP_TRY_UP: li t2,2 %
000008a5 : 02731a63;   % 170:             bne t1,t2,ZOOMER_OPERATIONS_LOOP_RIGHT %
000008a6 : 00029863;   % 172:                 bnez t0,ZOOMER_OPERATIONS_LOOP_UP_NOT_NORMAL %
000008a7 : 0fc1c517;   % 174:                     la a0,Zoomer_Up %
000008a8 : ec850513;   % 174:  %
000008a9 : 0540006f;   % 175:                     j ZOOMER_OPERATIONS_LOOP_RENDER %
000008aa : 00100393;   % 176:                 ZOOMER_OPERATIONS_LOOP_UP_NOT_NORMAL:li t2,1 %
000008ab : 00729863;   % 177:                 bne t0,t2,ZOOMER_OPERATIONS_LOOP_UP_DAMAGE %
000008ac : 0fc1c517;   % 179:                     la a0,Zoomer_Variant_Up %
000008ad : 6b450513;   % 179:  %
000008ae : 0400006f;   % 180:                     j ZOOMER_OPERATIONS_LOOP_RENDER %
000008af : 0fc1d517;   % 183:                     la a0,Zoomer_Damage_Up %
000008b0 : ea850513;   % 183:  %
000008b1 : 0340006f;   % 184:                     j ZOOMER_OPERATIONS_LOOP_RENDER %
000008b2 : 00029863;   % 188:                 bnez t0,ZOOMER_OPERATIONS_LOOP_RIGHT_NOT_NORMAL %
000008b3 : 0fc1c517;   % 190:                     la a0,Zoomer_Right %
000008b4 : 09850513;   % 190:  %
000008b5 : 0240006f;   % 191:                     j ZOOMER_OPERATIONS_LOOP_RENDER %
000008b6 : 00100393;   % 192:                 ZOOMER_OPERATIONS_LOOP_RIGHT_NOT_NORMAL:li t2,1 %
000008b7 : 00729863;   % 193:                 bne t0,t2,ZOOMER_OPERATIONS_LOOP_RIGHT_DAMAGE %
000008b8 : 0fc1d517;   % 195:                     la a0,Zoomer_Variant_Right %
000008b9 : 88450513;   % 195:  %
000008ba : 0100006f;   % 196:                     j ZOOMER_OPERATIONS_LOOP_RENDER %
000008bb : 0fc1d517;   % 199:                     la a0,Zoomer_Damage_Right %
000008bc : 07850513;   % 199:  %
000008bd : 0040006f;   % 200:                     j ZOOMER_OPERATIONS_LOOP_RENDER %
000008be : 00000893;   % 203:                 li a7,0             # Normal render %
000008bf : fffff317;   % 204:                 call RENDER_ENTITY  # Renders it %
000008c0 : 66c300e7;   % 204:  %
000008c1 : 0040006f;   % 205:                 j ZOOMER_OPERATIONS_LOOP_AFTER_OPERATIONS %
000008c2 : 00012483;   % 213:             lw s1,0(sp) %
000008c3 : 00412903;   % 214:             lw s2,4(sp) %
000008c4 : 00812983;   % 215:             lw s3,8(sp) %
000008c5 : 00c12a03;   % 216:             lw s4,12(sp) %
000008c6 : 01012503;   % 217:             lw a0,16(sp) %
000008c7 : 01412583;   % 218:             lw a1,20(sp) %
000008c8 : 01812603;   % 219:             lw a2,24(sp) %
000008c9 : 01c12683;   % 220:             lw a3,28(sp) %
000008ca : 02012203;   % 221:             lw tp,32(sp) %
000008cb : 02410113;   % 222:             addi sp,sp,36 %
000008cc : 00c50513;   % 226:             addi a0,a0,12  # Going to the next zoomer's address                                   %
000008cd : 00160613;   % 227:             addi a2,a2,1            # Iterating counter by 1                                    %
000008ce : 00b65463;   % 228:             bge a2,a1, END_ZOOMER_OPERATIONS_LOOP # If all of the zoomer's were checked, end loop                                   %
000008cf : e11ff06f;   % 229:             j ZOOMER_OPERATIONS_LOOP # otherwise, go back to the loop's beginning                      %
000008d0 : 00012083;   % 233:         lw ra,0(sp) %
000008d1 : 00410113;   % 234:         addi sp,sp,4 %
000008d2 : 00008067;   % 236:         ret %
000008d3 : ffc10113;   % 256:     addi sp,sp,-4 %
000008d4 : 00112023;   % 257:     sw ra,0(sp) %
000008d5 : 0fc0e517;   % 260:     la a0,Rippers  # Loads Rippers address %
000008d6 : fc450513;   % 260:  %
000008d7 : 0fc0e217;   % 261:     la tp, CURRENT_MAP # Loads CURRENT_MAP address %
000008d8 : da420213;   % 261:  %
000008d9 : 00052503;   % 263:     lw a0,0(a0)    # Loads the RippersA address over the Rippers address %
000008da : 12051a63;   % 264:     bnez a0,END_RIPPER_OPERATIONS_LOOP # If a0 = 0, there are no rippers in this map %
000008db : 1300006f;   % 265:         j END_RIPPER_OPERATIONS_LOOP %
000008dc : 00054583;   % 269:     lbu a1,0(a0)   # Loads number of Rippers in current map %
000008dd : 00000613;   % 271:     li a2,0        # Counter for rippers %
000008de : 00150513;   % 272:     addi a0,a0,1   # Goes to next byte (where rippers from current map start) %
000008df : 00624283;   % 275:         lbu t0,6(tp) # Loads map's current X %
000008e0 : 00354783;   % 276:         lbu a5,3(a0) # Loads ripper's current X %
000008e1 : 00400393;   % 277:         li t2,4  # Loads 4 (render distance) %
000008e2 : 40728e33;   % 278:         sub t3,t0,t2 # Gets leftmost threshold to manage ripper %
000008e3 : 11c7c063;   % 279:         blt a5,t3,NEXT_IN_RIPPER_OPERATIONS_LOOP # If ripper's X isn't inside left border, go to next %
000008e4 : 00728e33;   % 281:         add t3,t0,t2 # Calculate rightmost threshold to manage ripper %
000008e5 : 014e0e13;   % 282:         addi t3,t3,20 # finishing calculating threshold %
000008e6 : 0fc7da63;   % 283:         bge a5,t3,NEXT_IN_RIPPER_OPERATIONS_LOOP # If ripper's X isn't inside right border, go to next %
000008e7 : 00724303;   % 286:         lbu t1,7(tp) # Loads map's current Y %
000008e8 : 00554703;   % 287:         lbu a4,5(a0) # Loads ripper's current Y %
000008e9 : 40730e33;   % 289:         sub t3,t1,t2 # Gets uppermost threshold to manage ripper %
000008ea : 0fc74263;   % 290:         blt a4,t3,NEXT_IN_RIPPER_OPERATIONS_LOOP # If ripper's X isn't inside upper border, go to next %
000008eb : 00730e33;   % 292:         add t3,t1,t2 # Calculate lowermost threshold to manage ripper %
000008ec : 00fe0e13;   % 293:         addi t3,t3,15 # finishing calculating threshold %
000008ed : 0dc75c63;   % 294:         bge a4,t3,NEXT_IN_RIPPER_OPERATIONS_LOOP # If ripper's X isn't inside lower border, go to next %
000008ee : fdc10113;   % 298:             addi sp,sp,-36 %
000008ef : 00912023;   % 299:             sw s1,0(sp) %
000008f0 : 01212223;   % 300:             sw s2,4(sp) %
000008f1 : 01312423;   % 301:             sw s3,8(sp) %
000008f2 : 01412623;   % 302:             sw s4,12(sp) %
000008f3 : 00a12823;   % 303:             sw a0,16(sp) %
000008f4 : 00b12a23;   % 304:             sw a1,20(sp) %
000008f5 : 00c12c23;   % 305:             sw a2,24(sp) %
000008f6 : 00d12e23;   % 306:             sw a3,28(sp) %
000008f7 : 02412023;   % 307:             sw tp,32(sp) %
000008f8 : 00022583;   % 311:             lw a1,0(tp) %
000008f9 : 00003317;   % 312:             call MOVE_RIPPER %
000008fa : bf4300e7;   % 312:  %
000008fb : 01012503;   % 315:             lw a0,16(sp) # Gets a0 from stack again %
000008fc : 02012203;   % 316:             lw tp,32(sp) # Gets tp from stack again %
000008fd : 00354583;   % 317:             lbu a1,3(a0) # Loads ripper's current X %
000008fe : 00624283;   % 318:             lbu t0,6(tp) # Loads map's current X %
000008ff : 405585b3;   % 319:             sub a1,a1,t0 # Gets the X matrix related to the map's X (a1 = ripper's X - map's X) %
00000900 : 00459593;   % 320:             slli a1,a1,4 # Multiplies a5 by 16 in order to get X related to screen %
00000901 : 00254283;   % 321:             lbu t0,2(a0) # Loads ripper's X offset %
00000902 : 005585b3;   % 322:             add a1,a1,t0 # Adds offset to position %
00000903 : 00824283;   % 323:             lbu t0,8(tp) # Loads map's X offset %
00000904 : 405585b3;   % 324:             sub a1,a1,t0 # and takes it from ripper's position %
00000905 : 00554603;   % 328:             lbu a2,5(a0) # Loads ripper's current Y %
00000906 : 00724303;   % 329:             lbu t1,7(tp) # Loads map's current Y %
00000907 : 40660633;   % 330:             sub a2,a2,t1 # Gets the Y matrix related to the map's Y (a2 = ripper's Y - map's Y) %
00000908 : 00461613;   % 331:             slli a2,a2,4 # Multiplies a2 by 16 in order to get Y related to screen %
00000909 : 00924303;   % 333:             lbu t1,9(tp) # Loads map's Y offset %
0000090a : 40660633;   % 334:             sub a2,a2,t1 # and takes it from ripper's position %
0000090b : 01000693;   % 335:             li a3,16   # 16 = width of rendering area %
0000090c : 01000713;   % 336:             li a4,16   # 16 = height of rendering area %
0000090d : 008007b3;   % 337:             mv a5,s0          # gets frame to be rendered on %
0000090e : 00154803;   % 338:             lbu a6,1(a0)      # ripper's status is its direction %
0000090f : 00054503;   % 340:             lbu a0,0(a0)      # gets ripper's type number %
00000910 : 00050863;   % 341:             beqz a0,RIPPER_OPERATIONS_LOOP_RENDER_NORMAL %
00000911 : 0fc1d517;   % 342:                 la a0,Ripper_Variant  # loads image address of red ripper %
00000912 : 32050513;   % 342:  %
00000913 : 00c0006f;   % 343:                 j RIPPER_OPERATIONS_LOOP_RENDER %
00000914 : 0fc1d517;   % 345:                 la a0,Ripper  # loads image address of normal ripper %
00000915 : 11450513;   % 345:  %
00000916 : 00000893;   % 347:                 li a7,0             # Normal render %
00000917 : fffff317;   % 348:                 call RENDER_ENTITY  # Renders it %
00000918 : 50c300e7;   % 348:  %
00000919 : 00012483;   % 353:             lw s1,0(sp) %
0000091a : 00412903;   % 354:             lw s2,4(sp) %
0000091b : 00812983;   % 355:             lw s3,8(sp) %
0000091c : 00c12a03;   % 356:             lw s4,12(sp) %
0000091d : 01012503;   % 357:             lw a0,16(sp) %
0000091e : 01412583;   % 358:             lw a1,20(sp) %
0000091f : 01812603;   % 359:             lw a2,24(sp) %
00000920 : 01c12683;   % 360:             lw a3,28(sp) %
00000921 : 02012203;   % 361:             lw tp,32(sp) %
00000922 : 02410113;   % 362:             addi sp,sp,36 %
00000923 : 00750513;   % 366:             addi a0,a0,7  # Going to the next ripper's address                                   %
00000924 : 00160613;   % 367:             addi a2,a2,1            # Iterating counter by 1                                    %
00000925 : 00b65463;   % 368:             bge a2,a1, END_RIPPER_OPERATIONS_LOOP # If all of the ripper's were checked, end loop                                   %
00000926 : ee5ff06f;   % 369:             j RIPPER_OPERATIONS_LOOP # otherwise, go back to the loop's beginning                      %
00000927 : 00012083;   % 373:         lw ra,0(sp) %
00000928 : 00410113;   % 374:         addi sp,sp,4 %
00000929 : 00008067;   % 376:         ret %
0000092a : ffc10113;   % 395:     addi sp,sp,-4 %
0000092b : 00112023;   % 396:     sw ra,0(sp) %
0000092c : 0fc0e517;   % 399:     la a0,RIDLEY_INFO  # Loads Ridley's address %
0000092d : eb450513;   % 399:  %
0000092e : 0fc0e217;   % 400:     la tp, CURRENT_MAP # Loads CURRENT_MAP address %
0000092f : c4820213;   % 400:  %
00000930 : fdc10113;   % 403:     addi sp,sp,-36 %
00000931 : 00912023;   % 404:     sw s1,0(sp) %
00000932 : 01212223;   % 405:     sw s2,4(sp) %
00000933 : 01312423;   % 406:     sw s3,8(sp) %
00000934 : 01412623;   % 407:     sw s4,12(sp) %
00000935 : 00a12823;   % 408:     sw a0,16(sp) %
00000936 : 00b12a23;   % 409:     sw a1,20(sp) %
00000937 : 00c12c23;   % 410:     sw a2,24(sp) %
00000938 : 00d12e23;   % 411:     sw a3,28(sp) %
00000939 : 02412023;   % 412:     sw tp,32(sp) %
0000093a : 00022583;   % 416:     lw a1,0(tp) %
0000093b : 00003317;   % 417:     call MOVE_RIDLEY %
0000093c : bdc300e7;   % 417:  %
0000093d : 01012503;   % 420:     lw a0,16(sp)     # Gets a0 from stack again %
0000093e : 02012203;   % 421:     lw tp,32(sp)     # Gets tp from stack again %
0000093f : 00900593;   % 422:     li a1,9   # Loads ridley's current X %
00000940 : fff58593;   % 423:     addi a1,a1,-1    # subtracts 1 from it (a sort of offset for rendering sprite in proper place) %
00000941 : 00624283;   % 424:     lbu t0,6(tp)     # Loads map's current X   %
00000942 : 405585b3;   % 425:     sub a1,a1,t0     # Gets the X matrix related to the map's X (a1 = ridley's X - map's X) %
00000943 : 00459593;   % 426:     slli a1,a1,4 # Multiplies a5 by 16 in order to get X related to screen %
00000944 : 00600293;   % 427:     li t0,6 # Loads ridley's X offset %
00000945 : 005585b3;   % 428:     add a1,a1,t0          # Adds offset to position %
00000946 : 00824283;   % 429:     lbu t0,8(tp)          # Loads map's X offset %
00000947 : 405585b3;   % 430:     sub a1,a1,t0          # and takes it from ridley's position %
00000948 : 00354603;   % 434:     lbu a2,3(a0) # Loads ridley's current Y %
00000949 : 00724303;   % 435:     lbu t1,7(tp) # Loads map's current Y %
0000094a : 40660633;   % 436:     sub a2,a2,t1 # Gets the Y matrix related to the map's Y (a2 = ridley's Y - map's Y) %
0000094b : 00461613;   % 437:     slli a2,a2,4 # Multiplies a2 by 16 in order to get Y related to screen %
0000094c : 00254283;   % 438:     lbu t0,2(a0) # Loads ridley's Y offset %
0000094d : 00560633;   % 439:     add a2,a2,t0 # Adds offset to position %
0000094e : 00924303;   % 440:     lbu t1,9(tp) # Loads map's Y offset %
0000094f : 40660633;   % 441:     sub a2,a2,t1 # and takes it from ridley's position %
00000950 : 02000693;   % 443:     li a3,32   # 16 = width of rendering area %
00000951 : 008007b3;   % 444:     mv a5,s0          # gets frame to be rendered on %
00000952 : 00554803;   % 446:     lbu a6,5(a0)      # Loads ridley's status is its direction %
00000953 : 00184813;   % 447:     xori a6,a6,1      # switches it %
00000954 : 010502a3;   % 448:     sb a6,5(a0)       # and stores it back for using next time %
00000955 : 05000293;   % 450:     li t0, 80              # Loads screen's Y threshold where jumping animation appears %
00000956 : 00154503;   % 451:     lbu a0,1(a0)                              # Gets ridley's type number %
00000957 : 02c2d263;   % 452:     bge t0,a2,RIDLEY_OPERATIONS_RENDER_JUMP   # If Y (a2) <= 80, render jumping animation %
00000958 : 02800713;   % 454:         li a4,40   # 40 = height of rendering area %
00000959 : 00051863;   % 455:         bnez a0,RIDLEY_OPERATIONS_RENDER_DAMAGE %
0000095a : 0fc1d517;   % 457:             la a0,Ridley %
0000095b : 3fc50513;   % 457:  %
0000095c : 02c0006f;   % 458:             j RIDLEY_OPERATIONS_RENDER %
0000095d : 0fc1f517;   % 462:             la a0,Ridley_Damage %
0000095e : 9f050513;   % 462:  %
0000095f : 0200006f;   % 463:             j RIDLEY_OPERATIONS_RENDER %
00000960 : 03000713;   % 467:         li a4,48   # 48 = height of rendering area %
00000961 : 00051863;   % 468:         bnez a0,RIDLEY_OPERATIONS_RENDER_JUMP_DAMAGE %
00000962 : 0fc1e517;   % 470:             la a0,Ridley_Jump %
00000963 : ddc50513;   % 470:  %
00000964 : 00c0006f;   % 471:             j RIDLEY_OPERATIONS_RENDER %
00000965 : 0fc1f517;   % 475:             la a0,Ridley_Damage_Jump %
00000966 : 3d050513;   % 475:  %
00000967 : 00000893;   % 479:         li a7,0             # Normal render %
00000968 : fffff317;   % 480:         call RENDER_ENTITY  # Renders it %
00000969 : 3c8300e7;   % 480:  %
0000096a : 00012483;   % 485:     lw s1,0(sp) %
0000096b : 00412903;   % 486:     lw s2,4(sp) %
0000096c : 00812983;   % 487:     lw s3,8(sp) %
0000096d : 00c12a03;   % 488:     lw s4,12(sp) %
0000096e : 01012503;   % 489:     lw a0,16(sp) %
0000096f : 01412583;   % 490:     lw a1,20(sp) %
00000970 : 01812603;   % 491:     lw a2,24(sp) %
00000971 : 01c12683;   % 492:     lw a3,28(sp) %
00000972 : 02012203;   % 493:     lw tp,32(sp) %
00000973 : 02410113;   % 494:     addi sp,sp,36 %
00000974 : 00012083;   % 499:         lw ra,0(sp) %
00000975 : 00410113;   % 500:         addi sp,sp,4 %
00000976 : 00008067;   % 502:         ret %
00000977 : 0420d073;   % 107: 	csrwi ucause,1		# caso ocorra dropdown vai gerar exceï¿½ï¿½o de instruï¿½ï¿½o invï¿½lida %
00000978 : ff810113;   % 109: ExceptionHandling:	addi 	sp, sp, -8 	# salva 2 registradores utilizados para comparar ucause %
00000979 : 00512023;   % 110: 	sw 	t0, 0(sp) %
0000097a : 01a12223;   % 111: 	sw 	s10, 4(sp) %
0000097b : 04202d73;   % 113: 	csrr	s10,ucause     # le o ucause e salva em s10 %
0000097c : 00800293;   % 115: 	li 	t0, 8 %
0000097d : 01a29a63;   % 116: 	bne 	t0, s10, errorExceptions  	# Nï¿½o ï¿½ ecall - nem precisa arrumar a pilha! %
0000097e : 00012283;   % 118: 	lw 	t0, 0(sp)			# ï¿½ ecall %
0000097f : 00412d03;   % 119:     	lw 	s10, 4(sp)  			# recupera registradores usados %
00000980 : 00810113;   % 120:     	addi 	sp, sp, 8			 %
00000981 : 2080006f;   % 121: 	j 	ecallException %
00000982 : 04302df3;   % 127: errorExceptions: csrr 	s11, utval      # le o utval da exceï¿½ï¿½o e salva em s11	 %
00000983 : 0c000513;   % 128: 	addi 	a0, zero, 0xc0 		## printa tela de azul %
00000984 : 00000593;   % 129: 	addi 	a1, zero, 0 %
00000985 : 09400893;   % 130: 	addi 	a7, zero, 148 %
00000986 : 3ac010ef;   % 131: 	jal 	clsCLS %
00000987 : 00000293;   % 134: End_Cause0:	li 	t0, 0 %
00000988 : 03a29463;   % 135: 		bne 	t0, s10, End_Cause1 %
00000989 : 0fc21517;   % 136: 		la 	a0, Cause0 %
0000098a : 9cc50513;   % 136:  %
0000098b : 00000593;   % 137: 		li 	a1, 0 %
0000098c : 00100613;   % 138: 		li 	a2, 1 %
0000098d : 0000c6b7;   % 139: 		li 	a3, 0x0000c0ff %
0000098e : 0ff68693;   % 139:  %
0000098f : 00000793;   % 140: 		li 	a5,0 %
00000990 : 195000ef;   % 141: 		jal	printString %
00000991 : 18c0006f;   % 142: 		j	End_uepc %
00000992 : 00100293;   % 145: End_Cause1:	li 	t0, 1 %
00000993 : 03a29463;   % 146: 		bne 	t0, s10, End_Cause2 %
00000994 : 0fc21517;   % 147: 		la 	a0, Cause1 %
00000995 : 9c950513;   % 147:  %
00000996 : 00000593;   % 148: 		li 	a1, 0 %
00000997 : 00100613;   % 149: 		li 	a2, 1 %
00000998 : 0000c6b7;   % 150: 		li 	a3, 0x0000c0ff %
00000999 : 0ff68693;   % 150:  %
0000099a : 00000793;   % 151: 		li 	a5,0 %
0000099b : 169000ef;   % 152: 		jal	printString	 %
0000099c : 1600006f;   % 153: 		j	End_uepc %
0000099d : 00200293;   % 156: End_Cause2:	li 	t0, 2 %
0000099e : 03a29863;   % 157: 		bne 	t0, s10, End_Cause4 %
0000099f : 0fc21517;   % 158: 		la 	a0, Cause2 %
000009a0 : 9c050513;   % 158:  %
000009a1 : 00000593;   % 159: 		li 	a1, 0 %
000009a2 : 00100613;   % 160: 		li 	a2, 1 %
000009a3 : 0000c6b7;   % 161: 		li 	a3, 0x0000c0ff %
000009a4 : 0ff68693;   % 161:  %
000009a5 : 00000793;   % 162: 		li 	a5,0 %
000009a6 : 13d000ef;   % 163: 		jal	printString %
000009a7 : 0fc21517;   % 165: 		la 	a0, Instr %
000009a8 : a6650513;   % 165:  %
000009a9 : 0fc0006f;   % 166: 		j	End_utval %
000009aa : 00400293;   % 169: End_Cause4:	addi 	t0, zero, 4 %
000009ab : 03a29863;   % 170: 		bne	t0, s10, End_Cause5 %
000009ac : 0fc21517;   % 171: 		la 	a0, Cause4 %
000009ad : 9a950513;   % 171:  %
000009ae : 00000593;   % 172: 		li 	a1, 0 %
000009af : 00100613;   % 173: 		li 	a2, 1 %
000009b0 : 0000c6b7;   % 174: 		li 	a3, 0x0000c0ff %
000009b1 : 0ff68693;   % 174:  %
000009b2 : 00000793;   % 175: 		li 	a5,0 %
000009b3 : 109000ef;   % 176: 		jal	printString %
000009b4 : 0fc21517;   % 178: 		la 	a0, Addrs %
000009b5 : a2a50513;   % 178:  %
000009b6 : 0c80006f;   % 179: 		j	End_utval %
000009b7 : 00500293;   % 182: End_Cause5:	li 	t0, 5 %
000009b8 : 03a29863;   % 183: 		bne 	t0, s10, End_Cause6 %
000009b9 : 0fc21517;   % 184: 		la 	a0, Cause5 %
000009ba : 99750513;   % 184:  %
000009bb : 00000593;   % 185: 		li 	a1, 0 %
000009bc : 00100613;   % 186: 		li 	a2, 1 %
000009bd : 0000c6b7;   % 187: 		li 	a3, 0x0000c0ff %
000009be : 0ff68693;   % 187:  %
000009bf : 00000793;   % 188: 		li 	a5,0 %
000009c0 : 0d5000ef;   % 189: 		jal	printString	 %
000009c1 : 0fc21517;   % 191: 		la 	a0, Addrs %
000009c2 : 9f650513;   % 191:  %
000009c3 : 0940006f;   % 192: 		j	End_utval %
000009c4 : 00600293;   % 195: End_Cause6:	li 	t0, 6 %
000009c5 : 03a29863;   % 196: 		bne 	t0, s10, End_Cause7 %
000009c6 : 0fc21517;   % 197: 		la 	a0, Cause6 %
000009c7 : 97f50513;   % 197:  %
000009c8 : 00000593;   % 198: 		li 	a1, 0 %
000009c9 : 00100613;   % 199: 		li 	a2, 1 %
000009ca : 0000c6b7;   % 200: 		li 	a3, 0x0000c0ff %
000009cb : 0ff68693;   % 200:  %
000009cc : 00000793;   % 201: 		li 	a5,0 %
000009cd : 0a1000ef;   % 202: 		jal	printString %
000009ce : 0fc21517;   % 204: 		la 	a0, Addrs %
000009cf : 9c250513;   % 204:  %
000009d0 : 0600006f;   % 205: 		j	End_utval %
000009d1 : 00700293;   % 208: End_Cause7:	li 	t0, 7 %
000009d2 : 03a29863;   % 209: 		bne 	t0, s10, End_CauseD %
000009d3 : 0fc21517;   % 210: 		la 	a0, Cause7 %
000009d4 : 96e50513;   % 210:  %
000009d5 : 00000593;   % 211: 		li 	a1, 0 %
000009d6 : 00100613;   % 212: 		li 	a2, 1 %
000009d7 : 0000c6b7;   % 213: 		li 	a3, 0x0000c0ff %
000009d8 : 0ff68693;   % 213:  %
000009d9 : 00000793;   % 214: 		li 	a5,0 %
000009da : 06d000ef;   % 215: 		jal	printString %
000009db : 0fc21517;   % 217: 		la 	a0, Addrs %
000009dc : 98e50513;   % 217:  %
000009dd : 02c0006f;   % 218: 		j	End_utval %
000009de : 0fc21517;   % 221: End_CauseD: 	la 	a0, CauseD %
000009df : 95f50513;   % 221:  %
000009e0 : 00000593;   % 222: 		li 	a1, 0 %
000009e1 : 00100613;   % 223: 		li 	a2, 1 %
000009e2 : 0000c6b7;   % 224: 		li 	a3, 0x0000c0ff %
000009e3 : 0ff68693;   % 224:  %
000009e4 : 00000793;   % 225: 		li 	a5,0 %
000009e5 : 041000ef;   % 226: 		jal	printString %
000009e6 : 0fc21517;   % 228: 		la 	a0, Addrs %
000009e7 : 96250513;   % 228:  %
000009e8 : 00000593;   % 231: End_utval:	li 	a1, 0 %
000009e9 : 01800613;   % 232: 		li 	a2, 24 %
000009ea : 0000c6b7;   % 233: 		li 	a3, 0x000c0ff %
000009eb : 0ff68693;   % 233:  %
000009ec : 00000793;   % 234: 		li 	a5,0 %
000009ed : 021000ef;   % 235: 		jal	printString %
000009ee : 01b00533;   % 237: 		mv 	a0, s11 %
000009ef : 03800593;   % 238: 		li 	a1, 56 %
000009f0 : 01800613;   % 239: 		li 	a2, 24 %
000009f1 : 0000c6b7;   % 240: 		li 	a3, 0x0000c0ff %
000009f2 : 0ff68693;   % 240:  %
000009f3 : 794000ef;   % 241: 		jal 	printHex %
000009f4 : 0fc21517;   % 244: End_uepc: 	la 	a0, PC 		# Imprime o pc em que a exceï¿½ï¿½o ocorreu %
000009f5 : 92550513;   % 244:  %
000009f6 : 00000593;   % 245: 		li 	a1, 0 %
000009f7 : 00c00613;   % 246: 		li 	a2, 12 %
000009f8 : 0000c6b7;   % 247: 		li 	a3, 0x000c0ff %
000009f9 : 0ff68693;   % 247:  %
000009fa : 00000793;   % 248: 		li 	a5,0 %
000009fb : 7e8000ef;   % 249: 		jal	printString %
000009fc : 04102573;   % 251: 		csrr 	a0, uepc	# Le uepc	 %
000009fd : 01c00593;   % 252: 		li	a1, 28 %
000009fe : 00c00613;   % 253: 		li 	a2, 12 %
000009ff : 0000c6b7;   % 254: 		li 	a3, 0x0000c0ff %
00000a00 : 0ff68693;   % 254:  %
00000a01 : 75c000ef;   % 255: 		jal 	printHex	 %
00000a02 : 2800006f;   % 257: 		j goToExit 		# encerra execuï¿½ï¿½o %
00000a03 : ef810113;   % 264: ecallException:   addi    sp, sp, -264              # Salva todos os registradores na pilha %
00000a04 : 00112023;   % 265:     sw     x1,    0(sp) %
00000a05 : 00212223;   % 266:     sw     x2,    4(sp) %
00000a06 : 00312423;   % 267:     sw     x3,    8(sp) %
00000a07 : 00412623;   % 268:     sw     x4,   12(sp) %
00000a08 : 00512823;   % 269:     sw     x5,   16(sp) %
00000a09 : 00612a23;   % 270:     sw     x6,   20(sp) %
00000a0a : 00712c23;   % 271:     sw     x7,   24(sp) %
00000a0b : 00812e23;   % 272:     sw     x8,   28(sp) %
00000a0c : 02912023;   % 273:     sw     x9,   32(sp) %
00000a0d : 02a12223;   % 274:     sw     x10,  36(sp) %
00000a0e : 02b12423;   % 275:     sw     x11,  40(sp) %
00000a0f : 02c12623;   % 276:     sw     x12,  44(sp) %
00000a10 : 02d12823;   % 277:     sw     x13,  48(sp) %
00000a11 : 02e12a23;   % 278:     sw     x14,  52(sp) %
00000a12 : 02f12c23;   % 279:     sw     x15,  56(sp) %
00000a13 : 03012e23;   % 280:     sw     x16,  60(sp) %
00000a14 : 05112023;   % 281:     sw     x17,  64(sp) %
00000a15 : 05212223;   % 282:     sw     x18,  68(sp) %
00000a16 : 05312423;   % 283:     sw     x19,  72(sp) %
00000a17 : 05412623;   % 284:     sw     x20,  76(sp) %
00000a18 : 05512823;   % 285:     sw     x21,  80(sp) %
00000a19 : 05612a23;   % 286:     sw     x22,  84(sp) %
00000a1a : 05712c23;   % 287:     sw     x23,  88(sp) %
00000a1b : 05812e23;   % 288:     sw     x24,  92(sp) %
00000a1c : 07912023;   % 289:     sw     x25,  96(sp) %
00000a1d : 07a12223;   % 290:     sw     x26, 100(sp) %
00000a1e : 07b12423;   % 291:     sw     x27, 104(sp) %
00000a1f : 07c12623;   % 292:     sw     x28, 108(sp) %
00000a20 : 07d12823;   % 293:     sw     x29, 112(sp) %
00000a21 : 07e12a23;   % 294:     sw     x30, 116(sp) %
00000a22 : 07f12c23;   % 295:     sw     x31, 120(sp) %
00000a23 : 30102c73;   % 296: <22> csrr s8, misa %
00000a24 : 020c7c13;   % 296: <23> andi s8, s8, 0x020 %
00000a25 : 080c0263;   % 296: <24> beqz s8, ecallException.pula %
00000a26 : 06012e27;   % 297:     fsw    f0,  124(sp) %
00000a27 : 08112027;   % 298:     fsw    f1,  128(sp) %
00000a28 : 08212227;   % 299:     fsw    f2,  132(sp) %
00000a29 : 08312427;   % 300:     fsw    f3,  136(sp) %
00000a2a : 08412627;   % 301:     fsw    f4,  140(sp) %
00000a2b : 08512827;   % 302:     fsw    f5,  144(sp) %
00000a2c : 08612a27;   % 303:     fsw    f6,  148(sp) %
00000a2d : 08712c27;   % 304:     fsw    f7,  152(sp) %
00000a2e : 08812e27;   % 305:     fsw    f8,  156(sp) %
00000a2f : 0a912027;   % 306:     fsw    f9,  160(sp) %
00000a30 : 0aa12227;   % 307:     fsw    f10, 164(sp) %
00000a31 : 0ab12427;   % 308:     fsw    f11, 168(sp) %
00000a32 : 0ac12627;   % 309:     fsw    f12, 172(sp) %
00000a33 : 0ad12827;   % 310:     fsw    f13, 176(sp) %
00000a34 : 0ae12a27;   % 311:     fsw    f14, 180(sp) %
00000a35 : 0af12c27;   % 312:     fsw    f15, 184(sp) %
00000a36 : 0b012e27;   % 313:     fsw    f16, 188(sp) %
00000a37 : 0d112027;   % 314:     fsw    f17, 192(sp) %
00000a38 : 0d212227;   % 315:     fsw    f18, 196(sp) %
00000a39 : 0d312427;   % 316:     fsw    f19, 200(sp) %
00000a3a : 0d412627;   % 317:     fsw    f20, 204(sp) %
00000a3b : 0d512827;   % 318:     fsw    f21, 208(sp) %
00000a3c : 0d612a27;   % 319:     fsw    f22, 212(sp) %
00000a3d : 0d712c27;   % 320:     fsw    f23, 216(sp) %
00000a3e : 0d812e27;   % 321:     fsw    f24, 220(sp) %
00000a3f : 0f912027;   % 322:     fsw    f25, 224(sp) %
00000a40 : 0fa12227;   % 323:     fsw    f26, 228(sp) %
00000a41 : 0fb12427;   % 324:     fsw    f27, 232(sp) %
00000a42 : 0fc12627;   % 325:     fsw    f28, 236(sp) %
00000a43 : 0fd12827;   % 326:     fsw    f29, 240(sp) %
00000a44 : 0fe12a27;   % 327:     fsw    f30, 244(sp) %
00000a45 : 0ff12c27;   % 328:     fsw    f31, 248(sp) %
00000a46 : 000002b3;   % 331:     add     t0, zero, zero %
00000a47 : 00000333;   % 332:     add     t1, zero, zero %
00000a48 : 000003b3;   % 333:     add     t2, zero, zero %
00000a49 : 00000e33;   % 334:     add     t3, zero, zero %
00000a4a : 00000eb3;   % 335:     add     t4, zero, zero %
00000a4b : 00000f33;   % 336:     add     t5, zero, zero %
00000a4c : 00000fb3;   % 337:     add     t6, zero, zero %
00000a4d : 00a00293;   % 342:     addi    t0, zero, 10 %
00000a4e : 15128863;   % 343:     beq     t0, a7, goToExit          # ecall exit %
00000a4f : 06e00293;   % 344:     addi    t0, zero, 110 %
00000a50 : 15128463;   % 345:     beq     t0, a7, goToExit          # ecall exit %
00000a51 : 00100293;   % 347:     addi    t0, zero, 1               # ecall 1 = print int %
00000a52 : 15128c63;   % 348:     beq     t0, a7, goToPrintInt %
00000a53 : 06500293;   % 349:     addi    t0, zero, 101             # ecall 1 = print int %
00000a54 : 15128863;   % 350:     beq     t0, a7, goToPrintInt %
00000a55 : 00200293;   % 352:     addi    t0, zero, 2               # ecall 2 = print float %
00000a56 : 17128063;   % 353:     beq     t0, a7, goToPrintFloat %
00000a57 : 06600293;   % 354:     addi    t0, zero, 102             # ecall 2 = print float %
00000a58 : 15128c63;   % 355:     beq     t0, a7, goToPrintFloat %
00000a59 : 00300293;   % 357:     addi    t0, zero, 3               # ecall 3 = print double %
00000a5a : 17128263;   % 358:     beq     t0, a7, goToPrintDouble %
00000a5b : 06700293;   % 359:     addi    t0, zero, 103             # ecall 2 = print double %
00000a5c : 15128e63;   % 360:     beq     t0, a7, goToPrintDouble %
00000a5d : 00400293;   % 362:     addi    t0, zero, 4               # ecall 4 = print string %
00000a5e : 13128863;   % 363:     beq     t0, a7, goToPrintString %
00000a5f : 06800293;   % 364:     addi    t0, zero, 104             # ecall 4 = print string %
00000a60 : 13128463;   % 365:     beq     t0, a7, goToPrintString %
00000a61 : 00500293;   % 367:     addi    t0, zero, 5               # ecall 5 = read int %
00000a62 : 17128063;   % 368:     beq     t0, a7, goToReadInt %
00000a63 : 06900293;   % 369:     addi    t0, zero, 105             # ecall 5 = read int %
00000a64 : 15128c63;   % 370:     beq     t0, a7, goToReadInt %
00000a65 : 00600293;   % 372:     addi    t0, zero, 6               # ecall 6 = read float %
00000a66 : 17128063;   % 373:     beq     t0, a7, goToReadFloat %
00000a67 : 06a00293;   % 374:     addi    t0, zero, 106             # ecall 6 = read float %
00000a68 : 15128c63;   % 375:     beq     t0, a7, goToReadFloat %
00000a69 : 00700293;   % 377:     addi    t0, zero, 7               # ecall 7 = read Double %
00000a6a : 17128263;   % 378:     beq     t0, a7, goToReadDouble %
00000a6b : 06b00293;   % 379:     addi    t0, zero, 107             # ecall 7 = read Double %
00000a6c : 15128e63;   % 380:     beq     t0, a7, goToReadDouble %
00000a6d : 00800293;   % 382:     addi    t0, zero, 8               # ecall 8 = read string %
00000a6e : 13128c63;   % 383:     beq     t0, a7, goToReadString %
00000a6f : 06c00293;   % 384:     addi    t0, zero, 108             # ecall 8 = read string %
00000a70 : 13128863;   % 385:     beq     t0, a7, goToReadString %
00000a71 : 00b00293;   % 387:     addi    t0, zero, 11              # ecall 11 = print char %
00000a72 : 0f128463;   % 388:     beq     t0, a7, goToPrintChar %
00000a73 : 06f00293;   % 389:     addi    t0, zero, 111             # ecall 11 = print char %
00000a74 : 0f128063;   % 390:     beq     t0, a7, goToPrintChar %
00000a75 : 00c00293;   % 392:     addi    t0, zero, 12              # ecall 12 = read char %
00000a76 : 11128463;   % 393:     beq     t0, a7, goToReadChar %
00000a77 : 07000293;   % 394:     addi    t0, zero, 112             # ecall 12 = read char %
00000a78 : 11128063;   % 395:     beq     t0, a7, goToReadChar %
00000a79 : 01e00293;   % 398:     addi    t0, zero, 30              # ecall 30 = time %
00000a7a : 15128c63;   % 399:     beq     t0, a7, goToTime %
00000a7b : 08200293;   % 400:     addi    t0, zero, 130             # ecall 30 = time %
00000a7c : 15128863;   % 401:     beq     t0, a7, goToTime %
00000a7d : 01f00293;   % 403:     addi    t0, zero, 31              # ecall 31 = MIDI out %
00000a7e : 13128c63;   % 404:     beq     t0, a7, goToMidiOut       # Generate tone and return immediately %
00000a7f : 08300293;   % 405:     addi    t0, zero, 131             # ecall 31 = MIDI out %
00000a80 : 13128863;   % 406:     beq     t0, a7, goToMidiOut %
00000a81 : 02000293;   % 408:     addi    t0, zero, 32              # ecall 32 = sleep %
00000a82 : 15128063;   % 409:     beq     t0, a7, goToSleep %
00000a83 : 08400293;   % 410:     addi    t0, zero, 132             # ecall 32 = sleep %
00000a84 : 13128c63;   % 411:     beq     t0, a7, goToSleep %
00000a85 : 02100293;   % 413:     addi    t0, zero, 33              # ecall 33 = MIDI out synchronous %
00000a86 : 13128063;   % 414:     beq     t0, a7, goToMidiOutSync   # Generate tone and return upon tone completion %
00000a87 : 08500293;   % 415:     addi    t0, zero, 133             # ecall 33 = MIDI out synchronous %
00000a88 : 11128c63;   % 416:     beq     t0, a7, goToMidiOutSync %
00000a89 : 02200293;   % 418:     addi    t0, zero, 34       		# ecall 34 = print hex %
00000a8a : 0f128c63;   % 419:     beq     t0, a7, goToPrintHex %
00000a8b : 08600293;   % 420:     addi    t0, zero, 134		# ecall 34 = print hex %
00000a8c : 0f128863;   % 421:     beq     t0, a7, goToPrintHex %
00000a8d : 02400293;   % 429:     addi    t0, zero, 36              # ecall 36 = PrintIntUnsigned %
00000a8e : 0f128863;   % 430:     beq     t0, a7, goToPrintIntUnsigned %
00000a8f : 08800293;   % 431:     addi    t0, zero, 136             # ecall 36 = PrintIntUnsigned %
00000a90 : 0f128463;   % 432:     beq     t0, a7, goToPrintIntUnsigned %
00000a91 : 02900293;   % 435:     addi    t0, zero, 41              # ecall 41 = random %
00000a92 : 11128463;   % 436:     beq     t0, a7, goToRandom %
00000a93 : 08d00293;   % 437:     addi    t0, zero, 141             # ecall 41 = random %
00000a94 : 11128063;   % 438:     beq     t0, a7, goToRandom %
00000a95 : 02a00293;   % 440:     addi    t0, zero, 42              # ecall 41 = random %
00000a96 : 11128063;   % 441:     beq     t0, a7, goToRandom2 %
00000a97 : 08e00293;   % 442:     addi    t0, zero, 142             # ecall 41 = random %
00000a98 : 0f128c63;   % 443:     beq     t0, a7, goToRandom2 %
00000a99 : 02f00293;   % 446:     addi    t0, zero, 47              # ecall 47 = DrawLine %
00000a9a : 11128063;   % 447:     beq     t0, a7, goToBRES %
00000a9b : 09300293;   % 448:     addi    t0, zero, 147              # ecall 47 = DrawLine %
00000a9c : 0f128c63;   % 449:     beq     t0, a7, goToBRES     %
00000a9d : 03000293;   % 451:     addi    t0, zero, 48              # ecall 48 = CLS %
00000a9e : 0f128463;   % 452:     beq     t0, a7, goToCLS %
00000a9f : 09400293;   % 453:     addi    t0, zero, 148              # ecall 48 = CLS %
00000aa0 : 0f128063;   % 454:     beq     t0, a7, goToCLS %
00000aa1 : 1f8000ef;   % 459:     jal NaoExisteEcall  # ecall inexistente %
00000aa2 : 10008c37;   % 462: <9> li s8, 0x10008000	# carrega tp %
00000aa3 : 000c0c13;   % 462:  %
00000aa4 : 01819663;   % 462: <10> bne gp, s8, goToExitDE2	# Na DE1 gp = 0 ! Não tem segmento .extern %
00000aa5 : 00a00893;   % 463: 			li 	a7, 10			# chama o ecall normal do Rars %
00000aa6 : 00000073;   % 464: 			ecall				# exit ecall	 %
00000aa7 : 0000006f;   % 465: 	goToExitDE2:	j 	goToExitDE2		# trava o processador : Nï¿½o tem sistema operacional! %
00000aa8 : 244000ef;   % 467: 	goToPrintInt:	jal     printInt               	# chama printInt %
00000aa9 : 0cc0006f;   % 468: 			j       endEcall %
00000aaa : 52c000ef;   % 470: 	goToPrintString: jal     printString           	# chama printString %
00000aab : 0c40006f;   % 471: 			 j       endEcall %
00000aac : 56c000ef;   % 473: 	goToPrintChar:	jal     printChar		# chama printChar %
00000aad : 0bc0006f;   % 474: 			j       endEcall %
00000aae : 30102c73;   % 476: <22> csrr s8, misa %
00000aaf : 020c7c13;   % 476: <23> andi s8, s8, 0x020 %
00000ab0 : 1a0c0e63;   % 476: <24> beqz s8, NaoExisteEcall %
00000ab1 : 1ed000ef;   % 477: 			jal     printFloat		# chama printFloat %
00000ab2 : 0a80006f;   % 478: 			j       endEcall %
00000ab3 : 30102c73;   % 480: <22> csrr s8, misa %
00000ab4 : 020c7c13;   % 480: <23> andi s8, s8, 0x020 %
00000ab5 : 1a0c0463;   % 480: <24> beqz s8, NaoExisteEcall %
00000ab6 : 3dd000ef;   % 481: 			jal     printDouble		# chama printDuble %
00000ab7 : 0940006f;   % 482: 			j       endEcall %
00000ab8 : 688000ef;   % 485: 	goToReadChar:	jal     readChar              	# chama readChar %
00000ab9 : 08c0006f;   % 486: 			j       endEcall %
00000aba : 7b0000ef;   % 488: 	goToReadInt:   	jal     readInt                 # chama readInt %
00000abb : 0840006f;   % 489: 			j       endEcall %
00000abc : 718000ef;   % 491: 	goToReadString:	jal     readString              # chama readString %
00000abd : 07c0006f;   % 492: 			j       endEcall %
00000abe : 30102c73;   % 494: <22> csrr s8, misa %
00000abf : 020c7c13;   % 494: <23> andi s8, s8, 0x020 %
00000ac0 : 160c0e63;   % 494: <24> beqz s8, NaoExisteEcall %
00000ac1 : 3b9000ef;   % 495: 			jal     readFloat               # chama readFloat %
00000ac2 : 0680006f;   % 496: 			j       endEcall %
00000ac3 : 30102c73;   % 498: <22> csrr s8, misa %
00000ac4 : 020c7c13;   % 498: <23> andi s8, s8, 0x020 %
00000ac5 : 160c0463;   % 498: <24> beqz s8, NaoExisteEcall %
00000ac6 : 3a1000ef;   % 499: 			jal     readDouble               # chama readDouble %
00000ac7 : 0540006f;   % 500: 			j       endEcall %
00000ac8 : 440000ef;   % 503: 	goToPrintHex:	jal     printHex                # chama printHex %
00000ac9 : 04c0006f;   % 504: 			j       endEcall %
00000aca : 0b4010ef;   % 506: 	goToPrintIntUnsigned: 	jal	printIntUnsigned	# chama Print Unsigned Int %
00000acb : 0440006f;   % 507: 				j	endEcall   %
00000acc : 079000ef;   % 509: 	goToMidiOut:	jal     midiOut                 # chama MIDIout %
00000acd : 03c0006f;   % 510: 			j       endEcall %
00000ace : 0e9000ef;   % 512: 	goToMidiOutSync: jal     midiOutSync   		# chama MIDIoutSync %
00000acf : 0340006f;   % 513: 			 j       endEcall %
00000ad0 : 5e1000ef;   % 515: 	goToTime:	jal     Time                    # chama time %
00000ad1 : 02c0006f;   % 516: 			j       endEcall %
00000ad2 : 5fd000ef;   % 518: 	goToSleep:	jal     Sleep                  	# chama sleep %
00000ad3 : 0240006f;   % 519: 			j       endEcall %
00000ad4 : 621000ef;   % 521: 	goToRandom:	jal     Random                 	# chama random %
00000ad5 : 01c0006f;   % 522: 			j       endEcall %
00000ad6 : 641000ef;   % 524: 	goToRandom2:	jal     Random2                 # chama random2 %
00000ad7 : 0140006f;   % 525: 			j       endEcall %
00000ad8 : 665000ef;   % 527: 	goToCLS:	jal     clsCLS                 	# chama CLS %
00000ad9 : 00c0006f;   % 528: 			j       endEcall %
00000ada : 6b9000ef;   % 530: 	goToBRES:	jal     BRESENHAM               # chama BRESENHAM %
00000adb : 0040006f;   % 531: 			j       endEcall    	 %
00000adc : 00012083;   % 535: endEcall:  	lw	x1,   0(sp)  # recupera QUASE todos os registradores na pilha %
00000add : 00412103;   % 536: 		lw	x2,   4(sp)	 %
00000ade : 00812183;   % 537: 		lw	x3,   8(sp)	 %
00000adf : 00c12203;   % 538: 		lw	x4,  12(sp)      	 %
00000ae0 : 01012283;   % 539: 		lw	x5,  16(sp)      	 %
00000ae1 : 01412303;   % 540: 		lw	x6,  20(sp)	 %
00000ae2 : 01812383;   % 541: 		lw	x7,  24(sp) %
00000ae3 : 01c12403;   % 542: 		lw	x8,  28(sp) %
00000ae4 : 02012483;   % 543: 		lw	x9,  32(sp) %
00000ae5 : 02c12603;   % 546: 		lw     x12, 44(sp) %
00000ae6 : 03012683;   % 547: 		lw     x13, 48(sp) %
00000ae7 : 03412703;   % 548: 		lw     x14, 52(sp) %
00000ae8 : 03812783;   % 549: 		lw     x15, 56(sp) %
00000ae9 : 03c12803;   % 550: 		lw     x16, 60(sp) %
00000aea : 04012883;   % 551: 		lw     x17, 64(sp) %
00000aeb : 04412903;   % 552: 		lw     x18, 68(sp) %
00000aec : 04812983;   % 553: 		lw     x19, 72(sp) %
00000aed : 04c12a03;   % 554: 		lw     x20, 76(sp) %
00000aee : 05012a83;   % 555: 		lw     x21, 80(sp) %
00000aef : 05412b03;   % 556: 		lw     x22, 84(sp) %
00000af0 : 05812b83;   % 557: 		lw     x23, 88(sp) %
00000af1 : 05c12c03;   % 558: 		lw     x24, 92(sp) %
00000af2 : 06012c83;   % 559: 		lw     x25, 96(sp) %
00000af3 : 06412d03;   % 560: 		lw     x26, 100(sp) %
00000af4 : 06812d83;   % 561: 		lw     x27, 104(sp) %
00000af5 : 06c12e03;   % 562: 		lw     x28, 108(sp) %
00000af6 : 07012e83;   % 563: 		lw     x29, 112(sp) %
00000af7 : 07412f03;   % 564: 		lw     x30, 116(sp) %
00000af8 : 07812f83;   % 565: 		lw     x31, 120(sp) %
00000af9 : 30102c73;   % 566: <22> csrr s8, misa %
00000afa : 020c7c13;   % 566: <23> andi s8, s8, 0x020 %
00000afb : 060c0e63;   % 566: <24> beqz s8, endEcall.pula %
00000afc : 07c12007;   % 567: 		flw    f0,  124(sp) %
00000afd : 08012087;   % 568: 		flw    f1,  128(sp) %
00000afe : 08412107;   % 569: 		flw    f2,  132(sp) %
00000aff : 08812187;   % 570: 		flw    f3,  136(sp) %
00000b00 : 08c12207;   % 571: 		flw    f4,  140(sp) %
00000b01 : 09012287;   % 572: 		flw    f5,  144(sp) %
00000b02 : 09412307;   % 573: 		flw    f6,  148(sp) %
00000b03 : 09812387;   % 574: 		flw    f7,  152(sp) %
00000b04 : 09c12407;   % 575: 		flw    f8,  156(sp) %
00000b05 : 0a012487;   % 576: 		flw    f9,  160(sp) %
00000b06 : 0ac12607;   % 579: 		flw    f12, 172(sp) %
00000b07 : 0b012687;   % 580: 		flw    f13, 176(sp) %
00000b08 : 0b412707;   % 581: 		flw    f14, 180(sp) %
00000b09 : 0b812787;   % 582: 		flw    f15, 184(sp) %
00000b0a : 0bc12807;   % 583: 		flw    f16, 188(sp) %
00000b0b : 0c012887;   % 584: 		flw    f17, 192(sp) %
00000b0c : 0c412907;   % 585: 		flw    f18, 196(sp) %
00000b0d : 0c812987;   % 586: 		flw    f19, 200(sp) %
00000b0e : 0cc12a07;   % 587: 		flw    f20, 204(sp) %
00000b0f : 0d012a87;   % 588: 		flw    f21, 208(sp) %
00000b10 : 0d412b07;   % 589: 		flw    f22, 212(sp) %
00000b11 : 0d812b87;   % 590: 		flw    f23, 216(sp) %
00000b12 : 0dc12c07;   % 591: 		flw    f24, 220(sp) %
00000b13 : 0e012c87;   % 592: 		flw    f25, 224(sp) %
00000b14 : 0e412d07;   % 593: 		flw    f26, 228(sp) %
00000b15 : 0e812d87;   % 594: 		flw    f27, 232(sp) %
00000b16 : 0ec12e07;   % 595: 		flw    f28, 236(sp) %
00000b17 : 0f012e87;   % 596: 		flw    f29, 240(sp) %
00000b18 : 0f412f07;   % 597: 		flw    f30, 244(sp) %
00000b19 : 0f812f87;   % 598: 		flw    f31, 248(sp) %
00000b1a : 10810113;   % 600: endEcall.pula:	addi    sp, sp, 264 %
00000b1b : 04102273;   % 602: 		csrr 	tp, uepc 	# le o valor de EPC salvo no registrador uepc (reg 65) %
00000b1c : 00420213;   % 603: 		addi 	tp, tp, 4	# soma 4 para obter a instrucao seguinte ao ecall %
00000b1d : 04121073;   % 604: 		csrw 	tp, uepc	# coloca no registrador uepc %
00000b1e : 00200073;   % 605: 		uret			# retorna PC=uepc %
00000b1f : 0c000513;   % 613: NaoExisteEcall: addi 	a0, zero, 0xc0 		## printa tela de azul %
00000b20 : 00000593;   % 614: 		addi 	a1, zero, 0 %
00000b21 : 01100833;   % 615: 		mv 	a6, a7 %
00000b22 : 09400893;   % 616: 		addi 	a7, zero, 148 %
00000b23 : 539000ef;   % 617: 		jal 	clsCLS %
00000b24 : 0fc20517;   % 618:   		la 	a0, CauseE %
00000b25 : 45750513;   % 618:  %
00000b26 : 00000593;   % 619: 		li 	a1, 0 %
00000b27 : 00100613;   % 620: 		li 	a2, 1 %
00000b28 : 0000c6b7;   % 621: 		li 	a3, 0x0000c0ff %
00000b29 : 0ff68693;   % 621:  %
00000b2a : 00000793;   % 622: 		li 	a5,0 %
00000b2b : 328000ef;   % 623: 		jal	printString %
00000b2c : 01000533;   % 624: 		mv 	a0, a6 %
00000b2d : 06800593;   % 625: 		li 	a1, 104 %
00000b2e : 00100613;   % 626: 		li 	a2, 1 %
00000b2f : 0000c6b7;   % 627: 		li 	a3, 0x0000c0ff %
00000b30 : 0ff68693;   % 627:  %
00000b31 : 020000ef;   % 628: 		jal 	printInt %
00000b32 : 04102573;   % 629: 		csrr	a0,uepc %
00000b33 : 08800593;   % 630: 		li 	a1, 136 %
00000b34 : 00100613;   % 631: 		li 	a2, 1 %
00000b35 : 0000c6b7;   % 632: 		li 	a3, 0x0000c0ff %
00000b36 : 0ff68693;   % 632:  %
00000b37 : 284000ef;   % 633: 		jal 	printHex		 %
00000b38 : da9ff06f;   % 634: 		j 	goToExit %
00000b39 : ffc10113;   % 646: printInt:	addi 	sp, sp, -4			# Aloca espaco %
00000b3a : 00112023;   % 647: 		sw 	ra, 0(sp)			# salva ra %
00000b3b : 0fc20297;   % 648: 		la 	t0, TempBuffer			# carrega o Endereco do Buffer da String %
00000b3c : 0bc28293;   % 648:  %
00000b3d : 00055a63;   % 650: 		bge 	a0, zero, ehposprintInt		# Se eh positvo %
00000b3e : 02d00313;   % 651: 		li 	t1, '-'				# carrega o sinal - %
00000b3f : 00628023;   % 652: 		sb 	t1, 0(t0)			# coloca no buffer %
00000b40 : 00128293;   % 653: 		addi 	t0, t0, 1			# incrementa endereco do buffer %
00000b41 : 40a00533;   % 654: 		sub 	a0, zero, a0			# torna o numero positivo %
00000b42 : 00a00393;   % 656: ehposprintInt:  li 	t2, 10				# carrega numero 10 %
00000b43 : 00000313;   % 657: 		li 	t1, 0				# carrega numero de digitos com 0 %
00000b44 : 30102c73;   % 659: <29> csrr s8, misa %
00000b45 : 00cc5c13;   % 659: <30> srli s8, s8, 12 %
00000b46 : 001c7c13;   % 659: <31> andi s8, s8, 0x001 %
00000b47 : 1e0c1863;   % 659: <32> bnez s8, printInt.pula1 %
00000b48 : ff410113;   % 660: <99> addi 	sp,sp,-12 %
00000b49 : 00a12023;   % 660: <100> sw	a0,0(sp) %
00000b4a : 00b12223;   % 660: <101> sw	a1,4(sp) %
00000b4b : 00c12423;   % 660: <102> sw	a2,8(sp) %
00000b4c : 00a00633;   % 660: <103> mv 	a2,a0 %
00000b4d : 41f65593;   % 660: <104> srai 	a1,a2,31 %
00000b4e : 00c00533;   % 660: <105> mv 	a0,a2 %
00000b4f : 00058463;   % 660: <106> beqz 	a1,div10.pula1_M8 %
00000b50 : 40c00533;   % 660: <107> neg 	a0,a2 %
00000b51 : ff010113;   % 660: <65> addi 	sp, sp, -16 %
00000b52 : 00a12023;   % 660: <66> sw	a0, 0(sp) %
00000b53 : 00e12223;   % 660: <67> sw	a4, 4(sp) %
00000b54 : 00f12423;   % 660: <68> sw	a5, 8(sp) %
00000b55 : 00112623;   % 660: <69> sw	ra, 12(sp) %
00000b56 : 00a00533;   % 660: <70> mv 	a0, a0 %
00000b57 : 00155713;   % 660: <71> srli    a4,a0,1 %
00000b58 : 00255793;   % 660: <72> srli    a5,a0,2 %
00000b59 : 00f707b3;   % 660: <73> add     a5,a4,a5 %
00000b5a : 0047d713;   % 660: <74> srli    a4,a5,4 %
00000b5b : 00f70733;   % 660: <75> add     a4,a4,a5 %
00000b5c : 00875793;   % 660: <76> srli    a5,a4,8 %
00000b5d : 00e78733;   % 660: <77> add     a4,a5,a4 %
00000b5e : 01075793;   % 660: <78> srli    a5,a4,16 %
00000b5f : 00e787b3;   % 660: <79> add     a5,a5,a4 %
00000b60 : 0037d793;   % 660: <80> srli    a5,a5,3 %
00000b61 : 00279713;   % 660: <81> slli    a4,a5,2 %
00000b62 : 00f70733;   % 660: <82> add     a4,a4,a5 %
00000b63 : 00171713;   % 660: <83> slli    a4,a4,1 %
00000b64 : 40e50533;   % 660: <84> sub     a0,a0,a4 %
00000b65 : 00a53513;   % 660: <85> sltiu   a0,a0,10 %
00000b66 : 00154513;   % 660: <86> xori    a0,a0,1 %
00000b67 : 00f50533;   % 660: <87> add     a0,a0,a5 %
00000b68 : 04051073;   % 660: <88> csrw	a0,uscratch %
00000b69 : 00012503;   % 660: <89> lw	a0, 0(sp) %
00000b6a : 00412703;   % 660: <90> lw	a4, 4(sp) %
00000b6b : 00812783;   % 660: <91> lw	a5, 8(sp) %
00000b6c : 00c12083;   % 660: <92> lw	ra, 12(sp) %
00000b6d : 01010113;   % 660: <93> addi 	sp, sp, 16 %
00000b6e : 04002ef3;   % 660: <94> csrr	t4,uscratch %
00000b6f : 00058463;   % 660: <109> beqz 	a1,div10.pula2_M8 %
00000b70 : 41d00eb3;   % 660: <110> neg 	t4,t4 %
00000b71 : 040e9073;   % 660: <111> div10.pula2_M8:	csrw	t4,uscratch %
00000b72 : 00012503;   % 660: <112> lw	a0,0(sp) %
00000b73 : 00412583;   % 660: <113> lw 	a1,4(sp) %
00000b74 : 00812603;   % 660: <114> lw	a2,8(sp) %
00000b75 : 00c10113;   % 660: <115> addi 	sp,sp,12 %
00000b76 : 04002ef3;   % 660: <116> csrr	t4,uscratch %
00000b77 : ff010113;   % 661: <145> addi 	sp,sp,-16 %
00000b78 : 00a12023;   % 661: <146> sw	a0,0(sp) %
00000b79 : 00b12223;   % 661: <147> sw	a1,4(sp) %
00000b7a : 00c12423;   % 661: <148> sw	a2,8(sp) %
00000b7b : 00d12623;   % 661: <149> sw	a3,12(sp) %
00000b7c : 00a006b3;   % 661: <151> mv 	a3,a0 %
00000b7d : 00a00613;   % 661: <152> li 	a2,10 %
00000b7e : ff410113;   % 661: <99> addi 	sp,sp,-12 %
00000b7f : 00a12023;   % 661: <100> sw	a0,0(sp) %
00000b80 : 00b12223;   % 661: <101> sw	a1,4(sp) %
00000b81 : 00c12423;   % 661: <102> sw	a2,8(sp) %
00000b82 : 00d00633;   % 661: <103> mv 	a2,a3 %
00000b83 : 41f65593;   % 661: <104> srai 	a1,a2,31 %
00000b84 : 00c00533;   % 661: <105> mv 	a0,a2 %
00000b85 : 00058463;   % 661: <106> beqz 	a1,div10.pula1_M11 %
00000b86 : 40c00533;   % 661: <107> neg 	a0,a2 %
00000b87 : ff010113;   % 661: <65> addi 	sp, sp, -16 %
00000b88 : 00a12023;   % 661: <66> sw	a0, 0(sp) %
00000b89 : 00e12223;   % 661: <67> sw	a4, 4(sp) %
00000b8a : 00f12423;   % 661: <68> sw	a5, 8(sp) %
00000b8b : 00112623;   % 661: <69> sw	ra, 12(sp) %
00000b8c : 00a00533;   % 661: <70> mv 	a0, a0 %
00000b8d : 00155713;   % 661: <71> srli    a4,a0,1 %
00000b8e : 00255793;   % 661: <72> srli    a5,a0,2 %
00000b8f : 00f707b3;   % 661: <73> add     a5,a4,a5 %
00000b90 : 0047d713;   % 661: <74> srli    a4,a5,4 %
00000b91 : 00f70733;   % 661: <75> add     a4,a4,a5 %
00000b92 : 00875793;   % 661: <76> srli    a5,a4,8 %
00000b93 : 00e78733;   % 661: <77> add     a4,a5,a4 %
00000b94 : 01075793;   % 661: <78> srli    a5,a4,16 %
00000b95 : 00e787b3;   % 661: <79> add     a5,a5,a4 %
00000b96 : 0037d793;   % 661: <80> srli    a5,a5,3 %
00000b97 : 00279713;   % 661: <81> slli    a4,a5,2 %
00000b98 : 00f70733;   % 661: <82> add     a4,a4,a5 %
00000b99 : 00171713;   % 661: <83> slli    a4,a4,1 %
00000b9a : 40e50533;   % 661: <84> sub     a0,a0,a4 %
00000b9b : 00a53513;   % 661: <85> sltiu   a0,a0,10 %
00000b9c : 00154513;   % 661: <86> xori    a0,a0,1 %
00000b9d : 00f50533;   % 661: <87> add     a0,a0,a5 %
00000b9e : 04051073;   % 661: <88> csrw	a0,uscratch %
00000b9f : 00012503;   % 661: <89> lw	a0, 0(sp) %
00000ba0 : 00412703;   % 661: <90> lw	a4, 4(sp) %
00000ba1 : 00812783;   % 661: <91> lw	a5, 8(sp) %
00000ba2 : 00c12083;   % 661: <92> lw	ra, 12(sp) %
00000ba3 : 01010113;   % 661: <93> addi 	sp, sp, 16 %
00000ba4 : 04002573;   % 661: <94> csrr	a0,uscratch %
00000ba5 : 00058463;   % 661: <109> beqz 	a1,div10.pula2_M11 %
00000ba6 : 40a00533;   % 661: <110> neg 	a0,a0 %
00000ba7 : 04051073;   % 661: <111> div10.pula2_M11:	csrw	a0,uscratch %
00000ba8 : 00012503;   % 661: <112> lw	a0,0(sp) %
00000ba9 : 00412583;   % 661: <113> lw 	a1,4(sp) %
00000baa : 00812603;   % 661: <114> lw	a2,8(sp) %
00000bab : 00c10113;   % 661: <115> addi 	sp,sp,12 %
00000bac : 04002573;   % 661: <116> csrr	a0,uscratch %
00000bad : ff410113;   % 661: <45> addi 	sp, sp, -12 %
00000bae : 00a12023;   % 661: <46> sw	a0, 0(sp) %
00000baf : 00b12223;   % 661: <47> sw	a1, 4(sp) %
00000bb0 : 00112423;   % 661: <48> sw	ra, 8(sp) %
00000bb1 : 00a00533;   % 661: <50> mv 	a0, a0 %
00000bb2 : 00c005b3;   % 661: <51> mv 	a1, a2 %
00000bb3 : 6f1000ef;   % 661: <52> jal 	__mulsi3 %
00000bb4 : 04051073;   % 661: <53> csrw	a0,uscratch %
00000bb5 : 00012503;   % 661: <55> lw	a0, 0(sp) %
00000bb6 : 00412583;   % 661: <56> lw	a1, 4(sp) %
00000bb7 : 00812083;   % 661: <57> lw	ra, 8(sp) %
00000bb8 : 00c10113;   % 661: <58> addi 	sp, sp, 12 %
00000bb9 : 040025f3;   % 661: <59> csrr	a1,uscratch %
00000bba : 40b68e33;   % 661: <155> sub 	t3,a3,a1 %
00000bbb : 040e1073;   % 661: <157> csrw	t3,uscratch %
00000bbc : 00012503;   % 661: <158> lw	a0,0(sp) %
00000bbd : 00412583;   % 661: <159> lw 	a1,4(sp) %
00000bbe : 00812603;   % 661: <160> lw	a2,8(sp) %
00000bbf : 00c12683;   % 661: <161> lw 	a3,12(sp) %
00000bc0 : 01010113;   % 661: <162> addi 	sp,sp,16 %
00000bc1 : 04002e73;   % 661: <163> csrr	t3,uscratch %
00000bc2 : 00c0006f;   % 662: 		j 	printInt.pula1d %
00000bc3 : 02754eb3;   % 663: printInt.pula1:	div 	t4, a0, t2			# divide por 10 (quociente) %
00000bc4 : 02756e33;   % 664: 		rem 	t3, a0, t2			# resto %
00000bc5 : ffc10113;   % 665: printInt.pula1d:addi 	sp, sp, -4			# aloca espaco na pilha %
00000bc6 : 01c12023;   % 666: 		sw 	t3, 0(sp)			# coloca resto na pilha %
00000bc7 : 01d00533;   % 667: 		mv 	a0, t4				# atualiza o numero com o quociente %
00000bc8 : 00130313;   % 668: 		addi 	t1, t1, 1			# incrementa o contador de digitos %
00000bc9 : de0516e3;   % 669: 		bne 	a0, zero, loop1printInt		# verifica se o numero eh zero %
00000bca : 00012383;   % 671: loop2printInt:	lw 	t2, 0(sp)			# le digito da pilha %
00000bcb : 00410113;   % 672: 		addi 	sp, sp, 4			# libera espaco %
00000bcc : 03038393;   % 673: 		addi 	t2, t2, 48			# converte o digito para ascii %
00000bcd : 00728023;   % 674: 		sb 	t2, 0(t0)			# coloca caractere no buffer %
00000bce : 00128293;   % 675: 		addi 	t0, t0, 1			# incrementa endereco do buffer %
00000bcf : fff30313;   % 676: 		addi 	t1, t1, -1			# decrementa contador de digitos %
00000bd0 : fe0314e3;   % 677: 		bne 	t1, zero, loop2printInt		# eh o ultimo? %
00000bd1 : 00028023;   % 678: 		sb 	zero, 0(t0)			# insere \NULL na string %
00000bd2 : 0fc20517;   % 680: 		la 	a0, TempBuffer			# Endereco do buffer da srting %
00000bd3 : e6050513;   % 680:  %
00000bd4 : 084000ef;   % 681: 		jal	printString			# chama o print string %
00000bd5 : 00012083;   % 683: 		lw 	ra, 0(sp)			# recupera a %
00000bd6 : 00410113;   % 684: 		addi 	sp, sp, 4			# libera espaco %
00000bd7 : 00008067;   % 685: fimprintInt:	ret					# retorna %
00000bd8 : ffc10113;   % 697: printHex:	addi    sp, sp, -4    		# aloca espaco %
00000bd9 : 00112023;   % 698:     		sw      ra, 0(sp)		# salva ra %
00000bda : 00a002b3;   % 699: 		mv 	t0, a0			# Inteiro de 32 bits a ser impresso em Hexa %
00000bdb : 0fc20317;   % 700: 		la 	t1, TabelaHexASCII	# endereco da tabela HEX->ASCII %
00000bdc : 03c30313;   % 700:  %
00000bdd : 0fc20397;   % 701: 		la 	t2, TempBuffer		# onde a string sera montada %
00000bde : e3438393;   % 701:  %
00000bdf : 03000e13;   % 703: 		li 	t3,'0'			# Caractere '0' %
00000be0 : 01c38023;   % 704: 		sb 	t3,0(t2)		# Escreve '0' no Buffer da String %
00000be1 : 07800e13;   % 705: 		li 	t3,'x'			# Caractere 'x' %
00000be2 : 01c380a3;   % 706: 		sb 	t3,1(t2)		# Escreve 'x' no Buffer da String %
00000be3 : 00238393;   % 707: 		addi 	t2,t2,2			# novo endereco inicial da string %
00000be4 : 01c00e13;   % 709: 		li 	t3, 28			# contador de nibble   inicio = 28 %
00000be5 : 020e4263;   % 710: loopprintHex:	blt 	t3, zero, fimloopprintHex	# terminou? t3<0? %
00000be6 : 01c2deb3;   % 711: 		srl 	t4, t0, t3		# desloca o nibble para direita %
00000be7 : 00fefe93;   % 712: 		andi 	t4, t4, 0x000F		# mascara o nibble	 %
00000be8 : 01d30eb3;   % 713: 		add 	t4, t1, t4		# endereco do ascii do nibble %
00000be9 : 000e8e83;   % 714: 		lb 	t4, 0(t4)		# le ascii do nibble %
00000bea : 01d38023;   % 715: 		sb 	t4, 0(t2)		# armazena o ascii do nibble no buffer da string %
00000beb : 00138393;   % 716: 		addi 	t2, t2, 1		# incrementa o endereco do buffer %
00000bec : ffce0e13;   % 717: 		addi 	t3, t3, -4		# decrementa o numero do nibble %
00000bed : fe1ff06f;   % 718: 		j 	loopprintHex %
00000bee : 00038023;   % 720: fimloopprintHex: sb 	zero,0(t2)		# grava \null na string %
00000bef : 0fc20517;   % 721: 		la 	a0, TempBuffer		# Argumento do print String %
00000bf0 : dec50513;   % 721:  %
00000bf1 : 010000ef;   % 722: 		jal	printString		# Chama o print string %
00000bf2 : 00012083;   % 724: 		lw 	ra, 0(sp)		# recupera ra %
00000bf3 : 00410113;   % 725: 		addi 	sp, sp, 4		# libera espaco %
00000bf4 : 00008067;   % 726: fimprintHex:	ret				# retorna %
00000bf5 : ff810113;   % 737: printString:	addi	sp, sp, -8			# aloca espaco %
00000bf6 : 00112023;   % 738:     		sw	ra, 0(sp)			# salva ra %
00000bf7 : 00812223;   % 739:     		sw	s0, 4(sp)			# salva s0 %
00000bf8 : 00a00433;   % 740:     		mv	s0, a0              		# s0 = endereco do caractere na string %
00000bf9 : 00040503;   % 742: loopprintString:lb	a0, 0(s0)                 	# le em a0 o caracter a ser impresso %
00000bfa : 02050263;   % 744:     		beq     a0, zero, fimloopprintString	# string ASCIIZ termina com NULL %
00000bfb : 030000ef;   % 746:     		jal     printChar       		# imprime char %
00000bfc : 00858593;   % 748: 		addi    a1, a1, 8                 	# incrementa a coluna %
00000bfd : 13900f93;   % 749: 		li 	t6, 313		 %
00000bfe : 01f5c663;   % 750: 		blt	a1, t6, NaoPulaLinha	    	# se ainda tiver lugar na linha %
00000bff : 00860613;   % 751:     		addi    a2, a2, 8                 	# incrementa a linha %
00000c00 : 000005b3;   % 752:     		mv    	a1, zero			# volta a coluna zero %
00000c01 : 00140413;   % 754: NaoPulaLinha:	addi    s0, s0, 1			# proximo caractere %
00000c02 : fddff06f;   % 755:     		j       loopprintString       		# volta ao loop %
00000c03 : 00012083;   % 757: fimloopprintString:	lw      ra, 0(sp)    		# recupera ra %
00000c04 : 00012403;   % 758: 			lw 	s0, 0(sp)		# recupera s0 original %
00000c05 : 00810113;   % 759:     			addi    sp, sp, 8		# libera espaco %
00000c06 : 00008067;   % 760: fimprintString:	ret      	    			# retorna %
00000c07 : 0ff00e93;   % 783: printChar:	li 	t4, 0xFF	# t4 temporario %
00000c08 : 008e9e93;   % 784: 		slli 	t4, t4, 8	# t4 = 0x0000FF00 (no RARS, nao podemos fazer diretamente "andi rd, rs1, 0xFF00") %
00000c09 : 01d6ff33;   % 785: 		and    	t5, a3, t4   	# t5 obtem cor de fundo %
00000c0a : 008f5f13;   % 786:     		srli	t5, t5, 8	# numero da cor de fundo %
00000c0b : 0ff6ff93;   % 787: 		andi   	t6, a3, 0xFF    # t6 obtem cor de frente %
00000c0c : 02000213;   % 789: 		li 	tp, ' ' %
00000c0d : 00454863;   % 790: 		blt 	a0, tp, printChar.NAOIMPRIMIVEL	# ascii menor que 32 nao eh imprimivel %
00000c0e : 07e00213;   % 791: 		li 	tp, '~' %
00000c0f : 00a24463;   % 792: 		bgt	a0, tp, printChar.NAOIMPRIMIVEL	# ascii Maior que 126  nao eh imprimivel %
00000c10 : 0080006f;   % 793:     		j       printChar.IMPRIMIVEL %
00000c11 : 02000513;   % 795: printChar.NAOIMPRIMIVEL: li      a0, 32		# Imprime espaco %
00000c12 : 14000213;   % 797: printChar.IMPRIMIVEL:	li	tp, 320		# Num colunas 320 %
00000c13 : 30102c73;   % 798: <29> csrr s8, misa %
00000c14 : 00cc5c13;   % 798: <30> srli s8, s8, 12 %
00000c15 : 001c7c13;   % 798: <31> andi s8, s8, 0x001 %
00000c16 : 020c1e63;   % 798: <32> bnez s8, printChar.mul1 %
00000c17 : ff410113;   % 799: <45> addi 	sp, sp, -12 %
00000c18 : 00a12023;   % 799: <46> sw	a0, 0(sp) %
00000c19 : 00b12223;   % 799: <47> sw	a1, 4(sp) %
00000c1a : 00112423;   % 799: <48> sw	ra, 8(sp) %
00000c1b : 00400533;   % 799: <50> mv 	a0, tp %
00000c1c : 00c005b3;   % 799: <51> mv 	a1, a2 %
00000c1d : 549000ef;   % 799: <52> jal 	__mulsi3 %
00000c1e : 04051073;   % 799: <53> csrw	a0,uscratch %
00000c1f : 00012503;   % 799: <55> lw	a0, 0(sp) %
00000c20 : 00412583;   % 799: <56> lw	a1, 4(sp) %
00000c21 : 00812083;   % 799: <57> lw	ra, 8(sp) %
00000c22 : 00c10113;   % 799: <58> addi 	sp, sp, 12 %
00000c23 : 04002ef3;   % 799: <59> csrr	t4,uscratch %
00000c24 : 0080006f;   % 800: 			j printChar.mul1d %
00000c25 : 02c20eb3;   % 801: printChar.mul1:		mul     t4, tp, a2			# multiplica a2x320  t4 = coordenada y %
00000c26 : 00be8eb3;   % 802: printChar.mul1d:	add     t4, t4, a1               	# t4 = 320*y + x %
00000c27 : 007e8e93;   % 803: 			addi    t4, t4, 7                 	# t4 = 320*y + (x+7) %
00000c28 : ff000237;   % 804: 			li      tp, 0xFF000000          	# Endereco de inicio da memoria VGA0 %
00000c29 : 00020213;   % 804:  %
00000c2a : 00070663;   % 805: 			beq 	a4, zero, printChar.PULAFRAME		# Verifica qual o frame a ser usado em a4 %
00000c2b : ff100237;   % 806: 			li      tp, 0xFF100000          	# Endereco de inicio da memoria VGA1 %
00000c2c : 00020213;   % 806:  %
00000c2d : 004e8eb3;   % 807: printChar.PULAFRAME:	add     t4, t4, tp               	# t4 = endereco de impressao do ultimo pixel da primeira linha do char %
00000c2e : fe050393;   % 808: 			addi    t2, a0, -32               	# indice do char na memoria %
00000c2f : 00339393;   % 809: 			slli    t2, t2, 3                 	# offset em bytes em relacao ao endereco inicial %
00000c30 : 00079863;   % 810: 			bnez    a5, printChar.OUTRAFONTE # se a5 != 0, usar outra fonte %
00000c31 : 0fc20e17;   % 811: 			la      t3, LabelTabChar		# endereco dos caracteres na memoria %
00000c32 : 8c0e0e13;   % 811:  %
00000c33 : 00c0006f;   % 812: 			j printChar.endereco          # ir para calculo final do endereco %
00000c34 : 0fc20e17;   % 815: 			la      t3, LabelTabCharMetroid     # Fonte alternativa %
00000c35 : 8b4e0e13;   % 815:  %
00000c36 : 01c383b3;   % 818: 			add     t2, t2, t3               	# endereco do caractere na memoria %
00000c37 : 0003ae03;   % 819: 			lw      t3, 0(t2)                 	# carrega a primeira word do char %
00000c38 : 00400293;   % 820: 			li 	t0, 4				# i=4 %
00000c39 : 02028e63;   % 822: printChar.forChar1I:	beq     t0, zero, printChar.endForChar1I # if(i == 0) end for i %
00000c3a : 00800313;   % 823:     			addi    t1, zero, 8               	# j = 8 %
00000c3b : 02030463;   % 825: printChar.forChar1J:	beq     t1, zero, printChar.endForChar1J # if(j == 0) end for j %
00000c3c : 001e7c93;   % 826:         		andi    s9, t3, 0x001			# primeiro bit do caracter %
00000c3d : 001e5e13;   % 827:         		srli    t3, t3, 1             		# retira o primeiro bit %
00000c3e : 000c8663;   % 828:         		beq     s9, zero, printChar.printCharPixelbg1	# pixel eh fundo? %
00000c3f : 01fe8023;   % 829:         		sb      t6, 0(t4)             		# imprime pixel com cor de frente %
00000c40 : 0080006f;   % 830:         		j       printChar.endCharPixel1 %
00000c41 : 01ee8023;   % 831: printChar.printCharPixelbg1:	sb      t5, 0(t4)                # imprime pixel com cor de fundo %
00000c42 : fff30313;   % 832: printChar.endCharPixel1: addi    t1, t1, -1                	# j-- %
00000c43 : fffe8e93;   % 833:     			addi    t4, t4, -1                	# t4 aponta um pixel para a esquerda %
00000c44 : fddff06f;   % 834:     			j       printChar.forChar1J		# vollta novo pixel %
00000c45 : fff28293;   % 836: printChar.endForChar1J: addi    t0, t0, -1 		# i-- %
00000c46 : 148e8e93;   % 837:     			addi    t4, t4, 328           	# 2**12 + 8 %
00000c47 : fc9ff06f;   % 838:     			j       printChar.forChar1I	# volta ao loop %
00000c48 : 0043ae03;   % 840: printChar.endForChar1I:	lw      t3, 4(t2)           	# carrega a segunda word do char %
00000c49 : 00400293;   % 841: 			li 	t0, 4			# i = 4 %
00000c4a : 02028e63;   % 842: printChar.forChar2I:    beq     t0, zero, printChar.endForChar2I  # if(i == 0) end for i %
00000c4b : 00800313;   % 843:     			addi    t1, zero, 8             # j = 8 %
00000c4c : 02030463;   % 845: printChar.forChar2J:	beq	t1, zero, printChar.endForChar2J # if(j == 0) end for j %
00000c4d : 001e7c93;   % 846:         		andi    s9, t3, 0x001	    		# pixel a ser impresso %
00000c4e : 001e5e13;   % 847:         		srli    t3, t3, 1                 	# desloca para o proximo %
00000c4f : 000c8663;   % 848:         		beq     s9, zero, printChar.printCharPixelbg2 # pixel eh fundo? %
00000c50 : 01fe8023;   % 849:         		sb      t6, 0(t4)			# imprime cor frente %
00000c51 : 0080006f;   % 850:         		j       printChar.endCharPixel2		# volta ao loop %
00000c52 : 01ee8023;   % 852: printChar.printCharPixelbg2:	sb      t5, 0(t4)		# imprime cor de fundo %
00000c53 : fff30313;   % 854: printChar.endCharPixel2:	addi    t1, t1, -1		# j-- %
00000c54 : fffe8e93;   % 855:     				addi    t4, t4, -1              # t4 aponta um pixel para a esquerda %
00000c55 : fddff06f;   % 856:     				j       printChar.forChar2J %
00000c56 : fff28293;   % 858: printChar.endForChar2J:	addi	t0, t0, -1 		# i-- %
00000c57 : 148e8e93;   % 859:     			addi    t4, t4, 328		# %
00000c58 : fc9ff06f;   % 860:     			j       printChar.forChar2I	# volta ao loop %
00000c59 : 00008067;   % 862: printChar.endForChar2I:	ret				# retorna %
00000c5a : 00000013;   % 871: readChar: 		nop %
00000c5b : ff2002b7;   % 875: readCharKDMMIO:		li 	t0, 0xFF200000			# Execucao com Polling do KD MMIO %
00000c5c : 00028293;   % 875:  %
00000c5d : 0002a503;   % 877: loopReadCharKDMMIO:  	lw     	a0, 0(t0)   			# le o bit de flag do teclado %
00000c5e : 00157513;   % 878: 			andi 	a0, a0, 0x0001			# mascara bit 0 %
00000c5f : fe050ce3;   % 879: 			beqz    a0, loopReadCharKDMMIO  	# testa se uma tecla foi pressionada %
00000c60 : 0042a503;   % 880:    			lw 	a0, 4(t0)			# le o ascii da tecla pressionada %
00000c61 : 0800006f;   % 881: 			j fimreadChar				# fim Read Char %
00000c62 : ff2002b7;   % 887: readCharDE2:  	li      t0, 0xFF200100 			# Endereco buffer0 %
00000c63 : 10028293;   % 887:  %
00000c64 : 0002a303;   % 888:     		lw     	t1, 0(t0)				# conteudo inicial do buffer %
00000c65 : 0002a383;   % 890: loopReadChar:  	lw     	t2, 0(t0)   				# le buffer teclado %
00000c66 : 00639663;   % 891: 		bne     t2, t1, buffermodificadoChar    	# testa se o buffer foi modificado %
00000c67 : 00700333;   % 893: atualizaBufferChar:  mv t1, t2			# atualiza o buffer com o novo valor %
00000c68 : ff5ff06f;   % 894:     		j       loopReadChar		# loop de principal de leitura  %
00000c69 : 0ff00f13;   % 896: buffermodificadoChar:	li t5, 0xFF %
00000c6a : 008f1f13;   % 897: 	slli 	t5, t5, 8			# t5 = 0x0000FF00 %
00000c6b : 01e3fe33;   % 898: 	and    	t3, t2, t5 			# mascara o 2o scancode %
00000c6c : 0000f237;   % 899: 	li 	tp, 0x0000F000 %
00000c6d : 00020213;   % 899:  %
00000c6e : 024e0063;   % 900: 	beq     t3, tp, teclasoltaChar		# eh 0xF0 no 2o scancode? tecla foi solta %
00000c6f : 0ff00213;   % 901: 	li	tp, 0x000000FF %
00000c70 : 0043fe33;   % 902: 	and	t3, t2, tp			# mascara 1o scancode	(essa podemos fazer diretamente) %
00000c71 : 01200213;   % 903: 	li	tp, 0x00000012 %
00000c72 : fc4e1ae3;   % 904:     	bne 	t3, tp, atualizaBufferChar	# nao eh o SHIFT que esta pressionado ? volta a ler  %
00000c73 : 0fc20417;   % 905: 	la      s0, LabelScanCodeShift		# se for SHIFT que esta pressionado atualiza o endereco da tabel %
00000c74 : b5640413;   % 905:  %
00000c75 : fc9ff06f;   % 906:     	j       atualizaBufferChar		# volta a ler %
00000c76 : 0ff3fe13;   % 908: teclasoltaChar:		andi t3, t2, 0x00FF		# mascara o 1o scancode %
00000c77 : 08000213;   % 909: 	li	tp, 0x00000080 %
00000c78 : fbc24ee3;   % 910:   	bgt	t3, tp, atualizaBufferChar		# se o scancode for > 0x80 entao nao eh imprimivel! %
00000c79 : 01200213;   % 911:   	li	tp, 0x00000012 %
00000c7a : 004e1863;   % 912: 	bne 	t3, tp, naoehshiftChar			# nao foi o shift que foi solto? entao processa %
00000c7b : 0fc20417;   % 913: 	la 	s0, LabelScanCode			# shift foi solto atualiza o endereco da tabela %
00000c7c : ab040413;   % 913:  %
00000c7d : fa9ff06f;   % 914: 	j 	atualizaBufferChar			# volta a ler %
00000c7e : 01c40e33;   % 916: naoehshiftChar:	   	add     t3, s0, t3              # endereco na tabela de scancode da tecla com ou sem shift %
00000c7f : 000e0503;   % 917:     	lb      a0, 0(t3)				# le o ascii do caracter para a0 %
00000c80 : f8050ee3;   % 918:     	beq     a0, zero, atualizaBufferChar		# se for caractere nao imprimivel volta a ler %
00000c81 : 00008067;   % 920: fimreadChar: 	ret			# retorna %
00000c82 : ff810113;   % 932: readString: 	addi 	sp, sp, -8			# reserva espaco na pilha %
00000c83 : 00812223;   % 933: 		sw 	s0, 4(sp)			# salva s0 %
00000c84 : 00112023;   % 934: 		sw 	ra, 0(sp)			# salva ra %
00000c85 : 00000693;   % 935: 		li 	a3, 0				# zera o contador de caracteres digitados %
00000c86 : 00a00933;   % 936: 		mv 	s2, a0				# salva o endereco inicial %
00000c87 : 0fc20417;   % 937:     		la      s0, LabelScanCode      		# Endereco da tabela de scancode inicial para readChar %
00000c88 : a8040413;   % 937:  %
00000c89 : 04d58c63;   % 939: loopreadString: beq 	a1, a3, fimreadString   	# buffer cheio fim %
00000c8a : ff810113;   % 941: 		addi 	sp, sp, -8 %
00000c8b : 00112023;   % 942: 		sw 	ra, 0(sp)			# salva ra %
00000c8c : 00a12223;   % 943: 		sw 	a0, 4(sp)			# salva a0 pois ele sera reescrito em readChar %
00000c8d : f35ff0ef;   % 944: 		jal 	readChar			# le um caracter do teclado (retorno em a0) %
00000c8e : 00a00fb3;   % 945: 		mv 	t6, a0				# t6 eh a letra lida em readChar %
00000c8f : 00012083;   % 946: 		lw 	ra, 0(sp) %
00000c90 : 00412503;   % 947: 		lw 	a0, 4(sp) %
00000c91 : 00810113;   % 948: 		addi 	sp, sp, 8 %
00000c92 : 00800213;   % 950: 		li 	tp, 0x08			 %
00000c93 : 004f9c63;   % 951: 		bne	t6, tp, PulaBackSpace		# Se nao for BACKSPACE %
00000c94 : fcd00ae3;   % 952: 		beq	zero, a3, loopreadString	# Se nï¿½o tem nenhum caractere no buffer apenas volta a ler %
00000c95 : fff68693;   % 953: 		addi	a3, a3, -1			# diminui contador %
00000c96 : fff50513;   % 954: 		addi 	a0, a0, -1			# diminui endereco do buffer %
00000c97 : 00050023;   % 955: 		sb 	zero, 0(a0)			# coloca zero no caractere anterior %
00000c98 : fc5ff06f;   % 956: 		j loopreadString %
00000c99 : 00a00213;   % 958: PulaBackSpace:	li	tp, 0x0A %
00000c9a : 004f8a63;   % 959: 		beq 	t6, tp, fimreadString		# se for tecla ENTER fim %
00000c9b : 01f50023;   % 960: 		sb 	t6, 0(a0)			# grava no buffer %
00000c9c : 00168693;   % 961: 		addi 	a3, a3, 1			# incrementa contador %
00000c9d : 00150513;   % 962: 		addi 	a0, a0, 1			# incrementa endereco no buffer %
00000c9e : fadff06f;   % 963: 		j loopreadString			# volta a ler outro caractere %
00000c9f : 00050023;   % 965: fimreadString: 	sb 	zero, 0(a0)			# grava NULL no buffer %
00000ca0 : fff50613;   % 966: 		addi 	a2, a0, -1			# Para que a2 tenha o endereco do ultimo caractere digitado %
00000ca1 : 01200533;   % 967: 		mv	a0, s2				# a0 volta a ter o endereco inicial da string %
00000ca2 : 00012083;   % 968: 		lw 	ra, 0(sp)			# recupera ra %
00000ca3 : 00412403;   % 969: 		lw	s0, 4(sp)			# recupera s0 %
00000ca4 : 00810113;   % 970: 		addi 	sp, sp, 8			# libera espaco %
00000ca5 : 00008067;   % 971: 		ret					# retorna %
00000ca6 : ffc10113;   % 980: readInt: 	addi 	sp,sp,-4		# reserva espaco na pilha %
00000ca7 : 00112023;   % 981: 	sw 	ra, 0(sp)			# salva ra %
00000ca8 : 0fc20517;   % 982: 	la 	a0, TempBuffer			# Endereco do buffer de string %
00000ca9 : b0850513;   % 982:  %
00000caa : 00a00593;   % 983: 	li 	a1, 10				# numero maximo de digitos %
00000cab : f5dff0ef;   % 984: 	jal 	readString			# le uma string de ate 10 digitos, a3 numero de digitos %
00000cac : 00c002b3;   % 985: 	mv 	t0, a2				# copia endereco do ultimo digito %
00000cad : 00a00393;   % 986: 	li 	t2, 10				# dez %
00000cae : 00100e13;   % 987: 	li 	t3, 1				# dezenas, centenas, etc %
00000caf : 00000533;   % 988: 	mv 	a0, zero			# zera o numero %
00000cb0 : 0c068e63;   % 990: loopReadInt: 	beq	a3,zero, fimReadInt	# Leu todos os digitos %
00000cb1 : 00028303;   % 991: 	lb 	t1, (t0)			# le um digito %
00000cb2 : 02d00213;   % 992: 	li	tp, 0x0000002D %
00000cb3 : 0c430663;   % 993: 	beq 	t1, tp, ehnegReadInt		# = '-' %
00000cb4 : 02b00213;   % 994: 	li	tp, 0x0000002B %
00000cb5 : 0c430463;   % 995: 	beq 	t1, tp, ehposReadInt		# = '+' %
00000cb6 : 03000213;   % 996: 	li	tp, 0x00000030 %
00000cb7 : 0a434c63;   % 997: 	blt 	t1, tp, naoehReadInt		# <'0' %
00000cb8 : 03900213;   % 998: 	li	tp, 0x00000039 %
00000cb9 : 0a624863;   % 999: 	bgt 	t1, tp, naoehReadInt		# >'9' %
00000cba : fd030313;   % 1000: 	addi 	t1, t1, -48			# transforma ascii em numero %
00000cbb : 30102c73;   % 1001: <29> csrr s8, misa %
00000cbc : 00cc5c13;   % 1001: <30> srli s8, s8, 12 %
00000cbd : 001c7c13;   % 1001: <31> andi s8, s8, 0x001 %
00000cbe : 020c1e63;   % 1001: <32> bnez s8, readInt.mul1 %
00000cbf : ff410113;   % 1002: <45> addi 	sp, sp, -12 %
00000cc0 : 00a12023;   % 1002: <46> sw	a0, 0(sp) %
00000cc1 : 00b12223;   % 1002: <47> sw	a1, 4(sp) %
00000cc2 : 00112423;   % 1002: <48> sw	ra, 8(sp) %
00000cc3 : 00600533;   % 1002: <50> mv 	a0, t1 %
00000cc4 : 01c005b3;   % 1002: <51> mv 	a1, t3 %
00000cc5 : 2a9000ef;   % 1002: <52> jal 	__mulsi3 %
00000cc6 : 04051073;   % 1002: <53> csrw	a0,uscratch %
00000cc7 : 00012503;   % 1002: <55> lw	a0, 0(sp) %
00000cc8 : 00412583;   % 1002: <56> lw	a1, 4(sp) %
00000cc9 : 00812083;   % 1002: <57> lw	ra, 8(sp) %
00000cca : 00c10113;   % 1002: <58> addi 	sp, sp, 12 %
00000ccb : 04002373;   % 1002: <59> csrr	t1,uscratch %
00000ccc : 0080006f;   % 1003: 	j readInt.mul1d %
00000ccd : 03c30333;   % 1004: readInt.mul1: 	mul 	t1, t1, t3			# multiplica por dezenas/centenas %
00000cce : 00650533;   % 1005: readInt.mul1d:	add 	a0, a0, t1			# soma no numero %
00000ccf : 30102c73;   % 1006: <29> csrr s8, misa %
00000cd0 : 00cc5c13;   % 1006: <30> srli s8, s8, 12 %
00000cd1 : 001c7c13;   % 1006: <31> andi s8, s8, 0x001 %
00000cd2 : 020c1e63;   % 1006: <32> bnez s8, readInt.mul2 %
00000cd3 : ff410113;   % 1007: <45> addi 	sp, sp, -12 %
00000cd4 : 00a12023;   % 1007: <46> sw	a0, 0(sp) %
00000cd5 : 00b12223;   % 1007: <47> sw	a1, 4(sp) %
00000cd6 : 00112423;   % 1007: <48> sw	ra, 8(sp) %
00000cd7 : 01c00533;   % 1007: <50> mv 	a0, t3 %
00000cd8 : 007005b3;   % 1007: <51> mv 	a1, t2 %
00000cd9 : 259000ef;   % 1007: <52> jal 	__mulsi3 %
00000cda : 04051073;   % 1007: <53> csrw	a0,uscratch %
00000cdb : 00012503;   % 1007: <55> lw	a0, 0(sp) %
00000cdc : 00412583;   % 1007: <56> lw	a1, 4(sp) %
00000cdd : 00812083;   % 1007: <57> lw	ra, 8(sp) %
00000cde : 00c10113;   % 1007: <58> addi 	sp, sp, 12 %
00000cdf : 04002e73;   % 1007: <59> csrr	t3,uscratch %
00000ce0 : 0080006f;   % 1008: 	j readInt.mul2d %
00000ce1 : 027e0e33;   % 1009: readInt.mul2: 	mul 	t3, t3, t2			# proxima dezena/centena %
00000ce2 : fff28293;   % 1010: readInt.mul2d:	addi 	t0, t0, -1			# busca o digito anterior %
00000ce3 : fff68693;   % 1011: 	addi	a3, a3, -1			# reduz o contador de digitos  %
00000ce4 : f31ff06f;   % 1012: 	j 	loopReadInt			# volta para buscar proximo digito %
00000ce5 : 0080006f;   % 1015: 		j fimReadInt			# como nao esta implmentado apenas retorna %
00000ce6 : 40a00533;   % 1017: ehnegReadInt:	sub a0,zero,a0			# se for negativo %
00000ce7 : 00012083;   % 1021: fimReadInt:	lw 	ra, 0(sp)		# recupera ra %
00000ce8 : 00410113;   % 1022: 		addi 	sp, sp, 4		# libera espaco %
00000ce9 : 00008067;   % 1023: 		ret				# fim ReadInt %
00000cea : 10008c37;   % 1043: <9> li s8, 0x10008000	# carrega tp %
00000ceb : 000c0c13;   % 1043:  %
00000cec : 01819863;   % 1043: <10> bne gp, s8, midiOutDE2	# Na DE1 gp = 0 ! Não tem segmento .extern %
00000ced : 01f00893;   % 1045: 	li a7,31		# Chama o ecall normal %
00000cee : 00000073;   % 1046: 	ecall %
00000cef : 0600006f;   % 1047: 	j fimmidiOut %
00000cf0 : ff2002b7;   % 1049: midiOutDE2:	li      t0, 0xFF200178 %
00000cf1 : 17828293;   % 1049:  %
00000cf2 : 00000333;   % 1050:     		add     t1, zero, zero %
00000cf3 : 00f67393;   % 1055:    	 	andi    t2, a2, 0x0000000F %
00000cf4 : 01b39393;   % 1056:     		slli    t2, t2, 27 %
00000cf5 : 00736333;   % 1057:     		or      t1, t1, t2 %
00000cf6 : 07f6f393;   % 1060:     		andi    t2, a3, 0x0000007F %
00000cf7 : 01439393;   % 1061:     		slli    t2, t2, 20 %
00000cf8 : 00736333;   % 1062:     		or      t1, t1, t2 %
00000cf9 : 07f57393;   % 1065:     		andi    t2, a0, 0x0000007F %
00000cfa : 00d39393;   % 1066:     		slli    t2, t2, 13 %
00000cfb : 00736333;   % 1067:     		or      t1, t1, t2 %
00000cfc : 1ff00e93;   % 1070: 		li 	t4, 0x1FF %
00000cfd : 004e9e93;   % 1071: 		slli 	t4, t4, 4 %
00000cfe : 00fe8e93;   % 1072: 		addi 	t4, t4, 0x00F			# t4 = 0x00001FFF %
00000cff : 01d5f3b3;   % 1073:     		and    	t2, a1, t4 %
00000d00 : 00736333;   % 1074:     		or      t1, t1, t2 %
00000d01 : 0040006f;   % 1077:     		j       SintMidOut %
00000d02 : 0062a023;   % 1079: SintMidOut:	sw	t1, 0(t0) %
00000d03 : ff2003b7;   % 1082: 	    		li      t2, 0xFF20017C %
00000d04 : 17c38393;   % 1082:  %
00000d05 : 0003ae03;   % 1083: Check_AUD_DACLRCK:     	lw      t3, 0(t2) %
00000d06 : fe0e0ee3;   % 1084:     			beq     t3, zero, Check_AUD_DACLRCK %
00000d07 : 00008067;   % 1086: fimmidiOut:    		ret %
00000d08 : 10008c37;   % 1104: <9> li s8, 0x10008000	# carrega tp %
00000d09 : 000c0c13;   % 1104:  %
00000d0a : 01819863;   % 1104: <10> bne gp, s8, midiOutSyncDE2	# Na DE1 gp = 0 ! Não tem segmento .extern %
00000d0b : 02100893;   % 1106: 	li a7,33		# Chama o ecall normal %
00000d0c : 00000073;   % 1107: 	ecall %
00000d0d : 0780006f;   % 1108: 	j fimmidiOutSync %
00000d0e : ff2002b7;   % 1110: midiOutSyncDE2:	li      t0, 0xFF200178 %
00000d0f : 17828293;   % 1110:  %
00000d10 : 00000333;   % 1111:     		add     t1, zero, zero %
00000d11 : 08000337;   % 1114:     		lui    	t1, 0x08000 %
00000d12 : 00431313;   % 1115: 		slli	t1,t1,4 %
00000d13 : 00f67393;   % 1118:     		andi    t2, a2, 0x00F %
00000d14 : 01b39393;   % 1119:     		slli    t2, t2, 27 %
00000d15 : 00736333;   % 1120:     		or      t1, t1, t2 %
00000d16 : 07f6f393;   % 1123:     		andi    t2, a3, 0x07F %
00000d17 : 01439393;   % 1124:     		slli    t2, t2, 20 %
00000d18 : 00736333;   % 1125:     		or      t1, t1, t2 %
00000d19 : 07f57393;   % 1128:     		andi    t2, a0, 0x07F %
00000d1a : 00d39393;   % 1129:     		slli    t2, t2, 13 %
00000d1b : 00736333;   % 1130:     		or      t1, t1, t2 %
00000d1c : 1ff00e93;   % 1133: 		li 	t4, 0x1FF %
00000d1d : 004e9e93;   % 1134: 		slli 	t4, t4, 4 %
00000d1e : 00fe8e93;   % 1135: 		addi 	t4, t4, 0x00F			# t4 = 0x00001FFF %
00000d1f : 01d5f3b3;   % 1136:     		and    	t2, a1, t4 %
00000d20 : 00736333;   % 1137:     		or      t1, t1, t2 %
00000d21 : 0040006f;   % 1140:     		j       SintMidOutSync %
00000d22 : 0062a023;   % 1142: SintMidOutSync:	sw	t1, 0(t0) %
00000d23 : ff2003b7;   % 1145:     		li      t2, 0xFF20017C %
00000d24 : 17c38393;   % 1145:  %
00000d25 : ff200eb7;   % 1146:     		li      t4, 0xFF200180 %
00000d26 : 180e8e93;   % 1146:  %
00000d27 : 0003ae03;   % 1148: Check_AUD_DACLRCKSync:	lw      t3, 0(t2) %
00000d28 : fe0e0ee3;   % 1149:     			beq     t3, zero, Check_AUD_DACLRCKSync %
00000d29 : 000eaf03;   % 1151: Melody:     	lw      t5, 0(t4) %
00000d2a : fe0f1ee3;   % 1152:     		bne     t5, zero, Melody %
00000d2b : 00008067;   % 1154: fimmidiOutSync:	ret %
00000d2c : ffc10113;   % 1164: printFloat:	addi 	sp, sp, -4 %
00000d2d : 00112023;   % 1165: 		sw 	ra, 0(sp)				# salva ra %
00000d2e : 0fc20417;   % 1166: 		la 	s0, TempBuffer %
00000d2f : 8f040413;   % 1166:  %
00000d30 : 02b00293;   % 1169: 		li 	t0, '+'			# define sinal '+' %
00000d31 : e00504d3;   % 1170: 		fmv.x.s s1, fa0			# recupera o numero float sem conversao %
00000d32 : 01f4d493;   % 1171: 		srli	s1, s1, 31		# bit 31(sinal) em bit 0, numero eh negativo s1=1 %
00000d33 : 00048463;   % 1172: 		beq 	s1, zero, ehposprintFloat	# eh positivo s1=0 %
00000d34 : 02d00293;   % 1173: 		li 	t0, '-'				# define sinal '-' %
00000d35 : 00540023;   % 1174: ehposprintFloat: sb 	t0, 0(s0)			# coloca sinal no buffer %
00000d36 : 00140413;   % 1175: 		addi 	s0, s0, 1			# incrementa o endereco do buffer %
00000d37 : e00502d3;   % 1178: 		 fmv.x.s t0, fa0			# recupera o numero float sem conversao %
00000d38 : 7f800337;   % 1179: 		 lui	t1, 0x7F800 %
00000d39 : 0062f2b3;   % 1180: 		 and 	t0, t0, t1   			# mascara com 0111 1111 1000 0000 0000 0000... %
00000d3a : 00129293;   % 1181: 		 slli 	t0, t0, 1			# tira o sinal do numero %
00000d3b : 0182d293;   % 1182: 		 srli 	t0, t0, 24			# recupera o expoente %
00000d3c : e0050353;   % 1185: 		fmv.x.s t1, fa0				# recupera o numero float sem conversao %
00000d3d : 008003b7;   % 1186: 		li 	t2, 0x007FFFFF			# t2 = 0x007FFFFF %
00000d3e : fff38393;   % 1186:  %
00000d3f : 00737333;   % 1187: 		and 	t1, t1, t2			# mascara com 0000 0000 0111 1111 1111... 		  %
00000d40 : 14028c63;   % 1189: 		beq 	t0, zero, ehExp0printFloat	# Expoente = 0 %
00000d41 : 0ff00213;   % 1190: 		li	tp, 0x000000FF			# TP = 255 %
00000d42 : 16428c63;   % 1191: 		beq 	t0, tp, ehExp255printFloat	# Expoente = 255 %
00000d43 : 20a52053;   % 1195: 		fabs.s 		ft0, fa0		# ft0 recebe o modulo  de x %
00000d44 : 00100213;   % 1196: 		li		tp, 1 %
00000d45 : d00270d3;   % 1197: 		fcvt.s.w 	ft1, tp			# ft1 recebe o numero 1.0 %
00000d46 : 00a00213;   % 1198: 		li		tp, 10 %
00000d47 : d0027353;   % 1199: 		fcvt.s.w 	ft6, tp			# ft6 recebe o numero 10.0 %
00000d48 : 00200213;   % 1200: 		li		tp, 2 %
00000d49 : d0027e53;   % 1201: 		fcvt.s.w 	ft8, tp %
00000d4a : 19c0f3d3;   % 1202: 		fdiv.s		ft7, ft1, ft8		# ft7 recebe o numero 0.5 %
00000d4b : a0101ed3;   % 1204: 		flt.s 	t4, ft0, ft1		# ft0 < 1.0 ? Se sim, E deve ser negativo %
00000d4c : 000e9663;   % 1205: 		bnez	t4, menor1printFloat	# se a comparacao deu true (1), pula %
00000d4d : 20630153;   % 1206: 		fmv.s 	ft2, ft6		# ft2  fator de multiplicacao = 10 %
00000d4e : 02c0006f;   % 1207: 		j 	cont2printFloat		# vai para expoente positivo %
00000d4f : 1860f153;   % 1208: menor1printFloat: fdiv.s ft2,ft1,ft6		# ft2 fator multiplicativo = 0.1 %
00000d50 : 20000253;   % 1211: cont1printFloat: 	fmv.s 	ft4, ft0			# inicia com o numero x  %
00000d51 : 201081d3;   % 1212: 		 	fmv.s 	ft3, ft1			# contador comeca em 1 %
00000d52 : 18227253;   % 1213: loop1printFloat: 	fdiv.s 	ft4, ft4, ft2			# divide o numero pelo fator multiplicativo %
00000d53 : a0120e53;   % 1214: 		 	fle.s 	t3, ft4, ft1			# o numero eh > que 1? entao fim %
00000d54 : 000e0663;   % 1215: 		 	beq 	t3,zero, fimloop1printFloat %
00000d55 : 0011f1d3;   % 1216: 		 	fadd.s 	ft3, ft3, ft1			# incrementa o contador %
00000d56 : ff1ff06f;   % 1217: 		 	j 	loop1printFloat			# volta ao loop %
00000d57 : 18227253;   % 1219: fimloop1printFloat: 	fdiv.s 	ft4, ft4, ft2			# ajusta o numero %
00000d58 : 0200006f;   % 1220: 		 	j 	intprintFloat			# vai para imprimir a parte inteira %
00000d59 : 20000253;   % 1223: cont2printFloat:	fmv.s 	 ft4, ft0			# inicia com o numero x  %
00000d5a : d00071d3;   % 1224: 		 	fcvt.s.w ft3, zero			# contador comeca em 0 %
00000d5b : a0621e53;   % 1225: loop2printFloat:  	flt.s 	 t3, ft4, ft6			# resultado eh < que 10? entao fim %
00000d5c : 18227253;   % 1226: 			fdiv.s 	 ft4, ft4, ft2			# divide o numero pelo fator multiplicativo %
00000d5d : 000e1663;   % 1227: 			bne 	 t3, zero, intprintFloat %
00000d5e : 0011f1d3;   % 1228: 		 	fadd.s 	 ft3, ft3, ft1			# incrementa o contador %
00000d5f : ff1ff06f;   % 1229: 		 	j 	 loop2printFloat %
00000d60 : 10227253;   % 1235: intprintFloat:		fmul.s 		ft4, ft4, ft2		# ajusta o numero %
00000d61 : 08727253;   % 1236: 			fsub.s		ft4, ft4, ft7		# tira 0.5, dessa forma sempre ao converter estaremos fazendo floor %
00000d62 : c00272d3;   % 1237: 		  	fcvt.w.s	t0, ft4			# coloca floor de ft4 em t0 %
00000d63 : 00727253;   % 1238: 			fadd.s		ft4, ft4, ft7		# readiciona 0.5 %
00000d64 : 00029463;   % 1239: 			bnez		t0, pulaeh1print	# para corrigir multiplos inteiros de 10! %
00000d65 : 00100293;   % 1240: 			li 		t0, 1 %
00000d66 : 03028293;   % 1241: pulaeh1print:		addi 		t0, t0, 48		# converte para ascii			 %
00000d67 : 00540023;   % 1242: 			sb 		t0, 0(s0)		# coloca no buffer %
00000d68 : 00140413;   % 1243: 		  	addi 		s0, s0, 1		# incrementta o buffer %
00000d69 : 02e00293;   % 1246: 		  	li 	t0, '.'				# carrega o '.' %
00000d6a : 00540023;   % 1247: 		  	sb 	t0, 0(s0)			# coloca no buffer %
00000d6b : 00140413;   % 1248: 		  	addi 	s0, s0, 1			# incrementa o buffer %
00000d6c : 00800313;   % 1251: 		  	li 		t1, 8				# contador de digitos  -  8 casas decimais %
00000d6d : 04030a63;   % 1252: loopfracprintFloat:  	beq 		t1, zero, fimfracprintFloat	# fim dos digitos? %
00000d6e : 08727253;   % 1253: 			fsub.s		ft4, ft4, ft7			# tira 0.5 %
00000d6f : c0027f53;   % 1254: 			fcvt.w.s 	t5, ft4				# floor de ft4 %
00000d70 : 00727253;   % 1255: 			fadd.s		ft4, ft4, ft7			# readiciona 0.5 %
00000d71 : d00f72d3;   % 1256: 			fcvt.s.w	ft5, t5				# reconverte em float so com a parte inteira %
00000d72 : 085272d3;   % 1257: 		  	fsub.s 		ft5, ft4, ft5			# parte fracionaria %
00000d73 : 1062f2d3;   % 1258: 		  	fmul.s 		ft5, ft5, ft6			# mult x 10 %
00000d74 : 0872f2d3;   % 1259: 			fsub.s		ft5, ft5, ft7			# tira 0.5 %
00000d75 : c002f2d3;   % 1260: 			fcvt.w.s	t0, ft5				# coloca floor de ft5 em 10 %
00000d76 : 03028293;   % 1261: 		  	addi 		t0, t0, 48			# converte para ascii %
00000d77 : 03000213;   % 1263: 			li 		tp, 48 %
00000d78 : 0042c663;   % 1264: 			blt		t0, tp, pulaprtFloat1	# testa se eh menor que '0' %
00000d79 : 03900213;   % 1265: 			li		tp, 57 %
00000d7a : 00525463;   % 1266: 			ble		t0, tp, pulaprtFloat2	# testa se eh menor ou igual que '9' %
00000d7b : 03000293;   % 1267: pulaprtFloat1:		li		t0, 48			# define como '0'		  			  	 %
00000d7c : 00540023;   % 1269: pulaprtFloat2:	  	sb 		t0, 0(s0)			# coloca no buffer %
00000d7d : 00140413;   % 1270: 		  	addi 		s0, s0, 1			# incrementa endereco %
00000d7e : fff30313;   % 1271: 		  	addi 		t1, t1, -1			# decrementa contador %
00000d7f : 0072f2d3;   % 1272: 			fadd.s		ft5, ft5, ft7			# reincrementa 0.5 %
00000d80 : 20528253;   % 1273: 		  	fmv.s 		ft4, ft5			# coloca o numero em ft4 %
00000d81 : fb1ff06f;   % 1274: 		  	j 		loopfracprintFloat		# volta ao loop %
00000d82 : 04500293;   % 1277: fimfracprintFloat: 	li 	t0,'E'			# carrega 'E' %
00000d83 : 00540023;   % 1278: 			sb 	t0, 0(s0)		# coloca no buffer %
00000d84 : 00140413;   % 1279: 			addi 	s0, s0, 1		# incrementa endereco %
00000d85 : 02b00293;   % 1282: 		  	li 	t0, '+'				# carrega '+' %
00000d86 : 000e8463;   % 1283: 		  	beqz 	t4, expposprintFloat		# nao eh negativo? %
00000d87 : 02d00293;   % 1284: 		  	li 	t0, '-'				# carrega '-' %
00000d88 : 00540023;   % 1285: expposprintFloat: 	sb 	t0, 0(s0)			# coloca no buffer %
00000d89 : 00140413;   % 1286: 		  	addi 	s0, s0, 1			#incrementa endereco %
00000d8a : 00a00313;   % 1289: 			li 	t1, 10				# carrega 10	 %
00000d8b : c001f253;   % 1290: 			fcvt.w.s  tp, ft3			# passa ft3 para t0 %
00000d8c : 026242b3;   % 1291: 			div 	t0, tp, t1			# divide por 10 (dezena) %
00000d8d : 026263b3;   % 1292: 			rem	t2, tp, t1			# t0 = quociente, t2 = resto %
00000d8e : 03028293;   % 1293: 			addi 	t0, t0, 48			# converte para ascii %
00000d8f : 00540023;   % 1294: 			sb 	t0, 0(s0)			# coloca no buffer %
00000d90 : 03038393;   % 1295: 			addi 	t2, t2, 48			# converte para ascii %
00000d91 : 007400a3;   % 1296: 			sb 	t2, 1(s0)			# coloca no buffer %
00000d92 : 00040123;   % 1297: 			sb 	zero, 2(s0)			# insere \NULL da string %
00000d93 : 0fc1f517;   % 1298: 			la 	a0, TempBuffer			# endereco do Buffer										 %
00000d94 : 75c50513;   % 1298:  %
00000d95 : 0500006f;   % 1299: 	  		j 	fimprintFloat			# imprime a string %
00000d96 : 00030e63;   % 1301: ehExp0printFloat: 	beq 	t1, zero, eh0printFloat		# Verifica se eh zero %
00000d97 : 0fc20517;   % 1303: ehDesnormprintFloat: 	la 	a0, NumDesnormP			# string numero desnormalizado positivo %
00000d98 : 95f50513;   % 1303:  %
00000d99 : 04048063;   % 1304: 			beq 	s1, zero, fimprintFloat		# o sinal eh 1? entao eh negativo %
00000d9a : 0fc20517;   % 1305: 		 	la 	a0, NumDesnormN			# string numero desnormalizado negativo %
00000d9b : 95c50513;   % 1305:  %
00000d9c : 0340006f;   % 1306: 			j 	fimprintFloat			# imprime a string %
00000d9d : 0fc20517;   % 1308: eh0printFloat:		la 	a0, NumZero			# string do zero %
00000d9e : 95950513;   % 1308:  %
00000d9f : 0280006f;   % 1309: 			j 	fimprintFloat 	 		# imprime a string %
00000da0 : 00030863;   % 1311: ehExp255printFloat: 	beq 	t1, zero, ehInfprintFloat	# se mantissa eh zero entao eh Infinito %
00000da1 : 0fc20517;   % 1313: ehNaNprintfFloat:	la 	a0, NumNaN			# string do NaN %
00000da2 : 96850513;   % 1313:  %
00000da3 : 0180006f;   % 1314: 			j 	fimprintFloat			# imprime string %
00000da4 : 0fc20517;   % 1316: ehInfprintFloat:	la 	a0, NumInfP			# string do infinito positivo %
00000da5 : 94850513;   % 1316:  %
00000da6 : 00048663;   % 1317: 			beq 	s1, zero, fimprintFloat		# o sinal eh 1? entao eh negativo %
00000da7 : 0fc20517;   % 1318: 			la 	a0, NumInfN			# string do infinito negativo %
00000da8 : 94650513;   % 1318:  %
00000da9 : 931ff0ef;   % 1322: 			jal	printString			# imprime a string em a0 %
00000daa : 00012083;   % 1323: 			lw 	ra, 0(sp)			# recupera ra %
00000dab : 00410113;   % 1324: 			addi 	sp, sp, 4			# libera espaco %
00000dac : 00008067;   % 1325: 			ret					# retorna %
00000dad : 00008067;   % 1343: 			ret %
00000dae : 00008067;   % 1361: 			ret %
00000daf : ffc10113;   % 1372: readFloat: addi sp, sp, -4			# aloca espaco %
00000db0 : 00112023;   % 1373: 	sw 	ra, 0(sp)			# salva ra %
00000db1 : 0fc1f517;   % 1374: 	la 	a0, TempBuffer			# endereco do FloatBuffer %
00000db2 : 6e450513;   % 1374:  %
00000db3 : 02000593;   % 1375: 	li 	a1, 32				# numero maximo de caracteres %
00000db4 : b39ff0ef;   % 1376: 	jal	readString			# le string, retorna a2 ultimo endereco e a3 numero de caracteres %
00000db5 : 00c00433;   % 1377: 	mv 	s0, a2				# ultimo endereco da string (antes do \0) %
00000db6 : 00d004b3;   % 1378: 	mv 	s1, a3				# numero de caracteres digitados %
00000db7 : 0fc1fb97;   % 1379: 	la	s7, TempBuffer			# Endereco do primeiro caractere %
00000db8 : 6ccb8b93;   % 1379:  %
00000db9 : 017002b3;   % 1381: lePrimeiroreadFloat:	mv 	t0, s7		# Endereco de Inicio %
00000dba : 00028303;   % 1382: 	lb 	t1, 0(t0)				# le primeiro caractere %
00000dbb : 06500213;   % 1383: 	li	tp, 'e'					# TP = 101 = 'e' %
00000dbc : 02430863;   % 1384: 	beq 	t1, tp, insere0AreadFloat		# insere '0' antes %
00000dbd : 04500213;   % 1385: 	li 	tp, 'E'					# TP = 69 = 'E' %
00000dbe : 02430463;   % 1386: 	beq 	t1, tp, insere0AreadFloat		# insere '0' antes %
00000dbf : 02e00213;   % 1387: 	li	tp, '.'					# TP = 46 = '.' %
00000dc0 : 02430063;   % 1388: 	beq 	t1, tp, insere0AreadFloat		#  insere '0' antes %
00000dc1 : 02b00213;   % 1389: 	li	tp, '+'					# TP = 43 = '+' %
00000dc2 : 00430863;   % 1390: 	beq 	t1, tp, pulaPrimreadChar		# pula o primeiro caractere %
00000dc3 : 02d00213;   % 1391: 	li	tp, '-'					# TP = 45 = '-' %
00000dc4 : 00430463;   % 1392: 	beq 	t1, tp, pulaPrimreadChar %
00000dc5 : 03c0006f;   % 1393: 	j leUltimoreadFloat %
00000dc6 : 001b8b93;   % 1395: pulaPrimreadChar: addi s7,s7,1			# incrementa o endereco inicial %
00000dc7 : fc9ff06f;   % 1396: 		  j lePrimeiroreadFloat		# volta a testar o novo primeiro caractere %
00000dc8 : 008002b3;   % 1398: insere0AreadFloat: mv t0, s0			# endereco do ultimo caractere %
00000dc9 : 00140413;   % 1399: 		   addi s0, s0, 1		# desloca o ultimo endereco para o proximo %
00000dca : 00148493;   % 1400: 	   	   addi s1, s1, 1		# incrementa o num. caracteres %
00000dcb : 000400a3;   % 1401: 	   	   sb 	zero, 1(s0)		# \NULL do final de string %
00000dcc : 01700f33;   % 1402: 	   	   mv t5, s7			# primeiro caractere %
00000dcd : 01e28a63;   % 1403: insere0Aloop:	   beq 	t0, t5, saiinsere0AreadFloat	# chegou no inicio entao fim %
00000dce : 00028303;   % 1404: 		   lb 	t1, 0(t0)		# le caractere %
00000dcf : 006280a3;   % 1405: 		   sb 	t1, 1(t0)		# escreve no proximo %
00000dd0 : fff28293;   % 1406: 		   addi t0, t0, -1		# decrementa endereco %
00000dd1 : ff1ff06f;   % 1407: 		   j insere0Aloop		# volta ao loop %
00000dd2 : 03000313;   % 1408: saiinsere0AreadFloat: li t1, '0'		# ascii '0' %
00000dd3 : 00628023;   % 1409: 		   sb t1, 0(t0)			# escreve '0' no primeiro caractere %
00000dd4 : 00040303;   % 1411: leUltimoreadFloat: lb  	t1, 0(s0)			# le ultimo caractere %
00000dd5 : 06500213;   % 1412: 		li	tp, 'e'				# TP = 101 = 'e' %
00000dd6 : 00430c63;   % 1413: 		beq 	t1, tp, insere0PreadFloat	# insere '0' depois %
00000dd7 : 04500213;   % 1414: 		li 	tp, 'E'				# TP = 69 = 'E' %
00000dd8 : 00430863;   % 1415: 		beq 	t1, tp, insere0PreadFloat	# insere '0' depois %
00000dd9 : 02e00213;   % 1416: 		li	tp, '.'				# TP = 46 = '.' %
00000dda : 00430463;   % 1417: 		beq 	t1, tp, insere0PreadFloat	# insere '0' depois %
00000ddb : 0180006f;   % 1418: 		j 	inicioreadFloat %
00000ddc : 00140413;   % 1420: insere0PreadFloat: addi	s0, s0, 1		# desloca o ultimo endereco para o proximo %
00000ddd : 00148493;   % 1421: 	   	   addi	s1, s1, 1		# incrementa o num. caracteres %
00000dde : 03000313;   % 1422: 		   li 	t1,'0'			# ascii '0' %
00000ddf : 00640023;   % 1423: 		   sb 	t1,0(s0)		# escreve '0' no ultimo %
00000de0 : 000400a3;   % 1424: 		   sb 	zero,1(s0)		# \null do final de string %
00000de1 : d0007553;   % 1426: inicioreadFloat:  fcvt.s.w 	fa0, zero	# fa0 Resultado inicialmente zero %
00000de2 : 00a00293;   % 1427: 		li 	t0, 10			# inteiro 10	 %
00000de3 : d002f353;   % 1428: 		fcvt.s.w 	ft6, t0		# ft6 contem sempre o numero cte 10.0000 %
00000de4 : 00100293;   % 1429: 		li 	t0, 1			# inteiro 1 %
00000de5 : d002f0d3;   % 1430: 		fcvt.s.w 	ft1, t0		# ft1 contem sempre o numero cte 1.0000	 %
00000de6 : 00140993;   % 1433: procuraEreadFloat:	addi 	s3, s0, 1			# inicialmente nao tem 'e' ou 'E' na string (fora da string) %
00000de7 : 017002b3;   % 1434: 			mv 	t0, s7				# endereco inicial %
00000de8 : 02828263;   % 1435: loopEreadFloat: 	beq 	t0, s0, naotemEreadFloat	# sai se nao encontrou 'e' %
00000de9 : 00028303;   % 1436: 			lb 	t1, 0(t0)			# le o caractere %
00000dea : 06500213;   % 1437: 			li	tp, 'e'				# TP = 101 = 'e' %
00000deb : 00430a63;   % 1438: 			beq 	t1, tp, ehEreadFloat		# tem 'e' %
00000dec : 04500213;   % 1439: 			li 	tp, 'E'				# TP = 69 = 'E' %
00000ded : 00430663;   % 1440: 			beq	t1, tp, ehEreadFloat		# tem 'E' %
00000dee : 00128293;   % 1441: 			addi 	t0, t0, 1			# incrementa endereco %
00000def : fe5ff06f;   % 1442: 			j 	loopEreadFloat			# volta ao loop %
00000df0 : 005009b3;   % 1443: ehEreadFloat: 		mv 	s3, t0				# endereco do 'e' ou 'E' na string %
00000df1 : 01300933;   % 1447: procuraPontoreadFloat:	mv 	s2, s3				# local inicial do ponto na string (='e' se existir) ou fora da string	 %
00000df2 : 017002b3;   % 1448: 			mv 	t0, s7				# endereco inicial %
00000df3 : 00828e63;   % 1449: loopPontoreadFloat: 	beq 	t0, s0, naotemPontoreadFloat	# sai se nao encontrou '.' %
00000df4 : 00028303;   % 1450: 			lb 	t1, 0(t0)			# le o caractere %
00000df5 : 02e00213;   % 1451: 			li	tp, '.'				# TP = 46 = '.' %
00000df6 : 00430663;   % 1452: 			beq 	t1, tp, ehPontoreadFloat	# tem '.' %
00000df7 : 00128293;   % 1453: 			addi 	t0, t0, 1			# incrementa endereco %
00000df8 : fedff06f;   % 1454: 			j 	loopPontoreadFloat		# volta ao loop %
00000df9 : 00500933;   % 1455: ehPontoreadFloat: 	mv 	s2, t0				# endereco do '.' na string %
00000dfa : d0007153;   % 1459: intreadFloat:		fcvt.s.w 	ft2, zero		# zera parte inteira %
00000dfb : fff90293;   % 1460: 			addi 	t0, s2, -1			# endereco do caractere antes do ponto %
00000dfc : 201081d3;   % 1461: 			fmv.s 	ft3, ft1			# ft3 contem unidade/dezenas/centenas		 %
00000dfd : 01700f33;   % 1462: 			mv 	t5, s7				# Primeiro Endereco %
00000dfe : 03e2ca63;   % 1463: loopintreadFloat: 	blt 	t0, t5, fimintreadFloat		# sai se o endereco for < inicio da string %
00000dff : 00028303;   % 1464: 			lb 	t1, 0(t0)			# le o caracter %
00000e00 : 03000213;   % 1465: 			li	tp, '0'				# TP = 48 = '0' %
00000e01 : 10434863;   % 1466: 			blt 	t1, tp, erroreadFloat		# nao eh caractere valido para numero %
00000e02 : 03900213;   % 1467: 			li	tp, '9'				# TP = 57 = '9' %
00000e03 : 10624463;   % 1468: 			bgt 	t1, tp, erroreadFloat		# nao eh caractere valido para numero %
00000e04 : fd030313;   % 1469: 			addi 	t1, t1, -48			# converte ascii para decimal %
00000e05 : d0037153;   % 1470: 			fcvt.s.w  ft2, t1			# digito lido em float %
00000e06 : 10317153;   % 1472: 			fmul.s 	ft2,ft2,ft3			# multiplica por un/dezena/centena %
00000e07 : 00257553;   % 1473: 			fadd.s 	fa0,fa0,ft2			# soma no resultado %
00000e08 : 1061f1d3;   % 1474: 			fmul.s 	ft3,ft3,ft6			# proxima dezena/centena %
00000e09 : fff28293;   % 1476: 			addi 	t0,t0,-1			# endereco anterior %
00000e0a : fd1ff06f;   % 1477: 			j 	loopintreadFloat		# volta ao loop %
00000e0b : d0007153;   % 1481: fracreadFloat:		fcvt.s.w 	ft2, zero		# zera parte fracionaria %
00000e0c : 00190293;   % 1482: 			addi 	t0, s2, 1			# endereco depois do ponto %
00000e0d : 1860f1d3;   % 1483: 			fdiv.s 	ft3, ft1, ft6			# ft3 inicial 0.1 %
00000e0e : 0332da63;   % 1485: loopfracreadFloat: 	bge 	t0, s3, fimfracreadFloat	# endereco eh 'e' 'E' ou >ultimo %
00000e0f : 00028303;   % 1486: 			lb 	t1, 0(t0)			# le o caracter %
00000e10 : 03000213;   % 1487: 			li	tp, '0'				# TP = 48 = '0' %
00000e11 : 0c434863;   % 1488: 			blt 	t1, tp, erroreadFloat		# nao eh valido %
00000e12 : 03900213;   % 1489: 			li	tp, '9'				# TP = 57 = '9' %
00000e13 : 0c624463;   % 1490: 			bgt 	t1, tp, erroreadFloat		# nao eh valido %
00000e14 : fd030313;   % 1491: 			addi 	t1, t1, -48			# converte ascii para decimal %
00000e15 : d0037153;   % 1492: 			fcvt.s.w 	ft2, t1			# digito lido em float		 %
00000e16 : 10317153;   % 1494: 			fmul.s 	ft2, ft2, ft3			# multiplica por ezena/centena %
00000e17 : 00257553;   % 1495: 			fadd.s 	fa0, fa0, ft2			# soma no resultado %
00000e18 : 1861f1d3;   % 1496: 			fdiv.s 	ft3, ft3, ft6			# proxima frac un/dezena/centena %
00000e19 : 00128293;   % 1498: 			addi 	t0, t0, 1			# proximo endereco %
00000e1a : fd1ff06f;   % 1499: 			j 	loopfracreadFloat		# volta ao loop		 %
00000e1b : d0007153;   % 1504: potreadFloat:		fcvt.s.w 	ft2, zero		# zera potencia %
00000e1c : 00198293;   % 1505: 			addi 	t0, s3, 1			# endereco seguinte ao 'e' %
00000e1d : 00000a13;   % 1506: 			li 	s4, 0				# sinal do expoente positivo %
00000e1e : 00028303;   % 1507: 			lb 	t1, 0(t0)			# le o caractere seguinte ao 'e' %
00000e1f : 02d00213;   % 1508: 			li	tp, '-'				# TP = 45 = '-' %
00000e20 : 00430863;   % 1509: 			beq	t1, tp, potsinalnegreadFloat	# sinal do expoente esta escrito e eh positivo %
00000e21 : 02b00213;   % 1510: 			li	tp, '+'				# TP = 43 = '+' %
00000e22 : 00430663;   % 1511: 			beq 	t1, tp, potsinalposreadFloat	# sinal do expoente eh negativo %
00000e23 : 00c0006f;   % 1512: 			j 	pulapotsinalreadFloat		# nao esta escrito o sinal do expoente %
00000e24 : 00100a13;   % 1513: potsinalnegreadFloat:	li 	s4, 1				# s4=1 expoente negativo %
00000e25 : 00128293;   % 1514: potsinalposreadFloat:	addi 	t0, t0, 1			# se tiver '-' ou '+' avanca para o proximo endereco %
00000e26 : 00500ab3;   % 1515: pulapotsinalreadFloat:	mv 	s5, t0 				# Neste ponto s5 contem o endereco do primeiro digito da pot e s4 o sinal do expoente		 %
00000e27 : 201081d3;   % 1517: 			fmv.s 	ft3, ft1			# ft3 un/dez/cen = 1 %
00000e28 : 00000393;   % 1520: expreadFloat:		li 	t2, 0				# zera expoente %
00000e29 : 008002b3;   % 1521: 			mv 	t0, s0				# endereco do ultimo caractere da string %
00000e2a : 00a00e13;   % 1522: 			li 	t3, 10				# numero dez %
00000e2b : 00100e93;   % 1523: 			li 	t4, 1				# und/dez/cent %
00000e2c : 0352c063;   % 1525: loopexpreadFloat:	blt 	t0, s5, fimexpreadFloat		# ainda nao eh o endereco do primeiro digito? %
00000e2d : 00028303;   % 1526: 			lb 	t1, 0(t0)			# le o caracter %
00000e2e : fd030313;   % 1527: 			addi 	t1, t1, -48			# converte ascii para decimal %
00000e2f : 03d30333;   % 1528: 			mul 	t1, t1, t4			# mul digito %
00000e30 : 006383b3;   % 1529: 			add 	t2, t2, t1			# soma ao exp %
00000e31 : 03ce8eb3;   % 1530: 			mul 	t4, t4, t3			# proxima casa decimal %
00000e32 : fff28293;   % 1531: 			addi 	t0, t0, -1			# endereco anterior %
00000e33 : fe5ff06f;   % 1532: 			j loopexpreadFloat			# volta ao loop %
00000e34 : 20108153;   % 1536: 			fmv.s 	ft2, ft1			# numero 10^exp  inicial=1 %
00000e35 : 206301d3;   % 1537: 			fmv.s 	ft3, ft6			# se o sinal for + ft3 eh 10 %
00000e36 : 00000213;   % 1538: 			li	tp, 0x00000000			# TP = ZERO %
00000e37 : 004a0463;   % 1539: 			beq 	s4, tp, sinalexpPosreadFloat	# se sinal exp positivo %
00000e38 : 1860f1d3;   % 1540: 			fdiv.s 	ft3, ft1, ft6			# se o final for - ft3 eh 0.1 %
00000e39 : 00000293;   % 1541: sinalexpPosreadFloat:	li 	t0, 0				# contador  %
00000e3a : 00728863;   % 1542: sinalexpreadFloat: 	beq 	t0, t2, fimsinalexpreadFloat	# se chegou ao fim %
00000e3b : 10317153;   % 1543: 			fmul.s 	ft2, ft2, ft3			# multiplica pelo fator 10 ou 0.1 %
00000e3c : 00128293;   % 1544: 			addi 	t0, t0, 1			# incrementa o contador %
00000e3d : ff5ff06f;   % 1545: 			j 	sinalexpreadFloat %
00000e3e : 10257553;   % 1548: 		fmul.s 	fa0, fa0, ft2		# multiplicacao final! %
00000e3f : 0fc1f297;   % 1550: 		la 	t0, TempBuffer		# ajuste final do sinal do numero %
00000e40 : 4ac28293;   % 1550:  %
00000e41 : 00028303;   % 1551: 		lb 	t1, 0(t0)		# le primeiro caractere %
00000e42 : 02d00213;   % 1552: 		li	tp, '-'			# TP = 45 = '-' %
00000e43 : 00431463;   % 1553: 		bne 	t1, tp, fimreadFloat	# nao eh '-' entao fim %
00000e44 : 20a51553;   % 1554: 		fneg.s 	fa0, fa0		# nega o numero float %
00000e45 : 00012083;   % 1557: fimreadFloat: 	lw 	ra, 0(sp)		# recupera ra %
00000e46 : 00410113;   % 1558: 		addi 	sp, sp, 4		# libera espaco %
00000e47 : 00008067;   % 1559: 		ret				# retorna %
00000e48 : 10008c37;   % 1567: <9> li s8, 0x10008000	# carrega tp %
00000e49 : 000c0c13;   % 1567:  %
00000e4a : 01819863;   % 1567: <10> bne gp, s8, Time.DE1	# Na DE1 gp = 0 ! Não tem segmento .extern %
00000e4b : 01e00893;   % 1568: 	li 	a7, 30				# Chama o ecall do Rars %
00000e4c : 00000073;   % 1569: 	ecall %
00000e4d : 00008067;   % 1570: 	ret					# saida %
00000e4e : c0102573;   % 1572: Time.DE1:	csrr a0, time			#  Le time LOW %
00000e4f : c81025f3;   % 1573: 		csrr a1, timeh 			#  Le time HIGH %
00000e50 : 00008067;   % 1574: 		ret %
00000e51 : 10008c37;   % 1581: <9> li s8, 0x10008000	# carrega tp %
00000e52 : 000c0c13;   % 1581:  %
00000e53 : 01819863;   % 1581: <10> bne gp, s8, Sleep.DE1	# Na DE1 gp = 0 ! Não tem segmento .extern %
00000e54 : 02000893;   % 1582: 	li 	a7, 32				# Chama o ecall do Rars %
00000e55 : 00000073;   % 1583: 	ecall %
00000e56 : 00008067;   % 1584: 	ret					#Saida %
00000e57 : c01022f3;   % 1586: Sleep.DE1:	csrr 	t0, time		# Le o tempo do sistema %
00000e58 : 00a28333;   % 1587: 		add 	t1, t0, a0		# soma com o tempo solicitado %
00000e59 : c01022f3;   % 1588: Sleep.Loop:	csrr	t0, time		# Le o tempo do sistema %
00000e5a : fe62eee3;   % 1589: 		bltu	t0, t1, Sleep.Loop	# t0<t1 ? %
00000e5b : 00008067;   % 1590: 		ret %
00000e5c : 10008c37;   % 1598: <9> li s8, 0x10008000	# carrega tp %
00000e5d : 000c0c13;   % 1598:  %
00000e5e : 01819863;   % 1598: <10> bne gp, s8, Random.DE1	# Na DE1 gp = 0 ! Não tem segmento .extern %
00000e5f : 02900893;   % 1599: 	li 	a7,41			# Chama o ecall do Rars %
00000e60 : 00000073;   % 1600: 	ecall	 %
00000e61 : 00008067;   % 1601: 	ret				# saida %
00000e62 : ff2002b7;   % 1603: Random.DE1: 	li 	t0, 0xFF200514	# carrega endereco do LFSR %
00000e63 : 51428293;   % 1603:  %
00000e64 : 0002a503;   % 1604: 		lw 	a0, 0(t0)	# le a word em a0 %
00000e65 : 00008067;   % 1605: 		ret			# retorna %
00000e66 : 10008c37;   % 1615: <9> li s8, 0x10008000	# carrega tp %
00000e67 : 000c0c13;   % 1615:  %
00000e68 : 01819863;   % 1615: <10> bne gp, s8, Random2.DE1	# Na DE1 gp = 0 ! Não tem segmento .extern %
00000e69 : 02a00893;   % 1616: 		li 	a7,42			# Chama o ecall do Rars %
00000e6a : 00000073;   % 1617: 		ecall	 %
00000e6b : 00008067;   % 1618: 		ret				# saida %
00000e6c : ff2002b7;   % 1620: Random2.DE1: 	li 	t0, 0xFF200514	# carrega endereco do LFSR %
00000e6d : 51428293;   % 1620:  %
00000e6e : 0002a503;   % 1621: 		lw 	a0, 0(t0)	# le a word em a0 %
00000e6f : 4b0000ef;   % 1622: 		jal 	__umodsi3 %
00000e70 : 00008067;   % 1624: 		ret			# retorna %
00000e71 : 00058c63;   % 1635: clsCLS:	beq 	a1, zero, CLS.frame0 %
00000e72 : ff100337;   % 1636: 	li      t1, 0xFF100000              # Memoria VGA 1 %
00000e73 : 00030313;   % 1636:  %
00000e74 : ff1133b7;   % 1637:    	li      t2, 0xFF112C00 %
00000e75 : c0038393;   % 1637:  %
00000e76 : 0140006f;   % 1638:    	j 	CLS.pula %
00000e77 : ff000337;   % 1639: CLS.frame0: 	li      t1, 0xFF000000           # Memoria VGA 0 %
00000e78 : 00030313;   % 1639:  %
00000e79 : ff0133b7;   % 1640:    	    	li      t2, 0xFF012C00   	 %
00000e7a : c0038393;   % 1640:  %
00000e7b : 0ff57513;   % 1641: CLS.pula:	andi    a0, a0, 0x00FF %
00000e7c : 00a002b3;   % 1644:  		mv 	t0, a0 %
00000e7d : 00851513;   % 1645:  		slli 	a0, a0, 8 %
00000e7e : 00a2e2b3;   % 1646:  		or 	t0, t0, a0 %
00000e7f : 00851513;   % 1647:  		slli 	a0, a0, 8 %
00000e80 : 00a2e2b3;   % 1648:  		or 	t0, t0, a0 %
00000e81 : 00851513;   % 1649:  		slli 	a0, a0, 8 %
00000e82 : 00a2e2b3;   % 1650:  		or 	t0, t0, a0 %
00000e83 : 00730863;   % 1652: CLS.for:	beq     t1, t2, CLS.fim %
00000e84 : 00532023;   % 1653: 		sw      t0, 0(t1) %
00000e85 : 00430313;   % 1654:     		addi    t1, t1, 4 %
00000e86 : ff5ff06f;   % 1655:     		j       CLS.for %
00000e87 : 00008067;   % 1656: CLS.fim:	ret %
00000e88 : ff000837;   % 1665: BRESENHAM: 	li	a6, 0xFF000000           	# Memoria VGA 0 %
00000e89 : 00080813;   % 1665:  %
00000e8a : 00078663;   % 1666: 	   	beq	a5, zero, pulaBRES %
00000e8b : ff100837;   % 1667: 	   	li 	a6, 0xFF100000              # Memoria VGA 1 %
00000e8c : 00080813;   % 1667:  %
00000e8d : 14000893;   % 1669: pulaBRES: 	li 	a7, 320 %
00000e8e : 40b682b3;   % 1670: 	  	sub 	t0, a3, a1 %
00000e8f : 0002d463;   % 1671: 	  	bge 	t0, zero, PULAABRES %
00000e90 : 405002b3;   % 1672: 	  	sub 	t0, zero, t0 %
00000e91 : 40a60333;   % 1673: PULAABRES:	sub 	t1, a2, a0 %
00000e92 : 00035463;   % 1674: 	   	bge  	t1, zero, PULABBRES %
00000e93 : 40600333;   % 1675: 	   	sub  	t1, zero, t1	 %
00000e94 : 0262d263;   % 1676: PULABBRES: 	bge  	t0, t1, PULACBRES %
00000e95 : 00a65e63;   % 1677: 	   	ble  	a0, a2, PULAC1BRES %
00000e96 : 00a007b3;   % 1678: 	   	mv 	a5, a0 %
00000e97 : 00c00533;   % 1679: 	   	mv 	a0, a2 %
00000e98 : 00f00633;   % 1680: 	   	mv 	a2, a5 %
00000e99 : 00b007b3;   % 1681: 	   	mv	a5, a1 %
00000e9a : 00d005b3;   % 1682: 	   	mv 	a1, a3 %
00000e9b : 00f006b3;   % 1683: 	   	mv 	a3, a5 %
00000e9c : 0240006f;   % 1684: PULAC1BRES:	j PLOTLOWBRES %
00000e9d : 00b6de63;   % 1686: PULACBRES: 	ble  	a1, a3, PULAC2BRES %
00000e9e : 00a007b3;   % 1687: 	   	mv 	a5, a0 %
00000e9f : 00c00533;   % 1688: 	   	mv 	a0, a2 %
00000ea0 : 00f00633;   % 1689: 	   	mv 	a2, a5 %
00000ea1 : 00b007b3;   % 1690: 	   	mv 	a5, a1 %
00000ea2 : 00d005b3;   % 1691: 	   	mv 	a1, a3 %
00000ea3 : 00f006b3;   % 1692: 	   	mv 	a3, a5 %
00000ea4 : 0a80006f;   % 1693: PULAC2BRES:	j PLOTHIGHBRES %
00000ea5 : 40a602b3;   % 1695: PLOTLOWBRES:	sub 	t0, a2, a0		# dx=x1-x0 %
00000ea6 : 40b68333;   % 1696: 	 	sub 	t1, a3, a1		# dy y1-y0 %
00000ea7 : 00100393;   % 1697: 	 	li  	t2, 1			# yi=1 %
00000ea8 : 00035663;   % 1698: 	 	bge 	t1, zero, PULA1BRES	# dy>=0 PULA %
00000ea9 : fff00393;   % 1699: 	 	li  	t2, -1			# yi=-1 %
00000eaa : 40600333;   % 1700: 	 	sub 	t1, zero, t1		# dy=-dy %
00000eab : 00131e13;   % 1701: PULA1BRES:	slli 	t3, t1, 1		# 2*dy %
00000eac : 405e0e33;   % 1702: 		sub 	t3, t3, t0		# D=2*dy-dx %
00000ead : 00b00eb3;   % 1703: 		mv 	t4, a1			# y=y0 %
00000eae : 00a00f33;   % 1704: 		mv 	t5, a0			# x=x0 %
00000eaf : 30102c73;   % 1706: <29> csrr s8, misa %
00000eb0 : 00cc5c13;   % 1706: <30> srli s8, s8, 12 %
00000eb1 : 001c7c13;   % 1706: <31> andi s8, s8, 0x001 %
00000eb2 : 020c1e63;   % 1706: <32> bnez s8, BRESENHAM.mul1 %
00000eb3 : ff410113;   % 1707: <45> addi 	sp, sp, -12 %
00000eb4 : 00a12023;   % 1707: <46> sw	a0, 0(sp) %
00000eb5 : 00b12223;   % 1707: <47> sw	a1, 4(sp) %
00000eb6 : 00112423;   % 1707: <48> sw	ra, 8(sp) %
00000eb7 : 01d00533;   % 1707: <50> mv 	a0, t4 %
00000eb8 : 011005b3;   % 1707: <51> mv 	a1, a7 %
00000eb9 : 2d8000ef;   % 1707: <52> jal 	__mulsi3 %
00000eba : 04051073;   % 1707: <53> csrw	a0,uscratch %
00000ebb : 00012503;   % 1707: <55> lw	a0, 0(sp) %
00000ebc : 00412583;   % 1707: <56> lw	a1, 4(sp) %
00000ebd : 00812083;   % 1707: <57> lw	ra, 8(sp) %
00000ebe : 00c10113;   % 1707: <58> addi 	sp, sp, 12 %
00000ebf : 04002ff3;   % 1707: <59> csrr	t6,uscratch %
00000ec0 : 0080006f;   % 1708: 		j BRESENHAM.mul1d %
00000ec1 : 031e8fb3;   % 1709: BRESENHAM.mul1:	mul 	t6, t4, a7		# y*320 %
00000ec2 : 01ef8fb3;   % 1710: BRESENHAM.mul1d:add 	t6, t6, t5		# y*320+x %
00000ec3 : 010f8fb3;   % 1711: 		add 	t6, t6, a6		# 0xFF000000+y*320+x %
00000ec4 : 00ef8023;   % 1712: 		sb 	a4, 0(t6)		# plot com cor a4 %
00000ec5 : 01c05863;   % 1714: 		ble 	t3, zero, PULA2BRES	# D<=0 %
00000ec6 : 007e8eb3;   % 1715: 		add 	t4, t4, t2		# y=y+yi %
00000ec7 : 00129f93;   % 1716: 		slli 	t6, t0, 1		# 2*dx %
00000ec8 : 41fe0e33;   % 1717: 		sub 	t3, t3, t6		# D=D-2dx %
00000ec9 : 00131f93;   % 1718: PULA2BRES:	slli 	t6, t1, 1		# 2*dy %
00000eca : 01fe0e33;   % 1719: 		add 	t3, t3, t6		# D=D+2dx %
00000ecb : 001f0f13;   % 1720: 		addi	t5, t5, 1 %
00000ecc : f8cf16e3;   % 1721: 		bne 	t5, a2, LOOPx1BRES %
00000ecd : 00008067;   % 1722: 		ret %
00000ece : 40a602b3;   % 1724: PLOTHIGHBRES: 	sub 	t0, a2, a0		# dx=x1-x0 %
00000ecf : 40b68333;   % 1725: 	 	sub 	t1, a3, a1		# dy y1-y0 %
00000ed0 : 00100393;   % 1726: 	 	li 	t2, 1			# xi=1 %
00000ed1 : 0002d663;   % 1727: 	 	bge 	t0, zero, PULA3BRES	# dy>=0 PULA %
00000ed2 : fff00393;   % 1728: 	 	li 	t2, -1			# xi=-1 %
00000ed3 : 405002b3;   % 1729: 	 	sub 	t0, zero, t0		# dx=-dx %
00000ed4 : 00129e13;   % 1730: PULA3BRES:	slli 	t3, t0, 1		# 2*dx %
00000ed5 : 406e0e33;   % 1731: 		sub 	t3, t3, t1		# D=2*dx-d1 %
00000ed6 : 00a00eb3;   % 1732: 		mv 	t4, a0			# x=x0 %
00000ed7 : 00b00f33;   % 1733: 		mv 	t5, a1			# y=y0 %
00000ed8 : 30102c73;   % 1735: <29> csrr s8, misa %
00000ed9 : 00cc5c13;   % 1735: <30> srli s8, s8, 12 %
00000eda : 001c7c13;   % 1735: <31> andi s8, s8, 0x001 %
00000edb : 020c1e63;   % 1735: <32> bnez s8, BRESENHAM.mul2 %
00000edc : ff410113;   % 1736: <45> addi 	sp, sp, -12 %
00000edd : 00a12023;   % 1736: <46> sw	a0, 0(sp) %
00000ede : 00b12223;   % 1736: <47> sw	a1, 4(sp) %
00000edf : 00112423;   % 1736: <48> sw	ra, 8(sp) %
00000ee0 : 01e00533;   % 1736: <50> mv 	a0, t5 %
00000ee1 : 011005b3;   % 1736: <51> mv 	a1, a7 %
00000ee2 : 234000ef;   % 1736: <52> jal 	__mulsi3 %
00000ee3 : 04051073;   % 1736: <53> csrw	a0,uscratch %
00000ee4 : 00012503;   % 1736: <55> lw	a0, 0(sp) %
00000ee5 : 00412583;   % 1736: <56> lw	a1, 4(sp) %
00000ee6 : 00812083;   % 1736: <57> lw	ra, 8(sp) %
00000ee7 : 00c10113;   % 1736: <58> addi 	sp, sp, 12 %
00000ee8 : 04002ff3;   % 1736: <59> csrr	t6,uscratch %
00000ee9 : 0080006f;   % 1737: 		j BRESENHAM.mul2d %
00000eea : 031f0fb3;   % 1738: BRESENHAM.mul2:	mul 	t6, t5, a7		# y*320 %
00000eeb : 01df8fb3;   % 1739: BRESENHAM.mul2d:add 	t6, t6, t4		# y*320+x %
00000eec : 010f8fb3;   % 1740: 		add 	t6, t6, a6		# 0xFF000000+y*320+x %
00000eed : 00ef8023;   % 1741: 		sb 	a4, 0(t6)		# plot com cor a4 %
00000eee : 01c05863;   % 1743: 		ble 	t3, zero, PULA4BRES	# D<=0 %
00000eef : 007e8eb3;   % 1744: 		add 	t4, t4, t2		# x=x+xi %
00000ef0 : 00131f93;   % 1745: 		slli 	t6, t1, 1		# 2*dy %
00000ef1 : 41fe0e33;   % 1746: 		sub 	t3, t3, t6		# D=D-2dy %
00000ef2 : 00129f93;   % 1747: PULA4BRES: 	slli 	t6, t0, 1		# 2*dy %
00000ef3 : 01fe0e33;   % 1748: 		add 	t3, t3, t6		# D=D+2dx %
00000ef4 : 001f0f13;   % 1749: 		addi 	t5, t5, 1 %
00000ef5 : f8df16e3;   % 1750: 		bne 	t5, a3, LOOPx2BRES %
00000ef6 : 00008067;   % 1751: 		ret		 %
00000ef7 : ffc10113;   % 1766: printIntUnsigned:	addi 	sp, sp, -4		# Aloca espaco %
00000ef8 : 00112023;   % 1767: 		sw 	ra, 0(sp)			# salva ra %
00000ef9 : 0fc1f297;   % 1768: 		la 	t0, TempBuffer			# carrega o Endereco do Buffer da String %
00000efa : 1c428293;   % 1768:  %
00000efb : 00a00393;   % 1770: 		li 	t2, 10				# carrega numero 10 %
00000efc : 00000313;   % 1771: 		li 	t1, 0				# carrega numero de digitos com 0 %
00000efd : 30102c73;   % 1773: <29> csrr s8, misa %
00000efe : 00cc5c13;   % 1773: <30> srli s8, s8, 12 %
00000eff : 001c7c13;   % 1773: <31> andi s8, s8, 0x001 %
00000f00 : 160c1463;   % 1773: <32> bnez s8, printIntUnsigned.pula1 %
00000f01 : ff010113;   % 1774: <65> addi 	sp, sp, -16 %
00000f02 : 00a12023;   % 1774: <66> sw	a0, 0(sp) %
00000f03 : 00e12223;   % 1774: <67> sw	a4, 4(sp) %
00000f04 : 00f12423;   % 1774: <68> sw	a5, 8(sp) %
00000f05 : 00112623;   % 1774: <69> sw	ra, 12(sp) %
00000f06 : 00a00533;   % 1774: <70> mv 	a0, a0 %
00000f07 : 00155713;   % 1774: <71> srli    a4,a0,1 %
00000f08 : 00255793;   % 1774: <72> srli    a5,a0,2 %
00000f09 : 00f707b3;   % 1774: <73> add     a5,a4,a5 %
00000f0a : 0047d713;   % 1774: <74> srli    a4,a5,4 %
00000f0b : 00f70733;   % 1774: <75> add     a4,a4,a5 %
00000f0c : 00875793;   % 1774: <76> srli    a5,a4,8 %
00000f0d : 00e78733;   % 1774: <77> add     a4,a5,a4 %
00000f0e : 01075793;   % 1774: <78> srli    a5,a4,16 %
00000f0f : 00e787b3;   % 1774: <79> add     a5,a5,a4 %
00000f10 : 0037d793;   % 1774: <80> srli    a5,a5,3 %
00000f11 : 00279713;   % 1774: <81> slli    a4,a5,2 %
00000f12 : 00f70733;   % 1774: <82> add     a4,a4,a5 %
00000f13 : 00171713;   % 1774: <83> slli    a4,a4,1 %
00000f14 : 40e50533;   % 1774: <84> sub     a0,a0,a4 %
00000f15 : 00a53513;   % 1774: <85> sltiu   a0,a0,10 %
00000f16 : 00154513;   % 1774: <86> xori    a0,a0,1 %
00000f17 : 00f50533;   % 1774: <87> add     a0,a0,a5 %
00000f18 : 04051073;   % 1774: <88> csrw	a0,uscratch %
00000f19 : 00012503;   % 1774: <89> lw	a0, 0(sp) %
00000f1a : 00412703;   % 1774: <90> lw	a4, 4(sp) %
00000f1b : 00812783;   % 1774: <91> lw	a5, 8(sp) %
00000f1c : 00c12083;   % 1774: <92> lw	ra, 12(sp) %
00000f1d : 01010113;   % 1774: <93> addi 	sp, sp, 16 %
00000f1e : 04002ef3;   % 1774: <94> csrr	t4,uscratch %
00000f1f : ff010113;   % 1775: <122> addi 	sp,sp,-16 %
00000f20 : 00a12023;   % 1775: <123> sw	a0,0(sp) %
00000f21 : 00b12223;   % 1775: <124> sw	a1,4(sp) %
00000f22 : 00c12423;   % 1775: <125> sw	a2,8(sp) %
00000f23 : 00d12623;   % 1775: <126> sw	a3,12(sp) %
00000f24 : 00a006b3;   % 1775: <128> mv 	a3,a0 %
00000f25 : 00a00613;   % 1775: <129> li 	a2,10 %
00000f26 : ff010113;   % 1775: <65> addi 	sp, sp, -16 %
00000f27 : 00a12023;   % 1775: <66> sw	a0, 0(sp) %
00000f28 : 00e12223;   % 1775: <67> sw	a4, 4(sp) %
00000f29 : 00f12423;   % 1775: <68> sw	a5, 8(sp) %
00000f2a : 00112623;   % 1775: <69> sw	ra, 12(sp) %
00000f2b : 00d00533;   % 1775: <70> mv 	a0, a3 %
00000f2c : 00155713;   % 1775: <71> srli    a4,a0,1 %
00000f2d : 00255793;   % 1775: <72> srli    a5,a0,2 %
00000f2e : 00f707b3;   % 1775: <73> add     a5,a4,a5 %
00000f2f : 0047d713;   % 1775: <74> srli    a4,a5,4 %
00000f30 : 00f70733;   % 1775: <75> add     a4,a4,a5 %
00000f31 : 00875793;   % 1775: <76> srli    a5,a4,8 %
00000f32 : 00e78733;   % 1775: <77> add     a4,a5,a4 %
00000f33 : 01075793;   % 1775: <78> srli    a5,a4,16 %
00000f34 : 00e787b3;   % 1775: <79> add     a5,a5,a4 %
00000f35 : 0037d793;   % 1775: <80> srli    a5,a5,3 %
00000f36 : 00279713;   % 1775: <81> slli    a4,a5,2 %
00000f37 : 00f70733;   % 1775: <82> add     a4,a4,a5 %
00000f38 : 00171713;   % 1775: <83> slli    a4,a4,1 %
00000f39 : 40e50533;   % 1775: <84> sub     a0,a0,a4 %
00000f3a : 00a53513;   % 1775: <85> sltiu   a0,a0,10 %
00000f3b : 00154513;   % 1775: <86> xori    a0,a0,1 %
00000f3c : 00f50533;   % 1775: <87> add     a0,a0,a5 %
00000f3d : 04051073;   % 1775: <88> csrw	a0,uscratch %
00000f3e : 00012503;   % 1775: <89> lw	a0, 0(sp) %
00000f3f : 00412703;   % 1775: <90> lw	a4, 4(sp) %
00000f40 : 00812783;   % 1775: <91> lw	a5, 8(sp) %
00000f41 : 00c12083;   % 1775: <92> lw	ra, 12(sp) %
00000f42 : 01010113;   % 1775: <93> addi 	sp, sp, 16 %
00000f43 : 04002573;   % 1775: <94> csrr	a0,uscratch %
00000f44 : ff410113;   % 1775: <45> addi 	sp, sp, -12 %
00000f45 : 00a12023;   % 1775: <46> sw	a0, 0(sp) %
00000f46 : 00b12223;   % 1775: <47> sw	a1, 4(sp) %
00000f47 : 00112423;   % 1775: <48> sw	ra, 8(sp) %
00000f48 : 00a00533;   % 1775: <50> mv 	a0, a0 %
00000f49 : 00c005b3;   % 1775: <51> mv 	a1, a2 %
00000f4a : 094000ef;   % 1775: <52> jal 	__mulsi3 %
00000f4b : 04051073;   % 1775: <53> csrw	a0,uscratch %
00000f4c : 00012503;   % 1775: <55> lw	a0, 0(sp) %
00000f4d : 00412583;   % 1775: <56> lw	a1, 4(sp) %
00000f4e : 00812083;   % 1775: <57> lw	ra, 8(sp) %
00000f4f : 00c10113;   % 1775: <58> addi 	sp, sp, 12 %
00000f50 : 040025f3;   % 1775: <59> csrr	a1,uscratch %
00000f51 : 40b68e33;   % 1775: <132> sub 	t3,a3,a1 %
00000f52 : 040e1073;   % 1775: <134> csrw	t3,uscratch %
00000f53 : 00012503;   % 1775: <135> lw	a0,0(sp) %
00000f54 : 00412583;   % 1775: <136> lw 	a1,4(sp) %
00000f55 : 00812603;   % 1775: <137> lw	a2,8(sp) %
00000f56 : 00c12683;   % 1775: <138> lw	a3,12(sp) %
00000f57 : 01010113;   % 1775: <139> addi 	sp,sp,16 %
00000f58 : 04002e73;   % 1775: <140> csrr	t3,uscratch %
00000f59 : 00c0006f;   % 1776: 			j	printIntUnsigned.pula1d %
00000f5a : 02755eb3;   % 1777: printIntUnsigned.pula1:	divu 	t4, a0, t2			# divide por 10 (quociente) %
00000f5b : 02757e33;   % 1778: 			remu 	t3, a0, t2			# resto %
00000f5c : ffc10113;   % 1779: printIntUnsigned.pula1d:addi 	sp, sp, -4			# aloca espaco na pilha %
00000f5d : 01c12023;   % 1780: 		sw 	t3, 0(sp)			# coloca resto na pilha %
00000f5e : 01d00533;   % 1781: 		mv 	a0, t4				# atualiza o numero com o quociente %
00000f5f : 00130313;   % 1782: 		addi 	t1, t1, 1			# incrementa o contador de digitos %
00000f60 : e6051ae3;   % 1783: 		bne 	a0, zero, printIntUnsigned.loop1# verifica se o numero eh zero %
00000f61 : 00012383;   % 1785: printIntUnsigned.loop2:	lw 	t2, 0(sp)		# le digito da pilha %
00000f62 : 00410113;   % 1786: 		addi 	sp, sp, 4			# libera espaco %
00000f63 : 03038393;   % 1787: 		addi 	t2, t2, 48			# converte o digito para ascii %
00000f64 : 00728023;   % 1788: 		sb 	t2, 0(t0)			# coloca caractere no buffer %
00000f65 : 00128293;   % 1789: 		addi 	t0, t0, 1			# incrementa endereco do buffer %
00000f66 : fff30313;   % 1790: 		addi 	t1, t1, -1			# decrementa contador de digitos %
00000f67 : fe0314e3;   % 1791: 		bne 	t1, zero, printIntUnsigned.loop2# eh o ultimo? %
00000f68 : 00028023;   % 1792: 		sb 	zero, 0(t0)			# insere \NULL na string %
00000f69 : 0fc1f517;   % 1794: 		la 	a0, TempBuffer			# Endereco do buffer da srting %
00000f6a : 00450513;   % 1794:  %
00000f6b : a28ff0ef;   % 1795: 		jal	printString			# chama o print string %
00000f6c : 00012083;   % 1797: 		lw 	ra, 0(sp)			# recupera a %
00000f6d : 00410113;   % 1798: 		addi 	sp, sp, 4			# libera espaco %
00000f6e : 00008067;   % 1799: printIntUnsigned.fim:	ret %
00000f6f : ff410113;   % 1811: __mulsi3:	addi 	sp,sp,-12 %
00000f70 : 00b12023;   % 1812: 		sw 	a1,0(sp) %
00000f71 : 00e12223;   % 1813: 		sw 	a4,4(sp) %
00000f72 : 00f12423;   % 1814: 		sw	a5,8(sp) %
00000f73 : 00a007b3;   % 1816: 	 	mv      a5,a0 %
00000f74 : 00000513;   % 1817:         	li      a0,0 %
00000f75 : 00078e63;   % 1818: mulsi3.L4: 	beqz    a5,mulsi3.L1 %
00000f76 : 0017f713;   % 1819:         	andi    a4,a5,1 %
00000f77 : 00070463;   % 1820:         	beqz    a4,mulsi3.L3 %
00000f78 : 00b50533;   % 1821:         	add     a0,a0,a1 %
00000f79 : 0017d793;   % 1822: mulsi3.L3: 	srli    a5,a5,1 %
00000f7a : 00159593;   % 1823:         	slli    a1,a1,1 %
00000f7b : fe9ff06f;   % 1824:         	j       mulsi3.L4 %
00000f7c : 00012583;   % 1826: mulsi3.L1: 	lw 	a1,0(sp) %
00000f7d : 00412703;   % 1827: 		lw	a4,4(sp) %
00000f7e : 00812783;   % 1828: 		lw	a5,8(sp) %
00000f7f : 00c10113;   % 1829: 		addi 	sp,sp,12 %
00000f80 : 00008067;   % 1830: 		ret %
00000f81 : ff010113;   % 1834: __udivsi3:	addi 	sp,sp,-16 %
00000f82 : 00b12023;   % 1835: 		sw 	a1,0(sp) %
00000f83 : 00d12223;   % 1836: 		sw	a3,4(sp) %
00000f84 : 00e12423;   % 1837: 		sw 	a4,8(sp) %
00000f85 : 00f12623;   % 1838: 		sw	a5,12(sp) %
00000f86 : 00a00733;   % 1840:  		mv      a4,a0 %
00000f87 : 00155693;   % 1841:         	srli    a3,a0,1 %
00000f88 : 00100793;   % 1842:         	li      a5,1 %
00000f89 : 00b6e863;   % 1843: udivsi3.L3:    	bltu    a3,a1,udivsi3.L6 %
00000f8a : 00179793;   % 1844:         	slli    a5,a5,1 %
00000f8b : 00159593;   % 1845:         	slli    a1,a1,1 %
00000f8c : ff5ff06f;   % 1846:         	j       udivsi3.L3 %
00000f8d : 00000513;   % 1847: udivsi3.L6:    	li      a0,0 %
00000f8e : 00078e63;   % 1848: udivsi3.L2:   	beqz    a5,udivsi3.L1 %
00000f8f : 00b76663;   % 1849:         	bltu    a4,a1,udivsi3.L5 %
00000f90 : 40b70733;   % 1850:         	sub     a4,a4,a1 %
00000f91 : 00f50533;   % 1851:         	add     a0,a0,a5 %
00000f92 : 0017d793;   % 1852: udivsi3.L5:    	srli    a5,a5,1 %
00000f93 : 0015d593;   % 1853:         	srli    a1,a1,1 %
00000f94 : fe9ff06f;   % 1854:         	j       udivsi3.L2 %
00000f95 : 00012583;   % 1856: udivsi3.L1: 	lw 	a1,0(sp) %
00000f96 : 00412683;   % 1857: 		lw	a3,4(sp) %
00000f97 : 00812703;   % 1858: 		lw	a4,8(sp) %
00000f98 : 00c12783;   % 1859: 		lw	a5,12(sp) %
00000f99 : 01010113;   % 1860: 		addi 	sp,sp,16 %
00000f9a : 00008067;   % 1861:     		ret %
00000f9b : ff410113;   % 1864: __umodsi3:	addi	sp, sp, -12 %
00000f9c : 00512023;   % 1865: 		sw 	t0, 0(sp) %
00000f9d : 00612223;   % 1866: 		sw 	t1, 4(sp) %
00000f9e : 00112423;   % 1867: 		sw 	ra, 8(sp) %
00000f9f : 00a002b3;   % 1868: 	 	mv 	t0, a0		# dividendo %
00000fa0 : 00b00333;   % 1869: 		mv 	t1, a1		# divisor %
00000fa1 : f81ff0ef;   % 1870: 		jal 	__udivsi3 %
00000fa2 : 006005b3;   % 1871: 		mv 	a1, t1		# quociente * divisor %
00000fa3 : f31ff0ef;   % 1872: 		jal 	__mulsi3 %
00000fa4 : 40a28533;   % 1873: 		sub 	a0, t0, a0	# dividendo-quociente*divisor %
00000fa5 : 00012283;   % 1874: 		lw 	t0, 0(sp) %
00000fa6 : 00412303;   % 1875: 		lw 	t1, 4(sp) %
00000fa7 : 00812083;   % 1876: 		lw 	ra, 8(sp) %
00000fa8 : 00c10113;   % 1877: 		addi 	sp, sp, 12 %
00000fa9 : 00008067;   % 1878: 		ret %
00000faa : ff010113;   % 1881: __divsi3:	addi	sp, sp, -16 %
00000fab : 00512023;   % 1882: 		sw 	t0, 0(sp) %
00000fac : 00612223;   % 1883: 		sw 	t1, 4(sp) %
00000fad : 00712423;   % 1884: 		sw 	t2, 8(sp) %
00000fae : 00112623;   % 1885: 		sw 	ra, 12(sp) %
00000faf : 41f55293;   % 1886: 		srai	t0,a0,31	# indica se a0 ï¿½ pos(0) ou neg (2^32-1) %
00000fb0 : 41f5d313;   % 1887: 		srai 	t1,a1,31	# indica se a1 ï¿½ pos(0) ou neg (2^32-1) %
00000fb1 : 0062c3b3;   % 1888: 		xor	t2,t0,t1	# indica se deve(!=0) ou nï¿½o(==0) inverter o sinal do resultado %
00000fb2 : 00028463;   % 1889: 		beqz 	t0,divsi3.pula1 %
00000fb3 : 40a00533;   % 1890: 		neg	a0,a0		# nega %
00000fb4 : 00030463;   % 1891: divsi3.pula1:	beqz 	t1,divsi3.pula2 %
00000fb5 : 40b005b3;   % 1892: 		neg	a1,a1		# nega %
00000fb6 : f2dff0ef;   % 1893: divsi3.pula2:	jal 	__udivsi3	# divisï¿½o unsigned %
00000fb7 : 00038463;   % 1894: 		beqz	t2, divsi3.pula3	 %
00000fb8 : 40a00533;   % 1895: 		neg	a0,a0		# nega %
00000fb9 : 00012283;   % 1896: divsi3.pula3:	lw 	t0, 0(sp) %
00000fba : 00412303;   % 1897: 		lw 	t1, 4(sp) %
00000fbb : 00812383;   % 1898: 		lw 	t2, 8(sp) %
00000fbc : 00c12083;   % 1899: 		lw 	ra, 12(sp) %
00000fbd : 01010113;   % 1900: 		addi 	sp, sp, 16 %
00000fbe : 00008067;   % 1901: 		ret %
00000fbf : ff410113;   % 1904: __modsi3:	addi	sp, sp, -12 %
00000fc0 : 00512023;   % 1905: 		sw 	t0, 0(sp) %
00000fc1 : 00612223;   % 1906: 		sw 	t1, 4(sp) %
00000fc2 : 00112423;   % 1907: 		sw 	ra, 8(sp) %
00000fc3 : 41f55293;   % 1908: 		srai	t0,a0,31	# indica se a0 ï¿½ pos(0) ou neg (2^32-1) %
00000fc4 : 41f5d313;   % 1909: 		srai 	t1,a1,31	# indica se a1 ï¿½ pos(0) ou neg (2^32-1) %
00000fc5 : 00028463;   % 1910: 		beqz 	t0,modsi3.pula1 %
00000fc6 : 40a00533;   % 1911: 		neg	a0,a0		# nega %
00000fc7 : 00030463;   % 1912: modsi3.pula1:	beqz 	t1,modsi3.pula2 %
00000fc8 : 40b005b3;   % 1913: 		neg	a1,a1		# nega %
00000fc9 : f49ff0ef;   % 1914: modsi3.pula2:	jal 	__umodsi3	# resto unsigned %
00000fca : 00028463;   % 1915: 		beqz	t0, modsi3.pula3	# sinal do dividendo	 %
00000fcb : 40a00533;   % 1916: 		neg	a0,a0		# nega %
00000fcc : 00012283;   % 1917: modsi3.pula3:	lw 	t0, 0(sp) %
00000fcd : 00412303;   % 1918: 		lw 	t1, 4(sp) %
00000fce : 00812083;   % 1919: 		lw 	ra, 8(sp) %
00000fcf : 00c10113;   % 1920: 		addi 	sp, sp, 12 %
00000fd0 : 00008067;   % 1921: 		ret																				 %
00000fd1 : 0fc0c297;   % 12: 	la t0, CURRENT_MAP  # Loads CURRENT_MAP's address %
00000fd2 : 1bc28293;   % 12:  %
00000fd3 : 0052c303;   % 13: 	lbu t1, 5(t0)       # Loads on t1 the CURRENT_MAP's rendering byte %
00000fd4 : 00200313;   % 14: 	li t1,2 %
00000fd5 : 00300393;   % 15: 	li t2,3				# Loads number 3 -- related to "switch map" operation %
00000fd6 : 00734463;   % 16: 	blt t1,t2 CHECK_MAP_MOVE_RENDER_1 # If the rendering byte is 0, 1 or 2 %
00000fd7 : 00008067;   % 17: 		ret				# If the rendering byte isn't <= 2 %
00000fd8 : 00030a63;   % 19: 		beqz t1, END_MAP_MOVE_RENDER # If the rendering byte is 0 %
00000fd9 : 00000513;   % 21: 			li a0, 0	   # in order to render map normally %
00000fda : fff30313;   % 22: 			addi t1,t1,-1  # subtracting 1 from t1 so that if t1 = 2 -> t1 = 1 (will be rendered  %
00000fdb : 006282a3;   % 24: 			sb t1,5(t0)	   # Stores the new CURRENT_MAP's rendering byte %
00000fdc : 0080006f;   % 25: 			j SCENE_RENDER # Starts scene rendering procedure %
00000fdd : 00008067;   % 28: 		ret                %
00000fde : ffc10113;   % 48:     addi sp,sp,-4 %
00000fdf : 00112023;   % 49:     sw ra, 0(sp) %
00000fe0 : 00051c63;   % 51: 	bnez a0, SKIP_SCENE_RENDER_ARGUMENTS # If a0 = 1, the arguments bellow have already been set %
00000fe1 : 008007b3;   % 53: 		mv a5,s0	# Current frame %
00000fe2 : 01400813;   % 54: 		li a6, 20	# Screen Width = 20 %
00000fe3 : 00f00893;   % 55: 		li a7, 15	# Screen Height = 15 %
00000fe4 : 00000e13;   % 56: 		li t3, 0	# Starting X for rendering (top left, related to Matrix) %
00000fe5 : 00000393;   % 57: 		li t2, 0	# Starting Y for rendering (top left, related to Matrix) %
00000fe6 : 0fc0c297;   % 60:     la t0, CURRENT_MAP  # Loads CURRENT_MAP's address %
00000fe7 : 16828293;   % 60:  %
00000fe8 : 0002a503;   % 61:     lw a0, 0(t0) 	# a0 now has the Map Address %
00000fe9 : 0062c583;   % 63:     lbu a1, 6(t0)   # Loads current X on Map (starting X on Matrix (top left)) %
00000fea : 0072c603;   % 64:     lbu a2, 7(t0)   # Loads current Y on Map (starting Y on Matrix (top left))	 %
00000feb : 0082c683;   % 65:     lbu a3, 8(t0)   # Loads current X offset on Map %
00000fec : 0092c703;   % 66:     lbu a4, 9(t0)   # Loads current Y offset on Map %
00000fed : 00000213;   % 67: 	li tp, 0        # Map won't be dislocated %
00000fee : ffffe317;   % 69: 	call RENDER_MAP %
00000fef : d54300e7;   % 69:  %
00000ff0 : 00012083;   % 72: 	lw ra, 0(sp) %
00000ff1 : 00410113;   % 73:     addi sp,sp,4 %
00000ff2 : 00008067;   % 75:     ret %
00000ff3 : 0fc0c317;   % 91: 	la t1, NEXT_MAP  # Gets NEXT_MAP address %
00000ff4 : 14030313;   % 91:  %
00000ff5 : 0fc0cf17;   % 92: 	la t5, CURRENT_MAP  # Gets CURRENT_MAP address %
00000ff6 : 12cf0f13;   % 92:  %
00000ff7 : 00254383;   % 93: 	lbu t2,2(a0)     # Gets next map's number %
00000ff8 : 00730223;   % 94: 	sb t2,4(t1)      # and stores it in NEXT_MAP %
00000ff9 : 00354e03;   % 95: 	lbu t3,3(a0)     # Gets next map's door number %
00000ffa : 01c304a3;   % 96: 	sb t3,9(t1)      # and stores it in NEXT_MAP %
00000ffb : 002e1e13;   % 97: 	slli t3,t3,2     # t3 has the number of bytes to be skipped after finding door address %
00000ffc : 001e0e13;   % 98: 	addi t3,t3,1     # t3 has the number of bytes to be skipped after finding door address and skiping number of doors byte %
00000ffd : 00100293;   % 101: 	li t0, 1  %
00000ffe : 00729e63;   % 102:     bne t0, t2, SKIP_NEXT_MAP1  %
00000fff : 0fc0f297;   % 103: 		la t0, Map1   # If next map is Map1 %
00001000 : 71028293;   % 103:  %
00001001 : 00532023;   % 104: 		sw t0,0(t1)   # Store it into NEXT_MAP %
00001002 : 0fc0c397;   % 105: 		la t2,Doors1  # Gets Doors1 address  %
00001003 : 37438393;   % 105:  %
00001004 : 0d00006f;   % 106:     	j CONTINUE_CHANGE_MAP %
00001005 : 00200293;   % 108:         li t0, 2  %
00001006 : 00729e63;   % 109:         bne t0, t2, SKIP_NEXT_MAP2  %
00001007 : 0fc10297;   % 110: 			la t0, Map2   # If next map is Map2 %
00001008 : a7728293;   % 110:  %
00001009 : 00532023;   % 111: 			sw t0,0(t1)   # Store it into NEXT_MAP %
0000100a : 0fc0c397;   % 112: 			la t2,Doors2  # Gets Doors2 address  %
0000100b : 35938393;   % 112:  %
0000100c : 0b00006f;   % 113: 			j CONTINUE_CHANGE_MAP %
0000100d : 00300293;   % 116:         li t0, 3  %
0000100e : 00729e63;   % 117:         bne t0, t2, SKIP_NEXT_MAP3  %
0000100f : 0fc10297;   % 118: 			la t0, Map3   # If next map is Map3 %
00001010 : dde28293;   % 118:  %
00001011 : 00532023;   % 119: 			sw t0,0(t1)   # Store it into NEXT_MAP %
00001012 : 0fc0c397;   % 120: 			la t2,Doors3  # Gets Doors3 address  %
00001013 : 34638393;   % 120:  %
00001014 : 0900006f;   % 121: 			j CONTINUE_CHANGE_MAP %
00001015 : 00400293;   % 124:         li t0, 4   %
00001016 : 00729e63;   % 125:         bne t0, t2, SKIP_NEXT_MAP4  %
00001017 : 0fc10297;   % 126: 			la t0, Map4   # If next map is Map4 %
00001018 : 14528293;   % 126:  %
00001019 : 00532023;   % 127: 			sw t0,0(t1)   # Store it into NEXT_MAP %
0000101a : 0fc0c397;   % 128: 			la t2,Doors4  # Gets Doors4 address  %
0000101b : 32f38393;   % 128:  %
0000101c : 0700006f;   % 129: 			j CONTINUE_CHANGE_MAP %
0000101d : 00500293;   % 132:         li t0, 5  %
0000101e : 00729e63;   % 133:         bne t0, t2, SKIP_NEXT_MAP5  %
0000101f : 0fc10297;   % 134: 			la t0, Map5   # If next map is Map5 %
00001020 : 4ac28293;   % 134:  %
00001021 : 00532023;   % 135: 			sw t0,0(t1)   # Store it into NEXT_MAP %
00001022 : 0fc0c397;   % 136: 			la t2,Doors5  # Gets Doors5 address  %
00001023 : 31838393;   % 136:  %
00001024 : 0500006f;   % 137: 			j CONTINUE_CHANGE_MAP %
00001025 : 00600293;   % 140:         li t0, 6 %
00001026 : 00729e63;   % 141:         bne t0, t2, SKIP_NEXT_MAP6 %
00001027 : 0fc10297;   % 142: 			la t0, Map6   # If next map is Map6 %
00001028 : 6e728293;   % 142:  %
00001029 : 00532023;   % 143: 			sw t0,0(t1)   # Store it into NEXT_MAP %
0000102a : 0fc0c397;   % 144: 			la t2,Doors6  # Gets Doors6 address  %
0000102b : 30138393;   % 144:  %
0000102c : 0300006f;   % 145: 			j CONTINUE_CHANGE_MAP %
0000102d : 00700293;   % 148: 		li t0, 7  %
0000102e : 00729e63;   % 149: 		bne t0, t2, SKIP_NEXT_MAP7  %
0000102f : 0fc10297;   % 150: 			la t0, Map7   # If next map is Map7 %
00001030 : 7f628293;   % 150:  %
00001031 : 00532023;   % 151: 			sw t0,0(t1)   # Store it into NEXT_MAP %
00001032 : 0fc0c397;   % 152: 			la t2,Doors7  # Gets Doors7 address  %
00001033 : 2e638393;   % 152:  %
00001034 : 0100006f;   % 153: 			j CONTINUE_CHANGE_MAP %
00001035 : fe010113;   % 157: 		addi sp,sp,-32  # Restoring unchanged %
00001036 : 00000513;   % 158: 		li a0,0         # Player won't be able to move %
00001037 : e79fc06f;   % 159: 		j ERROR_ON_SWITCH %
00001038 : 02010113;   % 162: 	addi sp,sp,32    # Freeing stack since it won't return to Physics %
00001039 : 0012ce83;   % 164: 	lbu t4,1(t0)     # Gets next map's width %
0000103a : 0fc0c297;   % 166: 	la t0, Doors_Next # Gets Next Doors	address %
0000103b : 29028293;   % 166:  %
0000103c : 0072a023;   % 167: 	sw t2,0(t0)       # and stores t2 (the DoorsA address) in it %
0000103d : 007e03b3;   % 169: 	add t2,t3,t2     # t2 has the address of destination door (DoorsA) %
0000103e : 0013c283;   % 170: 	lbu t0,1(t2)     # Gets door's Y %
0000103f : ffb28293;   % 171: 	addi t0,t0,-5    # Gets screen's matrix top left Y %
00001040 : 005303a3;   % 172: 	sb t0,7(t1)      # Stores Y on NEXT_MAP %
00001041 : 000302a3;   % 174: 	sb zero,5(t1)    # Number of iterations %
00001042 : 00054e03;   % 175: 	lbu t3,0(a0)     # Loads door frame's current X position %
00001043 : 000e0e63;   % 176: 	beqz t3, SWITCH_TOWARDS_LEFT  # If door frame is on the left (t3 = 0), next map is on the left %
00001044 : 000f0523;   % 178: 		sb zero,10(t5)    # Stores 0 in the X dislocation for current map %
00001045 : 000f05a3;   % 179: 		sb zero,11(t5)    # Stores switch direction (next map is on the right) %
00001046 : 00030323;   % 180: 		sb zero,6(t1)     # Stores furthest X to the left of next map (0) on NEXT_MAP %
00001047 : 01400293;   % 181: 		li t0, 20 # Gets screen width in tiles (20) %
00001048 : 00530423;   % 182: 		sb t0,8(t1)           # and stores it in X dislocation for the next map  %
00001049 : 01c0006f;   % 183: 		j ENTER_DOOR_ANIMATION_PREP %
0000104a : 00100293;   % 185: 		li t0 1        # Direction is loaded by t0 %
0000104b : 005f05a3;   % 186: 		sb t0,11(t5)   # and stored (next map is on the left) %
0000104c : 005f0523;   % 187: 		sb t0,10(t5)   # Stores 1 in the X dislocation for current map %
0000104d : fffe8e93;   % 188: 		addi t4,t4,-1  # Subtracts 1 from map's width %
0000104e : 01d30323;   % 189: 		sb t4,6(t1)    # and stores the result as the X on NEXT_MAP %
0000104f : 00030423;   % 190: 		sb zero,8(t1)  # Stores 0 in the X dislocation for next map  %
00001050 : 0fc0c297;   % 207: 	la t0, PLYR_INPUT %
00001051 : fef28293;   % 207:  %
00001052 : 00000393;   % 208: 	li t2, 0   # There isn't input %
00001053 : 00728023;   % 209: 	sb t2, 0(t0)  %
00001054 : 0fc0c297;   % 211: 	la t0, PLYR_STATUS      # Loads Player Status %
00001055 : fd628293;   % 211:  %
00001056 : 00000313;   % 212: 	li t1, 0        # Loads vertical direction (0 = normal) %
00001057 : 00628123;   % 213: 	sb t1, 2(t0)    # Stores new direction on PLYR_STATUS %
00001058 : 006282a3;   % 215: 	sb t1, 5(t0)                   %
00001059 : 00028323;   % 216: 	sb zero, 6(t0)  # Stores new direction on MOVE_X %
0000105a : 00144413;   % 218: 	xori s0,s0,1   # Switches frame value (register)										 %
0000105b : 00100513;   % 219: 	li a0, 1       # Rendering player's trail operation %
0000105c : 00000593;   % 220: 	li a1, 0       # Rendering full player (a1 doesn't really matter when a0 = 1) %
0000105d : ffffd317;   % 221: 	call RENDER_PLAYER %
0000105e : 418300e7;   % 221:  %
0000105f : c01022f3;   % 225: 	csrr t0,3073                       # Gets current time %
00001060 : 409282b3;   % 226:     sub t0, t0, s1                     # t0 = current time - last frame's time %
00001061 : 03200313;   % 227:     li t1, 50                  # Loads frame rate (time (in ms) per frame) %
00001062 : fe62eae3;   % 228:     bltu t0,t1, ENTER_DOOR_ANIMATION  # While t0 < minimum time for a frame, keep looping  %
00001063 : 00144413;   % 230: 	xori s0,s0,1		    # Switches frame value (register) %
00001064 : 0fc0c297;   % 232: 	la t0, MOVE_Y  # Loads MOVE_Y %
00001065 : f9d28293;   % 232:  %
00001066 : 00028283;   % 233: 	lb t0,0(t0)    # and gets its value  %
00001067 : 02028463;   % 234: 	beqz t0,ENTER_DOOR_ANIMATION_MOVE_PLAYER # If player is on the ground, go to ENTER_DOOR_ANIMATION_MOVE_PLAYER %
00001068 : ffffd317;   % 236: 		call PHYSICS            # Physics operations %
00001069 : cf8300e7;   % 236:  %
0000106a : 00000317;   % 237: 		call UPDATE_STATUS      # Updates player's sprite status %
0000106b : 57c300e7;   % 237:  %
0000106c : 00000513;   % 239: 		li a0, 0     # Rendering player operation %
0000106d : 00000593;   % 240: 		li a1, 0     # Rendering full player %
0000106e : ffffd317;   % 241: 		call RENDER_PLAYER %
0000106f : 3d4300e7;   % 241:  %
00001070 : 0900006f;   % 242: 		j CONTINUE_ENTER_DOOR_ANIMATION %
00001071 : 0fc0c297;   % 244: 		la t0, CURRENT_MAP   # Loads CURRENT_MAP's address %
00001072 : f3c28293;   % 244:  %
00001073 : 0fc0c317;   % 245: 		la t1, PLYR_POS   # Loads PLYR_POS's address %
00001074 : f4e30313;   % 245:  %
00001075 : 00b2c383;   % 246: 		lbu t2,11(t0)        # Loads switch direction %
00001076 : 04038063;   % 247: 		beqz t2, ENTER_DOOR_ANIMATION_NEXT_ON_RIGHT # If next map is on the right, go to ENTER_DOOR_ANIMATION_NEXT_ON_RIGHT %
00001077 : 00031283;   % 249: 			lh t0,0(t1)   # Gets player's current X related to screen %
00001078 : 00531123;   % 250: 			sh t0,2(t1)   # Stores it on old X %
00001079 : ffc28293;   % 252: 			addi t0,t0,-4  # Adds 4 to player's X %
0000107a : 00531023;   % 253: 			sh t0,0(t1)   # Stores new X %
0000107b : 0fc0c297;   % 255: 			la t0, MOVE_X  # Loads MOVE_X %
0000107c : f4028293;   % 255:  %
0000107d : fff00313;   % 256: 			li t1,-1       # Loads direction (left) %
0000107e : 00628023;   % 257: 			sb t1,0(t0)    # Stores on MOVE_X %
0000107f : 00000317;   % 258: 			call UPDATE_STATUS      # Updates player's sprite status %
00001080 : 528300e7;   % 258:  %
00001081 : 00000513;   % 260: 			li a0, 0     # Rendering player operation %
00001082 : 00200593;   % 261: 			li a1, 2     # Rendering player's 16 rightmost pixels %
00001083 : ffffd317;   % 262: 			call RENDER_PLAYER %
00001084 : 380300e7;   % 262:  %
00001085 : 03c0006f;   % 263: 			j CONTINUE_ENTER_DOOR_ANIMATION %
00001086 : 00031283;   % 266: 			lh t0,0(t1)   # Gets player's current X related to screen %
00001087 : 00531123;   % 267: 			sh t0,2(t1)   # Stores it on old X %
00001088 : 00428293;   % 269: 			addi t0,t0,4  # Adds 4 to player's X %
00001089 : 00531023;   % 270: 			sh t0,0(t1)   # Stores new X %
0000108a : 0fc0c297;   % 272: 			la t0, MOVE_X  # Loads MOVE_X %
0000108b : f0428293;   % 272:  %
0000108c : 00100313;   % 273: 			li t1,1        # Loads direction (right) %
0000108d : 00628023;   % 274: 			sb t1,0(t0)    # Stores on MOVE_X %
0000108e : 00000317;   % 275: 			call UPDATE_STATUS      # Updates player's sprite status %
0000108f : 4ec300e7;   % 275:  %
00001090 : 00000513;   % 277: 			li a0, 0     # Rendering player operation %
00001091 : 00100593;   % 278: 			li a1, 1     # Rendering player's 16 leftmost pixels %
00001092 : ffffd317;   % 279: 			call RENDER_PLAYER %
00001093 : 344300e7;   % 279:  %
00001094 : ffffe317;   % 282: 	call RENDER_DOOR_FRAMES	 %
00001095 : 9a8300e7;   % 282:  %
00001096 : ff2002b7;   % 285: 	li t0,0xFF200604	# Loads Bitmap Display address %
00001097 : 60428293;   % 285:  %
00001098 : 0082a023;   % 286: 	sw s0,0(t0)         # Stores new frame value (from s0) on Bitmap Display %
00001099 : 00100513;   % 288: 	li a0, 1     # Rendering player's trail operation %
0000109a : 00000593;   % 289: 	li a1, 0     # Rendering full player (a1 doesn't really matter when a0 = 1) %
0000109b : ffffd317;   % 290: 	call RENDER_PLAYER %
0000109c : 320300e7;   % 290:  %
0000109d : ffffd317;   % 292: 	call RENDER_UI %
0000109e : 694300e7;   % 292:  %
0000109f : 0fc0c297;   % 296: 	la t0, MOVE_Y  # Loads MOVE_Y %
000010a0 : eb128293;   % 296:  %
000010a1 : 00028283;   % 297: 	lb t0,0(t0)    # and gets its value  %
000010a2 : 04029c63;   % 298: 	bnez t0,CONTINUE_ENTER_DOOR_ANIMATION_2 # If player is on the ground, go to CONTINUE_ENTER_DOOR_ANIMATION_2 %
000010a3 : 0fc0c297;   % 299: 		la t0, CURRENT_MAP   # Loads CURRENT_MAP's address %
000010a4 : e7428293;   % 299:  %
000010a5 : 0fc0c317;   % 300: 		la t1, PLYR_POS      # Loads PLYR_POS's address		 %
000010a6 : e8630313;   % 300:  %
000010a7 : 00a30383;   % 301: 		lb t2,10(t1)         # Gets player's current Y related to matrix %
000010a8 : 007305a3;   % 302: 		sb t2,11(t1)         # Stores it on old Y related to matrix %
000010a9 : 00b2c383;   % 303: 		lbu t2,11(t0)        # Loads switch direction %
000010aa : 00038c63;   % 304: 		beqz t2, ENTER_DOOR_ANIMATION_NEXT_ON_RIGHT_2 # If next map is on the right, go to ENTER_DOOR_ANIMATION_NEXT_ON_RIGHT_2 %
000010ab : 00031383;   % 306: 			lh t2,0(t1)           # Gets player's current X related to screen %
000010ac : 02039863;   % 307: 			bnez,t2,CONTINUE_ENTER_DOOR_ANIMATION_2  # If player's current X = !0, continue loop %
000010ad : 00400313;   % 309: 				li t1,4           # X Offset for map %
000010ae : 00628423;   % 310: 				sb t1,8(t0)       # storing X offset for map %
000010af : 02c0006f;   % 311: 				j SWITCH_MAP_PREP  %
000010b0 : 00031e03;   % 314: 			lh t3,0(t1)           # Gets player's current X related to screen %
000010b1 : 14000313;   % 315: 			li t1,320    # Loads 320 %
000010b2 : 01000393;   % 316: 			li t2,16       # Loads 16 %
000010b3 : 40730333;   % 317: 			sub t1,t1,t2          # t1 = 304	 %
000010b4 : 01c31863;   % 318: 			bne t1,t3,CONTINUE_ENTER_DOOR_ANIMATION_2  # If player's current X != 304, continue loop %
000010b5 : 00c00313;   % 320: 				li t1,12          # X Offset for map %
000010b6 : 00628423;   % 321: 				sb t1,8(t0)       # storing X offset for map %
000010b7 : 00c0006f;   % 322: 				j SWITCH_MAP_PREP   %
000010b8 : c01024f3;   % 324: 		csrr s1,3073    # new time is stored in s1, in order to be compared later		 %
000010b9 : e99ff06f;   % 326: 		j ENTER_DOOR_ANIMATION	# Returns to beginning of loop %
000010ba : 00100513;   % 342: 	li a0,1   # Close doors %
000010bb : 00100593;   % 343: 	li a1,1   # Close them fast    :) %
000010bc : ffffc317;   % 344: 	call CHANGE_DOORS_STATE %
000010bd : 77c300e7;   % 344:  %
000010be : 0fc0c297;   % 347: 	la t0,CURRENT_MAP %
000010bf : e0828293;   % 347:  %
000010c0 : 00300393;   % 348: 	li t2,3 %
000010c1 : 007282a3;   % 349: 	sb t2,5(t0) %
000010c2 : c01022f3;   % 353: 	csrr t0,3073 %
000010c3 : 409282b3;   % 354:     sub t0, t0, s1 #  # a0 = current time - last frame's time %
000010c4 : 03200313;   % 355:     li t1, 50       # Loads frame rate (time (in ms) per frame) %
000010c5 : fe62eae3;   % 356:     bltu t0,t1, SWITCH_MAP  # While a0 < minimum time for a frame, keep looping  %
000010c6 : 00144413;   % 359: 	xori s0,s0,1			# inverts frame value %
000010c7 : 0fc0c317;   % 362: 	la t1, NEXT_MAP         # Gets NEXT_MAP address %
000010c8 : df030313;   % 362:  %
000010c9 : 00030523;   % 363: 	sb zero,10(t1)          # Stores 0 on Render Next Map Door (in order to render doors properly) %
000010ca : 00534303;   % 364: 	lbu t1,5(t1)            # Gets number of iterations so far %
000010cb : 01400813;   % 365: 	li a6, 20 	# Screen Width = 20     # width (Related to Matrix) of rendering area %
000010cc : 15035c63;   % 366: 	bge t1,a6,END_OF_SWITCH_MAP %
000010cd : 0fc0c297;   % 370: 		la t0, CURRENT_MAP      # Gets CURRENT_MAP address %
000010ce : dcc28293;   % 370:  %
000010cf : 0002a503;   % 371: 		lw a0,0(t0)	            # Loads Current Map's address %
000010d0 : 0072c603;   % 372: 		lbu a2, 7(t0)           # Loads current Y on Map (starting Y on Matrix (top left))	 %
000010d1 : 0082c683;   % 373: 		lbu a3, 8(t0)           # Loads current X offset on Map %
000010d2 : 00000713;   % 374: 		li a4,0                 # Y offset will always be 0 during transition %
000010d3 : 008007b3;   % 375: 		mv a5,s0	            # Current frame %
000010d4 : 00f00893;   % 376: 		li a7, 15	# Screen Height = 15    # height (Related to Matrix) of rendering area %
000010d5 : 00000e13;   % 377: 		li t3, 0	            # Starting X for rendering (top left, related to Matrix) %
000010d6 : 00000393;   % 378: 		li t2, 0	            # Starting Y for rendering (top left, related to Matrix) %
000010d7 : 0062c583;   % 380: 		lbu a1, 6(t0)           # Loads current X on Map (starting X on Matrix (top left)) %
000010d8 : 00a2c203;   % 381: 		lbu tp,10(t0)           # X dislocation related to CURRENT_MAP %
000010d9 : 00b2ce83;   % 382: 		lbu t4,11(t0)           # Loads switch direction %
000010da : 020e8063;   % 383: 		beqz t4, SWITCH_MAP_CURRENT_ON_LEFT  # If next map is on the right, current map is on the left %
000010db : 00300e93;   % 385: 			li t4,3             # Loads 3 for holding comparision %
000010dc : 00deaeb3;   % 386: 			slt t4,t4,a3        # Sets t4 to 1 if X offset isn't 0 (in this case, if X offset < 4, X offset = 0) %
000010dd : 40680833;   % 387: 			sub a6,a6,t1       # Screen Width = Number of iterations (X offset = 0) or Number of iterations + 1 (X offset != 0) %
000010de : 00620233;   % 388: 			add tp,tp,t1        # Gets dislocation by adding the number of iterations from it %
000010df : ffffe317;   % 389: 			call RENDER_MAP %
000010e0 : 990300e7;   % 389:  %
000010e1 : 0100006f;   % 390: 			j SWITCH_MAP_NEXT %
000010e2 : 006585b3;   % 392: 			add a1,a1,t1            # Changes X %
000010e3 : ffffe317;   % 394: 			call RENDER_MAP %
000010e4 : 980300e7;   % 394:  %
000010e5 : 0fc0c297;   % 398: 		la t0, CURRENT_MAP      # Gets CURRENT_MAP address %
000010e6 : d6c28293;   % 398:  %
000010e7 : 0fc0c317;   % 399: 		la t1, NEXT_MAP         # Gets NEXT_MAP address %
000010e8 : d7030313;   % 399:  %
000010e9 : 00100393;   % 400: 		li t2,1                 # Loads 1 in order to render Next Map's Door %
000010ea : 00730523;   % 401: 		sb t2,10(t1)            # Stores 1 on Render Next Map Door %
000010eb : 00032503;   % 402: 		lw a0,0(t1)	            # Loads Next Map's address %
000010ec : 00734603;   % 403: 		lbu a2, 7(t1)           # Loads current Y on Map (starting Y on Matrix (top left))	 %
000010ed : 0082c683;   % 404: 		lbu a3, 8(t0)           # Loads current X offset on Map %
000010ee : 00000713;   % 405: 		li a4,0                 # Y offset will always be 0 during transition %
000010ef : 008007b3;   % 406: 		mv a5,s0	            # Current frame %
000010f0 : 00f00893;   % 407: 		li a7, 15	# Screen Height = 15    # height (Related to Matrix) of rendering area %
000010f1 : 00000e13;   % 408: 		li t3, 0	            # Starting X for rendering (top left, related to Matrix) %
000010f2 : 00000393;   % 409: 		li t2, 0	            # Starting Y for rendering (top left, related to Matrix) %
000010f3 : 00634583;   % 412: 		lbu a1, 6(t1)           # Loads current X on Map (starting X on Matrix (top left)) %
000010f4 : 00834203;   % 413: 		lbu tp,8(t1)            # X dislocation related to CURRENT_MAP %
000010f5 : 00b2ce83;   % 414: 		lbu t4,11(t0)           # Loads switch direction %
000010f6 : 00534f03;   % 415: 		lbu t5,5(t1)            # Gets number of iterations so far		 %
000010f7 : 020e8063;   % 416: 		beqz t4, SWITCH_MAP_NEXT_ON_RIGHT  # If next map is on the right %
000010f8 : 41e585b3;   % 418: 			sub a1,a1,t5        # Changes X %
000010f9 : 01400e93;   % 419: 			li t4,20            # Loads 3 for holding comparision %
000010fa : 01df2eb3;   % 420: 			slt t4,t5,t4        # Sets t4 to 1 if number of iterations is less than 19 %
000010fb : 01df0833;   % 421: 			add a6,t5,t4        # Screen Width = Number of iterations (if it's equal to 19) or Number of iterations + 1 (if it's < 19) %
000010fc : ffffe317;   % 423: 			call RENDER_MAP %
000010fd : 91c300e7;   % 423:  %
000010fe : 0200006f;   % 424: 			j SWITCH_MAP_CONTINUE %
000010ff : 00300e93;   % 426: 			li t4,3             # Loads 3 for holding comparision %
00001100 : 00deaeb3;   % 427: 			slt t4,t4,a3        # Sets t4 to 1 if X offset isn't 0 (in this case, if X offset < 4, X offset = 0) %
00001101 : 01df0833;   % 428: 			add a6,t5,t4        # Screen Width = Number of iterations (X offset = 0) or Number of iterations + 1 (X offset != 0) %
00001102 : 00834203;   % 429: 			lbu tp,8(t1)        # X dislocation related to CURRENT_MAP %
00001103 : 41e20233;   % 430: 			sub tp,tp,t5        # Gets dislocation by subtracting the number of iterations from it %
00001104 : ffffe317;   % 431: 			call RENDER_MAP %
00001105 : 8fc300e7;   % 431:  %
00001106 : ffffc317;   % 435: 	call UPDATE_DOORS       # Updates doors %
00001107 : 594300e7;   % 435:  %
00001108 : ff2002b7;   % 438: 	li t0,0xFF200604		# carrega em t0 o endereco de troca de frame %
00001109 : 60428293;   % 438:  %
0000110a : 0082a023;   % 439: 	sw s0,0(t0) %
0000110b : ffffd317;   % 441: 	call RENDER_UI %
0000110c : 4dc300e7;   % 441:  %
0000110d : 0fc0c297;   % 445: 	la t0, CURRENT_MAP      # Gets CURRENT_MAP address	 %
0000110e : ccc28293;   % 445:  %
0000110f : 0fc0c317;   % 446: 	la t1, NEXT_MAP         # Gets NEXT_MAP address %
00001110 : cd030313;   % 446:  %
00001111 : 00b2ce03;   % 447: 	lbu t3,11(t0)           # Loads switch direction %
00001112 : 0082c383;   % 448: 	lbu t2, 8(t0)           # Loads current X offset  %
00001113 : 000e0a63;   % 450: 	beqz t3, SWITCH_MAP_OFFSET_RIGHT # If next map is on the right %
00001114 : ffc38393;   % 452: 		addi t2,t2,-4   # decrease offset by 4  %
00001115 : 0203d463;   % 454: 		bge t2, zero, SWITCH_MAP_AFTER_OFFSET_OPERATION %
00001116 : 01038393;   % 456: 			addi t2,t2,16 # Corrects negative offset by adding 16 %
00001117 : 0140006f;   % 457: 			j SWITCH_MAP_ITERATE # iterates procedure  %
00001118 : 00438393;   % 459: 		addi t2,t2,4      # increase offset by 4  %
00001119 : 01000e13;   % 460: 		li t3,16   # loads 16 for operations %
0000111a : 01c3ca63;   % 462: 		blt t2, t3, SWITCH_MAP_AFTER_OFFSET_OPERATION  %
0000111b : 41c383b3;   % 464: 			sub t2,t2,t3           # Corrects offset by subtracting 16 %
0000111c : 00534e03;   % 467: 		lbu t3,5(t1)    # Gets number of iterations so far %
0000111d : 001e0e13;   % 468: 		addi t3,t3,1    # t2++ %
0000111e : 01c302a3;   % 469: 		sb t3,5(t1)     # Stores new iteration %
0000111f : 00728423;   % 471: 		sb t2, 8(t0)    # Stores new X offset %
00001120 : c01024f3;   % 472: 		csrr s1,3073    # new time is stored in s1, in order to be compared later %
00001121 : e85ff06f;   % 473: 		j SWITCH_MAP %
00001122 : 0fc0c297;   % 476: 	la t0,CURRENT_MAP %
00001123 : c7828293;   % 476:  %
00001124 : 0fc0c317;   % 477: 	la t1,NEXT_MAP %
00001125 : c7c30313;   % 477:  %
00001126 : 00032383;   % 478: 	lw t2,0(t1)        # Loads next map's address %
00001127 : 0072a023;   % 479: 	sw t2,0(t0)        # and stores it on CURRENT_MAP %
00001128 : 00434383;   % 480: 	lbu t2,4(t1)       # Loads next map's number %
00001129 : 00728223;   % 481: 	sb t2,4(t0)        # and stores it on CURRENT_MAP %
0000112a : 00634383;   % 482: 	lbu t2,6(t1)       # Loads next map's X %
0000112b : 00728323;   % 483: 	sb t2,6(t0)        # and stores it on CURRENT_MAP %
0000112c : 00734383;   % 484: 	lbu t2,7(t1)       # Loads next map's Y %
0000112d : 007283a3;   % 485: 	sb t2,7(t0)        # and stores it on CURRENT_MAP %
0000112e : 00028423;   % 486: 	sb zero,8(t0)      # Sets CURRENT_MAP's X offset to 0 %
0000112f : 000284a3;   % 487: 	sb zero,9(t0)      # Sets CURRENT_MAP's Y offset to 0 %
00001130 : 00b2ce03;   % 489: 	lbu t3,11(t0)  # Loads switch direction %
00001131 : 000e0c63;   % 490: 	beqz t3,END_OF_SWITCH_MAP_SKIP_CHANGE_MAP_POSITION # If next map was on the right, player will be on the left door %
00001132 : 0002ae03;   % 492: 		lw t3,0(t0)    # Gets current map's address %
00001133 : 001e4e03;   % 493: 		lbu t3,1(t3)   # and takes its width %
00001134 : 01400e93;   % 494: 		li t4,20  # t4 = 20 %
00001135 : 41de0eb3;   % 495: 		sub t4,t3,t4          # t4 = Current Map's X position %
00001136 : 01d28323;   % 496: 		sb t4,6(t0)           # Stores map's X %
00001137 : bedfb06f;   % 498: 		j SETUP %
00001138 : 0fc0c297;   % 512: 	la t0,CURRENT_MAP %
00001139 : c2028293;   % 512:  %
0000113a : 00200393;   % 513: 	li t2,2            # Loads 3 (switch map through door) %
0000113b : 007282a3;   % 514: 	sb t2,5(t0) %
0000113c : 0fc0c317;   % 517: 	la t1,NEXT_MAP %
0000113d : c1c30313;   % 517:  %
0000113e : 00934303;   % 518: 	lbu t1,9(t1)     # loads "next door"'s number %
0000113f : 00231313;   % 519: 	slli t1,t1,2     # multiplies it by 4 %
00001140 : 0fc0c517;   % 520: 	la a0, Doors     # Gets Doors address %
00001141 : e7450513;   % 520:  %
00001142 : 00052503;   % 521: 	lw a0,0(a0)      # gets current map's doors address %
00001143 : 00150513;   % 522: 	addi a0,a0,1     # skips number of doors %
00001144 : 00650533;   % 523: 	add a0,a0,t1     # and adds t1 to get the correct door's address %
00001145 : 00100393;   % 524: 	li t2,1             # Loads 1 (opening/closing) %
00001146 : 00750123;   % 525:     sb t2,2(a0)         # and stores it on door's state byte     %
00001147 : ffe00393;   % 526:     li t2,-2  # Gets new counter (related to opening door -- negative, in order to open) %
00001148 : 007501a3;   % 527:     sb t2,3(a0)         # and stores it on door's counter byte %
00001149 : 0fc0c397;   % 530: 	la t2, PLYR_POS %
0000114a : bf638393;   % 530:  %
0000114b : 0072ce83;   % 532: 	lbu t4,7(t0)                # Loads map's Y %
0000114c : 006e8e13;   % 533: 	addi t3,t4,6  # adds 6 to it to get Player's new Y related to matrix %
0000114d : 01c38523;   % 534: 	sb t3, 10(t2)               # and stores it  %
0000114e : 01c385a3;   % 535: 	sb t3, 11(t2)               # as well as on old Y %
0000114f : 41de0e33;   % 537: 	sub t3,t3,t4                # Gets player's matrix Y related to map's matrix Y  %
00001150 : 004e1e13;   % 538: 	slli t3,t3,4  # Multiplies t3 by 16 to get Player's new Y related to screen %
00001151 : 01c38223;   % 539: 	sb t3, 4(t2)                # and stores it %
00001152 : 00b2ce03;   % 542: 	lbu t3,11(t0)  # Loads switch direction %
00001153 : 000e0a63;   % 543: 	beqz t3,LEAVE_DOOR_ANIMATION_PREP_PLAYER_LEFT_DOOR # If next map was on the right, player will be on the left door %
00001154 : 0002ae03;   % 545: 		lw t3,0(t0)    # Gets current map's address %
00001155 : 001e4e03;   % 546: 		lbu t3,1(t3)   # and takes its width %
00001156 : fffe0e13;   % 547: 		addi t3,t3,-1         # Subtracts 1 from width to get Player's new X related to matrix (because coordinate starts on 0) %
00001157 : 0080006f;   % 548: 		j LEAVE_DOOR_ANIMATION_PREP_PLAYER_POS %
00001158 : 00000e13;   % 550: 		li t3,0               # Player's new X related to matrix %
00001159 : 01c38423;   % 552: 		sb t3, 8(t2)      # Stores new player's X related to the matrix %
0000115a : 01c384a3;   % 553: 		sb t3, 9(t2)      # as well as on player's old X related to the matrix %
0000115b : 0062ce83;   % 555: 		lbu t4,6(t0)                # Loads map's X %
0000115c : 41de0e33;   % 556: 		sub t3,t3,t4                # Gets player's matrix X related to map's matrix X  %
0000115d : 004e1e13;   % 557: 		slli t3,t3,4  # Multiplies t3 by 16 to get Player's new X related to screen %
0000115e : 01c39023;   % 558: 		sh t3, 0(t2)   # Stores new player's X related to the screen %
0000115f : 00000e13;   % 560: 		li t3, 0       # For player's offset %
00001160 : 01c38323;   % 561: 		sb t3, 6(t2)   # Stores new player's X offset %
00001161 : 01c383a3;   % 562: 		sb t3, 7(t2)   # Stores new player's Y offset %
00001162 : c01022f3;   % 567: 	csrr t0,3073                       # Gets current time %
00001163 : 409282b3;   % 568:     sub t0, t0, s1                     # t0 = current time - last frame's time %
00001164 : 03200313;   % 569:     li t1, 50                  # Loads frame rate (time (in ms) per frame) %
00001165 : fe62eae3;   % 570:     bltu t0,t1, LEAVE_DOOR_ANIMATION   # While t0 < minimum time for a frame, keep looping  %
00001166 : 00144413;   % 572: 	xori s0,s0,1		    # Switches frame value (register) %
00001167 : ffffc317;   % 574: 	call UPDATE_DOORS       # Updates doors %
00001168 : 410300e7;   % 574:  %
00001169 : 00000317;   % 575: 	call MAP_MOVE_RENDER    # Renders map when necessary %
0000116a : 9a0300e7;   % 575:  %
0000116b : 0fc0c297;   % 578: 	la t0, CURRENT_MAP   # Loads CURRENT_MAP's address %
0000116c : b5428293;   % 578:  %
0000116d : 0fc0c317;   % 579: 	la t1, PLYR_POS      # Loads PLYR_POS's address %
0000116e : b6630313;   % 579:  %
0000116f : 00b2c383;   % 580: 	lbu t2,11(t0)        # Loads switch direction %
00001170 : 04038063;   % 581: 	beqz t2, LEAVE_DOOR_ANIMATION_NEXT_ON_RIGHT # If next map is on the right, go to LEAVE_DOOR_ANIMATION_NEXT_ON_RIGHT %
00001171 : 00031283;   % 583: 		lh t0,0(t1)   # Gets player's current X related to screen %
00001172 : 00531123;   % 584: 		sh t0,2(t1)   # Stores it on old X %
00001173 : ffc28293;   % 586: 		addi t0,t0,-4  # Adds 4 to player's X %
00001174 : 00531023;   % 587: 		sh t0,0(t1)    # Stores new X %
00001175 : 0fc0c297;   % 589: 		la t0, MOVE_X  # Loads MOVE_X %
00001176 : b5828293;   % 589:  %
00001177 : fff00313;   % 590: 		li t1,-1       # Loads direction (left) %
00001178 : 00628023;   % 591: 		sb t1,0(t0)    # Stores on MOVE_X %
00001179 : 00000317;   % 592: 		call UPDATE_STATUS      # Updates player's sprite status %
0000117a : 140300e7;   % 592:  %
0000117b : 00000513;   % 594: 		li a0, 0     # Rendering player operation %
0000117c : 00000593;   % 595: 		li a1,0     # Rendering full player %
0000117d : ffffd317;   % 596: 		call RENDER_PLAYER %
0000117e : f98300e7;   % 596:  %
0000117f : 03c0006f;   % 597: 		j CONTINUE_LEAVE_DOOR_ANIMATION %
00001180 : 00031283;   % 600: 		lh t0,0(t1)   # Gets player's current X related to screen %
00001181 : 00531123;   % 601: 		sh t0,2(t1)   # Stores it on old X %
00001182 : 00428293;   % 603: 		addi t0,t0,4  # Adds 4 to player's X %
00001183 : 00531023;   % 604: 		sh t0,0(t1)   # Stores new X %
00001184 : 0fc0c297;   % 606: 		la t0, MOVE_X  # Loads MOVE_X %
00001185 : b1c28293;   % 606:  %
00001186 : 00100313;   % 607: 		li t1,1        # Loads direction (right) %
00001187 : 00628023;   % 608: 		sb t1,0(t0)    # Stores on MOVE_X %
00001188 : 00000317;   % 609: 		call UPDATE_STATUS      # Updates player's sprite status %
00001189 : 104300e7;   % 609:  %
0000118a : 00000513;   % 611: 		li a0, 0     # Rendering player operation %
0000118b : 00000593;   % 612: 		li a1, 0     # Rendering full player %
0000118c : ffffd317;   % 613: 		call RENDER_PLAYER %
0000118d : f5c300e7;   % 613:  %
0000118e : ffffd317;   % 616: 	call RENDER_DOOR_FRAMES %
0000118f : 5c0300e7;   % 616:  %
00001190 : ff2002b7;   % 619: 	li t0,0xFF200604	# Loads Bitmap Display address %
00001191 : 60428293;   % 619:  %
00001192 : 0082a023;   % 620: 	sw s0,0(t0)         # Stores new frame value (from s0) on Bitmap Display %
00001193 : 00100513;   % 622: 	li a0, 1     # Rendering player's trail operation %
00001194 : 00000593;   % 623: 	li a1, 0     # Rendering full player (a1 doesn't really matter when a0 = 1) %
00001195 : ffffd317;   % 624: 	call RENDER_PLAYER %
00001196 : f38300e7;   % 624:  %
00001197 : ffffd317;   % 626: 	call RENDER_UI %
00001198 : 2ac300e7;   % 626:  %
00001199 : 0fc0c297;   % 631: 	la t0, CURRENT_MAP   # Loads CURRENT_MAP's address %
0000119a : a9c28293;   % 631:  %
0000119b : 0fc0c317;   % 632: 	la t1, PLYR_POS   # Loads PLYR_POS's address	 %
0000119c : aae30313;   % 632:  %
0000119d : 00b2c383;   % 633: 	lbu t2,11(t0)        # Loads switch direction %
0000119e : 02038e63;   % 634: 	beqz t2, LEAVE_DOOR_ANIMATION_NEXT_ON_RIGHT_2 # If next map is on the right, go to LEAVE_DOOR_ANIMATION_NEXT_ON_RIGHT_2 %
0000119f : 00031e03;   % 636: 		lh t3,0(t1)           # Gets player's current X related to screen %
000011a0 : 14000293;   % 637: 		li t0,320    # Loads 320 (screen width in pixels) %
000011a1 : 01000393;   % 638: 		li t2,16       # Loads 16 (tile size) %
000011a2 : 407282b3;   % 639: 		sub t0,t0,t2          # t0 = 304 %
000011a3 : 407282b3;   % 640: 		sub t0,t0,t2          # t0 = 288 %
000011a4 : ff828293;   % 641: 		addi t0,t0,-8	      # Player should have an offset of 8 %
000011a5 : 05c29663;   % 642: 		bne t0,t3,CONTINUE_LEAVE_DOOR_ANIMATION_2  # If player's current X != 280, continue loop %
000011a6 : 00800393;   % 644: 			li t2,8           # Loads 8 for player's X offset %
000011a7 : 00730323;   % 645: 			sb t2,6(t1)       # and stores it %
000011a8 : 00834383;   % 646: 			lbu t2,8(t1)      # Gets player's current X related to matrix %
000011a9 : ffe38393;   % 647: 			addi t2,t2,-2     # subtracts 1 from it %
000011aa : 00730423;   % 648: 			sb t2,8(t1)       # and stores it back %
000011ab : 007304a3;   % 649: 			sb t2,9(t1)       # as well as storing on old X %
000011ac : 0380006f;   % 650: 			j END_LEAVE_DOOR_ANIMATION  # Finish procedure  %
000011ad : 00031383;   % 654: 		lh t2,0(t1)           # Gets player's current X related to screen %
000011ae : 01000e13;   % 655: 		li t3,16       # Loads 16 (tile size) %
000011af : 008e0e13;   % 656: 		addi t3,t3,8          # Player should have an offset of 8 %
000011b0 : 027e1063;   % 657: 		bne t3,t2,CONTINUE_LEAVE_DOOR_ANIMATION_2  # If player's current X != 16, continue loop %
000011b1 : 00800293;   % 659: 			li t0,8           # Loads 8 for player's X offset %
000011b2 : 00530323;   % 660: 			sb t0,6(t1)       # and stores it %
000011b3 : 00834383;   % 661: 			lbu t2,8(t1)      # Gets player's current X related to matrix %
000011b4 : 00138393;   % 662: 			addi t2,t2,1      # adds 1 to it %
000011b5 : 00730423;   % 663: 			sb t2,8(t1)       # and stores it back %
000011b6 : 007304a3;   % 664: 			sb t2,9(t1)       # as well as storing on old X %
000011b7 : 00c0006f;   % 665: 			j END_LEAVE_DOOR_ANIMATION  # Finish procedure  %
000011b8 : c01024f3;   % 668: 		csrr s1,3073    # new time is stored in s1, in order to be compared later		 %
000011b9 : ea5ff06f;   % 669: 		j LEAVE_DOOR_ANIMATION	# Returns to beginning of loop %
000011ba : 0fc0c317;   % 673: 		la t1,NEXT_MAP %
000011bb : a2430313;   % 673:  %
000011bc : 00934303;   % 674: 		lbu t1,9(t1)     # loads "next door"'s number %
000011bd : 00231313;   % 675: 		slli t1,t1,2     # multiplies it by 4 %
000011be : 0fc0c517;   % 676: 		la a0, Doors     # Gets Doors address %
000011bf : c7c50513;   % 676:  %
000011c0 : 00052503;   % 677: 		lw a0,0(a0)      # gets current map's doors address %
000011c1 : 00150513;   % 678: 		addi a0,a0,1     # skips number of doors %
000011c2 : 00650533;   % 679: 		add a0,a0,t1     # and adds t1 to get the correct door's address %
000011c3 : 00100393;   % 680: 		li t2,1             # Loads 1 (opening/closing) %
000011c4 : 00750123;   % 681: 		sb t2,2(a0)         # and stores it on door's state byte     %
000011c5 : 00400393;   % 682: 		li t2,4  # Gets new counter (related to closing door -- positive, in order to close) %
000011c6 : 007501a3;   % 683: 		sb t2,3(a0)         # and stores it on door's counter byte %
000011c7 : c01024f3;   % 685: 		csrr s1,3073      # new time is stored in s1, in order to be compared later		 %
000011c8 : 921fb06f;   % 686: 		j GAME_LOOP       # go to GAME_LOOP   %
000011c9 : 0fc0c297;   % 11:     la t0,PLYR_STATUS  # Loads Player Status %
000011ca : a0228293;   % 11:  %
000011cb : 00428303;   % 12:     lb t1, 4(t0)       # Loads Ball Byte  %
000011cc : 00031463;   % 13:     bnez t1, UPDATE_BALL_SPRITE # If player is on morph ball (t1 != 0), go to UPDATE_BALL_SPRITE %
000011cd : 0480006f;   % 14:     j CHECK_VERTICAL_MOV        # Otherwise, go to CHECK_VERTICAL_MOV %
000011ce : 0012c303;   % 18:         lbu t1, 1(t0) # Loads player's facing direction into t1 %
000011cf : 00031463;   % 19:         bnez t1, UPDATE_BALL_SPRITE_LEFT # If player is looking left, go to UPDATE_BALL_SPRITE_LEFT %
000011d0 : 01c0006f;   % 20:         j UPDATE_BALL_SPRITE_RIGHT       # otherwise, go to UPDATE_BALL_SPRITE_RIGHT %
000011d1 : 0002c303;   % 23:             lbu t1, 0(t0) # Loads sprite number %
000011d2 : 00300393;   % 24:             li t2, 3 # t2 = max_sprite %
000011d3 : 02730463;   % 25:             beq t1,t2,RESET_SPRITE_BALL # t1 == t2 ? RESET_SPRITE : INC_SPRITE %
000011d4 : 00130313;   % 26:             addi t1,t1,1 # INC_SPRITE %
000011d5 : 00628023;   % 27:             sb t1, 0(t0) # Store sprite number in status %
000011d6 : 0800006f;   % 28:             j END_UPDATE_STATUS %
000011d7 : 0002c303;   % 31:             lbu t1, 0(t0) # Loads sprite number %
000011d8 : 00300393;   % 32:             li t2, 3 # t2 = max_sprite %
000011d9 : 00730863;   % 33:             beq t1,t2,RESET_SPRITE_BALL # t1 == t2 ? RESET_SPRITE : INC_SPRITE %
000011da : 00130313;   % 34:             addi t1,t1,1 # INC_SPRITE %
000011db : 00628023;   % 35:             sb t1, 0(t0) # Store sprite number in status %
000011dc : 0680006f;   % 36:             j END_UPDATE_STATUS %
000011dd : 00028023;   % 39:             sb zero, 0(t0) # Reset sprite number %
000011de : 0600006f;   % 40:             j END_UPDATE_STATUS %
000011df : 0072c303;   % 43:     lbu t1, 7(t0) # Loads MOVE_Y to t1 %
000011e0 : 00030463;   % 44:     beqz t1, CHECK_HORIZONTAL_MOV # t1 == 0 ? CHECK_HORIZONTAL_MOV : END_UPDATE_STATUS %
000011e1 : 0500006f;   % 45:     j RESET_SPRITE %
000011e2 : 0062c303;   % 48:     lbu t1,6(t0) # Loads Move X to t1 %
000011e3 : 00031463;   % 49:     bnez t1, CHECK_HORIZONTAL_MOV_2 # t1 = 0 ? DONT UPDATE SPRITE : CHECK_SPRITES %
000011e4 : 0440006f;   % 50:     j RESET_SPRITE %
000011e5 : 00604463;   % 53:     blt zero, t1, SPRITE_LEFT # zero < moveX ? SPRITE_LEFT : SPRITE_RIGHT  %
000011e6 : 0200006f;   % 54:     j SPRITE_RIGHT %
000011e7 : 0002c303;   % 57:     lbu t1, 0(t0)   # Loads sprite number %
000011e8 : 00200393;   % 58:     li t2,2    # t2 = max sprite-number %
000011e9 : 00734463;   % 59:     blt t1,t2, ASC_LEFT_SPRITE # t1 < t2 ? ASC_ESQ_SPRITE  : DESC_LEFT_SPRITE %
000011ea : 02c0006f;   % 60:     j RESET_SPRITE %
000011eb : 00130313;   % 63:     addi t1,t1,1 # Increments sprite number %
000011ec : 00628023;   % 64:     sb t1, 0(t0) # Stores sprite_number in PLYR_STATUS %
000011ed : 0240006f;   % 65:     j END_UPDATE_STATUS %
000011ee : 0002c303;   % 69:     lbu t1, 0(t0)   # Loads sprite number %
000011ef : 00200393;   % 70:     li t2,2        # t2 = end of sprites %
000011f0 : 00734463;   % 71:     blt t1,t2, ASC_RIGHT_SPRITE # t1 < t2 ? ASC_RIGHT_SPRITE   %
000011f1 : 0100006f;   % 72:     j RESET_SPRITE %
000011f2 : 00130313;   % 75:     addi t1,t1,1 # increments sprite number %
000011f3 : 00628023;   % 76:     sb t1, 0(t0) # stores in PLYR_POS %
000011f4 : 0080006f;   % 77:     j END_UPDATE_STATUS %
000011f5 : 00028023;   % 80:     sb zero, 0(t0) # returns to sprite 0 %
000011f6 : 00008067;   % 83:     ret %
000011f7 : 0fc0c297;   % 87:     la t0,CURRENT_MAP # Loads CURRENT_MAP address %
000011f8 : 92428293;   % 87:  %
000011f9 : 0042c303;   % 88:     lbu t1, 4(t0)     # Loads Current Map byte %
000011fa : 00100393;   % 89:     li t2,1           # Number of map that maru mari appears %
000011fb : 06639a63;   % 90:     bne t2,t1,END_UPDATE_MARU_MARI # If not on correct map, ignore %
000011fc : 0fc0c317;   % 93:         la t1,MARU_MARI_INFO # Loads Maru Mari's info address %
000011fd : 94c30313;   % 93:  %
000011fe : 00134383;   % 94:         lbu t2, 1(t1)        # Loads status sprite %
000011ff : 00300e13;   % 95:         li t3, 3             # t3 = max_sprite %
00001200 : 01c38863;   % 96:         beq t2,t3,RESET_MARU_MARI # If status == 3, reset it %
00001201 : 00138393;   % 97:             addi t2,t2,1     # Increments status  %
00001202 : 007300a3;   % 98:             sb t2, 1(t1)     # Stores status sprite %
00001203 : 0080006f;   % 99:             j UPDATE_MARU_MARI_TRY_RENDER %
00001204 : 000300a3;   % 101:             sb zero, 1(t1)   # Stores status sprite %
00001205 : 0062c583;   % 105:         lbu a1, 6(t0)     # Loads Current Map's X %
00001206 : 00f00393;   % 106:         li t2,15 # Loads Maru_Mari's X %
00001207 : 40b38333;   % 107:         sub t1,t2,a1      # t1 = Maru_Mari's X - Current Map's X %
00001208 : 00035463;   % 108:         bge t1,zero,UPDATE_MARU_MARI_RENDER # If t1 >= 0, render maru mari %
00001209 : 03c0006f;   % 110:             j END_UPDATE_MARU_MARI %
0000120a : 0002a503;   % 112:             lw a0,0(t0) %
0000120b : 0072c603;   % 114:             lbu a2, 7(t0)     # Loads Current Map's Y %
0000120c : 0082c683;   % 115:             lbu a3, 8(t0)   # Loads current X offset on Map %
0000120d : 0092c703;   % 116:             lbu a4, 9(t0)   # Loads current Y offset on Map	 %
0000120e : 008007b3;   % 117:             mv a5, s0		# Frame = s0 %
0000120f : 00100813;   % 118:             li a6, 1        # Width of rendering area will always be 1 %
00001210 : 00100893;   % 119:             li a7, 1        # Height of rendering area will always be 1 %
00001211 : 00f00e13;   % 120:             li t3, 15  # X from map matrix where rendering will start from %
00001212 : 00900393;   % 121:             li t2, 9  # Y from map matrix where rendering will start from %
00001213 : 00000213;   % 122:             li tp, 0        # Map won't be dislocated		 %
00001214 : 00100db3;   % 123:             mv s11,ra %
00001215 : ffffd317;   % 124:             call RENDER_MAP		 %
00001216 : 4b8300e7;   % 124:  %
00001217 : 01b000b3;   % 125:             mv ra,s11 %
00001218 : 00008067;   % 128:         ret %
00001219 : 00000213;   % 39:     li tp, 0  # Player check %
0000121a : 00c003b3;   % 40:     mv t2,a2  # Moves a2 to t2 %
0000121b : 00200613;   % 41:     li a2, 2  # Base case: check 2 tiles horizontally (or 1 if on morph ball) %
0000121c : 00000693;   % 42:     li a3,0   # Sets for horizontal check  %
0000121d : 00000713;   % 43:     li a4,0   # Base case: ignore door %
0000121e : 0015c783;   % 44:     lbu a5,1(a1)   # Loads Map Matrix's width %
0000121f : 0083c803;   % 45:     lbu a6, 8(t2)  # a6 = Player's X related to matrix %
00001220 : 00a3c883;   % 46:     lbu a7, 10(t2) # a7 = Player's Y related to matrix %
00001221 : 00358593;   % 48:     addi a1,a1,3   # Adds 3 to the Matrix's address so that it goes to the beginning of matrix %
00001222 : 02f882b3;   % 49:     mul t0,a7,a5   # Player's Y related to matrix * Map Matrix's width %
00001223 : 005802b3;   % 50:     add t0,a6,t0   # t0 = Player's X related to matrix +  Player's Y related to matrix * Map Matrix's width   %
00001224 : 005585b3;   % 51:     add a1,a1,t0   # a1 = Map Matrix's address adjusted for Player's X and Y related to matrix %
00001225 : 0063ce03;   % 53:     lbu t3, 6(t2)  # t3 = Player's X offset %
00001226 : 00050283;   % 54:     lb t0, 0(a0)   # Loads MOVE_X information to t0 %
00001227 : 00200513;   % 55:     li a0,2        # Sets a0 to 2 (check any type of door) %
00001228 : 00029463;   % 56:     bnez t0, CHECK_X_DIRECTION  # If player's not moving, end procedure  %
00001229 : 0ac0006f;   % 57:     j END_HORIZONTAL_COLLISION  %
0000122a : 0fc0c317;   % 61:         la t1, MOVE_Y # Loads MOVE_Y address %
0000122b : 88530313;   % 61:  %
0000122c : 00030303;   % 62:         lb t1,0(t1)   # Loads MOVE_Y content %
0000122d : 02030c63;   % 63:         beqz t1, CONTINUE_CHECK_X_DIRECTION  # If MOVE_Y = 0, skip %
0000122e : 00605e63;   % 64:             bge zero,t1, UPWARDS_THIRD_CHECK # If MOVE_Y = 1 (down) continue %
0000122f : 0fc0c317;   % 65:                 la t1, PLYR_POS    # Loads PLYR_POS address %
00001230 : 85e30313;   % 65:  %
00001231 : 00730303;   % 66:                 lb t1, 7(t1)       # Loads Y offset %
00001232 : 02030263;   % 67:                 beqz t1 CONTINUE_CHECK_X_DIRECTION # If Y offset is zero, there's no need to check 3 tiles %
00001233 : 00160613;   % 68:                     addi a2,a2, 1  # Checks 3 tiles horizontally (or 2 if on morph ball) %
00001234 : 01c0006f;   % 69:                     j CONTINUE_CHECK_X_DIRECTION %
00001235 : 0fc0c317;   % 71:                 la t1, PLYR_POS # Loads PLYR_POS address %
00001236 : 84630313;   % 71:  %
00001237 : 00730303;   % 72:                 lb t1, 7(t1)    # Loads Y offset %
00001238 : 00200f13;   % 73:                 li t5, 2        # Represents the desired offset %
00001239 : 006f5463;   % 74:                 bge t5, t1 CONTINUE_CHECK_X_DIRECTION # If Y offset is zero, there's no need to check 3 tiles %
0000123a : 00160613;   % 75:                     addi a2,a2, 1  # Checks 3 tiles horizontally (or 2 if on morph ball) %
0000123b : 0103c303;   % 78:         lbu t1,16(t2) # Loads Player's morph ball byte %
0000123c : 00030863;   % 79:         beqz t1,CONTINUE_CHECK_X_DIRECTION_2 # If player's not on morph ball %
0000123d : fff60613;   % 80:         addi a2,a2,-1 # Morph ball requires one less iteration on horizontal check %
0000123e : 00b785b3;   % 81:         add a1,a5,a1  # Increments width to player's y on matrix (checks only one tile in front of them) %
0000123f : 00188893;   % 82:         addi a7,a7,1  # Increments current Y on matrix(+1 Y) %
00001240 : 0002c463;   % 85:         blt t0, zero, CHECK_X_LEFT # If player is moving left (t0 < 0), go to CHECK_X_LEFT %
00001241 : 0240006f;   % 86:         j CHECK_X_RIGHT            # otherwise, go to CHECK_X_RIGHT %
00001242 : 00c00293;   % 89:             li t0, 12    # Loads number 12 for comparing with X offset  %
00001243 : 005e0a63;   % 90:             beq t3, t0, CONTINUE_CHECK_X_LEFT # If X offset is 12, continue checking %
00001244 : ff828293;   % 91:             addi t0,t0, -8                    # Otherwise, compare with offset 4 %
00001245 : 00200713;   % 92:             li a4,2      # Sets to check for only doors (if the next condition isn't met, it doesn' matter the value of a4) %
00001246 : 005e0663;   % 93:             beq t3, t0, CONTINUE_CHECK_X_LEFT_DOOR # If X offset is 4, check for doors %
00001247 : 0340006f;   % 94:             j END_HORIZONTAL_COLLISION             # Otherwise, stop %
00001248 : 00000713;   % 97:                 li a4,0 # Sets to ignore doors %
00001249 : 1190006f;   % 99:                 j CHECK_MAP_COLLISION %
0000124a : 00158593;   % 102:             addi a1,a1, 1 # Looks to the tile on the right of player's current tile %
0000124b : 00180813;   % 103:             addi a6,a6,1  # Increments current X on matrix(+1 X) %
0000124c : 00400293;   % 104:             li t0, 4      # Loads number 4 for comparing with X offset  %
0000124d : 005e0a63;   % 105:             beq t3, t0, CONTINUE_CHECK_X_RIGHT # If X offset is 4, continue checking %
0000124e : 00828293;   % 106:             addi t0,t0, 8                      # Otherwise, compare with offset 12 %
0000124f : 00200713;   % 107:             li a4,2       # Sets to check for only doors (if the next condition isn't met, it doesn' matter the value of a4) %
00001250 : 005e0663;   % 108:             beq t3, t0, CONTINUE_CHECK_X_RIGHT_DOOR # If X offset is 12, check for doors %
00001251 : 00c0006f;   % 109:                 j END_HORIZONTAL_COLLISION  %
00001252 : 00000713;   % 112:                 li a4,0 # Sets to ignore doors %
00001253 : 0f10006f;   % 114:                 j CHECK_MAP_COLLISION %
00001254 : 00100513;   % 118:         li a0,1   %
00001255 : 00008067;   % 119:         ret  %
00001256 : 00c003b3;   % 151:     mv t2,a2  # Moves a2 to t2 %
00001257 : 00d00233;   % 152:     mv tp,a3  # Moves a3 to tp %
00001258 : 00100613;   % 153:     li a2,1   # Base case: check 1 tiles vertically %
00001259 : 00100693;   % 154:     li a3,1   # Sets for horizontal check  %
0000125a : 00000713;   % 155:     li a4,0   # Base case: ignore door %
0000125b : 0015c783;   % 156:     lbu a5,1(a1)   # Loads Map Matrix's width %
0000125c : 0083c803;   % 157:     lbu a6, 8(t2)  # a6 = Player's X related to matrix %
0000125d : 00a3c883;   % 158:     lbu a7, 10(t2) # a7 = Player's Y related to matrix %
0000125e : 00358593;   % 160:     addi a1,a1,3   # Adds 3 to the Matrix's address so that it goes to the beginning of matrix %
0000125f : 02f882b3;   % 161:     mul t0,a7,a5   # Player's Y related to matrix * Map Matrix's width %
00001260 : 005802b3;   % 162:     add t0,a6,t0   # t0 = Player's X related to matrix +  Player's Y related to matrix * Map Matrix's width   %
00001261 : 005585b3;   % 163:     add a1,a1,t0   # a1 = Map Matrix's address adjusted for Player's X and Y related to matrix %
00001262 : 0073ce03;   % 165:     lbu t3, 7(t2)  # t3 = Player's Y offset %
00001263 : 00050283;   % 166:     lb t0, 0(a0) # Loads MOVE_Y to t0  %
00001264 : 0002c463;   % 167:     blt t0,zero, CHECK_Y_UP # If t0 < 0, check up,  %
00001265 : 0500006f;   % 168:     j CHECK_Y_DOWN          # otherwise check down %
00001266 : 004e0e33;   % 172:         add t3,t3,tp     # current offset + offset modifier %
00001267 : 01c05463;   % 173:         bge zero,t3 CONTINUE_CHECK_Y_UP # If current offset + offset modifier <= 0, continue checking %
00001268 : 0d00006f;   % 174:         j END_VERTICAL_COLLISION    # otherwise, end procedure %
00001269 : 0103c303;   % 178:             lbu t1,16(t2)  # Loads Player's morph ball byte %
0000126a : 00031663;   % 179:             bnez t1, CONTINUE_CHECK_Y_UP2 # If player is on morph ball, don't update Y to be checked %
0000126b : 40f585b3;   % 180:             sub a1,a1,a5   # If player isn't on morph ball, update Y one tile up (-1 matrix Y)  %
0000126c : fff88893;   % 181:             addi a7,a7,-1  # Increments current Y on matrix(-1 Y) %
0000126d : 0063ce03;   % 185:             lbu t3, 6(t2)  # t3 = Player's X offset %
0000126e : 00800293;   % 186:             li t0, 8   # Loads number 8 for comparing with X offset  %
0000126f : 005e4863;   % 187:             blt t3,t0, CHECK_Y_UP_ABOVE # If X offset < 8, just check one tile above %
00001270 : 00c00293;   % 188:             li t0,12   # Loads number 12 for comparing with X offset  %
00001271 : 005e5863;   % 189:             bge t3,t0, CHECK_Y_UP_TO_THE_RIGHT # If X offset >= 12, check one tile above to the right  %
00001272 : 00200613;   % 190:             li a2,2    # If player's X offset = 8, check 2 tiles above the player (one above, the other above to the right) %
00001273 : 00000213;   % 193:                 li tp, 0  # Player check %
00001274 : 06d0006f;   % 194:                 j CHECK_MAP_COLLISION %
00001275 : 00158593;   % 197:                 addi a1,a1, 1 # Looks to the tile on the right of player's current tile %
00001276 : 00180813;   % 198:                 addi a6,a6,1  # Increments current X on matrix (+1 X) %
00001277 : 00000213;   % 199:                 li tp, 0  # Player check %
00001278 : 05d0006f;   % 200:                 j CHECK_MAP_COLLISION            %
00001279 : 00000e93;   % 203:         li t4,0   # If Y offset = 0 %
0000127a : 00000f13;   % 204:         li t5,0   # If Y offset = 0 %
0000127b : 000e0e63;   % 205:         beqz t3 CONTINUE_CHECK_Y_DOWN    # If player's Y offset = 0, continue checking %
0000127c : 00f00eb3;   % 208:         mv t4,a5  # If Y offset = 14 %
0000127d : 00100f13;   % 209:         li t5,1   # If Y offset = 14 %
0000127e : 01000313;   % 211:         li t1,16  # Loads 16 %
0000127f : 004e0e33;   % 212:         add t3,t3,tp     # current offset + offset modifier %
00001280 : 006e5463;   % 213:         bge t3,t1 CONTINUE_CHECK_Y_DOWN  # If current offset + offset modifier >= 16, continue checking (but check one tile bellow) %
00001281 : 06c0006f;   % 215:         j END_VERTICAL_COLLISION         # otherwise, end procedure %
00001282 : 00100713;   % 218:             li a4, 1  # Base case: Consider doors %
00001283 : 00179293;   % 220:             slli t0,a5,1     # t0 = 2 x Matrix width %
00001284 : 005585b3;   % 221:             add a1,a1,t0     # Updates Y 2 tiles down (+2 matrix Y)  %
00001285 : 00288893;   % 222:             addi a7,a7,2     # Increments current Y on matrix (+2 Y) %
00001286 : 01d585b3;   % 224:             add a1,a1,t4     # If Y offset = 14, update Y another tile down (+1 matrix Y) %
00001287 : 01e888b3;   % 225:             add a7,a7,t5    # If Y offset = 14, increment current Y on matrix once more (+1 Y) %
00001288 : 0063ce03;   % 227:             lbu t3, 6(t2)    # t3 = Player's X offset %
00001289 : 020e0063;   % 228:             beqz t3 CHECK_Y_DOWN_BOTH_DOORS # If X offset = 0, just check one tile bellow, and consider both doors %
0000128a : 00800293;   % 229:             li t0, 8   # Loads number 8 for comparing with X offset  %
0000128b : 025e4263;   % 230:             blt t3,t0, CHECK_Y_DOWN_RIGHT_DOOR # If X offset < 8, just check one tile bellow, and consider right doors %
0000128c : 03c2c663;   % 231:             blt t0,t3, CHECK_Y_DOWN_LEFT_DOOR # If X offset > 8, check one tile bellow to the right , and consider left doors %
0000128d : 00200613;   % 233:                 li a2,2  # Check 2 tiles above the player (one bellow, the other bellow to the right)   %
0000128e : 00000713;   % 234:                 li a4,0  # Ignore doors %
0000128f : 00000213;   % 235:                 li tp, 0  # Player check %
00001290 : 7fc0006f;   % 236:                 j CHECK_MAP_COLLISION %
00001291 : 00200513;   % 239:                 li a0, 2 # Consider both doors on the left and on the right sides of the map %
00001292 : 00000213;   % 240:                 li tp, 0  # Player check %
00001293 : 7f00006f;   % 241:                 j CHECK_MAP_COLLISION %
00001294 : 00000513;   % 244:                 li a0, 0 # Only consider doors on the right side of the map %
00001295 : 00000213;   % 245:                 li tp, 0  # Player check %
00001296 : 7e40006f;   % 246:                 j CHECK_MAP_COLLISION %
00001297 : 00100513;   % 249:                 li a0, 1 # Only consider doors on the left side of the map %
00001298 : 00158593;   % 250:                 addi a1,a1, 1 # Looks to the tile on the right of player's current tile %
00001299 : 00180813;   % 251:                 addi a6,a6,1  # Increments current X on matrix (+1 X) %
0000129a : 00000213;   % 252:                 li tp, 0  # Player check %
0000129b : 7d00006f;   % 253:                 j CHECK_MAP_COLLISION  %
0000129c : 00100513;   % 257:         li a0,1   %
0000129d : 00008067;   % 258:         ret  %
0000129e : 00454303;   % 292:     lbu t1,4(a0)  # Loads Zoomer's X %
0000129f : 006502a3;   % 293:     sb t1,5(a0)   # And stores it in Zoomer's old  %
000012a0 : 00654303;   % 294:     lbu t1,6(a0)  # Loads Zoomer's Y %
000012a1 : 006503a3;   % 295:     sb t1,7(a0)   # And stores it in Zoomer's old Y %
000012a2 : 00000613;   % 297:     li a2, 0      # First stage of check (platform)  %
000012a3 : ffc10113;   % 299:         addi sp,sp,-4 %
000012a4 : 00b12023;   % 300:         sw a1,0(sp) %
000012a5 : 00100293;   % 304:         li t0,1       # In case no collision check is made %
000012a6 : 00012583;   % 306:         lw a1,0(sp)   # Loads map's matrix original address %
000012a7 : 0015c783;   % 307:         lbu a5,1(a1)  # Loads map's matrix width %
000012a8 : 00454803;   % 308:         lbu a6,4(a0)  # Loads Zoomer's current X %
000012a9 : 00654883;   % 309:         lbu a7,6(a0)  # Loads Zoomer's current Y %
000012aa : 00358593;   % 311:         addi a1,a1,3   # Adds 3 to the Matrix's address so that it goes to the beginning of matrix %
000012ab : 02f88333;   % 312:         mul t1,a7,a5   # Zoomer's Y related to matrix * Map Matrix's width %
000012ac : 00680333;   % 313:         add t1,a6,t1   # t1 = Zoomer's X related to matrix +  Zoomer's Y related to matrix * Map Matrix's width   %
000012ad : 006585b3;   % 314:         add a1,a1,t1   # a1 = Map Matrix's address adjusted for Zoomer's X and Y related to matrix %
000012ae : 00000713;   % 316:         li a4,0  # Base case: Don't consider doors (if X offset stays 0) %
000012af : 00100213;   % 317:         li tp,1  # Base case (will be passed to a2): only check 1 tile (if X offset stays 0) %
000012b0 : 00a54303;   % 319:         lbu t1,10(a0)  # Loads Zoomer's Platform %
000012b1 : 00254383;   % 320:         lbu t2,2(a0)   # Loads Zoomer's X offset %
000012b2 : 00354e03;   % 321:         lbu t3,3(a0)   # Loads Zoomer's Y offset %
000012b3 : 00954e83;   % 322:         lbu t4,9(a0)   # Loads Zoomer's Clock movement %
000012b4 : 06031663;   % 323:         bnez t1,TRY_MOVE_ZOOMER_COLLISION_LEFT %
000012b5 : 00100713;   % 325:             li a4,1  # Base case: Consider doors %
000012b6 : 00800313;   % 326:             li t1,8 %
000012b7 : 00731c63;   % 327:             bne t1,t2,MOVE_ZOOMER_CHECK_DOWN_0_OFF  # If offset != 8, check if it's 0 %
000012b8 : 00100713;   % 328:                 li a4,1  # Base case: Consider doors %
000012b9 : 00c70733;   % 329:                 add a4,a4,a2 # If on second check, consider ONLY doors %
000012ba : 00200213;   % 330:                 li tp,2  # Check 2 tiles %
000012bb : 40c20233;   % 331:                 sub tp,tp,a2 # If on second check, check ONLY 1 tile %
000012bc : 00c0006f;   % 332:                 j MOVE_ZOOMER_CHECK_DOWN_SETUP # start collision check %
000012bd : 00038463;   % 335:             beqz t2, MOVE_ZOOMER_CHECK_DOWN_SETUP %
000012be : 3ec0006f;   % 336:                 j MOVE_ZOOMER_PROPERLY %
000012bf : 00061a63;   % 339:             bnez a2, MOVE_ZOOMER_CHECK_DOWN_FOWARD %
000012c0 : 00188893;   % 341:                 addi a7,a7,1 # Checking one tile down %
000012c1 : 00f585b3;   % 342:                 add a1,a1,a5 # Updates starting address on map matrix %
000012c2 : 00100693;   % 343:                 li a3,1  # Vertical check %
000012c3 : 1600006f;   % 344:                 j START_ZOOMER_COLLISION %
000012c4 : 000e8e63;   % 348:                 beqz t4, MOVE_ZOOMER_CHECK_DOWN_FOWARD_CLOCKWISE %
000012c5 : 00800313;   % 350:                 li t1,8 %
000012c6 : 00730663;   % 351:                 beq t1,t2,MOVE_ZOOMER_CHECK_DOWN_FOWARD_OFF_8 # If offset == 8, don't alter X %
000012c7 : fff80813;   % 352:                     addi a6,a6,-1   # Checking left tile %
000012c8 : fff58593;   % 353:                     addi a1,a1,-1   # Updates starting address on map matrix %
000012c9 : 00000693;   % 355:                     li a3,0  # Horizontal check %
000012ca : 1440006f;   % 356:                     j START_ZOOMER_COLLISION %
000012cb : 00180813;   % 360:                     addi a6,a6,1  # Checking right tile %
000012cc : 00158593;   % 361:                     addi a1,a1,1   # Updates starting address on map matrix %
000012cd : 00000693;   % 362:                     li a3,0  # Horizontal check %
000012ce : 1340006f;   % 363:                     j START_ZOOMER_COLLISION %
000012cf : 00100f13;   % 366:         TRY_MOVE_ZOOMER_COLLISION_LEFT:  li t5,1 %
000012d0 : 07e31463;   % 367:             bne t1,t5,TRY_MOVE_ZOOMER_COLLISION_UP %
000012d1 : 00800313;   % 369:             li t1,8 %
000012d2 : 00731663;   % 370:             bne t1,t2,MOVE_ZOOMER_CHECK_LEFT_0_OFF  # If X offset != 8, skip it %
000012d3 : 00100713;   % 371:                 li a4,1  # Base case: Consider doors %
000012d4 : 40c70733;   % 372:                 sub a4,a4,a2 # If on second check, don't consider doors            %
000012d5 : 000e0463;   % 375:             beqz t3, MOVE_ZOOMER_CHECK_LEFT_SETUP %
000012d6 : 38c0006f;   % 376:                 j MOVE_ZOOMER_PROPERLY %
000012d7 : 00061e63;   % 379:             bnez a2, MOVE_ZOOMER_CHECK_LEFT_FOWARD %
000012d8 : 00800313;   % 381:                 li t1,8 %
000012d9 : 00730663;   % 382:                 beq t1,t2,MOVE_ZOOMER_CHECK_LEFT_8_OFF  # If X offset is 8, don't update X  %
000012da : fff80813;   % 383:                     addi a6,a6,-1  # Checking left tile (or current tile if X offset == 8) %
000012db : fff58593;   % 384:                     addi a1,a1,-1   # Updates starting address on map matrix  %
000012dc : 00000693;   % 386:                 li a3,0  # Horizontal check %
000012dd : 0f80006f;   % 387:                 j START_ZOOMER_COLLISION %
000012de : 00800313;   % 391:                 li t1,8 %
000012df : 00730463;   % 392:                 beq t1,t2,MOVE_ZOOMER_CHECK_LEFT_FOWARD_8_OFF  # If X offset is 8, don't consider doors %
000012e0 : 00100713;   % 393:                     li a4,1  # Base case: Consider doors %
000012e1 : 000e8a63;   % 395:                 beqz t4, MOVE_ZOOMER_CHECK_LEFT_FOWARD_CLOCKWISE %
000012e2 : fff88893;   % 397:                     addi a7,a7,-1 # Checking one tile up %
000012e3 : 40f585b3;   % 398:                     sub a1,a1,a5  # Updates starting address on map matrix %
000012e4 : 00100693;   % 399:                     li a3,1  # Vertical check %
000012e5 : 0d80006f;   % 400:                     j START_ZOOMER_COLLISION %
000012e6 : 00188893;   % 404:                     addi a7,a7,1 # Checking one tile down %
000012e7 : 00f585b3;   % 405:                     add a1,a1,a5 # Updates starting address on map matrix %
000012e8 : 00100693;   % 406:                     li a3,1  # Vertical check %
000012e9 : 0c80006f;   % 407:                     j START_ZOOMER_COLLISION %
000012ea : 00200f13;   % 410:         TRY_MOVE_ZOOMER_COLLISION_UP:  li t5,2 %
000012eb : 07e31463;   % 411:             bne t1,t5,MOVE_ZOOMER_COLLISION_RIGHT %
000012ec : 00800f13;   % 413:             li t5,8 %
000012ed : 007f1c63;   % 414:             bne t5,t2,MOVE_ZOOMER_CHECK_UP_0_OFF  # If offset != 8, check if it's 0 %
000012ee : 00100713;   % 415:                 li a4,1  # Base case: Consider doors %
000012ef : 00c70733;   % 416:                 add a4,a4,a2 # If on second check, consider ONLY doors %
000012f0 : 00200213;   % 418:                 li tp,2  # Check 2 tiles %
000012f1 : 40c20233;   % 419:                 sub tp,tp,a2 # If on second check, check ONLY 1 tile %
000012f2 : 00c0006f;   % 421:                 j MOVE_ZOOMER_CHECK_UP_SETUP # start collision check %
000012f3 : 00038463;   % 424:             beqz t2, MOVE_ZOOMER_CHECK_UP_SETUP %
000012f4 : 3140006f;   % 425:                 j MOVE_ZOOMER_PROPERLY %
000012f5 : 00061a63;   % 428:             bnez a2, MOVE_ZOOMER_CHECK_UP_FOWARD %
000012f6 : fff88893;   % 430:                 addi a7,a7,-1 # Checking one tile above %
000012f7 : 40f585b3;   % 431:                 sub a1,a1,a5  # Updates starting address on map matrix %
000012f8 : 00100693;   % 432:                 li a3,1  # Vertical check %
000012f9 : 0880006f;   % 433:                 j START_ZOOMER_COLLISION %
000012fa : 000e8a63;   % 437:                 beqz t4, MOVE_ZOOMER_CHECK_UP_FOWARD_CLOCKWISE %
000012fb : 00180813;   % 439:                     addi a6,a6,1  # Checking right tile %
000012fc : 00158593;   % 440:                     addi a1,a1,1   # Updates starting address on map matrix %
000012fd : 00000693;   % 441:                     li a3,0  # Horizontal check %
000012fe : 0740006f;   % 442:                     j START_ZOOMER_COLLISION %
000012ff : 00800f13;   % 446:                     li t5,8 %
00001300 : 007f0663;   % 447:                     beq t5,t2,MOVE_ZOOMER_CHECK_UP_FOWARD_CLOCKWISE_0_OFF  # If offset is 8, don't update this %
00001301 : fff80813;   % 448:                         addi a6,a6,-1  # Checking left tile %
00001302 : fff58593;   % 449:                         addi a1,a1,-1   # Updates starting address on map matrix %
00001303 : 00000693;   % 451:                     li a3,0  # Horizontal check %
00001304 : 05c0006f;   % 452:                     j START_ZOOMER_COLLISION %
00001305 : 00800313;   % 457:             li t1,8 %
00001306 : 00731863;   % 458:             bne t1,t2,MOVE_ZOOMER_CHECK_RIGHT_0_OFF  # If X offset != 8, skip this %
00001307 : 00100713;   % 459:                 li a4,1  # Base case: Consider doors %
00001308 : 00c80833;   % 461:                 add a6,a6,a2   # Checking right tile %
00001309 : 00c585b3;   % 462:                 add a1,a1,a2   # Updates starting address on map matrix %
0000130a : 000e0463;   % 466:             beqz t3, MOVE_ZOOMER_CHECK_RIGHT_SETUP %
0000130b : 2b80006f;   % 467:                 j MOVE_ZOOMER_PROPERLY %
0000130c : 00061a63;   % 470:             bnez a2, MOVE_ZOOMER_CHECK_RIGHT_FOWARD %
0000130d : 00180813;   % 472:                 addi a6,a6,1   # Checking right tile %
0000130e : 00158593;   % 473:                 addi a1,a1,1   # Updates starting address on map matrix %
0000130f : 00000693;   % 474:                 li a3,0  # Horizontal check %
00001310 : 02c0006f;   % 475:                 j START_ZOOMER_COLLISION %
00001311 : 00100713;   % 479:                 li a4,1  # Base case: Consider doors %
00001312 : 000e8a63;   % 480:                 beqz t4, MOVE_ZOOMER_CHECK_RIGHT_FOWARD_CLOCKWISE %
00001313 : 00188893;   % 482:                     addi a7,a7,1 # Checking one tile down %
00001314 : 00f585b3;   % 483:                     add a1,a1,a5 # Updates starting address on map matrix %
00001315 : 00100693;   % 484:                     li a3,1  # Vertical check %
00001316 : 0140006f;   % 485:                     j START_ZOOMER_COLLISION %
00001317 : fff88893;   % 489:                     addi a7,a7,-1 # Checking one tile up %
00001318 : 40f585b3;   % 490:                     sub a1,a1,a5  # Updates starting address on map matrix %
00001319 : 00100693;   % 491:                     li a3,1  # Vertical check %
0000131a : 0040006f;   % 492:                     j START_ZOOMER_COLLISION %
0000131b : ff010113;   % 496:             addi sp,sp,-16 %
0000131c : 00112023;   % 497:             sw ra,0(sp) %
0000131d : 00a12223;   % 498:             sw a0,4(sp) %
0000131e : 00b12423;   % 499:             sw a1,8(sp) %
0000131f : 00c12623;   % 500:             sw a2,12(sp) %
00001320 : 00200513;   % 503:             li a0,2  # All doors should be checked %
00001321 : 00400633;   % 505:             mv a2,tp #li a2,1  # Only check one tile %
00001322 : 00100213;   % 511:             li tp, 1  # Entity collision %
00001323 : 00000317;   % 513:             call CHECK_MAP_COLLISION %
00001324 : 5b0300e7;   % 513:  %
00001325 : 00a002b3;   % 514:             mv t0,a0   # Stores result from a0 to t0 %
00001326 : 00b00233;   % 515:             mv tp,a1   # Stores result from a1 to tp %
00001327 : 00012083;   % 518:             lw ra,0(sp) %
00001328 : 00412503;   % 519:             lw a0,4(sp) %
00001329 : 00812583;   % 520:             lw a1,8(sp) %
0000132a : 00c12603;   % 521:             lw a2,12(sp) %
0000132b : 01010113;   % 522:             addi sp,sp,16 %
0000132c : 00060463;   % 525:         beqz a2, MOVE_ZOOMER_FIRST_CHECK  %
0000132d : 18c0006f;   % 526:             j MOVE_ZOOMER_SECOND_CHECK %
0000132e : 04029c63;   % 530:             bnez t0, MOVE_ZOOMER_CHANGE_PLATFORM # If returning anything but 0, change zoomer's platform %
0000132f : 00800f13;   % 531:             li t5,8 %
00001330 : 00254383;   % 532:             lbu t2,2(a0)   # Loads Zoomer's X offset %
00001331 : 047f1263;   % 533:             bne t5,t2,MOVE_ZOOMER_REPEAT_LOOP # If zoomer's X isn't 8, treat it as solid %
00001332 : 04020063;   % 534:             beqz tp,MOVE_ZOOMER_REPEAT_LOOP # If zoomer isn't on top of a door, treat as solid %
00001333 : 00a54303;   % 536:                 lbu t1,10(a0)  # Loads Zoomer's Platform %
00001334 : 00354e03;   % 537:                 lbu t3,3(a0)   # Loads Zoomer's Y offset %
00001335 : 00954e83;   % 538:                 lbu t4,9(a0)   # Loads Zoomer's Clock movement %
00001336 : 02031863;   % 539:                 bnez t1,MOVE_ZOOMER_REPEAT_LOOP %
00001337 : 000e8c63;   % 541:                     beqz t4, MOVE_ZOOMER_CHANGE_PLATFORM_DOWN_CLOCKWISE_OFF_8 %
00001338 : 00300313;   % 543:                         li t1, 3       # Sets platform to 3 (on the right) %
00001339 : 00200e13;   % 544:                         li t3, 2       # Sets Y offset to 4 %
0000133a : 00650523;   % 546:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
0000133b : 01c501a3;   % 547:                         sb t3,3(a0)   # Stores Zoomer's new Y offset %
0000133c : 2e00006f;   % 548:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
0000133d : 00100313;   % 552:                         li t1, 1       # Sets platform to 1 (on the left) %
0000133e : 00200e13;   % 554:                         li t3, 2       # Sets Y offset to 4 %
0000133f : 00650523;   % 556:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
00001340 : 01c501a3;   % 557:                         sb t3,3(a0)   # Stores Zoomer's new Y offset %
00001341 : 2cc0006f;   % 558:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
00001342 : 00100613;   % 562:                 li a2,1 # Loads second check state %
00001343 : d89ff06f;   % 563:                 j MOVE_ZOOMER_CHECK_LOOP # and return to the beginning %
00001344 : 00a54303;   % 566:                 lbu t1,10(a0)  # Loads Zoomer's Platform %
00001345 : 00254383;   % 567:                 lbu t2,2(a0)   # Loads Zoomer's X offset %
00001346 : 00354e03;   % 568:                 lbu t3,3(a0)   # Loads Zoomer's Y offset %
00001347 : 00954e83;   % 569:                 lbu t4,9(a0)   # Loads Zoomer's Clock movement %
00001348 : 02031863;   % 570:                 bnez t1,TRY_MOVE_ZOOMER_CHANGE_PLATFORM_LEFT %
00001349 : 000e8c63;   % 572:                     beqz t4, MOVE_ZOOMER_CHANGE_PLATFORM_DOWN_CLOCKWISE %
0000134a : 00300313;   % 574:                         li t1, 3       # Sets platform to 3 (on the right) %
0000134b : 00200e13;   % 576:                         li t3, 2       # Sets Y offset to 4 %
0000134c : 00650523;   % 578:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
0000134d : 01c501a3;   % 579:                         sb t3,3(a0)   # Stores Zoomer's new Y offset %
0000134e : 2980006f;   % 580:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
0000134f : 00100313;   % 584:                         li t1, 1       # Sets platform to 1 (on the left) %
00001350 : 00200e13;   % 586:                         li t3, 2       # Sets Y offset to 4 %
00001351 : 00650523;   % 588:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
00001352 : 01c501a3;   % 589:                         sb t3,3(a0)   # Stores Zoomer's new Y offset %
00001353 : 2840006f;   % 590:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
00001354 : 00100f13;   % 592:                 TRY_MOVE_ZOOMER_CHANGE_PLATFORM_LEFT:  li t5,1 %
00001355 : 07e31063;   % 593:                 bne t1,t5,TRY_MOVE_ZOOMER_CHANGE_PLATFORM_UP %
00001356 : 020e8e63;   % 595:                     beqz t4, MOVE_ZOOMER_CHANGE_PLATFORM_LEFT_CLOCKWISE %
00001357 : 00000313;   % 597:                         li t1, 0       # Sets platform to 0 (bellow) %
00001358 : 00800f13;   % 598:                         li t5,8 %
00001359 : 027f0063;   % 599:                         beq t5,t2,MOVE_ZOOMER_CHANGE_PLATFORM_LEFT_OFF_8 # If offset == 8, don't alter X %
0000135a : 00e00393;   % 600:                             li t2, 14      # Sets X offset to 12 %
0000135b : 00454e83;   % 601:                             lbu t4,4(a0)   # Loads Zoomer's X %
0000135c : fffe8e93;   % 602:                             addi t4,t4,-1  # Subtracts 1 from it (offset was reduced) %
0000135d : 00650523;   % 605:                             sb t1,10(a0)  # Stores Zoomer's new Platform %
0000135e : 00750123;   % 606:                             sb t2,2(a0)   # Stores Zoomer's new X offset %
0000135f : 01d50223;   % 607:                             sb t4,4(a0)   # Stores Zoomer's new X %
00001360 : 2500006f;   % 608:                             j END_MOVE_ZOOMER # Ends Move Zoomer %
00001361 : 00600393;   % 611:                             li t2, 6       # Sets X offset to 6 %
00001362 : 00650523;   % 614:                             sb t1,10(a0)  # Stores Zoomer's new Platform %
00001363 : 00750123;   % 615:                             sb t2,2(a0)   # Stores Zoomer's new X offset %
00001364 : 2400006f;   % 616:                             j END_MOVE_ZOOMER # Ends Move Zoomer %
00001365 : 00200313;   % 621:                         li t1, 2       # Sets platform to 2 (above) %
00001366 : 00e00393;   % 622:                         li t2, 14      # Sets X offset to 12 %
00001367 : 00454e83;   % 623:                         lbu t4,4(a0)   # Loads Zoomer's X %
00001368 : fffe8e93;   % 624:                         addi t4,t4,-1  # Subtracts 1 from it (offset was reduced) %
00001369 : 00650523;   % 627:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
0000136a : 00750123;   % 628:                         sb t2,2(a0)   # Stores Zoomer's new X offset %
0000136b : 01d50223;   % 629:                         sb t4,4(a0)   # Stores Zoomer's new X %
0000136c : 2200006f;   % 630:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
0000136d : 00200f13;   % 632:                 TRY_MOVE_ZOOMER_CHANGE_PLATFORM_UP:  li t5,2 %
0000136e : 05e31463;   % 633:                 bne t1,t5,MOVE_ZOOMER_CHANGE_PLATFORM_RIGHT %
0000136f : 020e8263;   % 635:                     beqz t4, MOVE_ZOOMER_CHANGE_PLATFORM_UP_CLOCKWISE %
00001370 : 00100313;   % 637:                         li t1, 1       # Sets platform to 1 (on the left) %
00001371 : 00e00e13;   % 639:                         li t3, 14      # Sets Y offset to 12 %
00001372 : 00654e83;   % 640:                         lbu t4,6(a0)   # Loads Zoomer's Y %
00001373 : fffe8e93;   % 641:                         addi t4,t4,-1  # Subtracts 1 from it (offset was reduced) %
00001374 : 00650523;   % 643:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
00001375 : 01c501a3;   % 644:                         sb t3,3(a0)   # Stores Zoomer's new Y offset %
00001376 : 01d50323;   % 645:                         sb t4,6(a0)   # Stores Zoomer's new Y %
00001377 : 1f40006f;   % 646:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
00001378 : 00300313;   % 650:                         li t1, 3       # Sets platform to 3 (on the right) %
00001379 : 00e00e13;   % 652:                         li t3, 14      # Sets Y offset to 12 %
0000137a : 00654e83;   % 653:                         lbu t4,6(a0)   # Loads Zoomer's Y %
0000137b : fffe8e93;   % 654:                         addi t4,t4,-1  # Subtracts 1 from it (offset was reduced) %
0000137c : 00650523;   % 656:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
0000137d : 01c501a3;   % 657:                         sb t3,3(a0)   # Stores Zoomer's new Y offset %
0000137e : 01d50323;   % 658:                         sb t4,6(a0)   # Stores Zoomer's new Y %
0000137f : 1d40006f;   % 659:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
00001380 : 000e8c63;   % 663:                     beqz t4, MOVE_ZOOMER_CHANGE_PLATFORM_RIGHT_CLOCKWISE %
00001381 : 00200313;   % 665:                         li t1, 2       # Sets platform to 2 (above) %
00001382 : 00200393;   % 666:                         li t2, 2       # Sets X offset to 4 %
00001383 : 00650523;   % 669:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
00001384 : 00750123;   % 670:                         sb t2,2(a0)   # Stores Zoomer's new X offset %
00001385 : 1bc0006f;   % 671:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
00001386 : 00000313;   % 675:                         li t1, 0       # Sets platform to 0 (bellow) %
00001387 : 00038a63;   % 676:                         beqz t2,MOVE_ZOOMER_CHANGE_PLATFORM_RIGHT_CLOCKWISE_0 %
00001388 : 00a00393;   % 677:                             li t2, 10      # Sets X offset to 10 %
00001389 : 00650523;   % 680:                             sb t1,10(a0)  # Stores Zoomer's new Platform %
0000138a : 00750123;   % 681:                             sb t2,2(a0)   # Stores Zoomer's new X offset %
0000138b : 1a40006f;   % 682:                             j END_MOVE_ZOOMER # Ends Move Zoomer %
0000138c : 00200393;   % 684:                             li t2, 2      # Sets X offset to 4 %
0000138d : 00650523;   % 687:                             sb t1,10(a0)  # Stores Zoomer's new Platform %
0000138e : 00750123;   % 688:                             sb t2,2(a0)   # Stores Zoomer's new X offset %
0000138f : 1940006f;   % 689:                             j END_MOVE_ZOOMER # Ends Move Zoomer %
00001390 : 0a029263;   % 693:             bnez t0, MOVE_ZOOMER_PROPERLY  # If returning anything but 0, properly move zoomer %
00001391 : 00a54303;   % 695:                 lbu t1,10(a0)  # Loads Zoomer's Platform %
00001392 : 00954e83;   % 697:                 lbu t4,9(a0)   # Loads Zoomer's Clock movement %
00001393 : 02031863;   % 698:                 bnez t1,TRY_MOVE_ZOOMER_CHANGE_PLATFORM_LEFT_V2 %
00001394 : 00254383;   % 700:                     lbu t2,2(a0)   # Loads Zoomer's new X offset %
00001395 : 00800f13;   % 701:                     li t5,8 %
00001396 : 007f0463;   % 702:                     beq t5,t2,CONTINUE_MOVE_ZOOMER_CHANGE_PLATFORM_DOWN # If offset == 8, continue %
00001397 : 08021463;   % 704:                         bnez tp,MOVE_ZOOMER_PROPERLY # If there was a door, don't change direction %
00001398 : 000e8863;   % 706:                     beqz t4, MOVE_ZOOMER_CHANGE_PLATFORM_DOWN_CLOCKWISE_V2 %
00001399 : 00100313;   % 708:                         li t1, 1       # Sets platform to 1 (on the left) %
0000139a : 00650523;   % 709:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
0000139b : 1640006f;   % 710:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
0000139c : 00300313;   % 714:                         li t1, 3       # Sets platform to 3 (on the right) %
0000139d : 00650523;   % 715:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
0000139e : 1580006f;   % 716:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
0000139f : 00100f13;   % 718:                 TRY_MOVE_ZOOMER_CHANGE_PLATFORM_LEFT_V2:  li t5,1 %
000013a0 : 03e31063;   % 719:                 bne t1,t5,TRY_MOVE_ZOOMER_CHANGE_PLATFORM_UP_V2 %
000013a1 : 000e8863;   % 721:                     beqz t4, MOVE_ZOOMER_CHANGE_PLATFORM_LEFT_CLOCKWISE_V2 %
000013a2 : 00200313;   % 723:                         li t1, 2       # Sets platform to 2 (above) %
000013a3 : 00650523;   % 724:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
000013a4 : 1400006f;   % 725:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
000013a5 : 00000313;   % 729:                         li t1, 0       # Sets platform to 0 (bellow) %
000013a6 : 00650523;   % 730:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
000013a7 : 1340006f;   % 731:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
000013a8 : 00200f13;   % 733:                 TRY_MOVE_ZOOMER_CHANGE_PLATFORM_UP_V2:  li t5,2 %
000013a9 : 03e31063;   % 734:                 bne t1,t5,MOVE_ZOOMER_CHANGE_PLATFORM_RIGHT_V2 %
000013aa : 000e8863;   % 736:                     beqz t4, MOVE_ZOOMER_CHANGE_PLATFORM_UP_CLOCKWISE_V2 %
000013ab : 00300313;   % 738:                         li t1, 3       # Sets platform to 3 (on the right) %
000013ac : 00650523;   % 739:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
000013ad : 11c0006f;   % 740:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
000013ae : 00100313;   % 744:                         li t1, 1       # Sets platform to 1 (on the left) %
000013af : 00650523;   % 745:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
000013b0 : 1100006f;   % 746:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
000013b1 : 02021063;   % 750:                     bnez tp,MOVE_ZOOMER_PROPERLY %
000013b2 : 000e8863;   % 751:                     beqz t4, MOVE_ZOOMER_CHANGE_PLATFORM_RIGHT_CLOCKWISE_V2 %
000013b3 : 00000313;   % 753:                         li t1, 0       # Sets platform to 0 (bellow) %
000013b4 : 00650523;   % 754:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
000013b5 : 0fc0006f;   % 755:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
000013b6 : 00200313;   % 759:                         li t1, 2       # Sets platform to 2 (above) %
000013b7 : 00650523;   % 760:                         sb t1,10(a0)  # Stores Zoomer's new Platform %
000013b8 : 0f00006f;   % 761:                         j END_MOVE_ZOOMER # Ends Move Zoomer %
000013b9 : 00a54303;   % 765:             lbu t1,10(a0)  # Loads Zoomer's Platform %
000013ba : 00254383;   % 766:             lbu t2,2(a0)   # Loads Zoomer's X offset %
000013bb : 00354e03;   % 767:             lbu t3,3(a0)   # Loads Zoomer's Y offset %
000013bc : 00954e83;   % 768:             lbu t4,9(a0)   # Loads Zoomer's Clock movement %
000013bd : 00031c63;   % 769:             bnez t1,TRY_MOVE_ZOOMER_PROPERLY_LEFT %
000013be : 000e8663;   % 771:                 beqz t4, MOVE_ZOOMER_PROPERLY_DOWN_CLOCKWISE %
000013bf : ffe38393;   % 773:                     addi t2,t2,-2     # Updates X offset %
000013c0 : 0540006f;   % 775:                     j MOVE_ZOOMER_PROPERLY_OFFSET_CHECK # Checking if offset is ok %
000013c1 : 00238393;   % 779:                     addi t2,t2,2     # Updates X offset %
000013c2 : 04c0006f;   % 781:                     j MOVE_ZOOMER_PROPERLY_OFFSET_CHECK # Checking if offset is ok %
000013c3 : 00100f13;   % 783:             TRY_MOVE_ZOOMER_PROPERLY_LEFT:  li t5,1 %
000013c4 : 01e31c63;   % 784:             bne t1,t5,TRY_MOVE_ZOOMER_PROPERLY_UP %
000013c5 : 000e8663;   % 786:                 beqz t4, MOVE_ZOOMER_PROPERLY_LEFT_CLOCKWISE %
000013c6 : ffee0e13;   % 789:                     addi t3,t3,-2     # Updates Y offset %
000013c7 : 0380006f;   % 790:                     j MOVE_ZOOMER_PROPERLY_OFFSET_CHECK # Checking if offset is ok %
000013c8 : 002e0e13;   % 795:                     addi t3,t3,2     # Updates Y offset %
000013c9 : 0300006f;   % 796:                     j MOVE_ZOOMER_PROPERLY_OFFSET_CHECK # Checking if offset is ok %
000013ca : 00200f13;   % 798:             TRY_MOVE_ZOOMER_PROPERLY_UP:  li t5,2 %
000013cb : 01e31c63;   % 799:             bne t1,t5,MOVE_ZOOMER_PROPERLY_RIGHT %
000013cc : 000e8663;   % 801:                 beqz t4, MOVE_ZOOMER_PROPERLY_UP_CLOCKWISE %
000013cd : 00238393;   % 803:                     addi t2,t2,2     # Updates X offset %
000013ce : 01c0006f;   % 805:                     j MOVE_ZOOMER_PROPERLY_OFFSET_CHECK # Checking if offset is ok %
000013cf : ffe38393;   % 809:                     addi t2,t2,-2     # Updates X offset %
000013d0 : 0140006f;   % 811:                     j MOVE_ZOOMER_PROPERLY_OFFSET_CHECK # Checking if offset is ok %
000013d1 : 000e8663;   % 815:                 beqz t4, MOVE_ZOOMER_PROPERLY_RIGHT_CLOCKWISE %
000013d2 : 002e0e13;   % 818:                     addi t3,t3,2     # Updates Y offset %
000013d3 : 0080006f;   % 819:                     j MOVE_ZOOMER_PROPERLY_OFFSET_CHECK # Checking if offset is ok %
000013d4 : ffee0e13;   % 824:                     addi t3,t3,-2     # Updates Y offset %
000013d5 : 00750123;   % 828:                 sb t2,2(a0)   # Stores Zoomer's new X offset (may change depending on next checks) %
000013d6 : 0003de63;   % 829:                 bge t2,zero, SKIP_MOVE_ZOOMER_PROPERLY_X_OFFSET_NEGATIVE %
000013d7 : 01038393;   % 831:                     addi t2,t2,16 # adds 16 to offset %
000013d8 : 00454e83;   % 832:                     lbu t4,4(a0)         # Loads Zoomer's X %
000013d9 : fffe8e93;   % 833:                     addi t4,t4,-1        # subtracts 1 from it %
000013da : 00750123;   % 835:                     sb t2,2(a0)          # Stores Zoomer's new X offset %
000013db : 01d50223;   % 836:                     sb t4,4(a0)          # Stores Zoomer's new X %
000013dc : 0200006f;   % 837:                     j MOVE_ZOOMER_PROPERLY_OFFSET_CHECK_Y    # check Y offset %
000013dd : 01000293;   % 841:                 li t0,16 %
000013de : 0053cc63;   % 842:                 blt t2,t0,MOVE_ZOOMER_PROPERLY_OFFSET_CHECK_Y # X offset is ok %
000013df : 405383b3;   % 844:                     sub t2,t2,t0         # subtracts 16 to offset %
000013e0 : 00454e83;   % 845:                     lbu t4,4(a0)         # Loads Zoomer's X %
000013e1 : 001e8e93;   % 846:                     addi t4,t4,1         # adds 1 from it %
000013e2 : 00750123;   % 848:                     sb t2,2(a0)          # Stores Zoomer's new X offset %
000013e3 : 01d50223;   % 849:                     sb t4,4(a0)          # Stores Zoomer's new X %
000013e4 : 01c501a3;   % 853:                 sb t3,3(a0)   # Stores Zoomer's new X offset (may change depending on next checks) %
000013e5 : 000e5e63;   % 854:                 bge t3,zero, SKIP_MOVE_ZOOMER_PROPERLY_Y_OFFSET_NEGATIVE %
000013e6 : 010e0e13;   % 856:                     addi t3,t3,16 # adds 16 to offset %
000013e7 : 00654e83;   % 857:                     lbu t4,6(a0)         # Loads Zoomer's Y %
000013e8 : fffe8e93;   % 858:                     addi t4,t4,-1        # subtracts 1 from it %
000013e9 : 01c501a3;   % 860:                     sb t3,3(a0)          # Stores Zoomer's new Y offset %
000013ea : 01d50323;   % 861:                     sb t4,6(a0)          # Stores Zoomer's new Y %
000013eb : 0240006f;   % 862:                     j END_MOVE_ZOOMER    # Finishes procedure %
000013ec : 01000293;   % 866:                 li t0,16 %
000013ed : 005e4e63;   % 867:                 blt t3,t0,END_MOVE_ZOOMER # Y offset is ok %
000013ee : 405e0e33;   % 869:                     sub t3,t3,t0         # subtracts 16 to offset %
000013ef : 00654e83;   % 870:                     lbu t4,6(a0)         # Loads Zoomer's Y %
000013f0 : 001e8e93;   % 871:                     addi t4,t4,1         # adds 1 from it %
000013f1 : 01c501a3;   % 873:                     sb t3,3(a0)          # Stores Zoomer's new Y offset %
000013f2 : 01d50323;   % 874:                     sb t4,6(a0)          # Stores Zoomer's new Y %
000013f3 : 0040006f;   % 875:                     j END_MOVE_ZOOMER    # Finishes procedure %
000013f4 : 00410113;   % 880:         addi sp,sp,4 %
000013f5 : 00008067;   % 882:         ret %
000013f6 : 00354303;   % 907:     lbu t1,3(a0)  # Loads Ripper's X %
000013f7 : 00650223;   % 908:     sb t1,4(a0)   # And stores it in Ripper's old  %
000013f8 : 00554303;   % 909:     lbu t1,5(a0)  # Loads Ripper's Y %
000013f9 : 00650323;   % 910:     sb t1,6(a0)   # And stores it in Ripper's old Y %
000013fa : 00100293;   % 913:     li t0,1       # In case no collision check is made %
000013fb : 00254303;   % 914:     lbu t1,2(a0)  # Loads Ripper's X offset %
000013fc : 06031e63;   % 916:     bnez t1,SKIP_RIPPER_COLLISION   # If offset isn't 0, just move ripper %
000013fd : 0015c783;   % 918:         lbu a5,1(a1)  # Loads map's matrix width %
000013fe : 00354803;   % 919:         lbu a6,3(a0)  # Loads Ripper's current X %
000013ff : 00554883;   % 920:         lbu a7,5(a0)  # Loads Ripper's current Y %
00001400 : 00358593;   % 922:         addi a1,a1,3   # Adds 3 to the Matrix's address so that it goes to the beginning of matrix %
00001401 : 02f882b3;   % 923:         mul t0,a7,a5   # Ripper's Y related to matrix * Map Matrix's width %
00001402 : 005802b3;   % 924:         add t0,a6,t0   # t0 = Ripper's X related to matrix +  Ripper's Y related to matrix * Map Matrix's width   %
00001403 : 005585b3;   % 925:         add a1,a1,t0   # a1 = Map Matrix's address adjusted for Ripper's X and Y related to matrix %
00001404 : 00154283;   % 927:         lbu t0,1(a0)  # Loads Ripper's direction %
00001405 : 00028863;   % 928:         beqz t0,RIPPER_COLLISION_RIGHT   # If moving right %
00001406 : fff80813;   % 930:             addi a6,a6,-1 # Checking tile to the left %
00001407 : fff58593;   % 931:             addi a1,a1,-1 # Updates starting address on map matrix %
00001408 : 00c0006f;   % 932:             j START_RIPPER_COLLISION %
00001409 : 00180813;   % 935:             addi a6,a6,1 # Checking tile to the right %
0000140a : 00158593;   % 936:             addi a1,a1,1 # Updates starting address on map matrix %
0000140b : ff410113;   % 941:         addi sp,sp,-12 %
0000140c : 00a12023;   % 942:         sw a0,0(sp) %
0000140d : 00b12223;   % 943:         sw a1,4(sp) %
0000140e : 00112423;   % 944:         sw ra,8(sp) %
0000140f : 00200513;   % 947:         li a0,2  # Doesn't matter, since no doors will be checked %
00001410 : 00100613;   % 949:         li a2,1  # Only check one tile %
00001411 : 00000693;   % 950:         li a3,0  # Horizontal check %
00001412 : 00000713;   % 951:         li a4,0  # Don't consider doors (since it never spawns there) %
00001413 : 00100213;   % 955:         li tp, 1  # Entity collision %
00001414 : 00000317;   % 957:         call CHECK_MAP_COLLISION %
00001415 : 1ec300e7;   % 957:  %
00001416 : 00a002b3;   % 958:         mv t0,a0 %
00001417 : 00012503;   % 961:         lw a0,0(sp) %
00001418 : 00412583;   % 962:         lw a1,4(sp) %
00001419 : 00812083;   % 963:         lw ra,8(sp) %
0000141a : 00c10113;   % 964:         addi sp,sp,12 %
0000141b : 00154303;   % 969:         lbu t1,1(a0)  # Loads Ripper's direction %
0000141c : 00029863;   % 970:         bnez t0, CONTINUE_MOVE_RIPPER  # If returning anything but 0, continue moving ripper %
0000141d : 00134313;   % 972:             xori t1,t1,1  # Inverts direction %
0000141e : 006500a3;   % 973:             sb t1,1(a0)   # and stores it back %
0000141f : 00008067;   % 974:             ret # and finish procedure %
00001420 : 00354283;   % 978:             lbu t0,3(a0)  # Loads Ripper's X %
00001421 : 00254383;   % 979:             lbu t2,2(a0)  # Loads Ripper's X offset %
00001422 : 02030063;   % 980:             beqz t1,MOVE_RIPPER_RIGHT  # If direction is to the right %
00001423 : ffe38393;   % 982:                 addi t2,t2,-2   # Movement for ripper to the left %
00001424 : 0003d663;   % 983:                 bge t2,zero,MOVE_RIPPER_LEFT_SKIP_CORRECTION %
00001425 : 01038393;   % 984:                     addi t2,t2,16 # adds 16 to offset %
00001426 : fff28293;   % 985:                     addi t0,t0,-1        # subtracts 1 from X %
00001427 : 005501a3;   % 987:                     sb t0,3(a0)    # Stores Ripper's new X %
00001428 : 00750123;   % 988:                     sb t2,2(a0)    # Stores Ripper's new X offset %
00001429 : 00008067;   % 989:                     ret # and finish procedure %
0000142a : 00238393;   % 992:                 addi t2,t2,2      # Movement for ripper to the right %
0000142b : 01000313;   % 993:                 li t1,16   # loads 16 %
0000142c : 0063c663;   % 994:                 blt t2,t1,MOVE_RIPPER_RIGHT_SKIP_CORRECTION %
0000142d : 406383b3;   % 995:                     sub t2,t2,t1  # subtracts 16 from offset %
0000142e : 00128293;   % 996:                     addi t0,t0,1  # subtracts 1 from X %
0000142f : 005501a3;   % 998:                     sb t0,3(a0)   # Stores Ripper's new X %
00001430 : 00750123;   % 999:                     sb t2,2(a0)   # Stores Ripper's new X offset %
00001431 : 00008067;   % 1000:                     ret # and finish procedure %
00001432 : 00254683;   % 1027:     lbu a3,2(a0)    # Loads Ridley's Y offset %
00001433 : 00354603;   % 1029:     lbu a2,3(a0)  # Loads Ridley's Y %
00001434 : 00c50223;   % 1030:     sb a2,4(a0)   # And stores it in Ridley's old Y %
00001435 : 00750283;   % 1033:     lb t0,7(a0)   # Loads Ridley's MOVE_Y %
00001436 : 00850383;   % 1034:     lb t2,8(a0)   # Loads JUMP information %
00001437 : 0002c663;   % 1035:     blt t0,zero, MOVE_RIDLEY_UP   # In case MOVE_Y = -1 %
00001438 : 02029663;   % 1036:     bnez t0, ITERATE_RIDLEY_JUMP  # In case of MOVE_Y = 1, just iterate jump downards %
00001439 : 1280006f;   % 1038:         j MOVE_RIDLEY_PROPERLY %
0000143a : c00a7353;   % 1041:         fcvt.w.s t1,fs4                    # gets Ridley's current Y speed (truncated) %
0000143b : 00035663;   % 1042:         bge t1,zero, SWITCH_RIDLEY_DOWN    # if less then zero, switch down %
0000143c : 02800313;   % 1043:         li t1, 40             # maximum height of jump  %
0000143d : 0063cc63;   % 1044:         blt t2, t1, ITERATE_RIDLEY_JUMP    # if still not there, iterate jump %
0000143e : 00100313;   % 1047:                 li t1, 1         # Loads 1 (Down)        %
0000143f : 006503a3;   % 1048:                 sb t1, 7(a0)     # Switches MOVE_Y to 1 (Down)   %
00001440 : 00050423;   % 1049:                 sb zero, 8(a0)   # reset jump information %
00001441 : d0007a53;   % 1051:                 fcvt.s.w fs4,zero       # Sets speed to zero        %
00001442 : 1300006f;   % 1052:                 j END_MOVE_RIDLEY   %
00001443 : 008a7a53;   % 1055:             fadd.s fs4,fs4,fs0    # fs4 = Ridley's current Y speed + gravity factor        %
00001444 : c00a7e53;   % 1056:             fcvt.w.s t3,fs4       # Sets t3 = floor(fs4) %
00001445 : 01c002b3;   % 1066:             mv t0,t3                # moves t3 to t0 %
00001446 : 0002d463;   % 1067:             bge t0,zero, SKIP_ABS_RIDLEY   # if t0 >= 0, skip this %
00001447 : 405002b3;   % 1068:                 sub t0,zero,t0             # otherwise, t0 will be its opposite  %
00001448 : 005383b3;   % 1070:                 add t2,t2,t0               # t0 to t2 (JUMP factor) %
00001449 : 00750423;   % 1071:                 sb t2, 8(a0)               # and stores it %
0000144a : 01c686b3;   % 1073:         add a3,a3,t3	# Adds the Y Movement to the Ridley's Offset %
0000144b : 0006d663;   % 1075:         bge a3,zero,SKIP_UP_Y_RIDLEY %
0000144c : fff60613;   % 1077:         addi a2, a2, -1		    # Ridley's Y on matrix -= 1 (goes to the left) %
0000144d : 01068693;   % 1078:         addi a3, a3, 16  # Offset gets corrected (relative to new Y on matrix coordinate) %
0000144e : 01000293;   % 1081:             li t0, 16 %
0000144f : 0056c663;   % 1082:             blt a3,t0, SKIP_DOWN_Y_RIDLEY %
00001450 : 00160613;   % 1084:             addi a2,a2, 1	 # Ridley's Y on matrix += 1 (goes to the right) %
00001451 : 405686b3;   % 1085:             sub a3,a3,t0	 # Offset gets corrected (relative to new Y on matrix coordinate) %
00001452 : 00100293;   % 1089:         li t0,1       # In case no collision check is made %
00001453 : 00750303;   % 1090:         lb t1,7(a0)   # Loads Ridley's MOVE_Y %
00001454 : 0a034e63;   % 1091:         blt t1,zero,MOVE_RIDLEY_PROPERLY # If moving up, doesn't need collision (he doesn't jump to high) %
00001455 : 00254283;   % 1093:             lbu t0,2(a0)   # Loads Ridley's Y offset %
00001456 : 00a00313;   % 1094:             li t1, 10      # For comparing %
00001457 : 01c282b3;   % 1095:             add t0,t0,t3   # Current Y offset + Y offset modifier %
00001458 : 0062d463;   % 1097:             bge t0,t1 CONTINUE_RIDLEY_COLLISION    # If the result >= 10, continue checking %
00001459 : 0a80006f;   % 1098:                 j MOVE_RIDLEY_PROPERLY             # Othewise, just move the reptile dragon thing Â¯\_(ã)_/Â¯ %
0000145a : 00750283;   % 1101:             lb t0,7(a0)   # Loads Ridley's MOVE_Y %
0000145b : 00504463;   % 1102:             bgt t0,zero CONTINUE_RIDLEY_COLLISION_2   # In case MOVE_Y = 1 %
0000145c : 09c0006f;   % 1103:                 j MOVE_RIDLEY_PROPERLY # If MOVE_Y = 0 or -1 %
0000145d : 0015c783;   % 1106:             lbu a5,1(a1)     # Loads map's matrix width %
0000145e : 00900813;   % 1107:             li a6,9   # Loads Ridley's current X %
0000145f : 00354883;   % 1108:             lbu a7,3(a0)     # Loads Ridley's current Y %
00001460 : 00388893;   % 1109:             addi a7,a7,3     # adds 3 to Y, so that address will be 3 tiles down %
00001461 : 00358593;   % 1111:             addi a1,a1,3          # Adds 3 to the Matrix's address so that it goes to the beginning of matrix %
00001462 : 02f882b3;   % 1112:             mul t0,a7,a5          # (Ridley's matrix Y + 3)  * Map Matrix's width %
00001463 : 005802b3;   % 1113:             add t0,a6,t0          # t0 = Ridley's X related to matrix + (Ridley's matrix Y + 3)  * Map Matrix's width %
00001464 : 005585b3;   % 1114:             add a1,a1,t0          # a1 = Map Matrix's address adjusted for Ridley's X and Y (+3) related to matrix        %
00001465 : fec10113;   % 1118:                 addi sp,sp,-20 %
00001466 : 00d12823;   % 1119:                 sw a3,16(sp) %
00001467 : 00c12623;   % 1120:                 sw a2,12(sp) %
00001468 : 00b12423;   % 1121:                 sw a1,8(sp) %
00001469 : 00a12223;   % 1122:                 sw a0,4(sp) %
0000146a : 00112023;   % 1123:                 sw ra,0(sp) %
0000146b : 00200513;   % 1126:                 li a0,2  # Doesn't matter, since no doors will be checked %
0000146c : 00100613;   % 1128:                 li a2,1  # Only check one tile %
0000146d : 00100693;   % 1129:                 li a3,1  # Vertical check %
0000146e : 00000713;   % 1130:                 li a4,0  # Don't consider doors (since it never spawns there) %
0000146f : 00100213;   % 1134:                 li tp, 1  # Entity collision %
00001470 : 00000317;   % 1135:                 call CHECK_MAP_COLLISION %
00001471 : 07c300e7;   % 1135:  %
00001472 : 00a002b3;   % 1136:                 mv t0,a0 %
00001473 : 01012683;   % 1139:                 lw a3,16(sp) %
00001474 : 00c12603;   % 1140:                 lw a2,12(sp) %
00001475 : 00812583;   % 1141:                 lw a1,8(sp) %
00001476 : 00412503;   % 1142:                 lw a0,4(sp) %
00001477 : 00012083;   % 1143:                 lw ra,0(sp) %
00001478 : 01410113;   % 1144:                 addi sp,sp,20 %
00001479 : 02029463;   % 1148:             bnez t0, MOVE_RIDLEY_PROPERLY   # If returning anything but 0, Ridley can move %
0000147a : d0007a53;   % 1150:                 fcvt.s.w fs4,zero # Resets Ridley's jump speed %
0000147b : 000503a3;   % 1151:                 sb zero, 7(a0) # RIDLEY_MOVE_Y = 0 %
0000147c : 00050423;   % 1152:                 sb zero, 8(a0) # RIDLEY_JUMP = 0 %
0000147d : 00a00293;   % 1154:                 li t0,10        # setting new Y offset     %
0000147e : 00550123;   % 1155:                 sb t0,2(a0)     # Sets Ridley's Y offset to 10 %
0000147f : 00954283;   % 1157:                 lbu t0, 9(a0)   # Loads jump cooldown %
00001480 : 00029663;   % 1158:                 bnez t0,MOVE_RIDLEY_SKIP_COOLDOWN_RESET  # If cooldown isn't 0, don't reset it %
00001481 : 01400293;   % 1160:                     li t0,20   %
00001482 : 005504a3;   % 1161:                     sb t0, 9(a0) %
00001483 : 00954283;   % 1166:             lbu t0, 9(a0)   # Loads jump cooldown  %
00001484 : 00029863;   % 1167:             bnez t0,MOVE_RIDLEY_PROPERLY_ITERATE_COOLDOWN %
00001485 : 00c501a3;   % 1169:                 sb a2,3(a0)     # Stores Ridley's new Y  %
00001486 : 00d50123;   % 1170:                 sb a3,2(a0)     # Stores new Y offset %
00001487 : 01c0006f;   % 1171:                 j END_MOVE_RIDLEY %
00001488 : fff28293;   % 1175:                 addi t0,t0,-1   # Takes 1 from cooldown %
00001489 : 00029863;   % 1176:                 bnez t0,MOVE_RIDLEY_PROPERLY_FINISH_ITERATE_COOLDOWN %
0000148a : 21398a53;   % 1178:                     fmv.s fs4,fs3  # moves ridley's initial speed to fs4 %
0000148b : fff00313;   % 1179:                     li t1,-1       # Loads -1 (Up) %
0000148c : 006503a3;   % 1180:                     sb t1,7(a0)    # and stores it on Ridley's MOVE_Y %
0000148d : 005504a3;   % 1184:                     sb t0, 9(a0)   # Loads jump cooldown %
0000148e : 00008067;   % 1188:         ret %
0000148f : 00400f33;   % 1217: mv t5,tp %
00001490 : 00a00233;   % 1218: mv tp,a0 # Moves door check to tp %
00001491 : 00100513;   % 1219: li a0,1  # Sets a0 to 1 (can move) %
00001492 : 00000f93;   % 1220: li t6,0  # Sets t6 to 0 (no doors detected) %
00001493 : 00051463;   % 1224:         bnez a0, CONTINUE_CHECK_MAP_COLLISION_1 # Otherwise, continue check %
00001494 : 1c40006f;   % 1225:         j END_COLLISON_MAP %
00001495 : 00c04463;   % 1229:             blt zero, a2, CONTINUE_CHECK_MAP_COLLISION_2 %
00001496 : 1bc0006f;   % 1230:             j END_COLLISON_MAP %
00001497 : 0005c303;   % 1233:             lbu t1, 0(a1) # Loads tile from current map %
00001498 : 0fb00293;   % 1235: 		    li t0, 251     # Value where special tiles start  %
00001499 : 02535863;   % 1236: 		    bge t1, t0, COLLISION_SPECIAL_1 # If it's a special tile %
0000149a : 00070e63;   % 1238:             beqz a4, SKIP_DOOR_CHECK_MAP_COLLISION  # If a4 = 0 (don't consider door), skip door check  %
0000149b : 02800293;   % 1239:                 li t0,40   # Tile where doors start %
0000149c : 00534463;   % 1240:                 blt t1,t0, NOT_DOOR_CHECK_MAP_COLLISION # If current tile isn't a door    %
0000149d : 0f40006f;   % 1241:                 j COLLISION_DOOR  # If tile is a door (t1 >= 40) %
0000149e : 00100293;   % 1243:                     li t0,1   # Consider all tiles %
0000149f : 00570463;   % 1244:                     beq a4,t0, SKIP_DOOR_CHECK_MAP_COLLISION # If no door was detected and other tiles should be checked, continue %
000014a0 : 1700006f;   % 1245:                     j CONTINUE_CHECK_MAP_COLLISION_3  # If no door was detected and only doors should be checked, skip to the end %
000014a1 : 00400293;   % 1247:                 li t0, 4      # Loads t0 = 4 for comparison %
000014a2 : 06535863;   % 1248:                 bge t1,t0,COLLISION_NOT_BACKGROUND # If tile isn't part of background or isn't breakable (t1 >= 4) %
000014a3 : 06650463;   % 1250:                     beq a0,t1, COLLISION_BREAKABLE   # If tile is breakable, there needs to be a check if it was broken %
000014a4 : 1600006f;   % 1251:                     j CONTINUE_CHECK_MAP_COLLISION_3 # Otherwise, continue checking collision %
000014a5 : 00069863;   % 1254:                 bnez a3,CONTINUE_COLLISION_SPECIAL_1 # If on vertical check, continue %
000014a6 : fff60393;   % 1256:                 addi t2,a2,-1 %
000014a7 : 00038463;   % 1257:                 beqz t2,CONTINUE_COLLISION_SPECIAL_1 %
000014a8 : 1500006f;   % 1258:                     j CONTINUE_CHECK_MAP_COLLISION_3 %
000014a9 : 040f1663;   % 1260:                     bnez t5,COLLISION_SPECIAL_1_NOT_MARU_MARI %
000014aa : 0ff00293;   % 1261:                     li t0,255 %
000014ab : 04629263;   % 1262:                     bne t0,t1,COLLISION_SPECIAL_1_NOT_MARU_MARI %
000014ac : 0fc0b317;   % 1263:                         la t1,MARU_MARI_INFO # Loads Maru Mari's info address %
000014ad : e8c30313;   % 1263:  %
000014ae : 00034283;   % 1264:                         lbu t0, 0(t1)        # Loads enable byte %
000014af : 02028a63;   % 1265:                         beqz t0,COLLISION_SPECIAL_1_BACKGROUND # If disabled, skip %
000014b0 : 00030023;   % 1267:                             sb zero, 0(t1)   # disables Maru Mari %
000014b1 : 00100293;   % 1268:                             li t0,1          # Loads 1 (1- ball) %
000014b2 : 0fc0b317;   % 1269:                             la t1,PLYR_INFO  # Loads Maru Mari's info address %
000014b3 : e5030313;   % 1269:  %
000014b4 : 005300a3;   % 1270:                             sb t0,1(t1)      # New ability %
000014b5 : 0040006f;   % 1271:                             j COLLISION_SPECIAL_1_GET %
000014b6 : c0102373;   % 1274:                         csrr t1,3073                       # Gets current time for loop %
000014b7 : c01022f3;   % 1276:                             csrr t0,3073                              # Gets current time %
000014b8 : 406282b3;   % 1277:                             sub t0, t0, t1                            # t0 = current time - last frame's time %
000014b9 : 7d000393;   % 1278:                             li t2, 2000                     # Loads power_up_delay %
000014ba : fe72eae3;   % 1279:                             bltu t0,t2, COLLISION_SPECIAL_1_GET_LOOP  # While t0 < minimum time for a frame, keep looping %
000014bb : 1040006f;   % 1280:                             j CONTINUE_CHECK_MAP_COLLISION_3 %
000014bc : 1000006f;   % 1285:                         j CONTINUE_CHECK_MAP_COLLISION_3 %
000014bd : 0fc0006f;   % 1290:                 j CONTINUE_CHECK_MAP_COLLISION_3 %
000014be : 00628863;   % 1293:                 beq t0,t1,COLLISION_DOOR_FRAME  # If t1 = 4, it's a door frame %
000014bf : 02400293;   % 1294:                 li t0,36   # Tile from which collision behaves differently %
000014c0 : 04535c63;   % 1295:                 bge t1,t0, COLLISION_SPECIAL_2  # If current tile is a door or a damaging tile (t1 >= 36) %
000014c1 : 0e80006f;   % 1296:                     j COLLISION_BLOCKED # If tile isn't special (3 < t1 < 36) %
000014c2 : 0e0f1263;   % 1299:                 bnez t5,COLLISION_BLOCKED  # If not player, consider this a solid object %
000014c3 : 000002b3;   % 1300:                 mv t0,zero   # Resets counter %
000014c4 : 0fc0b317;   % 1301:                 la t1, Frames # Loads Frames address %
000014c5 : 0a430313;   % 1301:  %
000014c6 : 00032303;   % 1302:                 lw t1,0(t1)	 # Gets the current map's door frame address %
000014c7 : 00034383;   % 1303:                 lbu t2,0(t1) # Gets the number of door frames in this map %
000014c8 : 00130313;   % 1304:                 addi t1,t1,1 # Starting address of the map's first door frame %
000014c9 : 00034e03;   % 1307:                     lbu t3, 0(t1) # Loads door frame's X on matrix %
000014ca : 010e1e63;   % 1308:                     bne t3, a6, NEXT_IN_COLLISION_DOOR_FRAME_LOOP # If door frame's X isn't the same as current X, skip it        %
000014cb : 00134e03;   % 1309:                     lbu t3, 1(t1) # Loads door frame's Y on matrix %
000014cc : 41c88e33;   % 1310:                     sub t3,a7,t3  # t3 needs to be equal to 0, 1 or 2 in order to be a tile from this door frame %
000014cd : 00200e93;   % 1311:                     li t4,2       # 2 is the threshold to be compared with t3 %
000014ce : 01cee663;   % 1312:                     bgtu t3,t4, NEXT_IN_COLLISION_DOOR_FRAME_LOOP # If current Y is above the door frame's uppermost Y or bellow it's downmost Y, skip it                        %
000014cf : 00600533;   % 1314:                         mv a0,t1       # Moves current door frame's address to a0 %
000014d0 : c8dfe06f;   % 1315:                         j CHANGE_MAP                             %
000014d1 : 00630313;   % 1317:                         addi t1,t1,6 # Going to the next door frame's address                                   %
000014d2 : 00128293;   % 1318:                         addi t0,t0,1 # Iterating counter by 1                                    %
000014d3 : 0072d463;   % 1319:                         bge t0,t2, END_COLLISION_DOOR_FRAME_LOOP # If all of the map's door frames were checked, end loop                                   %
000014d4 : fd5ff06f;   % 1320:                         j COLLISION_DOOR_FRAME_LOOP # otherwise, go back to the loop's beginning                      %
000014d5 : 09c0006f;   % 1323:                     j CONTINUE_CHECK_MAP_COLLISION_3      %
000014d6 : 02800293;   % 1327:                 li t0,40   # Tile from which door tiles begin %
000014d7 : 00534463;   % 1328:                 blt t1,t0, CONTINUE_COLLISION_SCPECIAL_2   # If tile is a door (t1 >= 40) %
000014d8 : 0900006f;   % 1329:                     j CONTINUE_CHECK_MAP_COLLISION_3     # Otherwise, finish this iteration's checks %
000014d9 : 0880006f;   % 1333:                     j COLLISION_BLOCKED # For now >:[ %
000014da : 000002b3;   % 1336:                 mv t0,zero   # Resets counter %
000014db : 0fc0b317;   % 1337:                 la t1, Doors # Loads Doors address %
000014dc : 00830313;   % 1337:  %
000014dd : 00032303;   % 1338:                 lw t1,0(t1)	 # Gets the current map's door address %
000014de : 00034383;   % 1339:                 lbu t2,0(t1) # Gets the number of doors in this map %
000014df : 00130313;   % 1340:                 addi t1,t1,1 # Starting address of the map's first door %
000014e0 : 00034e03;   % 1343:                     lbu t3, 0(t1) # Loads door's X on matrix %
000014e1 : 050e1a63;   % 1344:                     bne t3, a6, NEXT_IN_COLLISION_DOOR_LOOP # If door's X isn't the same as current X, skip this door %
000014e2 : 00134e03;   % 1345:                     lbu t3, 1(t1) # Loads door's Y on matrix %
000014e3 : 41c88e33;   % 1346:                     sub t3,a7,t3  # t3 needs to be equal to 0, 1 or 2 in order to be a tile from this door %
000014e4 : 00200e93;   % 1347:                     li t4,2       # 2 is the threshold to be compared with t3 %
000014e5 : 05cee263;   % 1348:                     bgtu t3,t4, NEXT_IN_COLLISION_DOOR_LOOP # If current Y is above the door's uppermost Y or bellow it's downmost Y, skip this door                         %
000014e6 : 024e8063;   % 1350:                         beq t4,tp,AFTER_COLLISION_DOOR_LOOP_DIRECTION_CHECK # If tp = 2, check any type of door %
000014e7 : 00034e03;   % 1351:                         lbu t3, 0(t1) # Loads door's X on matrix  %
000014e8 : 00020663;   % 1352:                         beqz tp,COLLISION_DOOR_LOOP_CHECK_RIGHT # If tp = 0, check if door is on right wall %
000014e9 : 01c20a63;   % 1354:                             beq tp,t3,AFTER_COLLISION_DOOR_LOOP_DIRECTION_CHECK # If t3 = 1, door is on left wall; continue checking collision %
000014ea : 0400006f;   % 1355:                             j END_COLLISION_DOOR_LOOP # Otherwise, door is on right wall and not on left wall (stop checking) %
000014eb : 00100e93;   % 1357:                             li t4, 1 # 1 is the threshold of when a door can be on right wall %
000014ec : 01cec463;   % 1358:                             bgt t3,t4, AFTER_COLLISION_DOOR_LOOP_DIRECTION_CHECK # If t3 > 1, door is on right wall; continue checking collision %
000014ed : 0340006f;   % 1359:                             j END_COLLISION_DOOR_LOOP # Otherwise, door is on left wall and not on right wall (stop checking) %
000014ee : 00234e83;   % 1361:                             lbu t4, 2(t1) # Loads door's state %
000014ef : 020e9663;   % 1362:                             bnez t4, END_COLLISION_DOOR_LOOP # If door is open or opening, player can move through  %
000014f0 : 00200e93;   % 1363:                                 li t4,2 # 1 is the threshold of when a door can be on right wall %
000014f1 : 020f9463;   % 1364:                                 bnez t6,COLLISION_BLOCKED  # if t6 != 0 , don't update it %
000014f2 : 00034e03;   % 1365:                                     lbu t3, 0(t1) # Loads door's X on matrix  %
000014f3 : 01de2fb3;   % 1366:                                     slt t6,t3,t4   # door's x < 2 ? t6 = 1 : t6 = 0 %
000014f4 : 001f8f93;   % 1367:                                     addi t6,t6,1   # If right door, t6 = 1; left door, t6 = 2 %
000014f5 : 0180006f;   % 1368:                                     j COLLISION_BLOCKED # Otherwise, door is closed and player can't move                    %
000014f6 : 00430313;   % 1370:                         addi t1,t1,4 # Going to the next door's address                                   %
000014f7 : 00128293;   % 1371:                         addi t0,t0,1 # Iterating counter by 1                                    %
000014f8 : 0072d463;   % 1372:                         bge t0,t2, END_COLLISION_DOOR_LOOP # If all of the map's doors were checked, end loop                                   %
000014f9 : f9dff06f;   % 1373:                         j COLLISION_DOOR_LOOP # otherwise, go back to the loop's beginning                      %
000014fa : 0080006f;   % 1376:                     j CONTINUE_CHECK_MAP_COLLISION_3                                                                  %
000014fb : 00000513;   % 1379:                 li a0,0 # Player can't move   %
000014fc : 00069a63;   % 1383:             bnez a3, CHECK_MAP_COLLISION_VERTICAL %
000014fd : 00f585b3;   % 1385:                 add a1,a1,a5   # a1 = current tile address + matrix width (+1 Y) %
000014fe : 00188893;   % 1386:                 addi a7,a7,1   # a7++ (+1 Y) %
000014ff : fff60613;   % 1387:                 addi a2,a2,-1  # Iterates a2 (a2--) %
00001500 : e4dff06f;   % 1388:                 j MAP_COLLISION_LOOP %
00001501 : 00158593;   % 1391:                 addi a1,a1,1   # a1 = current tile address + 1 (+1 X) %
00001502 : 00180813;   % 1392:                 addi a6,a6,1   # a6++ (+1 X) %
00001503 : fff60613;   % 1393:                 addi a2,a2,-1  # Iterates a2 (a2--) %
00001504 : e3dff06f;   % 1394:                 j MAP_COLLISION_LOOP %
00001505 : 01f005b3;   % 1397:     mv a1,t6  # moves t6 (0 - no door, 1 - right door, 2 - left door) %
00001506 : 00008067;   % 1398:     ret %
00001507 : 0fc0b297;   % 4:         la t0, MUSIC.NOTES %
00001508 : be428293;   % 4:  %
00001509 : 0fc0b317;   % 5:         la t1, MUSIC.STATUS %
0000150a : cd430313;   % 5:  %
0000150b : 00532223;   % 6:         sw t0, 4(t1) %
0000150c : 00032023;   % 7:         sw zero, 0(t1) %
0000150d : 00008067;   % 8:         ret %
0000150e : 0fc0b517;   % 19:         la a0, MUSIC.STATUS # loads status address %
0000150f : cc050513;   % 19:  %
00001510 : 03300613;   % 20:         li a2, 51 # instrument (range-ensemble) %
00001511 : 03200693;   % 21:         li a3, 50 # volume %
00001512 : 00052283;   % 23:         lw t0, 0(a0) %
00001513 : 00028863;   % 24:         beqz t0, MUSIC.PLAY.NOTE  %
00001514 : c0102373;   % 25:         csrr t1, 3073 # current time, read control and status register %
00001515 : 0062e463;   % 26:         bltu t0, t1, MUSIC.PLAY.NOTE # next note > now ? play note : do nothing %
00001516 : 0480006f;   % 27:         j MUSIC.RET %
00001517 : 00452283;   % 30:         lw t0, 4(a0) # t0 = current note address  %
00001518 : 0002a303;   % 31:         lw t1, 0(t0) # note  %
00001519 : 0042a383;   % 32:         lw t2, 4(t0) # duration  %
0000151a : 00030e63;   % 34:         beqz t1, MUSIC.LAST.PLAYED # note == 0, wait  %
0000151b : 00a00e33;   % 36:         mv t3, a0 # save a0  %
0000151c : 00600533;   % 37:         mv a0, t1 # a0 = note  %
0000151d : 007005b3;   % 38:         mv a1, t2 # a1 = duration  %
0000151e : 01f00893;   % 39:         li a7, 31 # Midi Out Syscall  %
0000151f : 00000073;   % 40:         ecall # play the note  %
00001520 : 01c00533;   % 42:         mv a0, t3 # save a0  %
00001521 : 00039463;   % 45:         bnez t2, MUSIC.LAST.PLAYED.SETUP # note != 0 && duration != 0 ? MUSIC.LAST.PLAYED.SETUP : restart %
00001522 : f95ff06f;   % 46:         j MUSIC.SETUP %
00001523 : c0102e73;   % 48:         csrr t3, 3073 # current time  %
00001524 : 007e0e33;   % 49:         add t3, t3, t2 # current time + note duration = next note time  %
00001525 : 01c52023;   % 50:         sw t3, 0(a0) # save next note time  %
00001526 : 00828293;   % 51:         addi t0, t0, 8 # inc address of next note  %
00001527 : 00552223;   % 52:         sw t0, 4(a0) # save next note  %
00001528 : 00008067;   % 55:         ret %
END;
